<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Microwave. Five minutes.</title>
  
  <subtitle>他大概会说你想得太多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pazyx.xyz/"/>
  <updated>2019-12-12T05:40:08.962Z</updated>
  <id>https://blog.pazyx.xyz/</id>
  
  <author>
    <name>pazyx.xyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「笔记」Oracle Database 期末考笔记</title>
    <link href="https://blog.pazyx.xyz/2019/12/12/oracle_endterm_notes/"/>
    <id>https://blog.pazyx.xyz/2019/12/12/oracle_endterm_notes/</id>
    <published>2019-12-12T06:43:18.000Z</published>
    <updated>2019-12-12T05:40:08.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">...</span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN ZERO_DIVIDE THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;DIvision by zero&apos;);</span><br><span class="line">  WHEN OTHERS THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;An exception occurred&apos;);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p><code>OTHERS</code> 异常可处理所有异常，但必须在 <code>EXCEPTION</code> 块中所有特定异常之后。<br>遇到异常后执行完异常处理代码后，程序会退出此代码块。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure hello</span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">  dbms_output.put_line(&apos;Hello World!&apos;);</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create or replace procedure hello(v_employee_id in employees.employee_id%type)</span><br><span class="line">as</span><br><span class="line">  v_salary employees.salary%type;</span><br><span class="line">begin</span><br><span class="line">  select salary into v_salary</span><br><span class="line">  from employees</span><br><span class="line">  where employee_id=v_employee_id;</span><br><span class="line">  dbms_output.put_line(v_salary);</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="参数模式"><a href="#参数模式" class="headerlink" title="参数模式"></a>参数模式</h4><ul><li><code>IN</code>: 参数默认模式，过程体中不能改变 <code>IN</code> 参数的值</li><li><code>OUT</code>: 只在过程体内部赋值，忽略传入值，必须为变量</li><li><code>IN OUT</code>: 在过程体内部赋值，保留传入值，可以修改，必须为变量 </li></ul><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec procedure_name</span><br><span class="line">SQL&gt; exec procedure_name(v_name)</span><br><span class="line">SQL&gt; exec procedure_name(:v_name) --外部变量</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">...</span><br><span class="line">procedure_name;</span><br><span class="line">procedure_name(v_name);</span><br><span class="line">...</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="定义外部变量"><a href="#定义外部变量" class="headerlink" title="定义外部变量"></a>定义外部变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; variable v_name v_type</span><br><span class="line">SQL&gt; print v_name</span><br></pre></td></tr></table></figure><h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE procedure_name;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create or replace function circle_area(p_radius number)</span><br><span class="line">return number</span><br><span class="line">as</span><br><span class="line">  v_pi number := 3.1416;</span><br><span class="line">  v_area number;</span><br><span class="line">begin</span><br><span class="line">  v_area := v_pi * power(p_radius,2);</span><br><span class="line">  return v_area;</span><br><span class="line">end circle_area;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION function_name;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>在 <code>DML</code>  语句之前或之后被激活。</p><p>语句级触发器：对于整条语句只执行一次触发器过程。</p><p>行级触发器：对于每行的操作各执行一次触发器过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] TRIGGER trigger_name</span><br><span class="line">&#123;BEFORE | AFTER | INSTEAD OF | FOR&#125; trigger_even</span><br><span class="line">-- 之前、之后、代替、11g复合触发器</span><br><span class="line">ON table_name</span><br><span class="line">[FOR EACH ROW]-- 行级触发器</span><br><span class="line">[&#123;FORWARD | REVERSE&#125; CROSSEDITION]  -- 11g</span><br><span class="line">[&#123;FORWARD | REVERSE&#125; schema.other_trigger]  -- 11g</span><br><span class="line">[&#123;ENABLE | DISABLE&#125;]-- 11g</span><br><span class="line">[WHEN tigger_condition]</span><br><span class="line">BEGIN</span><br><span class="line">    trigger_body</span><br><span class="line">END tigger_name;</span><br></pre></td></tr></table></figure><h4 id="trigger-even"><a href="#trigger-even" class="headerlink" title="trigger_even"></a>trigger_even</h4><ul><li><code>UPDATE</code></li><li><code>INSERT</code></li><li><code>DELETE</code></li><li><code>UPDATE OF col_name</code></li><li><code>DELETE OR INSERT OR UPDATE OF col_name</code></li></ul><h4 id="old-amp-new"><a href="#old-amp-new" class="headerlink" title="old  &amp; new"></a><code>old</code>  &amp; <code>new</code></h4><table><thead><tr><th>DML</th><th>OLD</th><th>NEW</th></tr></thead><tbody><tr><td>INSRET</td><td>NULL</td><td>insert value</td></tr><tr><td>UPDATE</td><td>value before update</td><td>value after update</td></tr><tr><td>DELETE</td><td>value before delete</td><td>NULL</td></tr></tbody></table><p>trigger_body 内使用 <code>old</code> 或  <code>new</code> 时，需加 <code>:</code> 使用外部变量，<code>:old</code>、 <code>:new</code>。</p><h4 id="禁用和启用触发器"><a href="#禁用和启用触发器" class="headerlink" title="禁用和启用触发器"></a>禁用和启用触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name DISABLE;</span><br><span class="line">ALTER TRIGGER trigger_name ENABLE;</span><br></pre></td></tr></table></figure><h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER trigger_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="计算机" scheme="https://blog.pazyx.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="异常" scheme="https://blog.pazyx.xyz/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="Oracle" scheme="https://blog.pazyx.xyz/tags/Oracle/"/>
    
      <category term="数据库" scheme="https://blog.pazyx.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://blog.pazyx.xyz/tags/SQL/"/>
    
      <category term="PL/SQL" scheme="https://blog.pazyx.xyz/tags/PL-SQL/"/>
    
      <category term="触发器" scheme="https://blog.pazyx.xyz/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」概率论与数理统计——数字特征</title>
    <link href="https://blog.pazyx.xyz/2019/12/08/probability_num_chara_notes/"/>
    <id>https://blog.pazyx.xyz/2019/12/08/probability_num_chara_notes/</id>
    <published>2019-12-08T15:08:42.000Z</published>
    <updated>2019-12-12T04:49:49.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>$$<br>\begin{align}<br>&amp; x \sim p_i \implies EX = \sum_i x_i P_i\\<br>&amp; x \sim f(x) \implies EX = \int_{-\infty}^{+\infty} xf(x)\, \mathrm{d}x \\<br>\\<br>&amp; x \sim p_i , Y = g(x) \implies EY = \sum_i g(x_i) P_i \\<br>&amp; x \sim f(x) , Y = g(x) \implies EY = \int_{-\infty}^{+\infty} g(x)f(x)\, \mathrm{d}x<br>\\<br>\end{align}<br>$$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>$$<br>E \left(\sum_{i=1}^n a_i X_i\right) = \sum_{i=1}^n a_i E X_i \\<br>Ec = c \; , \; E(EX) = EX \\<br>E(aX+c) = aEX + c \; , \; E(X \pm Y) = EX \pm EY<br>$$</p><p>若 $X,Y$ 独立<br>$$<br>EXY = EX \cdot EY<br>$$</p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>$$<br>Dx = E\left[\left(X-EX\right)^2\right] = E(X^2) - (EX)^2 \\<br>\Downarrow \\<br>E(X^2) = (EX)^2 + DX \\<br>\Downarrow \\<br>E(X^2) \geq (EX)^2<br>$$</p><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>$$<br>Dc = 0 \; , \; D(aX + b) = a^2 DX \\<br>D(X \pm Y) = DX + DY \pm 2Cov(X,Y) \\<br>$$</p><p>$$<br>\begin{cases}<br>&amp; D(X \pm Y) = DX + DY \pm 2Cov(X,Y)\\<br>&amp; D\left(\sum_{i=1}^n X_i\right) = \sum_{i=1}^n DX_i + 2\sum_{i=1}^n \sum_{j=1}^n cov(X_i,Y_i)<br>\end{cases}<br>$$</p><p>若 $X,Y$ 独立<br>$$<br>D(aX+bY) = a^2 DX + b^2 DY<br>$$</p><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>$$<br>Cov(X,Y) = E\left[(X-EX)(Y-EY)\right] = E(XY) - EX \cdot EY<br>$$</p><p>$$<br>E(XY) =<br>\begin{cases}<br>&amp; \sum_i \sum_j x_i y_j P{X = x_i,Y = y_i} \;{(离散)} \\<br>&amp; \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xyf(x,y) \mathrm{d}x \mathrm{d}y \;{(连续)}<br>\end{cases}<br>$$</p><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p>$$<br>\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{DX}\sqrt{DY}} \; , \; |\rho_{XY}| \leq 1<br>$$</p><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p>$$<br>Cov(X,X) = DX \; , \; \rho_{XX} = 1 \\<br>Cov(X,Y) = Cov(Y,X) \\<br>Cov(X,c) = 0 \; , \; Cov(aX+b,Y) = aCov(X,Y)\\<br>Cov(X_1 + X_2,Y) = Cov(X_1,Y) + Cov(X_2,Y)<br>$$</p><p>若 $Y = aX+b$，则<br>$$<br>\rho_{XY} =<br>\begin{cases}<br>1 &amp; \quad a &gt; 0\\<br>-1 &amp; \quad a &lt; 0<br>\end{cases}<br>$$</p><h3 id="常用分布的期望和方差列表"><a href="#常用分布的期望和方差列表" class="headerlink" title="常用分布的期望和方差列表"></a>常用分布的期望和方差列表</h3><table><thead><tr><th>分布</th><th>分布列 $p_k$ 或概率密度 $f(x)$</th></tr></thead><tbody><tr><td>$0 - 1$ 分布 $B(1,p)$</td><td>$P\{X=k\}=p^k(1-p)^{1-k},k=0,1$</td></tr><tr><td>二项分布 $B(n,p)$</td><td>$P\{X=k\} = C^k_n p^k(1-p)^{n-k},k=0,1,\dots,n$</td></tr><tr><td>泊松分布 $P(\lambda)$</td><td>$P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda},k=0,1,\dots$</td></tr><tr><td>几何分布 $G(p)$</td><td>$P\{X=k\} = (1-p)^{k-1}p,k=1,2,\cdots$</td></tr><tr><td>正态分布 $N(\mu,\sigma^2)$</td><td>$f(x) = \frac{1}{\sqrt{2\pi}\sigma}exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\} , -\infty &lt; x &lt; +\infty$</td></tr><tr><td>均匀分布 $U(a,b)$</td><td>$f(x) = \frac{1}{b-a},a &lt; x &lt; b$</td></tr><tr><td>指数分布 $E(\lambda)$</td><td>$f(x) = \lambda e^{-\lambda x},x&gt;0$</td></tr></tbody></table><table><thead><tr><th>分布</th><th>期望</th><th>方差</th></tr></thead><tbody><tr><td>$0 - 1$ 分布 $B(1,p)$</td><td>$p$</td><td>$p(1-p)$</td></tr><tr><td>二项分布 $B(n,p)$</td><td>$np$</td><td>$np(1-p)$</td></tr><tr><td>泊松分布 $P(\lambda)$</td><td>$\lambda$</td><td>$\lambda$</td></tr><tr><td>几何分布 $G(p)$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>正态分布 $N(\mu,\sigma^2)$</td><td>$\mu$</td><td>$\sigma^2$</td></tr><tr><td>均匀分布 $U(a,b)$</td><td>$\frac{a+b}{2}$</td><td>$\frac{(b-a)^2}{12}$</td></tr><tr><td>指数分布 $E(\lambda)$</td><td>$\frac{1}{\lambda}$</td><td>$\frac{1}{\lambda^2}$</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;随机变量的数字特征&quot;&gt;&lt;a href=&quot;#随机变量的数字特征&quot; class=&quot;headerlink&quot; title=&quot;随机变量的数字特征&quot;&gt;&lt;/a&gt;随机变量的数字特征&lt;/h2&gt;&lt;h3 id=&quot;期望&quot;&gt;&lt;a href=&quot;#期望&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数学" scheme="https://blog.pazyx.xyz/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="期望" scheme="https://blog.pazyx.xyz/tags/%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="方差" scheme="https://blog.pazyx.xyz/tags/%E6%96%B9%E5%B7%AE/"/>
    
      <category term="协方差" scheme="https://blog.pazyx.xyz/tags/%E5%8D%8F%E6%96%B9%E5%B7%AE/"/>
    
      <category term="概率论" scheme="https://blog.pazyx.xyz/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
      <category term="数字特征" scheme="https://blog.pazyx.xyz/tags/%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"/>
    
  </entry>
  
  <entry>
    <title>「朝花夕拾」0x04 重启</title>
    <link href="https://blog.pazyx.xyz/2019/12/07/diary_4/"/>
    <id>https://blog.pazyx.xyz/2019/12/07/diary_4/</id>
    <published>2019-12-06T20:13:47.000Z</published>
    <updated>2019-12-06T19:59:30.910Z</updated>
    
    <content type="html"><![CDATA[<p>在 19 年的最后一个月，我又拾起了我即将荒废的博客。上一篇随笔竟然是一年前，时间过得实在太快，身边的同学也都在感叹时间飞逝。</p><p>最近人工降雨，气温有点凉，很难顶。也许是气温的缘故我饭量大增，伙食费都不太够了。也怪吃得太饱热量过剩，赶上华为251，我真正成为了华为黑粉，卖力的做了两天黑公关。</p><p>我想记录一下我的思考过程和从华为的问题中我吸取的教训。</p><p>我发现在我思考过程中，我总会创造另一个质问我的我，它的质问总会以两个问题开始：一是，我一定是对的吗？二是，对方一定是错的吗？这样的质问的答案必将是两个否定的结果。对于每个问题，基本都有很多自己对自己的质问，想着想着就累了，思考的过程又过长，一段文字很难表达，而且观点趋于中立没什么劲，这就导致我很长一段时间很少在社交媒体发声。我不知道这是好是坏，我只知道从前我不是这样，反正不说有不说的好处，就是不太会激动，人在表达自己观点时都是激动的。</p><p><strong>以下包含我对华为的问题的思考和理解，作为黝黑粉，言论可能引起华为支持者的生理反应，快跑！</strong></p><p>说起华为，早年我买过一些它的配件，中规中矩，家里人逐渐转向苹果，华为的产品我确实了解甚少。近几年华为好像起来了，支持者越来越多。官方媒体也多次为华为发声，新闻中也能感受到华为和祖国密切的联系。这种联系好像不同于小米等其他民营企业，有种像国家电网那样的龙头国企的味道，甚至更夸张。（华为和祖国扯上关系，我个人认为主要原因还是在余某或者整个企业宣传过程中，多次发表华为被迫害的言论，引起支持者对敌方的攻势，在书本上的故事中人们多数情况只为国家民族而战，我认为这其实也算是一种暗示。）</p><p>这两年也听说过不少关于华为的黑料，自己不用也不太关心，而且我总感觉它的支持者太多，我想说两句时，就想到第二条质问，那么多支持者都是错的吗？也无法保证自己的正确性，只能憋着（其实我心里总有一句话在回想，在挑战那个质问，那就是“这个世界上百分之八十的人都是笨蛋。”，我觉得这句话挺对的，每次我在一个领域体会到笨蛋数量庞大之后我就快成了）。</p><p>在憋了很多脏话后，251 被曝光，我瞅准机会一通操作，在社交媒体发了一些黑华为的言论（黑其实也就是把华为做的事情讲一遍），还跟身边同学讲了讲故事，期间也骂脏话，把疑似花粉同学的微博拉黑了。越来越激动，也许是压抑了很久。起初我激动的原因是华为的恶心的事，后来慢慢就转向对笨蛋的气愤，怎么还会有很多笨蛋洗华为？我开始进行低烈度的人身攻击，质疑它们脑子的可用性。那可真是过瘾哟，完全不用思考，无脑黑，直接怼，发泄了一通。但很快我决定禁止自己在社交媒体再发乱七八糟关于华为的东西，我需要冷静。</p><p>冷静后，接下来是战术总结：</p><ul><li>华为为什么报案时多次变更李的罪名？</li><li>如果没有搞清楚就指控员工有负责任吗？</li><li>华为是否存在骗补行为？为什么不公布李敲诈勒索华为的资料？（如果华为是清白的）</li><li>华为不是一次两次了，60天的另一员工，直接从泰国遣返，最终检察院不起诉。</li><li>华为举报媒体曝光其产品质量问题为谣言，龙岗分局跨省兵分六路抓捕相关人员。</li></ul><p>说到底我质问的是华为是否滥用公权力。</p><p>我为什么要卖力的黑华为？如果这件事是其他企业做的，我绝不会这样激动，甚至会选择原谅。原因是我认为华为是个两面企业，表面树立民族企业的形象，利用大家的对祖国的感情发展企业。实则是个”小人“，不去维护国家的法制，任何事件从不道歉，利用法律逃避义务。实在看不惯“小人”得志。</p><p>我想这也是为什么有那么多人突然出来抵制华为的原因，华为培养与人民的感情到头来跟人民讲法律。这就好像你兄弟背后说你坏话诋毁你去讨好别人，你跟他讲情谊，他说老子没违法。这远比陌生人偷你一块钱，更让人生气，因为后者你直接报警就可以了，前者你也只能气着。注意！我没跟华为有什么狗屁感情，我只是单纯的讨厌华为情法两手抓的恶心行为，拿到了所有利益，却不履行义务。如果自封民族企业就应该承担责任去维护法制，996违法劳动法可以停一下。如果不想做民族企业，只想好好赚钱，那请不要再让公主写煽情文章博得人民的同情。</p><p>大三了，来学校两年多了，见过自私自利两面的同学，也见过利用他人达到自己目的的同学。我不了解自己口碑如何，但我知道他们得意的背后是被人唾弃（至少是被我唾弃）。做好自己，靠乱七八糟手段得到的东西肯定是要还的。</p><p><strong>最后，博客正式开始周更，每周写点儿，持续输出。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 19 年的最后一个月，我又拾起了我即将荒废的博客。上一篇随笔竟然是一年前，时间过得实在太快，身边的同学也都在感叹时间飞逝。&lt;/p&gt;
&lt;p&gt;最近人工降雨，气温有点凉，很难顶。也许是气温的缘故我饭量大增，伙食费都不太够了。也怪吃得太饱热量过剩，赶上华为251，我真正成为了华
      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="记" scheme="https://blog.pazyx.xyz/tags/%E8%AE%B0/"/>
    
      <category term="251" scheme="https://blog.pazyx.xyz/tags/251/"/>
    
  </entry>
  
  <entry>
    <title>「朝花夕拾」写在19年11月10日</title>
    <link href="https://blog.pazyx.xyz/2019/11/10/end/"/>
    <id>https://blog.pazyx.xyz/2019/11/10/end/</id>
    <published>2019-11-10T15:13:55.000Z</published>
    <updated>2019-12-06T17:11:42.545Z</updated>
    
    <content type="html"><![CDATA[<p>接下来你们看到的感言是我写过高度最高的感言，因为这里的每个字都是在南昌飞往厦门的一万一千米高空上俯瞰着祖国的大好河山写下的。<br>我记得在一年多以前省赛准备组队时，我就跟队友说我想拿到亚洲区域赛的银奖。其实当时我心里想的是拿个铜奖就好，说银奖只是想让大家把目标定的高一些。因为那时学长们最好成绩仅是省赛的铜奖，各种比赛的规则和报名学校都没人了解。<br>幸运的是我们在当年就拿到了省赛的铜奖，也是学校第一支大一就拿到省赛铜奖的队伍。正因省赛的成绩带来的迷之自信，我在暑假找到了ICPC的教练群，顺利的报名了北京站和青岛站的网络赛。阴错阳差的以垫底的成绩打进了青岛现场赛，不出意外的在现场赛垫底，拿到了生涯第一块铁牌，不过也见识了清北的大佬们，虽然那场是南大☕️🐔捧的杯，今天这场还是它们捧杯，不得不说历史总是惊人的相似。打铁的经历在当时对自己没有太大打击，因为自己还年轻才大二，想着明年一定可以拿到牌子。<br>那次打铁回来后，一个队友也退出了，去实验室做项目了。说到这里，这两年看着同学们都在进步各种比赛拿奖捧杯各种奖学金在实验室或者各种项目混的风生水起，过程中我没有羡慕什么，也没想过去做项目或者去实验室，因为我就想拿到那块区域赛的铜牌。<br>大二下学期，参加了CCPC的邀请赛和ICPC的邀请赛都拿到了铜奖，这也是我们第一次拿到全国比赛的奖项。最令人开心的是在省赛也拿到了银奖，打破了学校多年铜奖的记录。暑假厦大的友军还邀请我们和集大一起过去训练，只在家待了半个月就回到厦门到厦大集训，这些经历都让我感觉离那块牌子近了很多，下半年拿奖应该是八九不离十了。<br>遗憾的是下半年我们资源拉满，打了四场比赛哈尔滨厦门南京南昌，只有厦门拿到了铜奖。南京南昌都是只差一点点。上个月我看着南京隔壁队的铜牌，我只有一种感觉，我不服，我感觉我配得上那块牌子。但最终我还是没能拿到它。<br>暑假厦大集训回来后，我就决定打完今年的比赛就退役了。其实这是我早有的打算，感觉自己已经没有当初的激情了，暑假过后基本就再没刷过什么题。和临沂大学的友军聊天时，发现大家都一样，在比赛前都很浮躁，患得患失无心刷题，计划着退役后要做的事情。<br>幸运的是这两年也取得了一些成绩，如果说ICPC（IUPC）还算个体面的比赛，我也算参赛选手中的老年人跟大家过了两招，激流勇退。也算是给自己留了点颜面。<br>在最后跟这些比赛说再见前，我想正式出一次题，办一次比赛。给同学们一个交代，给大家贡献一些题目，纪念我逝去的青春。这场比赛也许会在下个月跟大家见面，希望同学们能够喜欢。<br>我要开始考研复习了，换个方向继续前进。<br>希望能够为计算机科学贡献出自己的智慧。<br>继续努力，为了心中的梦想！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下来你们看到的感言是我写过高度最高的感言，因为这里的每个字都是在南昌飞往厦门的一万一千米高空上俯瞰着祖国的大好河山写下的。&lt;br&gt;我记得在一年多以前省赛准备组队时，我就跟队友说我想拿到亚洲区域赛的银奖。其实当时我心里想的是拿个铜奖就好，说银奖只是想让大家把目标定的高一些。
      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="ICPC" scheme="https://blog.pazyx.xyz/tags/ICPC/"/>
    
      <category term="心得" scheme="https://blog.pazyx.xyz/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」Oracle Database 期中考笔记</title>
    <link href="https://blog.pazyx.xyz/2019/11/06/oracle_midterm_notes/"/>
    <id>https://blog.pazyx.xyz/2019/11/06/oracle_midterm_notes/</id>
    <published>2019-11-06T06:43:18.000Z</published>
    <updated>2019-12-10T15:09:51.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE staff (</span><br><span class="line">    PRIMARY KEY (staff_num),</span><br><span class="line">    staff_num      INTEGER       DEFAULT 1  NOT NULL,</span><br><span class="line">    first_name     VARCHAR2(100)            NOT NULL,</span><br><span class="line">    leader_num     INTEGER                  NOT NULL,</span><br><span class="line">                   CONSTRAINT staff_first_name_uq UNIQUE (first_name),</span><br><span class="line">                   </span><br><span class="line">                   CONSTRAINT staff_leader_num_ck</span><br><span class="line">                   CHECK(leader_num &gt;= 1 AND leader_num &lt; 100),</span><br><span class="line">                   </span><br><span class="line">                   CONSTRAINT staff_leader_fk </span><br><span class="line">                   FOREIGN KEY(first_name) </span><br><span class="line">                   REFERENCES staff2(first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>只复制表结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE staff_temp like staff;</span><br></pre></td></tr></table></figure></p><p>复制表结构及数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE staff_temp as select * from staff;</span><br></pre></td></tr></table></figure></p><h3 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE staff;</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE staff</span><br><span class="line">ADD new_column_name INTEGER;</span><br></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE staff</span><br><span class="line">DROP COLUMN drop_column_name;</span><br></pre></td></tr></table></figure><h4 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE staff</span><br><span class="line">MODIFY modify_column_name INTEGER;</span><br></pre></td></tr></table></figure><h4 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 添加 CHECK 约束</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">ADD CONSTRAINT staff_first_name_ck CHECK (first_name in (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));</span><br><span class="line"></span><br><span class="line">-- 添加 UNIQUE 约束</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">ADD CONSTRAINT staff_first_name_uq UNIQUE (first_name);</span><br><span class="line"></span><br><span class="line">-- 添加 FOREIGN KEY 约束</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">ADD CONSTRAINT staff_leader_fk </span><br><span class="line">    FOREIGN KEY(first_name) </span><br><span class="line">    REFERENCES staff2(first_name);</span><br><span class="line">    </span><br><span class="line">-- 添加 NOT NULL 约束 (使用 MODIFY !!!)</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">MODIFY first_name CONSTRAINT staff_first_name_nn NOT NULL;</span><br><span class="line"></span><br><span class="line">ALTER TABLE staff</span><br><span class="line">MODIFY first_name NOT NULL;</span><br></pre></td></tr></table></figure><h4 id="删除、禁用、启用约束"><a href="#删除、禁用、启用约束" class="headerlink" title="删除、禁用、启用约束"></a>删除、禁用、启用约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 删除</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">DROP CONSTRAINT staff_first_name_nn;</span><br><span class="line"></span><br><span class="line">-- 禁用</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">DISABLE CONSTRAINT staff_first_name_nn;</span><br><span class="line"></span><br><span class="line">-- 启用</span><br><span class="line">ALTER TABLE staff</span><br><span class="line">ENABLE CONSTRAINT staff_first_name_nn;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p><em>DELETE</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE staff;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p><em>TRUNCATE</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE staff;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>TRUNCATE</th><th>DELETE</th></tr></thead><tbody><tr><td>清空表格</td><td>T</td><td>F</td></tr><tr><td>语句类型</td><td>DDL</td><td>DML</td></tr><tr><td>自动提交</td><td>T</td><td>F</td></tr><tr><td>可回滚</td><td>F</td><td>T</td></tr><tr><td>释放储存空间</td><td>T</td><td>F</td></tr><tr><td>推荐使用</td><td>T</td><td>F</td></tr></tbody></table><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMENT ON TABLE table_name is &apos;表注释&apos;;</span><br><span class="line">COMMENT ON TABLE staff is &apos;员工表&apos;;</span><br><span class="line"></span><br><span class="line">COMMENT ON COLUMN column_name is &apos;列注释&apos;;</span><br><span class="line">COMMENT ON COLUMN staff_num is &apos;员工号&apos;;</span><br></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME staff TO staff2;</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="基本顺序"><a href="#基本顺序" class="headerlink" title="基本顺序"></a>基本顺序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT avg(group_column) FROM</span><br><span class="line">table_a INNER JOIN table_b</span><br><span class="line">USING(join_column)</span><br><span class="line">WHERE join_column &gt; 1</span><br><span class="line">GROUP BY group_column</span><br><span class="line">HAVING avg(group_column) &gt; 10</span><br><span class="line">ORDER BY oreder_column DESC;</span><br></pre></td></tr></table></figure><h4 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WITH t AS (</span><br><span class="line">    SELECT equipment_name,damage*speed*(1+durability/100) val </span><br><span class="line">    FROM equipments</span><br><span class="line">    WHERE durability IS NOT NULL AND</span><br><span class="line">          attack_id IS NOT null</span><br><span class="line">    </span><br><span class="line">    UNION ALL</span><br><span class="line">    </span><br><span class="line">    SELECT equipment_name,durability*dr_ratio*2</span><br><span class="line">    FROM equipments</span><br><span class="line">    WHERE durability IS NOT null AND</span><br><span class="line">          attack_id IS NULL)</span><br><span class="line"></span><br><span class="line">SELECT equipment_name,val</span><br><span class="line">FROM t</span><br><span class="line">WHERE val &gt; (</span><br><span class="line">    SELECT AVG(val) FROM t)</span><br><span class="line">ORDER BY val DESC;</span><br></pre></td></tr></table></figure><h4 id="IN-TABLE"><a href="#IN-TABLE" class="headerlink" title="IN TABLE"></a>IN TABLE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT npc_name,attack_type,npc_hp</span><br><span class="line">FROM npcs inner join attack_types USING(attack_id)</span><br><span class="line">WHERE (attack_id,npc_hp) in (</span><br><span class="line">      SELECT attack_id,max(npc_hp)</span><br><span class="line">      FROM npcs</span><br><span class="line">      GROUP BY attack_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 内连接</span><br><span class="line">FROM products INNER JOIN product_types</span><br><span class="line">USING (product_type_id);</span><br><span class="line"></span><br><span class="line">-- 外连接</span><br><span class="line">FROM products (LEFT | RIGHT | FULL) OUTER JOIN product_types</span><br><span class="line">USING (product_type_id);</span><br><span class="line"></span><br><span class="line">-- 自连接</span><br><span class="line">FROM employees w INNER JOIN employees m</span><br><span class="line">ON w.manager_id = m.employee_id;</span><br></pre></td></tr></table></figure><h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where equipment_name like &apos;%铁_&apos;</span><br><span class="line"></span><br><span class="line">group by cid,cname</span><br><span class="line"></span><br><span class="line">nvl(gname,&apos;无&apos;)</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO staff VALUES(1,&apos;fn&apos;,10);</span><br><span class="line">INSERT INTO staff(staff_num,first_name,leader_num) VALUES(1,&apos;fn&apos;,10);</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM staff</span><br><span class="line">WHERE staff_num = 1;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE staff SET staff_num = 3, first_name = &apos;xxx&apos;</span><br><span class="line">WHERE staff_num = 1;</span><br></pre></td></tr></table></figure><h2 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">set serveroutput on</span><br><span class="line"></span><br><span class="line">declare</span><br><span class="line"></span><br><span class="line">cursor c_countries IS </span><br><span class="line">select cname,cid from countries;</span><br><span class="line"></span><br><span class="line">v_cid countries.cid%type;</span><br><span class="line">v_city_cnt integer;</span><br><span class="line">v_gener_cnt integer;</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">  for v_c IN c_countries LOOP</span><br><span class="line">    v_cid := v_c.cid;</span><br><span class="line"></span><br><span class="line">    select count(*) into v_city_cnt from cities where cid = v_cid;</span><br><span class="line">    select count(*) into v_gener_cnt from generals where cid = v_cid and cityid is not null;</span><br><span class="line">IF gener_cnt &gt; 2 THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(v_c.cname ||&apos;有&apos;||v_city_cnt||&apos;座城市，&apos;||v_gener_cnt||&apos;名现役武将&apos;);</span><br><span class="line">  END IF;</span><br><span class="line">  END LOOP;</span><br><span class="line">end;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DDL&quot;&gt;&lt;a href=&quot;#DDL&quot; class=&quot;headerlink&quot; title=&quot;DDL&quot;&gt;&lt;/a&gt;DDL&lt;/h2&gt;&lt;h3 id=&quot;建表&quot;&gt;&lt;a href=&quot;#建表&quot; class=&quot;headerlink&quot; title=&quot;建表&quot;&gt;&lt;/a&gt;建表&lt;/h3&gt;&lt;f
      
    
    </summary>
    
      <category term="计算机" scheme="https://blog.pazyx.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Oracle" scheme="https://blog.pazyx.xyz/tags/Oracle/"/>
    
      <category term="数据库" scheme="https://blog.pazyx.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="https://blog.pazyx.xyz/tags/SQL/"/>
    
      <category term="PL/SQL" scheme="https://blog.pazyx.xyz/tags/PL-SQL/"/>
    
  </entry>
  
  <entry>
    <title>Apache2 服务器配置 HTTPS</title>
    <link href="https://blog.pazyx.xyz/2019/08/18/ssl/"/>
    <id>https://blog.pazyx.xyz/2019/08/18/ssl/</id>
    <published>2019-08-18T05:12:41.000Z</published>
    <updated>2019-11-21T01:57:42.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>由于多次配置 SSL 证书，每次间隔时间较长，每次都忘记怎么搞。。。特地总结一下，延缓阿兹海默。</p><p>这份教程只针对 Apache2 服务器，且已写好配置文件的选手。</p><p>大概分以下几个步骤：</p><ul><li>申请证书</li><li>验证域名所有权</li><li>下载证书转换格式</li><li>将证书传入服务器</li><li>修改配置文件</li><li>载入配置文件</li><li>重启 Apache</li></ul><h1 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h1><p>推荐 <a href="https://freessl.cn" target="_blank" rel="noopener">FreeSSL</a>，其中有两款免费证书：TrustAsia 的一年单域名证书、Let’s Encrypt的 90 天通配符证书。</p><p>如果子域名较少推荐选择前者，我用的子域名比较多选择后者，文件较少但 90 天要配置一次。</p><h1 id="验证域名所有权"><a href="#验证域名所有权" class="headerlink" title="验证域名所有权"></a>验证域名所有权</h1><p>根据 FreeSSL 网站的提示，在解析域名的网站按要求添加 TXT 记录即可。</p><h1 id="下载证书转换格式"><a href="#下载证书转换格式" class="headerlink" title="下载证书转换格式"></a>下载证书转换格式</h1><p>下载到证书后会发现是三个文件，而 Apache2 只需要两个文件，最终需要一个 <code>.key</code> 和一个 <code>.pem</code>的文件。</p><p>你将下载到如下三个文件：</p><ul><li><code>.key</code>文件，证书私钥</li><li><code>CA_xxx.crt</code>，CA 中间证书</li><li><code>域名.crt</code>，服务器证书</li></ul><p>其中 <code>.key</code> 文件就是最终需要的 <code>.key</code> 文件，而 <code>.pem</code> 文件需要自己创建再将 <code>域名.crt</code> 和  <code>CA_xxx.crt</code> 按顺序粘贴进去。</p><h1 id="将证书传入服务器"><a href="#将证书传入服务器" class="headerlink" title="将证书传入服务器"></a>将证书传入服务器</h1><p>使用 <code>scp</code> 将证书上传至服务器，当然这需要配置好 <code>ssh</code>。</p><p>命令格式和示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp file_source file_target</span><br><span class="line">scp ./pazyx_xyz.pem git@pazyx.xyz:~/</span><br></pre></td></tr></table></figure></p><p>我一般是将文件传入 home 目录后再 <code>ssh</code>登录到服务器将文件从 home 目录放到 <code>/etc/apache2/ssl/</code> 目录下，以免权限受限。</p><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>配置文件为 <code>/etc/apache2/site-available/default-ssl.conf</code><br>如何配置略，因为我也忘了，随便改一改就是了。</p><h1 id="载入配置文件"><a href="#载入配置文件" class="headerlink" title="载入配置文件"></a>载入配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2ensite default-ssl</span><br></pre></td></tr></table></figure><h1 id="重启-Apache"><a href="#重启-Apache" class="headerlink" title="重启 Apache"></a>重启 Apache</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/9e75d4068236" target="_blank" rel="noopener">Apache配置ssl</a></li><li><a href="https://help.aliyun.com/knowledge_detail/88447.html?spm=5176.2000002.0.0.51c93a1a65rvG5" target="_blank" rel="noopener">免费证书下载的两个文件的说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;由于多次配置 SSL 证书，每次间隔时间较长，每次都忘记怎么搞。。。特地总结一下，延缓阿兹海默。&lt;/p&gt;
&lt;p&gt;这份教程只针对 Apache
      
    
    </summary>
    
      <category term="笔记" scheme="https://blog.pazyx.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SSL" scheme="https://blog.pazyx.xyz/tags/SSL/"/>
    
      <category term="HTTPS" scheme="https://blog.pazyx.xyz/tags/HTTPS/"/>
    
      <category term="Apache" scheme="https://blog.pazyx.xyz/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>「题解」kuangbin 最小生成树</title>
    <link href="https://blog.pazyx.xyz/2019/04/29/kuangbin_MST/"/>
    <id>https://blog.pazyx.xyz/2019/04/29/kuangbin_MST/</id>
    <published>2019-04-29T13:23:42.000Z</published>
    <updated>2019-04-29T14:13:51.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>POJ-1251 Jungle Roads (水题，%c)</li><li>POJ-1287 Networking (水)</li><li>POJ-2031 Building a Space Station (%f浮点数尴尬精度，两球间距离)</li><li>POJ-2421 Constructing Roads (一些边已建好，简单处理一下)</li><li>ZOJ-1586 QS Network (处理一下边权)</li><li>HDU-1233 还是畅通工程 (水)</li><li>HDU-1875 畅通工程再续 (浮点数，条件连边)</li><li>HDU-1301 Jungle Roads (重复 -&gt; POJ-1251)</li><li>POJ-2349 Arctic Network (第 K 大边)</li><li>POJ-1751 Highways (求最小生成树的边，加 0 权边)</li><li>UVA-10147 Highways (多组的 POJ-1751) +</li><li>POJ-1258 Agri-Net (水)</li><li>POJ-3026 Borg Maze (BFS + Kruskal，用最短路建图，垃圾输入)</li><li>POJ-1789 Truck History (Prim，Kruskal 超时)</li><li>POJ-1679 The Unique MST (次小生成树)</li></ul><p><strong>代码最后附简单题解</strong></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kruskal 算法求 MST</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;  <span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;  <span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prim 求 MST</span></span><br><span class="line"><span class="comment"> * 耗费矩阵 cost[][]，标号从 0 开始，0∼n-1</span></span><br><span class="line"><span class="comment"> * 返回最小生成树的权值，返回 -1 表示原图不连通</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> lowc[MAXN];</span><br><span class="line"><span class="comment">//点是 0 n-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> cost[][MAXN], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) lowc[i] = cost[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minc = INF;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123;</span><br><span class="line">        minc = lowc[j];</span><br><span class="line">        p = j;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (minc == INF) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//原图不连通</span></span><br><span class="line">    ans += minc;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecondMST-Prim"><a href="#SecondMST-Prim" class="headerlink" title="SecondMST (Prim)"></a>SecondMST (Prim)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 次小生成树</span></span><br><span class="line"><span class="comment"> * 求最小生成树时，用数组 Max[i][j] 来表示 MST 中 i 到 j 最大边权</span></span><br><span class="line"><span class="comment"> * 求完后，直接枚举所有不在 MST 中的边，替换掉最大边权的边，更新答案</span></span><br><span class="line"><span class="comment"> * 点的编号从 0 开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> lowc[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="keyword">int</span> Max[MAXN][MAXN];</span><br><span class="line"><span class="comment">// Max[i][j] 表示在最小生成树中从 i 到 j 的路径中的最大边权</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> cost[][MAXN], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(Max, <span class="number">0</span>, <span class="keyword">sizeof</span>(Max));</span><br><span class="line">  <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">  vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  pre[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    lowc[i] = cost[<span class="number">0</span>][i];</span><br><span class="line">    pre[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lowc[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minc = INF;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123;</span><br><span class="line">        minc = lowc[j];</span><br><span class="line">        p = j;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (minc == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ans += minc;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line">    used[p][pre[p]] = used[pre[p]][p] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[j] &amp;&amp; j != p)</span><br><span class="line">        Max[j][p] = Max[p][j] = max(Max[j][pre[p]], lowc[p]);</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) &#123;</span><br><span class="line">        lowc[j] = cost[p][j];</span><br><span class="line">        pre[j] = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smst</span><span class="params">(<span class="keyword">int</span> cost[][MAXN], <span class="keyword">int</span> n, <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Min = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">if</span> (cost[i][j] != INF &amp;&amp; !used[i][j]) &#123;</span><br><span class="line">        Min = min(Min, ans + cost[i][j] - Max[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">if</span> (Min == INF) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不存在</span></span><br><span class="line">  <span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="POJ-1251-Jungle-Roads"><a href="#POJ-1251-Jungle-Roads" class="headerlink" title="POJ-1251 Jungle Roads"></a>POJ-1251 Jungle Roads</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1251 Jungle Roads</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1251</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> x;</span><br><span class="line">      <span class="keyword">int</span> m;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">" %c%d"</span>, &amp;x, &amp;m);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> y;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c%d"</span>, &amp;y, &amp;w);</span><br><span class="line">        addedge(x - <span class="string">'A'</span>, y - <span class="string">'A'</span>, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裸题，scanf %c 读入尴尬</span></span><br><span class="line"><span class="comment">// scanf(" %c%d", &amp;x, &amp;m);</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1287-Networking"><a href="#POJ-1287-Networking" class="headerlink" title="POJ-1287 Networking"></a>POJ-1287 Networking</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1287 Networking</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1287</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      addedge(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裸题</span></span><br></pre></td></tr></table></figure><h2 id="POJ-2031-Building-a-Space-Station"><a href="#POJ-2031-Building-a-Space-Station" class="headerlink" title="POJ-2031 Building a Space Station"></a>POJ-2031 Building a Space Station</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2031 Building a Space Station</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2031</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">double</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z, <span class="keyword">double</span> xx, <span class="keyword">double</span> yy, <span class="keyword">double</span> zz)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx - x) * (xx - x) + (yy - y) * (yy - y) + (zz - z) * (zz - z));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cirlen</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z, <span class="keyword">double</span> r, <span class="keyword">double</span> xx, <span class="keyword">double</span> yy,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">double</span> zz, <span class="keyword">double</span> rr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ll = len(x, y, z, xx, yy, zz);</span><br><span class="line">  <span class="keyword">if</span> (ll - r - rr &lt; <span class="number">1e-5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ll - r - rr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> xp[MAXN];</span><br><span class="line"><span class="keyword">double</span> yp[MAXN];</span><br><span class="line"><span class="keyword">double</span> zp[MAXN];</span><br><span class="line"><span class="keyword">double</span> rp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>, &amp;xp[i], &amp;yp[i], &amp;zp[i], &amp;rp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        addedge(i, j,</span><br><span class="line">                cirlen(xp[i], yp[i], zp[i], rp[i], xp[j], yp[j], zp[j], rp[j]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数的最小生成树，球之间的距离，距离小于零，就建一条权为 0 的边</span></span><br><span class="line"><span class="comment">// POJ尴尬精度 %f</span></span><br></pre></td></tr></table></figure><h2 id="POJ-2421-Constructing-Roads"><a href="#POJ-2421-Constructing-Roads" class="headerlink" title="POJ-2421 Constructing Roads"></a>POJ-2421 Constructing Roads</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2421 Constructing Roads</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2421</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;  <span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;  <span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mapx[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mapx[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> Q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    mapx[a][b] = <span class="number">0</span>;</span><br><span class="line">    mapx[b][a] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      addedge(i, j, min(mapx[i][j], mapx[j][i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = Kruskal(N);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一些路已建好，把边权改为 0 就好了</span></span><br></pre></td></tr></table></figure><h2 id="ZOJ-1586-QS-Network"><a href="#ZOJ-1586-QS-Network" class="headerlink" title="ZOJ-1586 QS Network"></a>ZOJ-1586 QS Network</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZOJ-1586 QS Network</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/ZOJ-1586</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1100</span>;     <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];               <span class="comment">//并查集使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> codec[MAXN];  <span class="comment">// *&amp;*</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line"></span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;codec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) addedge(i, j, w + codec[i] + codec[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边时，加一下适配器的价格</span></span><br></pre></td></tr></table></figure><h2 id="HDU-1233-还是畅通工程"><a href="#HDU-1233-还是畅通工程" class="headerlink" title="HDU-1233 还是畅通工程"></a>HDU-1233 还是畅通工程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU-1233 还是畅通工程</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/HDU-1233</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;  <span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;  <span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">      addedge(a, b, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裸题</span></span><br></pre></td></tr></table></figure><h2 id="HDU-1875-畅通工程再续"><a href="#HDU-1875-畅通工程再续" class="headerlink" title="HDU-1875 畅通工程再续"></a>HDU-1875 畅通工程再续</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU-1875 畅通工程再续</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/HDU-1875</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">310</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">double</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx - x) * (xx - x) + (yy - y) * (yy - y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> xp[MAXN];</span><br><span class="line"><span class="keyword">double</span> yp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xp[i], &amp;yp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> xly = len(xp[i], yp[i], xp[j], yp[j]);</span><br><span class="line">        <span class="keyword">if</span> (xly &gt;= <span class="number">10</span> &amp;&amp; xly &lt;= <span class="number">1000</span>) addedge(i, j, xly * <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = Kruskal(n);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"oh!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数，条件连边</span></span><br></pre></td></tr></table></figure><h2 id="HDU-1301-Jungle-Roads"><a href="#HDU-1301-Jungle-Roads" class="headerlink" title="HDU-1301 Jungle Roads"></a>HDU-1301 Jungle Roads</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU-1301 Jungle Roads</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/HDU-1301</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> x;</span><br><span class="line">      <span class="keyword">int</span> m;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">" %c%d"</span>, &amp;x, &amp;m);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> y;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c%d"</span>, &amp;y, &amp;w);</span><br><span class="line">        addedge(x - <span class="string">'A'</span>, y - <span class="string">'A'</span>, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 竟然有重复的题，一模一样 -&gt; POJ-1251</span></span><br><span class="line"><span class="comment">// 裸题，scanf %c 读入尴尬</span></span><br><span class="line"><span class="comment">// scanf(" %c%d", &amp;x, &amp;m);</span></span><br></pre></td></tr></table></figure><h2 id="POJ-2349-Arctic-Network"><a href="#POJ-2349-Arctic-Network" class="headerlink" title="POJ-2349 Arctic Network"></a>POJ-2349 Arctic Network</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2349 Arctic Network</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2349</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">510</span>;     <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">250000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];              <span class="comment">//并查集使用</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">double</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans = max(ans, w);</span><br><span class="line">      vd.push_back(w);</span><br><span class="line">      <span class="comment">// ans += w;</span></span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx - x) * (xx - x) + (yy - y) * (yy - y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> xp[MAXN];</span><br><span class="line"><span class="keyword">double</span> yp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    vd.clear();</span><br><span class="line">    <span class="keyword">int</span> n, s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xp[i], &amp;yp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> xly = len(xp[i], yp[i], xp[j], yp[j]);</span><br><span class="line">        addedge(i, j, xly);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = Kruskal(n);</span><br><span class="line">    ans = vd[vd.size() - s];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小生成树的第 K 大边</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1751-Highways"><a href="#POJ-1751-Highways" class="headerlink" title="POJ-1751 Highways"></a>POJ-1751 Highways</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1751 Highways</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1751</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;     <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[MAXN];  <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">double</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">1e-5</span>) &#123;</span><br><span class="line">        vx.push_back(u);</span><br><span class="line">        vy.push_back(v);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx - x) * (xx - x) + (yy - y) * (yy - y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> xp[MAXN];</span><br><span class="line"><span class="keyword">double</span> yp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  tol = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xp[i], &amp;yp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">double</span> xly = len(xp[i], yp[i], xp[j], yp[j]);</span><br><span class="line">      addedge(i, j, xly * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    addedge(a, b, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">double</span> ans = Kruskal(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vx.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, vx[i], vy[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小生成树的边，加 0 权边</span></span><br></pre></td></tr></table></figure><h2 id="UVA-10147-Highways"><a href="#UVA-10147-Highways" class="headerlink" title="UVA-10147 Highways"></a>UVA-10147 Highways</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UVA-10147 Highways</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/UVA-10147</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;     <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[MAXN];  <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">double</span> w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">double</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        vx.push_back(u);</span><br><span class="line">        vy.push_back(v);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> xx, <span class="keyword">double</span> yy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx - x) * (xx - x) + (yy - y) * (yy - y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> xp[MAXN];</span><br><span class="line"><span class="keyword">double</span> yp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    vx.clear();</span><br><span class="line">    vy.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xp[i], &amp;yp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> xly = len(xp[i], yp[i], xp[j], yp[j]);</span><br><span class="line">        addedge(i, j, xly * <span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">      addedge(a, b, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = Kruskal(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vx.size(); i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, vx[i], vy[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vx.size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No new highways need\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小生成树的边，加 0 权边</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1258-Agri-Net"><a href="#POJ-1258-Agri-Net" class="headerlink" title="POJ-1258 Agri-Net"></a>POJ-1258 Agri-Net</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1258 Agri-Net</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1258</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;    <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];             <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;  <span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;  <span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w);</span><br><span class="line">        addedge(i, j, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裸题</span></span><br></pre></td></tr></table></figure><h2 id="POJ-3026-Borg-Maze"><a href="#POJ-3026-Borg-Maze" class="headerlink" title="POJ-3026 Borg Maze"></a>POJ-3026 Borg Maze</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3026 Borg Maze</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3026</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1100</span>;     <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];               <span class="comment">//并查集使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"><span class="keyword">int</span> tol;       <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;  <span class="comment">//排序函数，讲边按照权值从小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;  <span class="comment">//传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mapx[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dirx[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> diry[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">queue</span>&lt;pair&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; Q;</span><br><span class="line">  Q.push(make_pair(make_pair(x, y), <span class="number">0</span>));</span><br><span class="line">  vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> xt = Q.front().first.first;</span><br><span class="line">    <span class="keyword">int</span> yt = Q.front().first.second;</span><br><span class="line">    <span class="keyword">int</span> times = Q.front().second;</span><br><span class="line">    Q.pop();</span><br><span class="line">    <span class="keyword">if</span> (mapx[x][y] != mapx[xt][yt] &amp;&amp; mapx[xt][yt] != <span class="number">0</span>) &#123;</span><br><span class="line">      addedge(mapx[x][y], mapx[xt][yt], times);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> tx = xt + dirx[i];</span><br><span class="line">      <span class="keyword">int</span> ty = yt + diry[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; tx &lt; n &amp;&amp; ty &lt; m &amp;&amp; !vis[tx][ty]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapx[tx][ty] != <span class="number">-1</span>) &#123;</span><br><span class="line">          Q.push(make_pair(make_pair(tx, ty), times + <span class="number">1</span>));</span><br><span class="line">          vis[tx][ty] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(mapx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mapx));</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      gets(str);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[j] == <span class="string">'A'</span> || str[j] == <span class="string">'S'</span>) &#123;</span><br><span class="line">          mapx[i][j] = ++cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[j] == <span class="string">' '</span>) &#123;</span><br><span class="line">          mapx[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapx[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          bfs(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal(cnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS + Kruskal</span></span><br><span class="line"><span class="comment">// 用无权图最短路权值加边</span></span><br><span class="line"><span class="comment">// 一开始 MAXN 和 MAXM 开小了，wa...wa...wa...</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1789-Truck-History"><a href="#POJ-1789-Truck-History" class="headerlink" title="POJ-1789 Truck History"></a>POJ-1789 Truck History</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1789 Truck History</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1789</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2010</span>;  <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> lowc[MAXN];</span><br><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="comment">//点是 0 n-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> cost[][MAXN], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) lowc[i] = cost[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minc = INF;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123;</span><br><span class="line">        minc = lowc[j];</span><br><span class="line">        p = j;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (minc == INF) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//原图不连通</span></span><br><span class="line">    ans += minc;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> str[MAXN][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[a][i] != str[b][i]) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">        cost[i][j] = len(i, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Prim(cost, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The highest possible quality is 1/%d.\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal 超时，用 Prim !</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1679-The-Unique-MST"><a href="#POJ-1679-The-Unique-MST" class="headerlink" title="POJ-1679 The Unique MST"></a>POJ-1679 The Unique MST</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1679 The Unique MST</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1679</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> lowc[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="keyword">int</span> Max[MAXN][MAXN];</span><br><span class="line"><span class="comment">// Max[i][j] 表示在最小生成树中从 i 到 j 的路径中的最大边权</span></span><br><span class="line"><span class="keyword">bool</span> used[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> cost[][MAXN], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(Max, <span class="number">0</span>, <span class="keyword">sizeof</span>(Max));</span><br><span class="line">  <span class="built_in">memset</span>(used, <span class="literal">false</span>, <span class="keyword">sizeof</span>(used));</span><br><span class="line">  vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  pre[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    lowc[i] = cost[<span class="number">0</span>][i];</span><br><span class="line">    pre[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lowc[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> minc = INF;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123;</span><br><span class="line">        minc = lowc[j];</span><br><span class="line">        p = j;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (minc == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ans += minc;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line">    used[p][pre[p]] = used[pre[p]][p] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[j] &amp;&amp; j != p)</span><br><span class="line">        Max[j][p] = Max[p][j] = max(Max[j][pre[p]], lowc[p]);</span><br><span class="line">      <span class="keyword">if</span> (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) &#123;</span><br><span class="line">        lowc[j] = cost[p][j];</span><br><span class="line">        pre[j] = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smst</span><span class="params">(<span class="keyword">int</span> cost[][MAXN],<span class="keyword">int</span> n,<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Min=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(cost[i][j]!=INF &amp;&amp; !used[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                Min=min(Min,ans+cost[i][j]-Max[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span>(Min==INF)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在</span></span><br><span class="line">    <span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> costx[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(costx, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(costx));</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) costx[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      a--;</span><br><span class="line">      b--;</span><br><span class="line">      costx[a][b] = c;</span><br><span class="line">      costx[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Prim(costx, n);</span><br><span class="line">    <span class="keyword">int</span> ansMST = smst(costx, n,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == ansMST) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Not Unique!\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次小生成树，不知道为什么最小生成树计数不行</span></span><br><span class="line"><span class="comment">// kuangbin 题解：https://www.cnblogs.com/kuangbin/p/3147329.html</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;POJ-1251 Jungle Roads (水题，%c)&lt;/li&gt;
&lt;li&gt;POJ-1287 Networking (水)&lt;/
      
    
    </summary>
    
      <category term="题解" scheme="https://blog.pazyx.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="DFS" scheme="https://blog.pazyx.xyz/tags/DFS/"/>
    
      <category term="Dijkstra" scheme="https://blog.pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="Kruskal" scheme="https://blog.pazyx.xyz/tags/Kruskal/"/>
    
      <category term="Prim" scheme="https://blog.pazyx.xyz/tags/Prim/"/>
    
  </entry>
  
  <entry>
    <title>「题解」kuangbin 最短路</title>
    <link href="https://blog.pazyx.xyz/2019/04/29/kuangbin_short_path/"/>
    <id>https://blog.pazyx.xyz/2019/04/29/kuangbin_short_path/</id>
    <published>2019-04-29T12:23:42.000Z</published>
    <updated>2019-04-29T14:17:14.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>POJ-2387 Til the Cows Come Home（水）</li><li>POJ-2253 Frogger（浮点数，尴尬精度）</li><li>POJ-1797 Heavy Transportation（求所有路径中最大边权的最小值）</li><li>POJ-3268 Silver Cow Party（求往返最短路，反向连边）</li><li>POJ-1860 Currency Exchange（换汇问题，最长路判断正环）</li><li>POJ-3259 Wormholes（判断负值圈）</li><li>POJ-1502 MPI Maelstrom（所有点最短路中的最长路）</li><li>POJ-3660 Cow Contest（传递闭包 floyd 或 DFS）</li><li>POJ-2240 Arbitrage（判断正环）</li><li>POJ-1511 Invitation Cards（求往返最短路，反向连边）</li><li>POJ-1847 Tram（水）</li><li>POJ-1062 昂贵的聘礼*</li><li>POJ-3159 Candies（伪差分约束系统（裸最短路）+ 输入输出挂）</li><li>POJ-2502 Subway（建图麻烦）</li><li>POJ-3169 Layout（差分约束系统，输出差值）</li><li>LightOJ-1074 Extended Traffic（判断所有负环）</li><li>HDU-4725 The Shortest Path in Nya Graph（建图技巧）</li><li>HDU-3416 Marriage Match IV（最短路 + 最大流 找出最短路经过的边）</li></ul><p><strong>代码最后附简单题解</strong></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="Dijkstra-simple"><a href="#Dijkstra-simple" class="headerlink" title="Dijkstra_simple"></a>Dijkstra_simple</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单源最短路径，Dijkstra 算法，邻接矩阵形式，复杂度为O(n^2)</span></span><br><span class="line"><span class="comment"> * 求出源 beg 到所有点的最短路径，传入图的顶点数，和邻接矩阵 cost[][]</span></span><br><span class="line"><span class="comment"> * 返回各点的最短路径 lowcost[], 路径 pre[].pre[i] 记录 beg 到 i</span></span><br><span class="line"><span class="comment"> * 路径上的父结点，pre[beg]=-1</span></span><br><span class="line"><span class="comment"> * 可更改路径权类型，但是权值必须为非负</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typec int</span></span><br><span class="line"><span class="keyword">const</span> typec INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(typec cost[][MAXN], typec lowcost[], <span class="keyword">int</span> n, <span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    lowcost[i] = INF;</span><br><span class="line">    vis[i] = <span class="literal">false</span>;</span><br><span class="line">    pre[i] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lowcost[beg] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Min = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i] &amp;&amp; lowcost[i] &lt; Min) &#123;</span><br><span class="line">        Min = lowcost[i];</span><br><span class="line">        k = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    vis[k] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i]) &#123;</span><br><span class="line">        lowcost[i] = lowcost[k] + cost[k][i];</span><br><span class="line">        pre[i] = k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra-set"><a href="#Dijkstra-set" class="headerlink" title="Dijkstra_set"></a>Dijkstra_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * 使用优先队列优化 Dijkstra 算法</span></span><br><span class="line"><span class="comment"> * 复杂度 O(ElogE)</span></span><br><span class="line"><span class="comment"> * 注意对</span></span><br><span class="line"><span class="comment"> * vector&lt;Edge&gt;E[MAXN] 进行初始化后加边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford"></a>Bellman_Ford</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单源最短路 bellman_ford 算法，复杂度 O(VE)</span></span><br><span class="line"><span class="comment"> * 可以处理负边权图。</span></span><br><span class="line"><span class="comment"> * 可以判断是否存在负环回路。返回 true, 当且仅当图中不包含从源点可达的负权回路</span></span><br><span class="line"><span class="comment"> * vector&lt;Edge&gt;E; 先 E.clear() 初始化，然后加入所有边</span></span><br><span class="line"><span class="comment"> * 点的编号从 1 开始 (从 0 开始简单修改就可以了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v;</span><br><span class="line">  <span class="keyword">int</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : u(_u), v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E;</span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman_ford</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//最多做 n-1 次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E.size(); j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u = E[j].u;</span><br><span class="line">      <span class="keyword">int</span> v = E[j].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[j].cost;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E.size(); j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist[E[j].v] &gt; dist[E[j].u] + E[j].cost) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单源最短路 SPFA</span></span><br><span class="line"><span class="comment"> * 时间复杂度 0(kE)</span></span><br><span class="line"><span class="comment"> * 这个是队列实现，有时候改成栈实现会更加快，很容易修改</span></span><br><span class="line"><span class="comment"> * 这个复杂度是不定的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          que.push(v);</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dist[i][j] = min(dist[i][j], dist[i][k] + dist[j][k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出挂"><a href="#输入输出挂" class="headerlink" title="输入输出挂"></a>输入输出挂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span> </span>&#123;  <span class="comment">//输入外挂</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="keyword">if</span> ((ch = getchar()) == <span class="string">'-'</span>)</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">    res = ch - <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) res = res * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">  <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;  <span class="comment">//输出外挂</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    a = -a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a &gt;= <span class="number">10</span>) Out(a / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="POJ-2387-Til-the-Cows-Come-Home"><a href="#POJ-2387-Til-the-Cows-Come-Home" class="headerlink" title="POJ-2387 Til the Cows Come Home"></a>POJ-2387 Til the Cows Come Home</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2387 Til the Cows Come Home</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2387</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, N;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;N)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> u, v, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">      addedge(u, v, w);</span><br><span class="line">      addedge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(N, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[N]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裸的 dji_set，坑：多组输入！</span></span><br></pre></td></tr></table></figure><h2 id="POJ-2253-Frogger"><a href="#POJ-2253-Frogger" class="headerlink" title="POJ-2253 Frogger"></a>POJ-2253 Frogger</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2253 Frogger</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2253</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">double</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">double</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">double</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">double</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">double</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; max(dist[u], cost)) &#123;</span><br><span class="line">        dist[v] = max(dist[u], cost);</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> tone_x[MAXN], tone_y[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((tone_x[a] - tone_x[b]) * (tone_x[a] - tone_x[b]) +</span><br><span class="line">              (tone_y[a] - tone_y[b]) * (tone_y[a] - tone_y[b]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N;</span><br><span class="line">  <span class="keyword">int</span> CNT = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;tone_x[i], &amp;tone_y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">        addedge(i, j, len(i, j));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(N, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scenario #%d\n"</span>, CNT++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Frog Distance = %.3lf\n\n"</span>, dist[<span class="number">2</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最短路变形，大坑：POJ选择C++才能过？？？</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1797-Heavy-Transportation"><a href="#POJ-1797-Heavy-Transportation" class="headerlink" title="POJ-1797 Heavy Transportation"></a>POJ-1797 Heavy Transportation</h2><h3 id="dij-set"><a href="#dij-set" class="headerlink" title="dij_set"></a>dij_set</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1797 Heavy Transportation</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1797</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &lt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = INF;</span><br><span class="line">  que.push(qnode(start, dist[start]));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &lt; min(dist[u], cost)) &#123;</span><br><span class="line">        dist[v] = min(dist[u], cost);</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, CNT = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (CNT &lt;= T) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">      addedge(a, b, w);</span><br><span class="line">      addedge(b, a, w);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>, CNT++, dist[n]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求 1 - n 中所有路径中最大边权的最小值</span></span><br></pre></td></tr></table></figure><h3 id="dij-simple"><a href="#dij-simple" class="headerlink" title="dij_simple"></a>dij_simple</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1797 Heavy Transportation</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1797</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> typec int</span></span><br><span class="line"><span class="keyword">const</span> typec INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xcost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(typec cost[][MAXN], typec lowcost[], <span class="keyword">int</span> n, <span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    lowcost[i] = <span class="number">0</span>;</span><br><span class="line">    vis[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  lowcost[beg] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i] &amp;&amp; lowcost[i] &gt; Min) &#123;</span><br><span class="line">        Min = lowcost[i];</span><br><span class="line">        k = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    vis[k] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i] &amp;&amp; min(lowcost[k], cost[k][i]) &gt; lowcost[i]) &#123;</span><br><span class="line">        lowcost[i] = min(lowcost[k], cost[k][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, CNT = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (CNT &lt;= T) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(xcost, <span class="number">0</span>, <span class="keyword">sizeof</span>(xcost));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">      a--;</span><br><span class="line">      b--;</span><br><span class="line">      xcost[a][b] = xcost[b][a] = max(w, xcost[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(xcost, dist, n, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>, CNT++, dist[n - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求 1 - n 中所有路径中最大边权的最小值</span></span><br></pre></td></tr></table></figure><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1797 Heavy Transportation</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1797</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2005</span>;     <span class="comment">//最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000005</span>;  <span class="comment">//最大边数</span></span><br><span class="line"><span class="keyword">int</span> F[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">&#125; edge[MAXM];  <span class="comment">//存储边的信息，包括起点/终点/权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tol;  <span class="comment">//边数，加边前赋值为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[tol].u = u;</span><br><span class="line">  edge[tol].v = v;</span><br><span class="line">  edge[tol++].w = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序函数，讲边按照权值从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123; <span class="keyword">return</span> a.w &gt; b.w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (F[x] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> xans;</span><br><span class="line"><span class="comment">// 传入点数，返回最小生成树的权值，如果不连通返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span>(F));</span><br><span class="line">  sort(edge, edge + tol, cmp);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;  <span class="comment">//计算加入的边数</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tol; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = edge[i].u;</span><br><span class="line">    <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">    <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">    <span class="keyword">int</span> t1 = find(u);</span><br><span class="line">    <span class="keyword">int</span> t2 = find(v);</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">      ans += w;</span><br><span class="line">      xans = min(xans, w);</span><br><span class="line">      F[t1] = t2;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">int</span> x1 = find(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> xn = find(n);</span><br><span class="line">    <span class="keyword">if</span> (x1 == xn) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//----------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// 1-n连接后就不需贪心</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不连通</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T, CNT = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (CNT &lt;= T) &#123;</span><br><span class="line">    tol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, w;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">      addedge(a, b, w);</span><br><span class="line">      <span class="comment">//   addedge(b, a, w);</span></span><br><span class="line">    &#125;</span><br><span class="line">    xans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    Kruskal(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>, CNT++, xans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求 1 - n 中所有路径中最大边权的最小值</span></span><br></pre></td></tr></table></figure><h2 id="POJ-3268-Silver-Cow-Party"><a href="#POJ-3268-Silver-Cow-Party" class="headerlink" title="POJ-3268 Silver Cow Party"></a>POJ-3268 Silver Cow Party</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3268 Silver Cow Party</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3268</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : u(_u), v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; Etmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"><span class="keyword">int</span> tdist[MAXN];</span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(u, v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, x;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    addedge(a, b, c);</span><br><span class="line">    Etmp.push_back(Edge(a, b, c));</span><br><span class="line">  &#125;</span><br><span class="line">  Dijkstra(n, x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    tdist[i] = dist[i];</span><br><span class="line">    E[i].clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    addedge(Etmp[i].v, Etmp[i].u, Etmp[i].cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  Dijkstra(n, x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    tdist[i] += dist[i];</span><br><span class="line">    ans = max(ans, tdist[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 x 向所有点跑一次 dij，将边反向再来一次，求往返距离</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1860-Currency-Exchange"><a href="#POJ-1860-Currency-Exchange" class="headerlink" title="POJ-1860 Currency Exchange"></a>POJ-1860 Currency Exchange</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1860 Currency Exchange</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1860</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, S;</span><br><span class="line"><span class="keyword">double</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">10000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">double</span> cost;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">double</span> _cost = <span class="number">0</span>, <span class="keyword">double</span> _c = <span class="number">0</span>)</span><br><span class="line">      : v(_v), cost(_cost), c(_c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w, <span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">  E[u].push_back(Edge(v, w, c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">double</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = <span class="number">0</span>;</span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = V;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &lt; (dist[u] - E[u][i].c) * E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = (dist[u] - E[u][i].c) * E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          que.push(v);</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%lf"</span>, &amp;N, &amp;M, &amp;S, &amp;V);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> rab, cab, rba, cba;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf%lf%lf"</span>, &amp;a, &amp;b, &amp;rab, &amp;cab, &amp;rba, &amp;cba);</span><br><span class="line">    addedge(a, b, rab, cab);</span><br><span class="line">    addedge(b, a, rba, cba);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SPFA(S, N)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换汇问题，最长路判断正环</span></span><br></pre></td></tr></table></figure><h2 id="POJ-3259-Wormholes"><a href="#POJ-3259-Wormholes" class="headerlink" title="POJ-3259 Wormholes"></a>POJ-3259 Wormholes</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3159 Candies</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3159</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span> </span>&#123;  <span class="comment">//输入外挂</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="keyword">if</span> ((ch = getchar()) == <span class="string">'-'</span>)</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">    res = ch - <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) res = res * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">  <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;  <span class="comment">//输出外挂</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    a = -a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a &gt;= <span class="number">10</span>) Out(a / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  n = Scan();</span><br><span class="line">  m = Scan();</span><br><span class="line">  <span class="comment">//   scanf("%d%d", &amp;n, &amp;m);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    a = Scan();</span><br><span class="line">    b = Scan();</span><br><span class="line">    c = Scan();</span><br><span class="line">    <span class="comment">// scanf("%d%d%d", &amp;a, &amp;b, &amp;c);</span></span><br><span class="line">    addedge(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  Dijkstra(n, <span class="number">1</span>);</span><br><span class="line">  Out(dist[n]);</span><br><span class="line">  <span class="comment">// printf("%d\n", dist[n]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪装的差分约束系统（裸的最短路），输入输出TLE，上输入输出挂</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1502-MPI-Maelstrom"><a href="#POJ-1502-MPI-Maelstrom" class="headerlink" title="POJ-1502 MPI Maelstrom"></a>POJ-1502 MPI Maelstrom</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1502 MPI Maelstrom</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1502</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;sstream&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="comment">//   string s;</span></span><br><span class="line">      <span class="comment">//   cin &gt;&gt; s;</span></span><br><span class="line">      <span class="comment">//   if (s[0] == 'x') continue;</span></span><br><span class="line">      <span class="comment">//   stringstream ss;</span></span><br><span class="line">      <span class="comment">//   ss &lt;&lt; s;</span></span><br><span class="line">      <span class="comment">//   ss &gt;&gt; tmp;</span></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">      <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'x'</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> tmp = atoi(str);</span><br><span class="line">      addedge(i, j, tmp);</span><br><span class="line">      addedge(j, i, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Dijkstra(n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    ans = max(ans, dist[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 1 出发最短路中的最长路</span></span><br></pre></td></tr></table></figure><h2 id="POJ-3660-Cow-Contest"><a href="#POJ-3660-Cow-Contest" class="headerlink" title="POJ-3660 Cow Contest"></a>POJ-3660 Cow Contest</h2><h3 id="Floyd-1"><a href="#Floyd-1" class="headerlink" title="Floyd"></a>Floyd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3660 Cow Contest</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3660</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        dist[i][j] = (dist[i][j] || (dist[i][k] &amp;&amp; dist[k][j]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    dist[a][b] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  floyd(n);</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dist[i][j] || dist[j][i]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递闭包</span></span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3660 Cow Contest</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3660</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ed[MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN][MAXN];  <span class="comment">// vis[i][j]表示i-&gt;j可达</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span>       <span class="comment">//普通的dfs算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = n;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">  st.push(s);</span><br><span class="line">  vis[s][s] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> now = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    <span class="keyword">int</span> len = ed[now].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vis[s][ed[now][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">        st.push(ed[now][i]);</span><br><span class="line">        vis[s][ed[now][i]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    ed[a].push_back(b);</span><br><span class="line">    <span class="comment">// vis[a][b] = 1;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dfs(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (vis[i][j] || vis[j][i]) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递闭包</span></span><br></pre></td></tr></table></figure><h2 id="POJ-2240-Arbitrage"><a href="#POJ-2240-Arbitrage" class="headerlink" title="POJ-2240 Arbitrage"></a>POJ-2240 Arbitrage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2240 Arbitrage</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2240</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">double</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">double</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">double</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = <span class="number">0</span>;</span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &lt; dist[u] * E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = dist[u] * E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          que.push(v);</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> Case = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; name;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">string</span> str;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">      name[str] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="built_in">string</span> a, b;</span><br><span class="line">      <span class="keyword">double</span> x;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; x &gt;&gt; b;</span><br><span class="line">      addedge(name[a], name[b], x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; Case++ &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span> (!SPFA(<span class="number">1</span>, n)) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPFA 判断正环</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1511-Invitation-Cards"><a href="#POJ-1511-Invitation-Cards" class="headerlink" title="POJ-1511 Invitation Cards"></a>POJ-1511 Invitation Cards</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1511 Invitation Cards</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1511</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : u(_u), v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; Etmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"><span class="keyword">int</span> tdist[MAXN];</span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(u, v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    Etmp.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      addedge(a, b, c);</span><br><span class="line">      Etmp.push_back(Edge(a, b, c));</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      sum += dist[i];</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      addedge(Etmp[i].v, Etmp[i].u, Etmp[i].cost);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      sum += dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 1 到所有点再返回的最短路径长度求和，sum需要 long long</span></span><br><span class="line"><span class="comment">// 与 POJ-3268 Silver Cow Party 类似，将边反向再求一次即可</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1847-Tram"><a href="#POJ-1847-Tram" class="headerlink" title="POJ-1847 Tram"></a>POJ-1847 Tram</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1847 Tram</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1847</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          que.push(v);</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, A, B;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;A, &amp;B);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> ct, a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;ct, &amp;a);</span><br><span class="line">    addedge(i, a, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; ct; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">      addedge(i, a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  SPFA(A, N);</span><br><span class="line">  <span class="keyword">if</span> (dist[B] != INF) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[B]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 裸最短路，SPFA，Dij 都可以</span></span><br></pre></td></tr></table></figure><h2 id="POJ-1062-昂贵的聘礼"><a href="#POJ-1062-昂贵的聘礼" class="headerlink" title="POJ-1062 昂贵的聘礼"></a>POJ-1062 昂贵的聘礼</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-1062 昂贵的聘礼</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-1062</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> degree[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (degree[v] &lt; a || degree[v] &gt; b) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          que.push(v);</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;M, &amp;N);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    E[i].clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> mind = <span class="number">100000</span>, maxd = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> w, X;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld%d"</span>, &amp;w, &amp;degree[i], &amp;X);</span><br><span class="line"></span><br><span class="line">    mind = min(mind, degree[i]);</span><br><span class="line">    maxd = max(maxd, degree[i]);</span><br><span class="line">    addedge(<span class="number">0</span>, i, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; X; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> T, V;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;V);</span><br><span class="line">      addedge(T, i, V);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = E[<span class="number">0</span>][<span class="number">0</span>].cost;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = degree[<span class="number">1</span>] - M; i &lt;= degree[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">    SPFA(<span class="number">0</span>, N, i, i + M);</span><br><span class="line">    ans = min(ans, dist[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ-3159-Candies"><a href="#POJ-3159-Candies" class="headerlink" title="POJ-3159 Candies"></a>POJ-3159 Candies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3159 Candies</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3159</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span> </span>&#123;  <span class="comment">//输入外挂</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> ch;</span><br><span class="line">  <span class="keyword">if</span> ((ch = getchar()) == <span class="string">'-'</span>)</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">    res = ch - <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) res = res * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">  <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;  <span class="comment">//输出外挂</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    a = -a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a &gt;= <span class="number">10</span>) Out(a / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  n = Scan();</span><br><span class="line">  m = Scan();</span><br><span class="line">  <span class="comment">//   scanf("%d%d", &amp;n, &amp;m);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    a = Scan();</span><br><span class="line">    b = Scan();</span><br><span class="line">    c = Scan();</span><br><span class="line">    <span class="comment">// scanf("%d%d%d", &amp;a, &amp;b, &amp;c);</span></span><br><span class="line">    addedge(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  Dijkstra(n, <span class="number">1</span>);</span><br><span class="line">  Out(dist[n]);</span><br><span class="line">  <span class="comment">// printf("%d\n", dist[n]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪装的差分约束系统（裸的最短路），输入输出TLE，上输入输出挂</span></span><br></pre></td></tr></table></figure><h2 id="POJ-2502-Subway"><a href="#POJ-2502-Subway" class="headerlink" title="POJ-2502 Subway"></a>POJ-2502 Subway</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-2502 Subway</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-2502</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">double</span> c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">double</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">double</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">double</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">double</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> xx[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">double</span> yy[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((xx[a] - xx[b]) * (xx[a] - xx[b]) +</span><br><span class="line">              (yy[a] - yy[b]) * (yy[a] - yy[b]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xx[cnt], &amp;yy[cnt]);</span><br><span class="line">  cnt++;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xx[cnt], &amp;yy[cnt]);</span><br><span class="line">  cnt++;</span><br><span class="line">  <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xx[cnt], &amp;yy[cnt])) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subway;</span><br><span class="line">    subway.push_back(cnt);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">while</span> (xx[cnt - <span class="number">1</span>] != <span class="number">-1</span> &amp;&amp; yy[cnt - <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;xx[cnt], &amp;yy[cnt]);</span><br><span class="line">      subway.push_back(cnt);</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subway.size() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">      addedge(subway[i], subway[i + <span class="number">1</span>],</span><br><span class="line">              len(subway[i], subway[i + <span class="number">1</span>]) / <span class="number">40</span> * <span class="number">60</span>);</span><br><span class="line">      addedge(subway[i + <span class="number">1</span>], subway[i],</span><br><span class="line">              len(subway[i], subway[i + <span class="number">1</span>]) / <span class="number">40</span> * <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      addedge(i, j, len(i, j) / <span class="number">10</span> * <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Dijkstra(cnt, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(dist[<span class="number">2</span>] / <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水题，连边麻烦一点，输入也麻烦</span></span><br><span class="line"><span class="comment">// 地铁只能一站一站的走</span></span><br><span class="line"><span class="comment">// 结果要输出整数，竟然要四舍五入！！！</span></span><br></pre></td></tr></table></figure><h2 id="POJ-3169-Layout"><a href="#POJ-3169-Layout" class="headerlink" title="POJ-3169 Layout"></a>POJ-3169 Layout</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// POJ-3169 Layout</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/POJ-3169</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          que.push(v);</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N, ML, MD;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;ML, &amp;MD);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ML; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    addedge(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MD; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    addedge(b, a, -c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (SPFA(<span class="number">1</span>, N)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist[N] == INF) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"-2"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d"</span>, dist[N]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差分约束系统</span></span><br><span class="line"><span class="comment">// A - B &lt;= D -&gt; add(A，B，D)</span></span><br><span class="line"><span class="comment">// A - B &gt;= D -&gt; 同乘 - 1得 B - A &lt;= -D -&gt; add(B，A，-D)</span></span><br></pre></td></tr></table></figure><h2 id="LightOJ-1074-Extended-Traffic"><a href="#LightOJ-1074-Extended-Traffic" class="headerlink" title="LightOJ-1074 Extended Traffic"></a>LightOJ-1074 Extended Traffic</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LightOJ-1074 Extended Traffic</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/LightOJ-1074</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">int</span> cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];   <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  vis[start] = <span class="literal">true</span>;</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  que.push(start);</span><br><span class="line">  <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">  cnt[start] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + E[u][i].cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">          vis[v] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (++cnt[v] &gt; n) &#123;</span><br><span class="line">            dist[v] = -INF;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            que.push(v);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, Case);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">      addedge(a, b, (arr[b] - arr[a]) * (arr[b] - arr[a]) * (arr[b] - arr[a]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = SPFA(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> x, ans;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">      <span class="keyword">if</span> (dist[x] == INF || dist[x] &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"?\n"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[x]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPFA 判断**所有负环**</span></span><br></pre></td></tr></table></figure><h2 id="HDU-4725-The-Shortest-Path-in-Nya-Graph"><a href="#HDU-4725-The-Shortest-Path-in-Nya-Graph" class="headerlink" title="HDU-4725 The Shortest Path in Nya Graph"></a>HDU-4725 The Shortest Path in Nya Graph</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU-4725 The Shortest Path in Nya Graph</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/HDU-4725</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(v, w)); &#125;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN];</span><br><span class="line"><span class="keyword">int</span> flag[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> Case = <span class="number">1</span>; Case &lt;= T; Case++) &#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, C;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;M, &amp;C);</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N * <span class="number">3</span>; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">      flag[arr[i]]++;</span><br><span class="line"></span><br><span class="line">      addedge(i, arr[i] + N + <span class="number">1</span> + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      addedge(i, arr[i] + N + <span class="number">1</span> - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      addedge(arr[i] + N + <span class="number">1</span>, i, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      addedge(a, b, c);</span><br><span class="line">      addedge(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(N * <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>, Case);</span><br><span class="line">    <span class="keyword">if</span> (dist[N] == INF) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[N]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图困难一些的最短路问题，如果完全按题意建图会超时</span></span><br><span class="line"><span class="comment">// 将层抽象成虚点，点到相邻层的虚点连一条 0</span></span><br><span class="line"><span class="comment">// 边权的虚边，虚点到当前层的点连一条 C 边权的边</span></span><br></pre></td></tr></table></figure><h2 id="HDU-3416-Marriage-Match-IV"><a href="#HDU-3416-Marriage-Match-IV" class="headerlink" title="HDU-3416 Marriage Match IV"></a>HDU-3416 Marriage Match IV</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDU-3416 Marriage Match IV</span></span><br><span class="line"><span class="comment">// https://vjudge.net/problem/HDU-3416</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, c;</span><br><span class="line">  qnode(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _c = <span class="number">0</span>) : v(_v), c(_c)&#123;&#125;;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> qnode &amp;r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> c &gt; r.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, cost;</span><br><span class="line">  Edge(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : u(_u), v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; Ex;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//点的编号从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;</span><br><span class="line">  priority_queue&lt;qnode&gt; que;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">  dist[start] = <span class="number">0</span>;</span><br><span class="line">  que.push(qnode(start, <span class="number">0</span>));</span><br><span class="line">  qnode tmp;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    tmp = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> u = tmp.v;</span><br><span class="line">    <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = E[tmp.v][i].v;</span><br><span class="line">      <span class="keyword">int</span> cost = E[u][i].cost;</span><br><span class="line">      <span class="keyword">if</span> (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123;</span><br><span class="line">        dist[v] = dist[u] + cost;</span><br><span class="line">        que.push(qnode(v, dist[v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; E[u].push_back(Edge(u, v, w)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1200010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edgef</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, next, cap, flow;</span><br><span class="line">&#125; edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> tol;</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  tol = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> rw)</span> </span>&#123;</span><br><span class="line">  edge[tol].to = v;</span><br><span class="line">  edge[tol].cap = w;</span><br><span class="line">  edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">  edge[tol].next = head[u];</span><br><span class="line">  head[u] = tol++;</span><br><span class="line">  edge[tol].to = u;</span><br><span class="line">  edge[tol].cap = rw;</span><br><span class="line">  edge[tol].flow = <span class="number">0</span>;</span><br><span class="line">  edge[tol].next = head[v];</span><br><span class="line">  head[v] = tol++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Q[MAXN];</span><br><span class="line"><span class="keyword">int</span> dep[MAXN], cur[MAXN], sta[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> front = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep[<span class="number">0</span>]) * (n + <span class="number">1</span>));</span><br><span class="line">  dep[s] = <span class="number">0</span>;</span><br><span class="line">  Q[tail++] = s;</span><br><span class="line">  <span class="keyword">while</span> (front &lt; tail) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q[front++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">      <span class="keyword">if</span> (edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">        dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Q[tail++] = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (bfs(s, t, n)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      cur[i] = head[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u = s, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur[s] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">        <span class="keyword">int</span> tp = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          tp = min(tp, edge[sta[i]].cap - edge[sta[i]].flow);</span><br><span class="line">        &#125;</span><br><span class="line">        maxflow += tp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tail - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          edge[sta[i]].flow += tp;</span><br><span class="line">          edge[sta[i] ^ <span class="number">1</span>].flow -= tp;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (edge[sta[i]].cap - edge[sta[i]].flow == <span class="number">0</span>) tail = i;</span><br><span class="line">        &#125;</span><br><span class="line">        u = edge[sta[tail] ^ <span class="number">1</span>].to;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur[u] != <span class="number">-1</span> &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp;</span><br><span class="line">                 dep[u] + <span class="number">1</span> == dep[edge[cur[u]].to]) &#123;</span><br><span class="line">        sta[tail++] = cur[u];</span><br><span class="line">        u = edge[cur[u]].to;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (u != s &amp;&amp; cur[u] == <span class="number">-1</span>) &#123;</span><br><span class="line">          u = edge[sta[--tail] ^ <span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">        cur[u] = edge[cur[u]].next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> distA[MAXN];</span><br><span class="line"><span class="keyword">int</span> distB[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    init();</span><br><span class="line">    Ex.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, c;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">      Ex.push_back(Edge(a, b, c));</span><br><span class="line">      addedge(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> A, B;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B);</span><br><span class="line">    Dijkstra(n, A);</span><br><span class="line">    <span class="built_in">memcpy</span>(distA, dist, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">      E[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Ex.size(); i++) &#123;</span><br><span class="line">      addedge(Ex[i].v, Ex[i].u, Ex[i].cost);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(n, B);</span><br><span class="line">    <span class="built_in">memcpy</span>(distB, dist, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Ex.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (distA[Ex[i].u] + distB[Ex[i].v] + Ex[i].cost == distA[B]) &#123;</span><br><span class="line">        addedge(Ex[i].u, Ex[i].v, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = dinic(A, B, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最短路的条数（无公共边）</span></span><br><span class="line"><span class="comment">// 找出最短路经过的边，跑最大流</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;POJ-2387 Til the Cows Come Home（水）&lt;/li&gt;
&lt;li&gt;POJ-2253 Frogger（浮点数
      
    
    </summary>
    
      <category term="题解" scheme="https://blog.pazyx.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="DFS" scheme="https://blog.pazyx.xyz/tags/DFS/"/>
    
      <category term="Dijkstra" scheme="https://blog.pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="SPFA" scheme="https://blog.pazyx.xyz/tags/SPFA/"/>
    
      <category term="Kruskal" scheme="https://blog.pazyx.xyz/tags/Kruskal/"/>
    
      <category term="Floyd" scheme="https://blog.pazyx.xyz/tags/Floyd/"/>
    
      <category term="最短路" scheme="https://blog.pazyx.xyz/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路算法2——SPFA</title>
    <link href="https://blog.pazyx.xyz/2019/02/02/spfa/"/>
    <id>https://blog.pazyx.xyz/2019/02/02/spfa/</id>
    <published>2019-02-02T00:12:41.000Z</published>
    <updated>2019-02-02T09:07:05.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在<a href="/2018/03/23/dijkstra/">最短路算法1——Dijkstra</a>中，我介绍了 Dijkstra 算法，其中给出了一种奇怪的优先队列优化，优化后的代码其实有点不像 Dijkstra 算法，而更像今天要介绍的 SPFA（Shortest Path Faster Algorithm） 算法。SPFA 算法也是一种单源最短路算法，实际上是 Bellman-Ford 算法的队列优化，它最大的特点是它可处理有负权边的图，并可以判断是否存在负值圈。</p><h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>SPFA 算法采用动态逼进法，使用队列保存待优化的顶点，从队列中取出一点对其邻接点进行优化，若有调整则将其入队等待调整。反复取出队首更新最短路，直至队列为空。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> next, weight;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;G[MAX_N]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> inq[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].next;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + G[u][i].weight &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + G[u][i].weight;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>G</code> 邻接表</li><li><code>inq</code> 标示顶点是否已入队</li><li><code>dist</code> 保存起始点到各个点的距离</li><li><code>que</code> 保存等待优化的顶点</li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="负值圈判断"><a href="#负值圈判断" class="headerlink" title="负值圈判断"></a>负值圈判断</h2><p>在 SPFA 算法中增加 <code>cnt</code> 数组记录顶点入队次数，如果入队次数大于顶点总数 <code>n</code> 说明存在负值圈。</p><p>补充后部分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(s);</span><br><span class="line">cnt[s]++;<span class="comment">// **</span></span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    inq[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i].next;</span><br><span class="line">        <span class="keyword">if</span> (dist[u] + G[u][i].weight &lt; dist[v]) &#123;</span><br><span class="line">            dist[v] = dist[u] + G[u][i].weight;</span><br><span class="line">            <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                que.push(v);</span><br><span class="line">                cnt[v]++;<span class="comment">// **</span></span><br><span class="line">                inq[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[v] &gt; n)&#123;<span class="comment">// **</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"存在负值圈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长路"><a href="#最长路" class="headerlink" title="最长路"></a>最长路</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>将边权取相反数，跑完算法后，<code>dist</code> 数组的值为距离的相反数。</p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><ul><li>将更新操作改为的条件 <code>dist[u] + G[u][i].weight &gt; dist[v]</code></li><li>初始化 <code>dist</code> 数组时给予极小值如 <code>0xbf</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0xbf</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (dist[u] + G[u][i].weight &gt; dist[v])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h2><p>如果一个不等式组由 $n​$ 个变量和 $m​$ 个约束条件组成，且每个约束条件都是形如 $x_j - x_i \leq k, 1 \leq i,j \leq n​$ 的不等式，则称其为差分约束系统。</p><p>$x_j - x_i \leq k$ 对应于最短路网络中的三角不等式 $dist_v - dist_u \leq w_{&lt;u,v&gt;}$，即 $dist_v + w_{&lt;u,v&gt;} \leq dist_u$。用最短路算法得到答案 $dist_i$，也就求出了不等式组的一个解。</p><p>增加一个超级源 $s$ ，$s$ 连接其余每个顶点，边权均为 $0$。执行 SPFA 算法，如果未出现负值圈 <code>dist</code> 数组即满足条件的一组解，反之不等式组无解。</p><p>由于差分约束系统可能出现负权边和负值圈，所以基本只能用 SPFA 算法解决。</p><p>$x_j - x_i \leq k​$  </p><ul><li>求最短路变形为 $x_i +k \geq x_j​$ 从 $i​$ 到 $j​$ 连一条权值为 $k​$ 的边</li><li>求最短路变形为 $x_j - k \leq x_i$ 从 $j$ 到 $i$ 连一条权值为 $-k$ 的边</li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>SPFA 算法有两种优化方式</p><ul><li>SLF：Small Label First 策略</li><li>LLL：Large Label Last 策略</li></ul><p>SLF 可使速度提升 $15\sim20\%$；SLF + LLL 可提高约 $50\%$</p><h2 id="SLF"><a href="#SLF" class="headerlink" title="SLF"></a>SLF</h2><p>设要入队的顶点为 $j$ ，队首元素为 $i$ ，若 $dist[j] &lt; dist[i]$ ，则将 $j$ 从队首入队，反之从队尾入队。</p><p>实现上需要在队首插入元素，需要将容器从 <code>queue</code> 改为 <code>deque</code> 双端队列。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push_back(s);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop_front();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].next;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + G[u][i].weight &gt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + G[u][i].weight;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[i] &lt; dist[que.front()])&#123;</span><br><span class="line">                        que.push_front(v);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        que.push_back(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LLL"><a href="#LLL" class="headerlink" title="LLL"></a>LLL</h2><p>设队首元素为 $i$ ，队列中所有最短距离值的平均值为 $x$ ，若 $d[i] &gt; x$ 则将其插入到队尾，查找下一个元素，直到找到某一顶点 $i$ 使得 $d[i] &lt; x$ ，则将 $i$ 出队进行松弛操作。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,cnt = <span class="number">1</span>;<span class="comment">// **</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push_back(s);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop_front();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[u] * cnt &gt; sum)&#123;</span><br><span class="line">            que.push_back(u);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= dist[u];<span class="comment">// **</span></span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].next;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + G[u][i].weight &gt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + G[u][i].weight;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                    que.push_back(v);</span><br><span class="line">                    </span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                    sum += dist[v];<span class="comment">// **</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SLF-LLL"><a href="#SLF-LLL" class="headerlink" title="SLF + LLL"></a>SLF + LLL</h3><p>综合 SLF 策略和 LLL 策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inq));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,cnt = <span class="number">1</span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push_back(s);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop_front();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[u] * cnt &gt; sum)&#123;<span class="comment">// LLL</span></span><br><span class="line">            que.push_back(u);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum -= dist[u];</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].next;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + G[u][i].weight &gt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + G[u][i].weight;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                    <span class="comment">// SLF</span></span><br><span class="line">                    <span class="keyword">if</span>(dist[i] &lt; dist[que.front()])&#123;</span><br><span class="line">                        que.push_front(v);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        que.push_back(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                    sum += dist[v];</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>设 $V$ 代表结点的个数，$E$ 代表边的个数。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>除去邻接表的空间占用，SPFA 算法额外空间开销显然为 $O(V)$</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>如果顶点的平均入队次数为 $k$ ，则 SPFA 算法的时间复杂度为 $O(kE)$，对于较为随机的稀疏图，根据经验 $k$ 一般不超过 $4$ 。</p><p>SPFA 的本质是 Bellman-Ford 算法的队列优化，本质上没有改变 Bellman-Ford 算法的时间复杂度，对于稠密图来说，SPFA 最坏仍是 $O(VE)$ 的时间复杂度，远差于 Dijkstra 算法的 $O( (V + E) \log V )$ 复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;/2018/03/23/dijkstra/&quot;&gt;最短路算法1——Dijkstra&lt;/a&gt;中，我介绍了 Dijkstra 算
      
    
    </summary>
    
      <category term="算法" scheme="https://blog.pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://blog.pazyx.xyz/tags/ACM/"/>
    
      <category term="优先队列" scheme="https://blog.pazyx.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
      <category term="SPFA" scheme="https://blog.pazyx.xyz/tags/SPFA/"/>
    
      <category term="Bellman-Ford" scheme="https://blog.pazyx.xyz/tags/Bellman-Ford/"/>
    
      <category term="最短路径" scheme="https://blog.pazyx.xyz/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>「书摘」《深度探索 C++ 对象模型》（三）</title>
    <link href="https://blog.pazyx.xyz/2018/12/21/inside_cpp_obj_model_3/"/>
    <id>https://blog.pazyx.xyz/2018/12/21/inside_cpp_obj_model_3/</id>
    <published>2018-12-21T12:23:42.000Z</published>
    <updated>2019-05-10T11:01:25.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-语意学-The-Semantics-of-Data"><a href="#Data-语意学-The-Semantics-of-Data" class="headerlink" title="Data 语意学 (The Semantics of Data)"></a>Data 语意学 (The Semantics of Data)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>Y</code> 和 <code>Z</code> 的大小与机器（字长）有关，也和编译器有关，具体受以下三个因素的影响：</p><ul><li>语言本身所造成的额外负担（overhea）</li><li>编译器对于特殊情况所提供的优化处理</li><li>Alignment 的限制</li></ul><p><code>class A</code> 的大小由下列几点决定：</p><ul><li>被大家共享的唯一一个 <code>class X</code> 实例，大小为 1 <code>byte</code>。</li><li><code>Base class Y</code> 和 <code>Base class Y</code> 的大小，减去“因 virtual base class X 而配置” 的大小，结果式 4 <code>bytes</code>。</li><li><code>class A</code> 自己的大小：0 <code>byte</code>。</li><li><code>class A</code> 的 alignment 数量（如果有的化）。<br>结果为 12 <code>bytes</code></li></ul><p>”特别对 empty virual base class 做了处理“ 的编译器，class X 实例的那 1 <code>byte</code> 将被拿掉，class A 的大小将是 8 <code>bytes</code>。</p><p>继承得到的数据的存放顺序，C++标准没有强制定义其间的排列顺序。</p><h2 id="Data-Member-的绑定-The-Binding-of-a-Data-Member"><a href="#Data-Member-的绑定-The-Binding-of-a-Data-Member" class="headerlink" title="Data Member 的绑定 (The Binding of a Data Member)"></a>Data Member 的绑定 (The Binding of a Data Member)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对于函数本体的分析将延迟，直至 class 声明的右大括号出现才开始。</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 分析在这里进行</span></span><br></pre></td></tr></table></figure><p>member function 的 argument list 会在第一次遭遇时被适当地决议完成。extern 和 nested type names 之间的非直觉绑定操作还是会发生。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">( length val )</span> </span>&#123; _val = val; &#125;<span class="comment">// length 为 int</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line">    length _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>采用防御性程序风格改进后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">( length val )</span> </span>&#123; _val = val; &#125;<span class="comment">// length 为 float</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    length _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>请总是把 “nested type 声明” 放在 class 的起始处。</strong> </p><h2 id="Data-Member-的布局-Data-Member-Layout"><a href="#Data-Member-的布局-Data-Member-Layout" class="headerlink" title="Data Member 的布局 (Data Member Layout)"></a>Data Member 的布局 (Data Member Layout)</h2><p>C++ Standard 要求，在同一个 access section（也就是 private。public，protected 等区段）中，members 的排列只需符合“较晚出现的 members 在 class object 中有较高的地址”这一条件即可。</p><p>判断哪个 section 先出现的 template function：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">class_type</span>, <span class="title">class</span> <span class="title">data_type1</span>, <span class="title">class</span> <span class="title">data_type2</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">char</span>* <span class="title">access_order</span>( </span></span><br><span class="line"><span class="class"><span class="title">data_type1</span> <span class="title">class_type</span>:</span>:*mem1, </span><br><span class="line">data_type2 class_type::*mem2 )</span><br><span class="line">&#123;</span><br><span class="line">    assert (mem1 != mem2);</span><br><span class="line">    <span class="keyword">return</span> mem1 &lt; mem2 </span><br><span class="line">    ? <span class="string">"member 1 occurs first"</span> </span><br><span class="line">    : <span class="string">"member 1 occurs first"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用：<code>access_order( &amp;Point3d::z, &amp;Point3d::y );</code></p><h2 id="Data-Member-的存取"><a href="#Data-Member-的存取" class="headerlink" title="Data Member 的存取"></a>Data Member 的存取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point origin;</span><br><span class="line">Point *pt = &amp;origin;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.x = <span class="number">0.0</span>;</span><br><span class="line">pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>通过 <code>origin</code> 存取，和通过 <code>pt</code> 存取的差异将在本节得出答案。</p><h3 id="Static-Data-Member"><a href="#Static-Data-Member" class="headerlink" title="Static Data Member"></a>Static Data Member</h3><p>每个 static member 的存取许可，以及与 class 的关联，并不会招致任何空间上或执行时间上的额外负担，不论是在个别的 class objects 还是在 static data member 本身。</p><h3 id="Nonstatic-Data-Member"><a href="#Nonstatic-Data-Member" class="headerlink" title="Nonstatic Data Member"></a>Nonstatic Data Member</h3><p>Nonstatic Data Member 直接存放在每一个 class object 之中。除非经由显式的（explicit）或隐式的（implicit）class object，否则没有办法直接存取它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="number">3</span>d</span><br><span class="line">Point <span class="number">3</span>d::translate( <span class="keyword">const</span> Point3d &amp;pt)&#123;</span><br><span class="line">    x += pt.x;</span><br><span class="line">    y += pt.y;</span><br><span class="line">    z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面上所看到的对于 <code>x</code>,<code>y</code>,<code>z</code> 的直接存取，事实上是经由一个“implicit class object”（由 <code>this</code> 指针表达）完成的。事实上这个函数的参数是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="number">3</span>d</span><br><span class="line">Point <span class="number">3</span>d::translate( Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;pt)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x += pt.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y += pt.y;</span><br><span class="line">    <span class="keyword">this</span>-&gt;z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>欲对一个 nonstatic data member 进行存取操作，编译器需要把 class object 的起始地址加上 data member 的偏移位置（offset）。<br><code>origin._y = 0.0;</code> 会转化为 <code>&amp;origin + (&amp;Point3d::_y - 1);</code>。<br>请注意其中的 <code>-1</code>操作。指向 data member 的指针，其 offset 值总是被加上 1，这样可以使编译系统区分出“一个指向 data member 的指针，用以指出 class 的第一个 member” 和 “一个指向 data members 的指针，没有指出任何 member” 两种情况。</p><p>每一个 nonstatic data member 的偏移位置（offset）在编译时期即可获知，甚至如果 member 属于一个 base class subobject（派生自单一或多重继承串链）也是一样的。存取一个 nonstatic data member ，其效率和存取一个 C struct member 或 一个 nonderived class 的 member 是一样的。</p><h4 id="Nonstatic-Data-Member-在虚拟继承中"><a href="#Nonstatic-Data-Member-在虚拟继承中" class="headerlink" title="Nonstatic Data Member 在虚拟继承中"></a>Nonstatic Data Member 在虚拟继承中</h4><p>虚拟继承将为“经由 base class subobject 存取 class member“ 导入一层新的间接性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d *pt3d;</span><br><span class="line">pt3d-&gt;_x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure></p><p>其执行效率在 <code>_x</code> 是一个 struct member、一个 class member、单一继承、多重继承的情况下都完全相同。但如果 <code>_x</code> 是一个 virtual base class 的 member ，存取速度会稍慢一点。</p><p><code>origin._y = 0.0;</code> 会转化为 <code>&amp;origin + (&amp;Point3d::_y - 1);</code><br>当 <code>Point3d</code> 是一个 derived class，而其继承结构中有一个 virtual base class，并且被存取的 member（如本例的 <code>x</code> ）是一个从该 virtual base class 继承而来的 member 时，就会有重大的差异。<br>这时候我们不能说 <code>pt</code> 必然指向哪一种 class type（因此，我们也就不知道编译时期这个 member 真正的 offset 位置），所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。但如果使用 <code>origin</code> ，就不会有这些问题，members 的 offset 位置在编译时期就固定了。</p><h2 id="“继承”-与-Data-Member"><a href="#“继承”-与-Data-Member" class="headerlink" title="“继承” 与 Data Member"></a>“继承” 与 Data Member</h2><p>derived class members 和 base class(es) members 的排列顺序，则并未在 C++ Standard 中强制指定；理论上编译器可以自由安排。在大多数编译器上头，base class members 总是先出现，但属于 virtual base class 的除外（一般而言，任何一条通则一旦碰上 virtual base class 就没辙了，这里亦不例外）。</p><h3 id="只要继承不要多态-Inheritance-without-Polymorphism"><a href="#只要继承不要多态-Inheritance-without-Polymorphism" class="headerlink" title="只要继承不要多态 (Inheritance without Polymorphism)"></a>只要继承不要多态 (Inheritance without Polymorphism)</h3><p>一般而言，具体继承（concrete inheritance）相对虚拟继承（virtual inheritance）并不会增加空间或存取时间上的额外负担。</p><p><strong>C++语言保证“出现在 derived class 中的 base class subobject 有其完整原样性”。</strong><br>因为要保证 bitwise 拷贝的正确性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line"><span class="keyword">char</span> c2;</span><br><span class="line"><span class="keyword">char</span> c3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>val</code> 占用 4 <code>bytes</code>；</li><li><code>c1</code>、<code>c2</code>和<code>c3</code> 各占用 1 <code>bytes</code>；</li><li>alignment（调整到 word 边界）需要 1 <code>byte</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span> :</span> <span class="keyword">public</span> Concrete1 &#123;</span><br><span class="line"><span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete3</span> :</span> <span class="keyword">public</span> Concrete2 &#123;</span><br><span class="line"><span class="keyword">char</span> c3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Concrete1</code> 占用 8 <code>bytes</code>，包括填补用的 3 <code>bytes</code>。</li><li><code>Concrete2</code> 占用 12 <code>bytes</code>，填补 3 <code>bytes</code>。</li><li><code>Concrete3</code> 占用 16 <code>bytes</code>，填补 3 <code>bytes</code>。</li></ul><h3 id="加上多态-Adding-Polymorphism"><a href="#加上多态-Adding-Polymorphism" class="headerlink" title="加上多态 (Adding Polymorphism)"></a>加上多态 (Adding Polymorphism)</h3><p>Polymorphism 带来空间和存取时间上的额外负担</p><ul><li>导入一个 virtual table，用来存取它所声明的每一个 virtual functions 的地址。这个 table 的元素个数一般而言是被声明的 virtual functions 的个数，再加上一个或两个 slots（用以支持 runtime tyoe identifition）。</li><li>在每一个 class object 中导入一个 <code>vptr</code>，提供执行器的链接，使每一个 object 能够找到相应的 virtual table。</li><li>加强 constructor，使它能够为 <code>vptr</code> 设定初值，让它指向 class 所对应的 virtual table。这可能意味着在 derived class 和每一个 base class 的 constructor 中，重新设定 <code>vptr</code> 的值。其情况视编译器优化的积极性而定。</li><li>加强 destructor，使它能够抹消“指向 class 之相关 virtual table” 的 <code>vptr</code>。<code>vptr</code> 很可能已经在 derived class destructor 中被设定为 derived class 的 virtual table 的地址。destructor 的调用的顺序上反向的：从 derived class 到 base class，一个积极的优化编译器可以压抑那些大量的制定操作。</li></ul><p><code>vptr</code> 放在前端，代价是丧失了 C 语言兼容性。</p><h3 id="多重继承-Multiple-Inheritance"><a href="#多重继承-Multiple-Inheritance" class="headerlink" title="多重继承 (Multiple Inheritance)"></a>多重继承 (Multiple Inheritance)</h3><p>……</p><h3 id="虚拟继承-Virtual-Inheritance"><a href="#虚拟继承-Virtual-Inheritance" class="headerlink" title="虚拟继承 (Virtual Inheritance)"></a>虚拟继承 (Virtual Inheritance)</h3><p>虚拟继承的两个问题</p><ul><li>每一个对象必须针对其每一个 virtual base class 背负一个额外的指针，然而理想上我们希望 class object 有固定负担，不因为其 virtual base classes 的个数而有所变化。</li><li>由于虚拟继承串链的加长，导致间接存取层次的增加。我们希望有固定的存取时间，不因为虚拟派生的深度而改变。</li></ul><p>第一个问题两种解决办法：</p><ul><li>Microsoft 编译器引入的 virtual base class table。</li><li>在 virtual function table 中放置 virtual base class 的 offset（不是地址），在 Sun 编译器中，virtual function table 可经由正值或负值来索引，如果是正值索引到 virtual function ，如果是负值索引到 virtual base class offset。</li></ul><p>第二个问题，它们经由拷贝操作取得所有的 nested  virtual base class 指针，放到的 derived class object 之中。</p><h2 id="对象成员的效率-Object-Member-Efficiency"><a href="#对象成员的效率-Object-Member-Efficiency" class="headerlink" title="对象成员的效率 (Object Member Efficiency)"></a>对象成员的效率 (Object Member Efficiency)</h2><p>聚合（aggregtion）<br>封装（encapsulation）<br>继承（inheritance）</p><p><strong>不断加强抽象化程度后，数据的存取效率</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>个别的局部变量</td><td>0.80</td><td>1.42</td></tr><tr><td></td><td></td><td></td></tr><tr><td>局部数组</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>2.55</td></tr><tr><td>NCC</td><td>0.80</td><td>1.42</td></tr><tr><td></td><td></td><td></td></tr><tr><td>struct 之中有 public 成员</td><td>0.80</td><td>1.42</td></tr><tr><td></td><td></td><td></td></tr><tr><td>class 之中有 inline Get 函数</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>2.56</td></tr><tr><td>NCC</td><td>0.80</td><td>3.10</td></tr><tr><td></td><td></td><td></td></tr><tr><td>class 之中有 inline Get &amp; Set 函数</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>1.74</td></tr><tr><td>NCC</td><td>0.80</td><td>2.87</td></tr></tbody></table><p>如果把优化开关打开，“封装”就不会带来执行器的效率成本，使用 inline 存取函数亦然。</p><p>为什么在 CC 之下存取数组，几乎比 NCC 慢两倍？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CC assembler output</span><br><span class="line"># 13 pB[ x ] = pA[ x ] - pB[ x ];</span><br><span class="line">add $25, $sp, 20</span><br><span class="line">1.s $f4, 0($25)</span><br><span class="line">addu $24, $sp, 8</span><br><span class="line">1.s $f6, 8($24)</span><br><span class="line">sub.s $f8, $f4, $f6</span><br><span class="line">s.s $f8, 0($24)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NCC assembler output</span><br><span class="line"># 13 pB[ x ] = pA[ x ] - pB[ x ];</span><br><span class="line">1.s $f4, 20($25)</span><br><span class="line">1.s $f6, 16($24)</span><br><span class="line">sub.s $f8, $f4, $f6</span><br><span class="line">s.s $f8, 0($24)</span><br></pre></td></tr></table></figure><ul><li><code>1.s</code> 加载一个单精度浮点数</li><li><code>s.s</code> 存储一个单精度浮点数</li><li><code>sub.s</code> 将两个单精度浮点数相减</li></ul><p><strong>在继承模型之下的数据存取</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>单一继承</td><td></td><td></td></tr><tr><td>直接存取</td><td>0.80</td><td>1.42</td></tr><tr><td>使用 inline 函数</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>2.55</td></tr><tr><td>NCC</td><td>0.80</td><td>3.10</td></tr><tr><td></td><td></td><td></td></tr><tr><td>虚拟继承（单层）</td><td></td><td></td></tr><tr><td>直接存取</td><td>1.60</td><td>1.94</td></tr><tr><td>使用 inline 函数</td><td></td><td></td></tr><tr><td>CC</td><td>1.60</td><td>2.75</td></tr><tr><td>NCC</td><td>1.60</td><td>3.30</td></tr><tr><td></td><td></td><td></td></tr><tr><td>虚拟继承（双层）</td><td></td><td></td></tr><tr><td>直接存取</td><td></td><td></td></tr><tr><td>CC</td><td>2.25</td><td>2.74</td></tr><tr><td>NCC</td><td>3.04</td><td>3.68</td></tr><tr><td>使用 inline 函数</td><td></td><td></td></tr><tr><td>CC</td><td>2.25</td><td>3.22</td></tr><tr><td>NCC</td><td>2.50</td><td>3.81</td></tr></tbody></table><h2 id="指向-Data-Member-的指针-Pointer-to-Data-Members"><a href="#指向-Data-Member-的指针-Pointer-to-Data-Members" class="headerlink" title="指向 Data Member 的指针 (Pointer to Data Members)"></a>指向 Data Member 的指针 (Pointer to Data Members)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">    <span class="keyword">static</span> Point3d origin;</span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;Point3d::z <span class="comment">// 得到 z 在 class object 中的 offset</span></span><br></pre></td></tr></table></figure><p>输出 offset<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Point3d::x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Point3d::y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Point3d::z);</span><br></pre></td></tr></table></figure></p><p>早期一些编译器 <code>&amp;Point3d::z</code> 这个操作的值为 <code>z</code> 的 offset + 1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d:x;</span><br><span class="line"><span class="comment">// Point3d::* 的意思是 "指向 Point3d data member" 的指针类型</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 == p2) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" p1 &amp; p2 contain the same value -- "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" they must address the same member!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 offset 加 1，方便区分 <code>NULL</code> 和第一个 data member。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span> <span class="keyword">int</span> val1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span> <span class="keyword">int</span> val2; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> Derived::*dmp, Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pd-&gt;*dmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">( Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// bmp 为 1</span></span><br><span class="line">    <span class="keyword">int</span> Base2::*bmp = &amp;Base2::val2;</span><br><span class="line"><span class="comment">// bmp == 1</span></span><br><span class="line"><span class="comment">// 但在 Derived 中， val2 == 5</span></span><br><span class="line">    func1(bmp,pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经由编译器内部转换</span></span><br><span class="line">func1( bmp + <span class="keyword">sizeof</span>( Base1 ), pd );</span><br></pre></td></tr></table></figure><p>一般而言，我们不能够保证 <code>bmp</code> 不是 0，因此必须注意这一点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1( bmp ? bmp + <span class="keyword">sizeof</span>( Base1 ) : <span class="number">0</span>, pd );</span><br></pre></td></tr></table></figure></p><p><strong>我的测试程序：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span> <span class="keyword">int</span> val1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span> <span class="keyword">int</span> val2; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> Derived::*dmp, Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dmp);</span><br><span class="line">    <span class="keyword">return</span> pd-&gt;*dmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">( Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Base2::*bmp = &amp;Base2::val2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,bmp);</span><br><span class="line">    <span class="keyword">return</span> func1(bmp,pd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived xx;</span><br><span class="line"></span><br><span class="line">    xx.val1 = <span class="number">11</span>;</span><br><span class="line">    xx.val2 = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func2(&amp;xx) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="“指向-Data-Member-的指针”-的效率问题"><a href="#“指向-Data-Member-的指针”-的效率问题" class="headerlink" title="“指向 Data Member 的指针” 的效率问题"></a>“指向 Data Member 的指针” 的效率问题</h3><p><strong>存取 Nonstatic Data Member</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>直接存取</td><td>0.80</td><td>1.42</td></tr><tr><td>指针指向已绑定的 Member</td><td>0.80</td><td>3.04</td></tr><tr><td>指针指向 Data Member</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>5.34</td></tr><tr><td>NCC</td><td>4.04</td><td>5.34</td></tr></tbody></table><p><strong>“指向 Data Member 的指针”存取方式</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>没有继承</td><td>0.80</td><td>5.34</td></tr><tr><td>单一继承（三层）</td><td>0.80</td><td>5.34</td></tr><tr><td>虚拟继承（单层）</td><td>1.60</td><td>5.44</td></tr><tr><td>虚拟继承（双层）</td><td>2.14</td><td>5.51</td></tr></tbody></table><p>在两个编译器中，每次存取 <code>Point::x</code>，像这样： <code>pB.*bx</code> 会被转换为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;pB-&gt;__vbcPoint + ( bx - <span class="number">1</span> )</span><br></pre></td></tr></table></figure></p><p>而不是转换为最直接的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;pB + ( bx - <span class="number">1</span> )</span><br></pre></td></tr></table></figure></p><p>额外的间接性会降低“把所有的处理都搬移到寄存器中执行”的优化能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data-语意学-The-Semantics-of-Data&quot;&gt;&lt;a href=&quot;#Data-语意学-The-Semantics-of-Data&quot; class=&quot;headerlink&quot; title=&quot;Data 语意学 (The Semantics of Data)
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」《Effective C++》 读书笔记（三）</title>
    <link href="https://blog.pazyx.xyz/2018/12/19/effective-cpp03/"/>
    <id>https://blog.pazyx.xyz/2018/12/19/effective-cpp03/</id>
    <published>2018-12-18T16:02:25.000Z</published>
    <updated>2019-05-10T11:04:36.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。</p><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Investment* pInv = creteInvestment();<span class="comment">// 调用 factory 函数</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pInv;<span class="comment">// 释放 pInv 所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>...</code> 可能存在过早的 <code>return</code> 语句，或抛出某些异常，<code>delete</code> 语句将不会被执行。类似的 <code>goto</code> 语句或循环中的 <code>continue</code> 和 <code>break</code>。</p><p>使用智能指针，利用栈中对象的析构函数自动对其 <code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>获得资源后立刻放进管理对象（managing object）</strong></li><li><strong>管理对象（managing object）运用析构函数确保资源被释放</strong></li></ul><p>常使用的 RAII classes ：<code>tr1::shared_ptr</code> 和 <code>auto_ptr</code> 。</p><h2 id="条款-14：在资源管理类中小心-copying-行为"><a href="#条款-14：在资源管理类中小心-copying-行为" class="headerlink" title="条款 14：在资源管理类中小心 copying 行为"></a>条款 14：在资源管理类中小心 <em>copying</em> 行为</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">explicit Lock(Mutex* pm) : mutexPtr(pm)</span><br><span class="line">&#123;</span><br><span class="line">lock(muterPtr);</span><br><span class="line">&#125;</span><br><span class="line">~Lock()</span><br><span class="line">&#123;</span><br><span class="line">        unlock(mutexPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;</span><br></pre></td></tr></table></figure><p>RAII classes 应被禁止复制或采用“引用计数法（reference-count）”。</p><h3 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span> <span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“引用计数法”（reference-count）"><a href="#“引用计数法”（reference-count）" class="headerlink" title="“引用计数法”（reference-count）"></a>“引用计数法”（reference-count）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)</span><br><span class="line">&#123;</span><br><span class="line">lock(muterPtr.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进行“深度拷贝”，复制底部资源</li><li>转移底部资源的拥有权，如：<code>auto_ptr</code></li></ul><p><code>Coping</code> 函数包括 <code>copy</code> 构造函数和 <code>copy assignment</code>操作符。</p><h2 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h2><p>每个 RAII class 应该提供一个 “取得其所管理之资源” 的方法。<br>对原始资源的访问可能经由显式转换或隐式转换。显式转换比较安全，但隐式转换对客户比较方便。</p><h2 id="条款-16：成对使用-new-和-delete-时要采取相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采取相同形式"></a>条款 16：成对使用 new 和 delete 时要采取相同形式</h2><p>使用 <code>new</code> 要严格搭配 <code>delete</code>，如使用 <code>delete[]</code> 为未定义的行为，可能多次调用析构函数。<br>使用 <code>new[]</code> 要严格搭配 <code>delete[]</code>。<br>谨慎对数组类型 <code>typedef</code> 。 </p><h2 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line">void processWidget(std::tr1::shared_ptr&lt;Widget&gt;, priority());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br><span class="line"><span class="comment">// 进入函数前做了以下三件事</span></span><br><span class="line"><span class="comment">// 执行 "new Widget"</span></span><br><span class="line"><span class="comment">// 调用 tr1::shared_ptr 构造函数</span></span><br><span class="line"><span class="comment">// 调用 priority()</span></span><br></pre></td></tr></table></figure><p>编译器对这三件事的完成次序上弹性很大。<br>如在 <code>priority()</code> 抛出了异常，<code>new Widget</code> 返回的指针将可能遗失，因为它尚未被置入 <code>std::tr1::shared_ptr</code> 内。</p><p>避免这类问题只需分离语句，控制执行顺序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意！&quot;&gt;&lt;a href=&quot;#注意！&quot; class=&quot;headerlink&quot; title=&quot;注意！&quot;&gt;&lt;/a&gt;注意！&lt;/h1&gt;&lt;p&gt;这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）
      
    
    </summary>
    
      <category term="泛 - 笔记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="读书" scheme="https://blog.pazyx.xyz/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="https://blog.pazyx.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="https://blog.pazyx.xyz/tags/Effective-C/"/>
    
      <category term="智能指针" scheme="https://blog.pazyx.xyz/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>「书摘」《自控力》</title>
    <link href="https://blog.pazyx.xyz/2018/12/12/books-1/"/>
    <id>https://blog.pazyx.xyz/2018/12/12/books-1/</id>
    <published>2018-12-11T23:31:20.000Z</published>
    <updated>2018-12-21T12:28:20.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？"><a href="#我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？" class="headerlink" title="我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？"></a>我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？</h1><ul><li>研究表明，自诩意志坚定的人反而最容易在诱惑面前失控。比如，自信能抵制诱惑的戒烟者最容易在4个月后故态复萌，过于乐观的节食者最不容易减肥成功。这是为什么呢？因为他们无法预测自己在何时何地、会由于何种原因失控。</li><li>每个人都在以某种方式抵制诱惑、癖好、干扰和拖延。这不是个体的弱点或个人的不足，而是普遍的经验，是人所共有的状态。</li><li>“说不”属于意志力的一部分，而且是不可或缺的一部分。</li><li>牢记自己真正想要的是什么</li><li>前额皮质并不是挤成一团的灰质，而是分成了三个区域，分管“我要做”“我不要”和“我想要”三种力量。</li><li>如果没有了欲望，人们就会变得沮丧；如果没有了恐惧，人们就没法保护自己、远离伤害。</li><li>在意志力挑战中获胜的关键，在于学会利用原始本能，而不是反抗这些本能。</li><li>注意力分散的人更容易向诱惑屈服。</li><li>如果你想有更强的自控力，就得有更多的自我意识。</li><li>只要她能意识到自己在做什么，就有可能停下来。</li><li>观察自己究竟是怎样屈服于冲动的。</li><li>神经学家发现，如果你经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你集中注意力、管理压力、克制冲动和认识自我的能力。一段时间之后，你的大脑就会变成调试良好的意志力机器。</li><li>不仅要关注自己能否将注意力集中到呼吸上，还要注意观察，这种训练在其他时候是否影响了你的选择。</li><li>在冥想训练里做的事正是他在生活中也要面对的——把自己的注意力收回，专注于最初的目标。（在冥想训练中，目标就是专注呼吸。）</li></ul><h1 id="意志力的本能：人生来就能抵制奶酪蛋糕的诱惑"><a href="#意志力的本能：人生来就能抵制奶酪蛋糕的诱惑" class="headerlink" title="意志力的本能：人生来就能抵制奶酪蛋糕的诱惑"></a>意志力的本能：人生来就能抵制奶酪蛋糕的诱惑</h1><ul><li>自控力不仅和心理有关，更和生理有关。只有在大脑和身体同时作用的瞬间，你才有力量克服冲动。</li><li>应激反应是一种管理能量的本能，这种本能决定了你将如何利用有限的体力和脑力。</li><li>我们总觉得诱惑和麻烦来自外部世界，比如危险的甜甜圈、罪恶的香烟、充满诱惑的网络。但自控力告诉我们，问题出在我们自己身上，是我们的思想、欲望、情绪和冲动出了问题。</li><li>“三思而后行”反应和应激反应有一处关键的区别：前者的起因是你意识到了内在的冲突，而不是外在的威胁。</li><li>最有效的做法就是先让自己放慢速度，而不是给自己加速（比如应激反应）。“三思而后行”反应就是让你慢下来。当你意识到内在冲突的时候，大脑和身体会做出反应，帮助你放慢速度、抑制冲动。</li><li>当人们感到压力时，交感神经系统会控制身体。这种生理学现象让你能够战斗或者逃跑。心率升高，心率变异度就会降低。此时，由于伴随应激反应产生的焦虑或愤怒，心率会被迫保持在较高的水平上。相反，当人们成功自控的时候，副交感神经系统会发挥主要作用，缓解压力，控制冲动行为。心率降低，心率变异度便会升高。此时，人们能更好地集中注意力并保持平静。</li><li>心率变异度较高的人能更好地集中注意力、避免及时行乐的想法、更好地应对压力。</li><li>有很多因素会影响到意志力储备，比如你吃什么（以植物为原材料的、未经加工的食物有助于提高心率变异度，垃圾食品则会降低心率变异度）或是住在哪里（糟糕的空气质量会降低心率变异度）。任何给你的身心带来压力的东西都会影响自控力的生理基础，甚至会摧毁你的意志力。焦虑、愤怒、抑郁和孤独都与较低的心率变异度和较差的自控力有关。慢性疼痛和慢性疾病则会消耗身体和大脑的意志力储备。</li><li>将呼吸频率降低到每分钟4-6次，也就是每次呼吸用10-15秒时间，比平常呼吸要慢一些。只要你有足够的耐心，加上必要的练习，这一点不难办到。放慢呼吸能激活前额皮质、提高心率变异度，有助于你的身心从压力状态调整到自控力状态。这样训练几分钟之后，你就会感到平静、有控制感，能够克制欲望、迎接挑战。</li><li>滥用药物或患有创伤后应激障碍症的成年人，每天进行20分钟放慢呼吸的练习，就能提高心率变异度，降低欲望和抑郁程度。</li><li>锻炼能提高心率变异度的基准线，从而改善自控力的生理基础。</li><li>改善心情、缓解压力的最有效的锻炼是每次5分钟，而不是每次几小时。</li><li>任何能让你离开椅子的活动，都能提高你的意志力储备。</li><li>如果你觉得锻炼太累了，或是没有时间锻炼，那么不妨将锻炼当做恢复体能和意志力的方法。</li><li>长期睡眠不足让你更容易感到压力、萌生欲望、受到诱惑。你还会很难控制情绪、集中注意力，或是无力应付“我想要”的意志力挑战。</li><li>如果睡眠不足的人补上一个好觉，他的前额皮质就会恢复如初。实际上，他的大脑和休息良好的人的大脑会完全一样。</li><li>如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</li><li>自控需要大量能量，很多科学家都认为，长时间的自控就像慢性压力一样，会削弱免疫系统的功能，增大患病的概率。</li><li>正如适度的压力是有意义的健康生活不可缺少的一部分，适当的自控也是必需的。但是正如慢性压力会影响健康一样，试图控制所有的思想、情绪和行为也是一剂毒药，会给你带去过重的生理负担。</li><li>为了能够保持健康、维持幸福生活，你需要放弃对意志力的完美控制。</li><li>从压力和自控力中恢复的最佳途径就是放松。放松，即便只放松几分钟，都能激活副交感神经系统，舒缓交感神经系统，从而提高心率变异度。它还能把身体调整到修复和自愈状态、提高免疫功能、降低压力荷尔蒙分泌。</li><li>能提高意志力的“放松”是真正意义上的身心休整。哈佛医学院心脏病专家赫伯特·本森（Herbert Benson）称之为“生理学放松反应”。你的心率和呼吸速度会放缓，血压会降低，肌肉会放松。你的大脑不会去规划未来，也不会去分析过去。<br>想要激发这种放松反应，你需要躺下来，用枕头垫着膝盖，腿稍稍抬起（或者，你可以选择任何一个你觉得舒服的姿势）。闭上眼睛，做几次深呼吸，感觉你的腹部有起伏。如果你觉得身体某处很紧张，你可以有意识地挤压或收缩肌肉，然后就不要再去管它了。比如，如果你发现手掌和手指很紧张，那么就攥一下拳头，然后张开手掌。如果你发现前额和下巴很紧张，那么就挤挤眼、皱皱眉，然后张大嘴巴，放松整个面部。保持这种状态5-10分钟，试着享受这种除了呼吸什么都不用想的状态。如果你担心会睡着，那就先设定好闹钟。</li><li>意志力是一种不断进化的能力，是每个人都有的本能。它详细地记录了身体和大脑的状态。</li><li>意志力会受到多方面的影响，比如睡眠不足、饮食不良、久坐不动和各种消耗能量的事情，或是身心长期处于压力状态之下。</li><li>从长远的角度看，没有什么比压力更消耗意志力了。压力和自控的生理学基础是互相排斥的。</li><li>压力让你关注即时的、短期的目标和结果，自控力则需要你的大脑有更广阔的视野。</li><li>学会如何更好地管理压力，是提高意志力的重要组成部分。</li><li>儿童多动症的概率急剧攀升很可能和这种睡眠习惯有关，因为儿童往往受成人睡眠习惯的影响，而且儿童需要更多的睡眠。</li><li>我们的坏习惯（比如过度饮食和睡眠不足）不仅反映了我们缺乏自控力，还消耗了我们的体力，带来了更多的压力，偷走了我们的自控力。</li><li>当我们面对的意志力挑战过于强大时，我们很容易给自己下这样的结论——我是个软弱、懒惰、毫无意志力的废物。但通常的情形是，我们的大脑和身体并未处于自控状态。当我们处在慢性压力中时，迎接意志力挑战的是最冲动的自己。想要赢得意志力挑战，我们需要调整到正确的身心状态，用能量去自控，而不是自卫。这就意味着，我们需要从压力中恢复过来，保证有能量做最好的自己。</li><li>意志力是种生理本能，它和压力一样，通过不断进化来保护我们不受自身伤害。</li></ul><h1 id="累到无力抵抗：为什么自控力和肌肉一样有极限？"><a href="#累到无力抵抗：为什么自控力和肌肉一样有极限？" class="headerlink" title="累到无力抵抗：为什么自控力和肌肉一样有极限？"></a>累到无力抵抗：为什么自控力和肌肉一样有极限？</h1><ul><li>似乎我们只有一定量的意志力，一旦你将它消耗殆尽，你在诱惑面前就会毫无防备力，至少会处于下风。</li><li>人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。</li><li>时间过长，注意力训练就不仅会分散注意力，还会耗尽身体的能量。控制情绪不仅会导致情绪失控，还会促使人们购买他们本不需要的东西。抵抗甜食的诱惑不仅会让人更想吃巧克力，还会导致拖延症。</li><li>资源不足时，大脑会选择满足当下的需求；资源充足时，大脑则会转向选择长期的投资。</li><li>更好的方法是保证你的身体有足够的食物供应，这样能给你更持久的能量。大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。</li><li>这些研究中训练的“肌肉”不是为了让你在规定期限前完成任务、用左手开门或不说脏话，而是让你养成习惯、关注自己正在做的事情、选择更难的而不是最简单的事。通过每一次意志力练习，大脑开始习惯于三思而后行。</li><li>我们总是在意志力真正耗尽之前就感到无法坚持了。从某种程度上说，我们应该感谢大脑帮助我们保存能量。正如大脑担心体能枯竭时会告诉肌肉放慢速度一样，大脑也会对大量消耗前额皮质中能量的活动喊“停”。这并不意味着我们用光了意志力，我们只是需要积攒使用意志力的动力罢了。</li><li>知道我们的意志力比想象中多得多，这确实是件令人开心的事。或许我们也可以像运动员一样，挺过意志力消耗殆尽的感觉，冲过意志力挑战的终点。</li></ul><h1 id="容忍罪恶：为何善行之后会有恶行？"><a href="#容忍罪恶：为何善行之后会有恶行？" class="headerlink" title="容忍罪恶：为何善行之后会有恶行？"></a>容忍罪恶：为何善行之后会有恶行？</h1><ul><li>心理学家一直认为，当你表达一种态度时，你更可能按这种准则行事。毕竟，谁愿意做伪君子？但普林斯顿的心理学家揭示了一个例外，这和我们对表里如一的渴望背道而驰。当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。</li><li>明确驳斥性别歧视和种族歧视言论的学生，觉得自己已经获得了道德许可证。他们已经向自己证明了，他们没有性别歧视或种族歧视。这就让他们在心理学家所谓的“道德许可”（moral licensing）面前不堪一击。当你做善事的时候，你会感觉良好。这就意味着，你更可能相信自己的冲动。而冲动常常会允许你做坏事。</li><li>“道德许可”不仅会批准我们做坏事，也会让我们错失做善事的机会。</li><li>如果你去锻炼了就说自己很“好”，没去锻炼就说自己很“坏”，那么你很可能因为今天去锻炼了，明天就不去了。如果你去处理了一个重要项目就说自己很“好”，拖延着不去处理就说自己很“坏”，那么你很可能因为早上取得了进步，下午就变懒散了。简单说来，只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。</li><li>任何让你对自己的美德感到满意的事，即便只是想想你做过的善事，都会允许我们冲动行事。</li><li>“道德许可”最糟糕的部分并不是它可疑的逻辑，而是它会诱使我们做出背离自己最大利益的事。</li><li>不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</li><li>大部分人认为，取得进步会刺激我们获得更大的成功。但心理学家知道，我们总是把进步当做放松的借口。</li><li>芝加哥大学商学院研究生院的教授阿耶莱特·费什巴赫（Ayelet Fishbach）和耶鲁大学管理学教授拉维·多尔（Ravi Dhar）已经证明了，在完成某个目标过程中取得的进步，会刺激人们做出妨碍完成目标的行为</li><li>应该想着“我做这件事是因为我想要……”</li><li>有时候，大脑会对能完成目标的可能性感到兴奋，它错把可能性当成真正完成了目标。</li><li>对未来的乐观主义精神，不仅会影响我们自己的决定，还会影响我们究竟会不会按自己所说的去做。心理学家已经证明了，我们错误地认为自己明天会比今天有更多的空闲时间。</li><li>人们是为理想世界作出预估，却在现实世界生活了两周。</li><li>当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。</li><li>你明知道应该做一件事情却拖延不做时，不要问自己“我是想今天做还是明天做？”，而要问自己“我是不是想承担永远拖延下去的恶果？”</li><li>研究表明，选择健康主食的人，通常会在饮料、配菜和甜点上纵容自己。</li><li>托儿所会让晚接孩子的父母交罚款，但这种制度实际上增加了晚接孩子的概率。家长可以购买晚接孩子的权利，以此来消除自己的罪恶感。</li><li>从本质上看，道德许可就是一种身份危机。我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。</li><li>在追求自控的过程中，我们不应该把所有的意志力挑战都放在道德标准的框架中。我们总是轻易地认为，自己做过的善行，或是仅仅考虑要去做的善行，给了我们道德上的许可。如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。</li><li>明天和今天毫无区别。当你想改变行为的时候，试着减少行为的变化性，而不是减少某种行为。</li><li>取消许可，牢记理由。下一回，当你发现自己在用曾经的善行为放纵辩护的时候，停下来想一想你做“好”事的原因，而不是你应不应该得到奖励。</li></ul><h1 id="大脑的弥天大谎：为什么我们误把渴望当幸福"><a href="#大脑的弥天大谎：为什么我们误把渴望当幸福" class="headerlink" title="大脑的弥天大谎：为什么我们误把渴望当幸福"></a>大脑的弥天大谎：为什么我们误把渴望当幸福</h1><ul><li>多巴胺会告诉大脑其他的部分它们需要注意什么，怎样才能让贪婪的我们得手。大量的多巴胺并不能产生快乐的感觉，那种感觉更像是一种激励。我们会觉得警醒、清醒、着迷。我们发现了如何才能得到快乐，而且愿意为了获得这种感觉付出努力。</li><li>这些设备就这样俘获了我们，让我们不断要求更多。在我们所处的时代里，奖励的承诺可以用我们上网时的行为来打比方——我们搜索，再搜索，搜索更多的。我们点击鼠标，就像笼子里的小白鼠想再感受一次电击一样。我们追寻着难以捉摸的奖励，直到最终觉得满意。</li><li>手机、互联网和其他社交媒体可能是无意中激活了我们的奖励系统，但电脑和电子游戏的设计者是有意识地控制了人们的奖励系统，让玩家上钩。“升级”和“获胜”随时可能出现，游戏就这样激发了人们的兴趣。这也是人们很难戒掉游戏的原因。</li><li>2005年，28岁的韩国锅炉修理工李承生在连续50个小时奋战“星际争霸”之后死于心血管衰竭。他不吃不睡，只想继续玩游戏。听到这件事的时候，我们很难不联想到奥尔兹和米尔纳实验中力竭而亡的小白鼠。</li><li>多巴胺在我们上瘾时会发挥某些作用。最令我们吃惊的是它在帕金森患者治疗过程中发挥的作用。帕金森症是一种常见的神经退化性疾病，病因是脑细胞中缺少多巴胺。多巴胺在刺激行为中起的作用主要表现在：减缓或减少运动、抑郁以及间歇性紧张症。标准的帕金森治疗方式是同时服用两种药物：左旋多巴和多巴胺受体激动剂。前者可以帮助大脑产生多巴胺，后者能刺激大脑中的多巴胺腺体，模仿多巴胺的行为。当病人刚开始接受药物治疗时，大脑中多巴胺的含量会比往常多。这就减轻了帕金森的主要症状，但同时带来了难以预料的新问题。</li><li>当多巴胺给我们的大脑安排寻找奖励的任务时，我们就展现了自己最敢于冒险、最冲动、最失控的一面。</li><li>更重要的是，如果奖励迟迟没有到来的话，奖励的承诺（和一想到要停下来就不断增长的焦虑）足以让我们一直上瘾。如果你是实验室里的小白鼠，你就会一次次地去按杠杆，直到力竭而亡或被饿死。如果你是人类，你就会掏空钱包、填满肚子——这还是好的。如果严重的话，你会发现自己患上了强迫症。</li><li>当奖励的承诺释放多巴胺的时候，你更容易受到其他形式的诱惑。</li><li>大量分泌的多巴胺会放大“及时行乐”的快感，让你不再关心长期的后果。</li><li>如果你咬了一口店里新推出的肉桂卷，你就会发现自己又往购物车里多放了几件东西。即便你抵挡住了样品的诱惑，你也会因为大脑释放了更多的多巴胺而去寻找一些东西，以满足你奖励的承诺。</li><li>大脑的奖励系统对新鲜感和多样性也会有反应。你的多巴胺神经元会对熟悉的奖励反应较少</li><li>虽然我们所处的世界总让我们产生欲望，但我们只要用心观察，就能看透一些东西。知道那是怎么一回事并不能完全消除你的欲望，但它能让你至少有机会抗争一下，锻炼一下“我不要”力量。</li><li>我们的奖励系统面对可能获得的大奖会更加兴奋。它会促使我们去做任何可能获奖的事。这就是为什么人们宁愿买乐透彩票，也不愿意把钱存到银行里</li><li>我的学生通过使用音乐、时尚杂志和电视，让自己在做通常会推迟的任务时，产生更多多巴胺，帮助他们找到了解决办法，比如带上可怕的文书工作走进自己喜欢的咖啡厅，边喝热巧克力边完成工作，或是极富创意地买一堆刮刮乐彩票，把它们放在你想拖延的项目周围。还有一些人想象自己努力工作后取得的最佳结果，让未来的奖励显得更加真实。如果有什么事让你觉得很不愉快，所以你总是拖延着不去做，你能不能把它和能让多巴胺神经元燃烧的事联系在一起，从而促使自己去做呢？</li><li>如果我们能够停下来观察一下，自己在有所渴望的时候，大脑和身体中究竟发生了什么事情，我们就会发现，奖励的承诺带给我们的压力和快乐几乎不分上下。渴望并不是总能让我们感觉良好。有时候，它会让我们觉得自己堕落了。这是因为，多巴胺的首要功能是让我们追求快乐，而不是让我们快乐。它并不介意给我们来点压力，即便这会让我们在追求快乐的时候觉得不快乐。</li><li>大部分人会更关注对快乐的承诺，而不关注多巴胺刺激欲望时感觉到的不快乐。</li><li>我们误把渴望的感觉当做了快乐的保证。</li><li>我们误以为的快乐源泉，其实正是痛苦的根源。</li><li>当我们的奖励系统平静下来时，我们并不会感到满足，而更可能表现得冷漠。这就是为什么很多帕金森病人会觉得抑郁，而不是安宁，因为他们的大脑无法产生足够的多巴胺。</li><li>我们需要奖励的承诺，让我们保持对生活的兴趣，并继续生活下去。如果我们幸运的话，奖励系统会继续这样为我们服务下去。同时，我们也希望它不要和我们作对。我们所处的世界充满了科学技术、广告和各种各样的机会，我们总是产生欲望，却很少得到满足。如果我们想拥有自控力，就需要区分让我们的生活有意义的真实奖励，和让我们分散精力、上瘾的虚假奖励。学会区分这两种奖励，也许是我们能做到的最好的事了。</li><li>欲望没有绝对的好坏之分，重要的是欲望将我们引向哪个方向，以及我们是否足够明智，知道什么时候该听从欲望的声音。</li></ul><h1 id="“那又如何”：情绪低落为何会使人屈服于诱惑？"><a href="#“那又如何”：情绪低落为何会使人屈服于诱惑？" class="headerlink" title="“那又如何”：情绪低落为何会使人屈服于诱惑？"></a>“那又如何”：情绪低落为何会使人屈服于诱惑？</h1><ul><li>在研究压力、焦虑、罪恶感对自控力的影响时，我们发现，情绪低落会使人屈服，而且经常是以令人吃惊的方式屈服。令人恐惧的吸烟警示会让烟民更渴望香烟，经济危机会让人更想购物，晚间新闻会让人吃得更多。</li><li>当你感到压力时，你的大脑就会指引着你，让你去做它认为能带给你快乐的事情。</li><li>神经科学家证明了，压力包括愤怒、悲伤、自我怀疑、焦虑等消极情绪，会使你的大脑进入寻找奖励的状态。只要你的大脑和奖励的承诺联系起来，你就会渴望得到那个“奖励”。</li><li>奖励的承诺和缓解压力的承诺会导致各种各样不合逻辑的行为。比如，一项经济学研究发现，那些对自己的经济状况表示担忧的女性，会通过购物来排解内心的焦虑和压抑。</li><li>有效和无效的策略最主要的区别是什么？真正能缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质，如血清素、γ-氨基丁酸和让人感觉良好的催产素。这些物质还会让大脑不再对压力产生反应，减少身体里的压力荷尔蒙，产生有治愈效果的放松反应。</li><li>根据“恐惧管理”理论，当人类想到自己的死亡时，很自然会觉得害怕。我们可以暂时避开危险，但终究逃不过宿命。每当我们想起自己不可能永生时（比如，看晚间新闻的时候，每29秒我们就会有一次这样的想法），大脑就会产生恐惧的反应。我们并非总能意识到这一点，因为焦虑可能还没有浮出水面，还没有产生强烈的不适感，或者我们并不知道这是为什么。即使我们意识不到这种恐惧，它还是会让我们立即作出回应，对抗自己的无力感。我们会去寻找保护伞，寻找任何能让自己觉得安全、有力量、得到安慰的东西</li><li>研究发现，当我们意识到自己不会永生时，我们会更容易屈服于各种诱惑，就像是在奖励和减压的承诺里寻找希望和安全感一样。</li><li>一项调查发现，新闻中的死亡报道会让观众对豪华轿车、劳力士手表等彰显身份地位的东西产生更积极的回应。这并不是说，我们认为一块劳力士手表就能让自己不被导弹打中，而是这些商品提升了我们的自我形象，让我们感到充满力量。对很多人来说，购物是让自己更乐观、更有掌控感的快速途径。这就是美国人为什么在“9·11”事件后如此愿意接受小布什总统的提议：“我和我夫人鼓励美国人购物。”</li><li>“恐惧管理”的方法能让我们不去想那个不可避免的死亡。但当我们在诱惑中寻找慰藉的时候，我们是在不自觉地加速迈向坟墓的脚步。</li><li>有时候，“恐惧管理”带来的不是诱惑，而是拖延。我们最想拖延的很多事情，都和死亡有或多或少的关联，比如预约看医生，按处方开药，遵医嘱服药，保管法律文件和写遗嘱，存钱养老，甚至是扔掉自己绝不会用到的东西和不合身的衣服。</li><li>远离那些会让你产生恐惧的电视新闻、访谈节目、杂志或网页。</li><li>毫无意外，头天晚上喝了太多酒的人第二天早上会感到痛苦，会觉得头疼、恶心、疲倦。但他们的痛苦不仅仅源于宿醉。很多人还感到罪恶和羞愧。这才是真正让人感到困扰的。当被试者因为前一晚饮酒过量而情绪低落时，他们更可能在当天晚上或以后喝更多的酒。罪恶感驱使他们再度饮酒。</li><li>屈服会让你对自己失望，会让你想做一些改善心情的事。那么，最廉价、最快捷的改善心情的方法是什么？往往是做导致你情绪低落的事。</li><li>关键是，导致更多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。一旦你陷入了这样的循环，似乎除了继续做下去，就没有别的出路了。当你（又一次）责备自己（又一次）屈服于诱惑的时候，往往会带来更多意志力的失效，造成更多的痛苦。但是，你寻求安慰的东西并不能中断这个循环，它只会给你带来更深切的罪恶感。</li><li>我们可能会想，罪恶感会促使我们改正错误，但其实这正是“情绪低落让我们屈服于诱惑”的另一个表现方式。</li><li>众多研究显示，自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。它不仅耗尽了“我要做”的力量，还耗尽了“我想要”的力量。相反，自我同情则会提升积极性和自控力，比如，在压力和挫折面前支持自己、对自己好一些。</li><li>出人意料的是，增强责任感的不是罪恶感，而是自我谅解。研究人员发现，在个人挫折面前，持自我同情态度的人比持自我批评的态度的人更愿意承担责任。他们也更愿意接受别人的反馈和建议，更可能从这种经历中学到东西。</li><li>自我谅解能帮助人们从错误中恢复过来，因为它能消除人们想到失败时的羞愧和痛苦。</li><li>如果你觉得遇到挫折意味着你将一事无成、只会把事情搞糟，那么反思这个挫折只会让你在痛苦中更讨厌自己。你最紧迫的目标是安抚这种感觉，而不是吸取教训。</li><li>你只是个凡人。每个人都会遇到意志力挑战，每个人都有失去自控的时候。这只是人性的组成部分，挫折并不意味着你本身有问题。想一想这些说法是不是真的。你能想象你尊敬、关心的其他人也经历过同样的抗争和挫折吗？这个视角会让自我批评和自我怀疑的声音变得不那么尖锐。</li><li>压力会引起欲望，让我们的大脑更容易受到诱惑。如果有东西提醒我们不能永生，就会让我们从食物、购物或香烟中寻找慰藉。那么罪恶感和自我批评呢？它们会让你立刻想到“那又如何，我还不如再放纵一下自己呢”。</li><li>发誓改变会让我们充满希望。我们喜欢想象改变后的生活，幻想改变后的自己。研究显示，节食计划会让人感觉更有力量，运动计划会让人觉得自己更高大。（当然，这些幻想不一定会实现。）</li><li>不幸的是，就像奖励的承诺和缓解压力的承诺一样，改变的承诺也很少能朝我们希望的方向发展。不切实际的乐观可能给我们一时的快乐，但接下来我们就会感到失落。</li><li>当我们第一次面对挫折时，失望就会取代最初决定改变时的良好感觉。没能达到预期目标会再度引发曾经的罪恶感、抑郁和自我怀疑，而承诺改变的情绪慰藉作用也消失了。这时，大多数人会彻底放弃努力。只有当我们感觉失控，需要再次拥有希望的时候，我们才会再次发誓作出改变。于是，这个循环又开始了。</li><li>我们需要相信，改变是可能做到的。如果失去了希望，我们就会听天由命了。但是，我们必须避免常见的意志力陷阱，即用“改变的承诺”而不是“改变”来改善我们的心情。否则，这种看似意志力的东西就会把我们变成按压杠杆的小白鼠，觉得这个东西能让我们获得奖励。</li><li>乐观给我们动力，但少许的悲观能帮我们走向成功。研究发现，如果能预测自己什么时候、会如何受到诱惑和违背承诺，你就更有可能拥有坚定的决心。</li><li>为了避免压力导致的意志力失效，我们需要找到能让我们真正快乐的东西，而不是虚假的奖励承诺，也不是空洞的改变承诺。我们需要允许自己去做真正让自己快乐的事，远离那些与我们生活无关的压力根源。当我们遭遇挫折时（这种情况是难以避免的），我们需要原谅曾经的失败，不要把它们作为屈服或放弃的借口。想要增强自控力，自我同情比自我打击有效得多。</li></ul><h1 id="出售未来：及时享乐的经济学"><a href="#出售未来：及时享乐的经济学" class="headerlink" title="出售未来：及时享乐的经济学"></a>出售未来：及时享乐的经济学</h1><ul><li>如果我们处在最佳状态，人类控制冲动的能力让其他物种自惭形秽。但通常情况下，我们想象力丰富的大脑不会作出最有战略性的决定，而是让我们表现得像是失去了理性。这是因为，前额皮质最擅长的不是自控。它会为错误的决定寻找借口，向我们承诺明天会更好。你可以肯定，那些黑猩猩不会对自己说：“我现在要吃2颗葡萄，因为我还有下一次可以等着吃6颗葡萄。”但人类总有各种各样的花招，让自己相信抵抗诱惑是明天的事情。因此，拥有巨大前额皮质的我们，会一再屈服于即刻的满足感。</li><li>为了迅速得到瞬间的快感，他们忘记了自己真正想要的东西。</li><li>经济学家称之为“延迟折扣”。也就是说，等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。</li><li>当诱惑真实存在时，我们的大脑就进入了“搜寻奖励”模式，确保我们不会错过任何奖励。</li><li>当我们和诱惑正面交锋的时候，我们只愿意选择短期的、即时的奖励，这种欲望是无可抵挡的。这就带来了“有限意志力”。也就是说，到我们真的需要自控力之前，我们一直拥有自控力。</li><li>我们在权衡“即时奖励”和“未来奖励”时，大脑处理选项的方式相当不一样。“即时奖励”会激活更古老、更原始的奖励系统，刺激相应的多巴胺产生欲望。“未来奖励”则不太能激活这个奖励系统。</li><li>对那些想延迟快感的人来说，这是个好消息。只要你能创造一点距离，就会让拒绝变得容易起来。</li><li>当他对自己的欲望直截了当地说“不”时，那句“好，但要等10分钟”减少了一部分的恐惧和压力，让他等起来更轻松。几次之后，他就能转移注意力，忘掉吸烟的冲动了。</li><li><p>当你觉得自己无法做到“不会有下一次”的时候，不妨用“10分钟延迟法则”来增强你的自控力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 当你受到诱惑要做与长期利益相悖的事时，请想象一下，这个选择就意味着，你为了即时的满足感放弃了更好的长期奖励。</span><br><span class="line">2. 想象你已经得到了长期的奖励。想象未来的你正在享受自控的成果。</span><br><span class="line">3. 然后扪心自问：你愿意放弃它，来换取正在诱惑你的短暂快感吗？</span><br></pre></td></tr></table></figure></li><li><p>大脑会把未来的自己当成别人，这种习惯对自控力影响极大。研究发现，当你想到未来的自己时，大脑中越是想不到自己，你就越可能对未来的自己说“去你的”，也就越可能对即时的满足感说“好”。</p></li><li>当我们思考未来时，我们能预测到未来的自己和想象中有什么不同。未来的奖励似乎并不那么有诱惑力，所以我们选择了即时的满足感。我们无法预测自己会怎么受到诱惑、怎么被分散注意力，所以我们无法坚定自己的目标。如果我们想作出更明智的决定，就要更好地理解和支持未来的自己。我们还需要记住，为现在的行为承担后果的，看似是未来的自己，实际上还是我们自己。未来的自己会对我们现在的付出感激不尽。</li></ul><h1 id="传染：为什么意志力会传染？"><a href="#传染：为什么意志力会传染？" class="headerlink" title="传染：为什么意志力会传染？"></a>传染：为什么意志力会传染？</h1><ul><li>意志力薄弱可能会传染，但你仍然可以获得自控力。</li><li>我们有模仿别人行动的本能，这就意味着，当你看到别人去拿零食、饮料或信用卡的时候，你自己也会无意识地模仿他们的行为。同时，你也会失去自己的意志力。</li><li>当我们想象别人想要什么的时候，他们的欲望就会引发我们的欲望，他们的食欲也会引发我们的食欲。</li><li>有时候，我们感染的不是某种具体的目标，比如吃零食、花钱、诱惑陌生人，而是和我们的冲动一致的、更普遍的目标。</li><li>人们感染的目标是做自己想做的事，而不是自己应该做的事。</li><li>为什么在关系密切的人中间，行为会传染得这么严重呢？我们可以用免疫系统作个类比。只有当免疫系统发现那些人“和我们不同”时，它才会拒绝他们的目标和行为。毕竟，我们体内的免疫系统不会攻击自身的细胞。只要它能辨别出那是自己的东西，它就不会作出任何反应。</li><li>当我们想到我们喜爱、尊重的人和感觉相似的人时，我们的大脑会像对待自己一样对待他们，而不会把他们视为“别人”。</li><li>当他们认识到自己的行为与信仰不符时，鼓励他们去制订改变行为的计划。相信好的基督徒应该减肥和锻炼身体，这是强有力的“社会认同”，远比检测出高胆固醇后医生的严厉警告来得有效。</li><li>如果我们想让别人更有意志力，就要让他们相信自控是个社会规范。</li><li>2010年《内科医学档案》中的一份报告指出，有37%的人在被临床诊断为肥胖后，不仅认为自己并不胖，还相信自己变胖的风险很低。</li><li>在说到“社会认同”的时候，我们认为别人做的事比别人实际做的更重要。比如，大学生对身边同学普遍作弊的情况估计过高。要想知道一个学生有没有作弊，要看他是否相信别人也在作弊，而不是看作弊的惩罚是否严厉，也不是看他是否认为自己会被抓。当他们相信自己的同学作了弊时，原本诚实的班级也会变成所有学生都在考试中发短信、传答案的班级。（是的，我曾抓到一个学生抄别人答案。）</li><li>如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。</li><li>自豪和羞愧依赖大脑皮层的情绪区，而不是用来作逻辑分析的前额皮层。社会情感可能进一步帮助我们作出选择，让我们在自己的群体里站稳脚跟。</li><li>实验研究发现，表现出内疚感会减少心率的变化，降低意志力的生理储备。反之，自豪感会保持甚至增加这种储备。</li><li>为了让自豪感发挥作用，我们必须认为别人都在监视自己，或我们有机会向别人报告自己的成功。</li><li>让自己坚定决心的有效策略是——公开你的意志力挑战</li><li>研究显示，人一旦被踢出群体，意志力就会耗竭。举个例子，当人们被社会拒绝时，他们就很难抵制新鲜出炉的曲奇饼干，面对具有挑战性的任务会很快放弃，在需要精神集中的实验里也更容易分心。</li><li>研究也显示，少数族群越是受到歧视，自我控制能力就越差。这只是提醒少数族群，歧视会耗尽他们的意志力。只要我们觉得被排斥或被冒犯，我们就有可能屈服于自己最糟糕的冲动。</li><li>值得注意的是，我们的大脑会把别人的目标、信念和行为整合到自己的决策中。当我们跟别人在一起时，或者只是简单地想到他们时，在我们的脑海里，别人就会成为另一个“自我”，并且和“自我”比赛自控。反之亦然：我们的行为也影响了其他无数人，我们做的每个选择对别人来说也是一种鼓舞或诱惑。</li></ul><h1 id="别读这章：“我不要”力量的局限性"><a href="#别读这章：“我不要”力量的局限性" class="headerlink" title="别读这章：“我不要”力量的局限性"></a>别读这章：“我不要”力量的局限性</h1><ul><li>没法不去想白熊，这或许不是最糟糕的意志力失效的案例。但正如我们所见，越是不让我们想一件事，我们就会越去想它。对焦虑、沮丧、节食、上瘾的最新调查证实，把“我不要”的力量用在涉及思想、情感的内心世界，它就会失效。当深入内心世界时，我们会发现，我们需要给自控一个全新的定义，给放弃自控留出一点空间来。</li><li>当人们试图摆脱某种想法时，它却像回飞镖一样“嗖”地飞回来了。</li><li>压抑人的本能时，就会产生这种讽刺性反弹效应。</li><li>韦格纳认为，这和大脑如何处理“不要去想”这个指令有关。大脑把这个指令分为两部分，分别由两个不同系统去执行。大脑的一部分负责将人的注意力从被禁止的想法那里引开，就像韦格纳第一个实验中那位设法不去想白熊的女士一样，“我试着去想白熊以外的其他所有东西……嘿，看看这面棕色的墙”。韦格纳将这个过程称为“操作”。“操作”依靠大脑的自控系统来完成。和所有需要付出努力的自我控制一样，这需要耗费大量的精力和能量。大脑的另一部分则负责寻找证据，证明你没有去想、去感觉、去做你不该去想、去感觉、去做的事，就像那位年轻的女士观察到的：“我想呀想呀想……每当我试着不去想白熊的时候，我其实总是想着它。”韦格纳将这个过程称为“监控”。“监控”和“操作”不同，它自动运行，无须耗费大量精力。“监控”与大脑的自动危险检测系统的联系更紧密。自动自控！这听起来可能很棒，但如果你认识到了“操作”与“监控”的配合有多重要，你就不会这么想了。无论基于什么原因，只要“操作”减弱了，“监控”就会成为自控的噩梦。</li><li>疲惫的“操作”和精力充沛的“监控”造成了大脑的不平衡，这会带来问题。当“监控”寻找被禁的内容时，它会让人不断想起要寻找的目标。神经学家指出，大脑的潜意识不断想到被禁止的内容。这么做的结果是，你会想到、感觉到或去做自己正在努力避免的事。</li><li>无论你想摆脱哪种恐惧或欲望，它们最后都会变得更让人信服，更引人注目。</li><li>怎么才能找到摆脱这种困境的方法呢？韦格纳提出了一种对抗讽刺性反弹的方法。这个方法本身就很有讽刺意味——这个方法就是放弃自控。当人们不再试图控制那些不希望出现的想法和情绪时，它们也就不会再来烦你了。</li><li>结果证明，这种方法对消除许多不好的内心感受都有用，它的适用范围大得令人吃惊。去想自己所想，追随自己的感觉（你不必相信它是真的，不要觉得必须采取行动），这是治疗焦虑、抑郁、嗜食和各种上瘾症状的有效方法。我们通过这些证据可以看到，放弃控制内心感受，反而能让我们更好地控制外在行为。</li><li>如果不和焦虑对抗，焦虑就会自然离去。</li><li>忠于你的感受，但别相信你所有的想法</li><li>直面自身欲望，但不要付诸行动。</li><li>当冲动占据你的头脑时，花至少一分钟去感觉自己的身体。你的冲动是什么样的？是热的还是冷的？身体有没有感到不舒服？心率、呼吸或内脏有什么变化？保持这个状态至少一分钟。看看这些感觉在强度或特性上有什么变化。</li><li>驾驭冲动不只适用于戒除癖好，还能帮助你掌控有害的冲动。</li><li>对内接受自我，对外控制行动。</li><li>抑制欲望的反面不是自我放纵。</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>我们天生就有自控的能力，即便有时我们不太会运用这种能力。它们帮我们找到失败的原因，为我们指出可行的解决方法。它们甚至告诉我们，做人意味着什么。</li><li>在未来的人生道路上，请保持科学家的心态。尝试新鲜事物，收集自己的数据，根据证据作出判断。对出人意料的想法保持开放的心态，从失败和成功中汲取经验教训。坚持有效的方法，和他人分享你了解的知识。面对复杂的人性和现代社会的诱惑，我们最好能做到这几点。但是，如果我们能保持好奇心和自我同情，那对付它们就绰绰有余了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot;&gt;&lt;a href=&quot;#我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot; class=&quot;headerlink&quot; title=&quot;我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot;&gt;
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="自控力" scheme="https://blog.pazyx.xyz/tags/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>吃草 - 打铁</title>
    <link href="https://blog.pazyx.xyz/2018/11/06/2018_icpc_qingdao_regional/"/>
    <id>https://blog.pazyx.xyz/2018/11/06/2018_icpc_qingdao_regional/</id>
    <published>2018-11-05T16:00:24.000Z</published>
    <updated>2018-11-06T00:19:27.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest"><a href="#The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest" class="headerlink" title="The 2018 ACM-ICPC Asia Qingdao Regional Contest"></a><center>The 2018 ACM-ICPC Asia Qingdao Regional Contest</center></h1><center><a href="http://acm.zju.edu.cn/contest-materials/qd2018/qd2018_problems.pdf" target="_blank" rel="noopener">试题</a> | <a href="http://acm.upc.edu.cn/rank/" target="_blank" rel="noopener">终榜</a></center><p><br></p><p><img src="/2018/11/06/2018_icpc_qingdao_regional/IMG_1515.JPG" alt=""></p><p><br></p><h1 id="三题残酷打铁"><a href="#三题残酷打铁" class="headerlink" title="三题残酷打铁"></a><center>三题残酷打铁</center></h1><h2 id="Problem-C-Flippy-Sequence"><a href="#Problem-C-Flippy-Sequence" class="headerlink" title="Problem C. Flippy Sequence"></a>Problem C. Flippy Sequence</h2><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem C. Flippy Sequence_0.png" alt=""></p><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem C. Flippy Sequence_1.png" alt=""></p><h2 id="Problem-J-Books"><a href="#Problem-J-Books" class="headerlink" title="Problem J. Books"></a>Problem J. Books</h2><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem J. Books.png" alt=""></p><h2 id="Problem-M-Function-and-Function"><a href="#Problem-M-Function-and-Function" class="headerlink" title="Problem M. Function and Function"></a>Problem M. Function and Function</h2><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem M. Function and Function.png" alt=""></p><p><br></p><h1 id="铁牌区的友谊"><a href="#铁牌区的友谊" class="headerlink" title="铁牌区的友谊"></a><center>铁牌区的友谊</center></h1><p><img src="/2018/11/06/2018_icpc_qingdao_regional/IMG_1542.jpg" alt=""></p><center>燃烧我的判题机(BURN MY OJ) 🤝 猛吃草(VnEpCxmR)</center><p><br></p><h1 id="《打铁归来》"><a href="#《打铁归来》" class="headerlink" title=" 《打铁归来》 "></a><center> 《打铁归来》 </center></h1><p>由著名波普艺术家赵砚潇拍摄的大电影《打铁归来》将在近日登陆 <a href="https://www.youtube.com/channel/UCJzVbUq9UE_OjHpWymygPSg?view_as=subscriber/" target="_blank" rel="noopener">YouTube</a>，敬请期待。</p><p><br><br><br></p><p><center><font size="20">“输入理想程序，输出快乐人生。”</font></center><br><br></p><p><center><font size="20">谢谢大家！</font></center><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest&quot;&gt;&lt;a href=&quot;#The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="ACM" scheme="https://blog.pazyx.xyz/tags/ACM/"/>
    
      <category term="纪念" scheme="https://blog.pazyx.xyz/tags/%E7%BA%AA%E5%BF%B5/"/>
    
      <category term="ICPC" scheme="https://blog.pazyx.xyz/tags/ICPC/"/>
    
      <category term="青岛" scheme="https://blog.pazyx.xyz/tags/%E9%9D%92%E5%B2%9B/"/>
    
  </entry>
  
  <entry>
    <title>「朝花夕拾」0x03 二零一八年十月二十九日凌晨人民喝不到冰镇可乐</title>
    <link href="https://blog.pazyx.xyz/2018/10/29/diary_3/"/>
    <id>https://blog.pazyx.xyz/2018/10/29/diary_3/</id>
    <published>2018-10-28T16:13:47.000Z</published>
    <updated>2019-12-06T17:15:29.672Z</updated>
    
    <content type="html"><![CDATA[<p>二零一八年十月我因为半夜出去买可乐已经刷了四次晚归，然而五次就要记过…</p><p>我们没有办法，只能痛苦的入睡…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二零一八年十月我因为半夜出去买可乐已经刷了四次晚归，然而五次就要记过…&lt;/p&gt;
&lt;p&gt;我们没有办法，只能痛苦的入睡…&lt;/p&gt;

      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="记" scheme="https://blog.pazyx.xyz/tags/%E8%AE%B0/"/>
    
      <category term="可乐" scheme="https://blog.pazyx.xyz/tags/%E5%8F%AF%E4%B9%90/"/>
    
      <category term="自由" scheme="https://blog.pazyx.xyz/tags/%E8%87%AA%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营解题总结（第二周）//ToDo</title>
    <link href="https://blog.pazyx.xyz/2018/08/12/algor_club_code_2/"/>
    <id>https://blog.pazyx.xyz/2018/08/12/algor_club_code_2/</id>
    <published>2018-08-11T16:30:49.000Z</published>
    <updated>2018-12-14T04:46:24.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意-amp-代码实现"><a href="#题目大意-amp-代码实现" class="headerlink" title="题目大意 &amp; 代码实现"></a>题目大意 &amp; 代码实现</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>给出n个整数，将它们从小到大排序后输出。</p><ul><li>对于前30%的数据，n ≤ 100，给出的n个整数的绝对值不超过10；</li><li>对于前60%的数据，n ≤ 5000，给出的n个整数的绝对值不超过10^9；</li><li>对于另20%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^5；</li><li>对于100%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^9。</li></ul><p>时间：2 sec<br>空间：256 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        a.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    <span class="comment">//a = getAnswer(n, a);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>有n个正整数排成一排，你要将这些数分成m份（同一份中的数字都是连续的，不能隔开），同时数字之和最大的那一份的数字之和尽量小。</p><ul><li>对于50%的数据，n ≤ 100，给出的n个正整数不超过10；</li><li>对于100%的数据，m ≤ n ≤ 300000，给出的n个正整数不超过1000000。</li></ul><p>时间：4 sec<br>空间：512 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> d, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &gt; d )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span>( sum &gt; d ) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            i--;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; m)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所给数组分成连续的m份，使得数字之和最大的那一份的数字之和最小</span></span><br><span class="line"><span class="comment">// n：数组大小</span></span><br><span class="line"><span class="comment">// m：题中的m</span></span><br><span class="line"><span class="comment">// a：所给数组，大小为n</span></span><br><span class="line"><span class="comment">// 返回值：最优方案中，数字之和最大的那一份的数字之和</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        r += a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r ) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid, n, m, a))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, m, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大转盘"><a href="#大转盘" class="headerlink" title="大转盘"></a>大转盘</h2><p>邓老师有一个大转盘，被平分成了 2^n 份。<br>邓老师还有一个长度为 2^n 的数组 a（下标从 0 开始），其中的每个元素都是 0 或 1。于是邓老师就可以选择大转盘上的一个位置，将 a[0] 填入其中，然后按顺时针顺序依次将 a[1],a[2],…,a[2^n-1] 填入。<br>对于大转盘上的一个指定位置，邓老师可以从它开始，取出顺时针方向的 n 个位置，并将它们按原顺序拼接起来，得到一个长度为 n 的 01 串，也就是一个 n 位二进制数。我们把这个二进制数称作从这个位置开始的幸运数。<br>显然地，大转盘上共有 2^n 个位置可以获得幸运数，而巧合的是 n 位二进制数恰好也有 2^n 个，所以邓老师希望这些所有的幸运数包含了所有的 n 位二进制数。<br>请输出一个数组 a，使其满足邓老师的要求。（如果有多解，输出任一即可）</p><p>本题包含 16 个测试点。对于第 i 个测试点（1&lt;=i&lt;=16），满足 n=i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allOne;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twoPow</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i][u])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = ((u &lt;&lt; <span class="number">1</span>) | i) &amp; allOne;</span><br><span class="line">            vis[i][u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            dfs(v);</span><br><span class="line">            ans.push_back(<span class="string">'0'</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数求解大转盘上的数，你需要把大转盘上的数按顺时针顺序返回</span></span><br><span class="line"><span class="comment">// n：对应转盘大小，意义与题目描述一致，具体见题目描述。</span></span><br><span class="line"><span class="comment">// 返回值：将大转盘上的数按顺时针顺序放到一个string中并返回</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    allOne = twoPow(n - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">        vis[i].resize(twoPow(n - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getAnswer(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="象棋"><a href="#象棋" class="headerlink" title="象棋"></a>象棋</h2><p>你有足够多的象棋“车”，在一个n×n的棋盘上你能放多少个“车”呢？注意，所给棋盘上有些位置不能放任何东西。同时，某一行（列）最多只能存在一个“车”。</p><ul><li>对于30%的数据，n ≤ 5；</li><li>对于60%的数据，n ≤ 20；</li><li>对于100%的数据，n ≤ 500。</li></ul><p>时间：2 sec<br>空间：256 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span> * <span class="number">2</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, ihead[N], mc[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    e[cnt].next = ihead[x];</span><br><span class="line">    e[cnt].to = y;</span><br><span class="line">    ihead[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = ihead[x]; i; i = e[i].next )&#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">            vis[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(mc[y] == <span class="number">0</span> || dfs(mc[y]))&#123;</span><br><span class="line">                <span class="comment">//3</span></span><br><span class="line">                mc[x] = y;</span><br><span class="line">                mc[y] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解棋盘上最多能放多少个“车”</span></span><br><span class="line"><span class="comment">// n：棋盘的大小为n×n的</span></span><br><span class="line"><span class="comment">// board：所给棋盘，对于某个位置上的数：若值为1表示可以放“车”；若值为0表示不能放“车”</span></span><br><span class="line"><span class="comment">// 返回值：能放“车”的最大个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)&#123;</span><br><span class="line">        ihead[i] = <span class="number">0</span>;</span><br><span class="line">        mc[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span>(board[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                add(i,j+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mc[i])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            t.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        e.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getAnswer(n, e));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h2><p>给定一个n个整数的序列以及一个非负整数d，请你输出这个序列中有多少个连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d。</p><ul><li>对于60%的数据，n ≤ 5000；</li><li>对于100%的数据，n ≤ 300000。</li><li>保证所有整数的绝对值不超过10^9，d不超过2×10^9。</li></ul><p>时间：10 sec<br>空间：512 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n,d,max_value[N],min_value[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//中点</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = solve(l,mid)+solve(mid+<span class="number">1</span>,r);<span class="comment">//分治求出左右两半的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">        min_value[i] = (i == mid + <span class="number">1</span>) ? a[i] : min(min_value[i - <span class="number">1</span>], a[i]);</span><br><span class="line">        max_value[i] = (i == mid + <span class="number">1</span>) ? a[i] : max(max_value[i - <span class="number">1</span>], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">0</span>, mx = <span class="number">0</span>, pos = r;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid; i &gt;= l &amp;&amp; pos &gt; mid; i--)&#123;</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        mn = (i==mid)?a[i]:min(mn,a[i]);</span><br><span class="line">        mx = (i==mid)?a[i]:max(mx,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(; pos &gt; mid &amp;&amp; max(mx,max_value[pos]) - min(mn,min_value[pos]) &gt; d; pos--);</span><br><span class="line">        ans += pos - mid;<span class="comment">//更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出有多少个a数组中的连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d</span></span><br><span class="line"><span class="comment">// n：a数组的长度</span></span><br><span class="line"><span class="comment">// d：所给d</span></span><br><span class="line"><span class="comment">// a：数组a，长度为n</span></span><br><span class="line"><span class="comment">// 返回值：满足条件的连续子序列的个数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    ::n = n;</span><br><span class="line">    ::d = d;</span><br><span class="line">    ::a = a;</span><br><span class="line">    <span class="keyword">return</span> solve(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, d, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小交换"><a href="#最小交换" class="headerlink" title="最小交换"></a>最小交换</h2><p>给定一个 1 到 n 的排列（即一个序列，其中 [1,n] 之间的正整数每个都出现了恰好 1 次）。<br>你可以花 1 元钱交换两个相邻的数。<br>现在，你希望把它们升序排序。求你完成这个目标最少需要花费多少元钱。</p><ul><li>对于 20% 的数据，保证 n&lt;=7。</li><li>对于 60% 的数据，保证 n&lt;=1,000。</li><li>对于 100% 的数据，保证 n&lt;=200,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq, seqTemp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(l, mid);</span><br><span class="line">    mergeSort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> p = l, q = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q &gt; r || p &lt;= mid &amp;&amp; seq[p] &lt;= seq[q])</span><br><span class="line">            seqTemp[i] = seq[p++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            seqTemp[i] = seq[q++];</span><br><span class="line">            cnt += (mid - p + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        seq[i] = seqTemp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的功能是计算答案（即最少花费的金钱）</span></span><br><span class="line"><span class="comment">// n：表示序列长度</span></span><br><span class="line"><span class="comment">// a：存储整个序列 a</span></span><br><span class="line"><span class="comment">// 返回值：最少花费的金钱（需要注意，返回值的类型为 64 位有符号整数）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    seq = a;</span><br><span class="line">    seqTemp.resize(n);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    mergeSort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = getAnswer(n, a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="楼尔邦德"><a href="#楼尔邦德" class="headerlink" title="楼尔邦德"></a>楼尔邦德</h2><p>给定包含 n 个数的序列 A。<br>再给出 Q 个询问，每个询问包含一个数 x，询问的是序列 A 中不小于 x 的最小整数是多少（无解输出-1）。</p><ul><li>对于 50% 的数据，保证 n&lt;=2000。</li><li>对于 100% 的数据，保证 n&lt;=300,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数传入数组 a 及所有询问，你需要求解所有询问并一并返回</span></span><br><span class="line"><span class="comment">// n：序列 a 的长度</span></span><br><span class="line"><span class="comment">// a：存储了序列 a</span></span><br><span class="line"><span class="comment">// Q：询问个数</span></span><br><span class="line"><span class="comment">// query：依次存储了所有询问的参数 x</span></span><br><span class="line"><span class="comment">// 返回值：一个 vector&lt;int&gt;，依次存放各询问的答案</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> Q, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query) &#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.clear();</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = query[i];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>,r = n,mid;</span><br><span class="line">        <span class="keyword">while</span>(l+<span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &lt; key)</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = r;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= n)</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans.push_back(a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q, tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, query;</span><br><span class="line">    a.clear();</span><br><span class="line">    query.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        query.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, a, Q, query);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>给定一张 n 个点的无向带权图，节点的编号从 1 至 n，求从 S 到 T 的最短路径长度。</p><p>本题共设置 12 个测试点。</p><ul><li>对于前 10 个测试点，保证 n&lt;=2500，m&lt;=6200，对于每条边有 w&lt;=1000。这部分数据有梯度。</li><li>对于所有的 12 个测试点，保证 n&lt;=100,000，m&lt;=250,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;set&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, weight;</span><br><span class="line">    edge(<span class="keyword">int</span> ne,<span class="keyword">int</span> we):next(ne),weight(we)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;G[MAX_N];   <span class="comment">//邻接表表示的图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"><span class="comment">//int path[MAX_N];</span></span><br><span class="line"><span class="keyword">bool</span> collected[MAX_N];  <span class="comment">//标记每个顶点是否被收录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(collected,<span class="number">0</span>,<span class="keyword">sizeof</span>(collected));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;P, less&lt;P&gt; &gt; min_heap;  </span><br><span class="line">    <span class="comment">//用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, start));</span><br><span class="line">    collected[start] = <span class="literal">true</span>;   </span><br><span class="line">    <span class="keyword">while</span>(min_heap.size())&#123;    </span><br><span class="line">    <span class="comment">//如果堆为空，说明所有点都已被收录，结束该算法</span></span><br><span class="line">        <span class="keyword">auto</span> iter = min_heap.begin();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        collected[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!collected[e.next] </span><br><span class="line">            &amp;&amp; dist[e.next] &gt; dist[v] + e.weight)</span><br><span class="line">            &#123;</span><br><span class="line">                min_heap.erase(make_pair(dist[e.next], e.next));    </span><br><span class="line">                dist[e.next] = dist[v] + e.weight;</span><br><span class="line">                <span class="comment">//path[e.next] = v;</span></span><br><span class="line">                min_heap.insert(make_pair(dist[e.next], e.next));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用于计算答案（最短路）</span></span><br><span class="line"><span class="comment">// n：节点数目</span></span><br><span class="line"><span class="comment">// m：双向边数目</span></span><br><span class="line"><span class="comment">// U,V,W：分别存放各边的两端点、边权</span></span><br><span class="line"><span class="comment">// s,t：分别表示起点、重点</span></span><br><span class="line"><span class="comment">// 返回值：答案（即从 s 到 t 的最短路径长度）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; W, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        G[U[i]].push_back(edge(V[i],W[i]));</span><br><span class="line">        G[V[i]].push_back(edge(U[i],W[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(s);</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, V, W;</span><br><span class="line">    U.clear();</span><br><span class="line">    V.clear();</span><br><span class="line">    W.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        U.push_back(u);</span><br><span class="line">        V.push_back(v);</span><br><span class="line">        W.push_back(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, shortestPath(n, m, U, V, W, s, t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>涉及题目：</p><ul><li>分组</li><li>序列计数</li><li>楼尔邦德</li></ul><h2 id="Dijkstra-的局限"><a href="#Dijkstra-的局限" class="headerlink" title="Dijkstra 的局限"></a>Dijkstra 的局限</h2><p>之前只认为，Dijkstra 算法不可以处理带有负值圈的图。实际上 Dijkstra 在处理有复值边权的图时很可能不正确。</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 w = 1</span><br><span class="line">1 -&gt; 3 w = 2</span><br><span class="line">2 -&gt; 4 w = 1</span><br><span class="line">3 -&gt; 2 w = -2</span><br></pre></td></tr></table></figure></p><p>正确答案为 1，Dijkstra 给出的答案为 2 。</p><h2 id="一些算法"><a href="#一些算法" class="headerlink" title="一些算法"></a>一些算法</h2><ul><li>二分图最大匹配</li><li>求欧拉回路</li><li>归并排序求逆序对</li></ul><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>手动实现</p><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>快速排序</li></ul><h2 id="最小交换-1"><a href="#最小交换-1" class="headerlink" title="最小交换"></a>最小交换</h2><p>使用树状数组优化求逆序对的暴力算法，达到与归并排序相同的复杂度。</p><h2 id="总结欧拉回路算法"><a href="#总结欧拉回路算法" class="headerlink" title="总结欧拉回路算法"></a>总结欧拉回路算法</h2><ul><li><a href="https://www.jisuanke.com/minicourse/740/37823" target="_blank" rel="noopener">欧拉回路 计蒜客</a></li></ul><h2 id="总结匈牙利算法"><a href="#总结匈牙利算法" class="headerlink" title="总结匈牙利算法"></a>总结匈牙利算法</h2><ul><li><a href="https://www.jisuanke.com/minicourse/741/37831" target="_blank" rel="noopener">匈牙利算法 计蒜客</a></li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>学习使用 <code>std::lower_bound</code> ，注意边界。</p><h2 id="实现-Bellman-Ford-算法"><a href="#实现-Bellman-Ford-算法" class="headerlink" title="实现 Bellman-Ford 算法"></a>实现 Bellman-Ford 算法</h2><p>伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化 mind 数组</span><br><span class="line">mind[0] : 0</span><br><span class="line">for round 1 to n</span><br><span class="line">枚举所有边 (u,v,len)</span><br><span class="line">mind[v] : min(min[v],mind[u]+len)</span><br><span class="line">if 本轮中没有点被更新</span><br><span class="line">break;</span><br><span class="line">if round == n+1</span><br><span class="line">无解</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意-amp-代码实现&quot;&gt;&lt;a href=&quot;#题目大意-amp-代码实现&quot; class=&quot;headerlink&quot; title=&quot;题目大意 &amp;amp; 代码实现&quot;&gt;&lt;/a&gt;题目大意 &amp;amp; 代码实现&lt;/h1&gt;&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot;
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Dijkstra" scheme="https://blog.pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="Bellman-Ford" scheme="https://blog.pazyx.xyz/tags/Bellman-Ford/"/>
    
      <category term="ToDo" scheme="https://blog.pazyx.xyz/tags/ToDo/"/>
    
      <category term="二分" scheme="https://blog.pazyx.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="匈牙利算法" scheme="https://blog.pazyx.xyz/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://blog.pazyx.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://blog.pazyx.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="欧拉回路" scheme="https://blog.pazyx.xyz/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营解题总结（第一周）//ToDo</title>
    <link href="https://blog.pazyx.xyz/2018/08/04/algor_club_code_1/"/>
    <id>https://blog.pazyx.xyz/2018/08/04/algor_club_code_1/</id>
    <published>2018-08-03T18:30:49.000Z</published>
    <updated>2018-08-03T18:31:58.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意-amp-代码实现"><a href="#题目大意-amp-代码实现" class="headerlink" title="题目大意 &amp; 代码实现"></a>题目大意 &amp; 代码实现</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>简单的栈实现，我使用数组实现，可以使用 <code>vector</code> 代替数组。日常可以直接使用 STL 库中的 <code>stack</code> 类，但其无法进行 “call by rank” 的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> mtop = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">string</span> mstack[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入栈顶</span></span><br><span class="line"><span class="comment">// name：被压入的人的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    mtop++;</span><br><span class="line">    mstack[mtop] = name;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出栈顶</span></span><br><span class="line"><span class="comment">// 返回值：被弹出人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mtop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        mtop--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mstack[mtop+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问栈中某个位置上的人的姓名（栈底位置为1，向栈顶方向的位置依次递增）</span></span><br><span class="line"><span class="comment">// pos：询问的位置</span></span><br><span class="line"><span class="comment">// 返回值：pos位置上人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">return</span> mstack[pos<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (; n--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">            push(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pop().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(pos).c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>简单的队列实现，这个队列问题很大，就是元素出队后的空间无法回收，造成无法持续使用，占用空间大的问题。题目要求较低。应该使用链表或循环数组实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> mque[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾入队</span></span><br><span class="line"><span class="comment">// name：入队人的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    mque[h] = name;</span><br><span class="line">    h++;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首出队</span></span><br><span class="line"><span class="comment">// 返回值：队首的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q++;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">return</span> mque[q<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问队列中某个位置上的人的姓名（队首位置为1，往后位置依次递增）</span></span><br><span class="line"><span class="comment">// pos：询问的位置</span></span><br><span class="line"><span class="comment">// 返回值：pos位置上人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mque[q+pos<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (; n--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">            enqueue(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dequeue().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(pos).c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>实现并维护二叉搜索树，并输出其前序和后序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node* l;</span><br><span class="line">    node* r;</span><br><span class="line">    node():val(<span class="number">0</span>),l(<span class="literal">nullptr</span>),r(<span class="literal">nullptr</span>)&#123;&#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v, node*&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="keyword">new</span> node();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        x-&gt;l = <span class="literal">nullptr</span>;</span><br><span class="line">        x-&gt;r = <span class="literal">nullptr</span>;</span><br><span class="line">        x-&gt;val = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= x-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(v,x-&gt;l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; x-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(v,x-&gt;r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlr</span><span class="params">( node* x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        ans.push_back(x-&gt;val);</span><br><span class="line">        dlr(x-&gt;l,ans);</span><br><span class="line">        dlr(x-&gt;r,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrd</span><span class="params">( node* x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        lrd(x-&gt;l,ans);</span><br><span class="line">        lrd(x-&gt;r,ans);</span><br><span class="line">        ans.push_back(x-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(sequence.size()); ++i)</span><br><span class="line">        insert(sequence[i],root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    dlr(root,ans);</span><br><span class="line">    lrd(root,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        sequence.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[n + i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字盒子"><a href="#数字盒子" class="headerlink" title="数字盒子"></a>数字盒子</h2><p>Hash Map 实现，由于我的问题，没有去实现，使用了STL库中的 <code>map</code> 类，周末会补充 Hash Map 的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行操作时会调用这个函数</span></span><br><span class="line"><span class="comment">// op：对应该次操作的 op（具体请见题目描述）</span></span><br><span class="line"><span class="comment">// x：对应该次操作的 x（具体请见题目描述）</span></span><br><span class="line"><span class="comment">// 返回值：如果输出为"Succeeded"，则这个函数返回 1，否则返回 0</span></span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">bool</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> op, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[x])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[x])&#123;</span><br><span class="line">            Map[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Map[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q, op;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="built_in">puts</span>(check(op, x) ? <span class="string">"Succeeded"</span> : <span class="string">"Failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重编码"><a href="#重编码" class="headerlink" title="重编码"></a>重编码</h2><p>哈夫曼编码问题，合并森林。<br>与 <a href="/2018/01/24/poj-3253-fence-repair/">POJ 3253 Fence Repair</a> 相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是求解整个问题的函数</span></span><br><span class="line"><span class="comment">// w：题目描述中的 w（所有）</span></span><br><span class="line"><span class="comment">// n：题目描述中的 n</span></span><br><span class="line"><span class="comment">// 返回值：答案</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;ll&gt; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;    <span class="comment">//把n块木板的长度入队</span></span><br><span class="line">        q.push(w[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>)&#123;            <span class="comment">//如果还没有合成一块木板就继续合并</span></span><br><span class="line">        ll minOne,minTwo;</span><br><span class="line">        minOne = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        minTwo = q.top();</span><br><span class="line">        q.pop();                        <span class="comment">//从队头拿出两个最短的木板</span></span><br><span class="line">        sum += (minOne + minTwo);       <span class="comment">//加上这次合并的开销</span></span><br><span class="line">        q.push(minOne+minTwo);   <span class="comment">//将合并后的木板入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">        w.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, w));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><p>排序并输出逆序对数目，使用冒泡排序在每次交换记数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是进行排序的函数</span></span><br><span class="line"><span class="comment">// n：题目描述中的 n</span></span><br><span class="line"><span class="comment">// A：各同学的算法训练营成绩</span></span><br><span class="line"><span class="comment">// DS：各同学的数据结构训练营成绩</span></span><br><span class="line"><span class="comment">// 返回值：将要输出的数字依次加入到返回值的数组中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> algorithm,dataStruct;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    student()&#123;&#125;</span><br><span class="line">    student(<span class="keyword">int</span> i,<span class="keyword">int</span> a,<span class="keyword">int</span> d):id(i),algorithm(a),dataStruct(d),score(a+d)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (student a,student b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score &lt; b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.algorithm &lt; b.algorithm)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt; &amp;a,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = size<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;          <span class="comment">//记录在一趟排序中是否有交换</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                student temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//swap(a[j],a[j+1]);</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DS) &#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        temp.push_back(student(i+<span class="number">1</span>,A[i],DS[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = BubbleSort(temp,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans.push_back(temp[i].id);</span><br><span class="line">        ans.push_back(temp[i].score);</span><br><span class="line">        ans.push_back(temp[i].algorithm);</span><br><span class="line">        ans.push_back(temp[i].dataStruct);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(cnt);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, DS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, ds;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;ds);</span><br><span class="line">        A.push_back(a);</span><br><span class="line">        DS.push_back(ds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, A, DS);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, ans[cnt], ans[cnt + <span class="number">1</span>], ans[cnt + <span class="number">2</span>], ans[cnt + <span class="number">3</span>]);</span><br><span class="line">        cnt += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[cnt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><p>来源：<em>NOI 2015 day1 T1 程序自动分析</em><br>简单并查集题目，主意一下检查应该留到最后检查即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定n个变量以及m个约束，判定是否能找出一种赋值方案满足这m个约束条件</span></span><br><span class="line"><span class="comment">// n：如题意</span></span><br><span class="line"><span class="comment">// m：如题意</span></span><br><span class="line"><span class="comment">// A：大小为m的数组，表示m条约束中的a</span></span><br><span class="line"><span class="comment">// B：大小为m的数组，表示m条约束中的b</span></span><br><span class="line"><span class="comment">// E：大小为m的数组，表示m条约束中的e</span></span><br><span class="line"><span class="comment">// 返回值：若能找出一种方案，返回"Yes"；否则返回"No"（不包括引号）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">500004</span>; i++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x)&#123;</span><br><span class="line">    <span class="comment">//x 节点就是根节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[x] = get(pre[x]);</span><br><span class="line">    <span class="comment">//返回父节点的根节点，并另当前节点父节点直接为根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = get(x);</span><br><span class="line">    y = get(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;<span class="comment">// 不住同一个集合</span></span><br><span class="line">        pre[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zero;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i])&#123;</span><br><span class="line">            merge(A[i],B[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            zero.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zero.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(get(A[zero[i]]) == get(B[zero[i]]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"No"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); T--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B, E;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;e);</span><br><span class="line">            A.push_back(a);</span><br><span class="line">            B.push_back(b);</span><br><span class="line">            E.push_back(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, getAnswer(n, m, A, B, E).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="道路升级"><a href="#道路升级" class="headerlink" title="道路升级"></a>道路升级</h2><p>最大生成树问题，与最小生成树一样。<br>使用 Kruskal 算法解决，需要简单实现一下并查集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">200050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">400050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;a)</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> w &gt; a.w; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAX_N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        e[i].u = U[i];</span><br><span class="line">        e[i].v = V[i];</span><br><span class="line">        e[i].w = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+m);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(e[i].u), y = get(e[i].v);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            re.push_back(e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(re.begin(), re.end());</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        U.push_back(u);</span><br><span class="line">        V.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, m, U, V);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(ans.size()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(ans.size()); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="输入输出挂"><a href="#输入输出挂" class="headerlink" title="输入输出挂"></a>输入输出挂</h2><p>输入输出挂是真的快！</p><p>简单的数字输入输出挂，完整的见 -&gt; <a href="https://blog.csdn.net/f_zyj/article/details/51473493" target="_blank" rel="noopener">这里</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span> </span>&#123;    <span class="comment">//输入外挂</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>((ch = getchar()) == <span class="string">'-'</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) res = ch - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        res = res * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;    <span class="comment">//输出外挂</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">'-'</span>); a = -a; &#125;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">10</span>) Out(a / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入输出分离"><a href="#输入输出分离" class="headerlink" title="输入输出分离"></a>输入输出分离</h2><p>助教给的解题模板真舒服，可以不用考虑输出问题，专心实现算法～～～<br>代码可读性也提高不少，但竞赛中打的时间也许会增加一些，复杂度也会增加一些。</p><h2 id="哈夫曼编码-amp-POJ-3253"><a href="#哈夫曼编码-amp-POJ-3253" class="headerlink" title="哈夫曼编码 &amp; POJ 3253"></a>哈夫曼编码 &amp; POJ 3253</h2><p>哈夫曼编码就是贪心～<br>在《挑战程序设计竞赛(第2版) 》中讲解的 POJ 3253 现在一看真是醍醐灌顶～～～</p><h2 id="学到一些算法实现"><a href="#学到一些算法实现" class="headerlink" title="学到一些算法实现"></a>学到一些算法实现</h2><ul><li>二叉树</li><li>Kruskal 算法</li><li>哈夫曼编码的 \(O(n)\) 实现</li></ul><h2 id="题目中数据范围分析技巧"><a href="#题目中数据范围分析技巧" class="headerlink" title="题目中数据范围分析技巧"></a>题目中数据范围分析技巧</h2><p>计算机每秒运算 \(10^8\)</p><ul><li>\(n = 10^6\) -&gt; \(O(n)\)</li><li>\(n = 5  \times 10^5\) -&gt; \(O(n log n)\)</li><li>\(n = 10^4\) -&gt; \(O(n^2)\)</li></ul><hr><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><h2 id="Hash-Map-的实现"><a href="#Hash-Map-的实现" class="headerlink" title="Hash Map 的实现"></a>Hash Map 的实现</h2><p>…</p><h2 id="哈夫曼编码的-O-n-实现"><a href="#哈夫曼编码的-O-n-实现" class="headerlink" title="哈夫曼编码的 \(O(n)\) 实现"></a>哈夫曼编码的 \(O(n)\) 实现</h2><p>使用栈和队列优化</p><h2 id="成绩排序-优化"><a href="#成绩排序-优化" class="headerlink" title="成绩排序 优化"></a>成绩排序 优化</h2><p>\(O(n^2)\) -&gt; \(O(n log n)\)</p><p>排序 -&gt; 快排排序、归并排序<br>求逆序对 -&gt; 归并排序、树状数组辅助统计</p><h2 id="重编码-gt-【NOI2015】荷马史诗"><a href="#重编码-gt-【NOI2015】荷马史诗" class="headerlink" title="重编码 -&gt;【NOI2015】荷马史诗"></a>重编码 -&gt;【NOI2015】荷马史诗</h2><p>不同进制下的哈夫曼编码。<br><a href="http://uoj.ac/problem/130" target="_blank" rel="noopener">【NOI2015】荷马史诗</a></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/sdfgdbvc/article/details/51490791" target="_blank" rel="noopener">输入输出外挂</a></li><li><a href="https://blog.csdn.net/f_zyj/article/details/51473493" target="_blank" rel="noopener">输入输出外挂总结</a></li><li><a href="https://blog.csdn.net/yang_teng_/article/details/53493125" target="_blank" rel="noopener">二叉树的C++简单实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意-amp-代码实现&quot;&gt;&lt;a href=&quot;#题目大意-amp-代码实现&quot; class=&quot;headerlink&quot; title=&quot;题目大意 &amp;amp; 代码实现&quot;&gt;&lt;/a&gt;题目大意 &amp;amp; 代码实现&lt;/h1&gt;&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; c
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="队列" scheme="https://blog.pazyx.xyz/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="并查集" scheme="https://blog.pazyx.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="栈" scheme="https://blog.pazyx.xyz/tags/%E6%A0%88/"/>
    
      <category term="二叉树" scheme="https://blog.pazyx.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="哈夫曼编码" scheme="https://blog.pazyx.xyz/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
      <category term="Kruskal" scheme="https://blog.pazyx.xyz/tags/Kruskal/"/>
    
      <category term="Hash Map" scheme="https://blog.pazyx.xyz/tags/Hash-Map/"/>
    
      <category term="输入输出挂" scheme="https://blog.pazyx.xyz/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%82/"/>
    
      <category term="ToDo" scheme="https://blog.pazyx.xyz/tags/ToDo/"/>
    
  </entry>
  
  <entry>
    <title>求质数表3——高级筛法</title>
    <link href="https://blog.pazyx.xyz/2018/07/26/isprimes-3/"/>
    <id>https://blog.pazyx.xyz/2018/07/26/isprimes-3/</id>
    <published>2018-07-26T11:36:26.000Z</published>
    <updated>2018-07-26T11:37:44.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增量式筛法"><a href="#增量式筛法" class="headerlink" title="增量式筛法"></a>增量式筛法</h1><p>之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去，如试除法就是增量式运行的。 增量式算法可以在简易欧拉筛进行改进的。<br><img src="/2018/07/26/isprimes-3/1.jpg" alt=""><br>简易欧拉筛限制它不能增量式运行的问题是在于它的空间。比如增量式运行筛选到 11 时你需要划掉 121 ，这样你就需要维持 N^2 的空间，这样就很成问题，想象如果 N 到1亿时，那空间将是不可接受的。<br><img src="/2018/07/26/isprimes-3/2.jpg" alt=""><br>我们将不再枚举p和f，而是依次检查每个数，检查到一个数时划去下一个数，并再下一个数处做标记。比如我们检查到 10 ，我们通过某种方式计算出它的下一个要被划掉的数为 15 ，我们划掉 15 并在 15 处做标记，保证检查到 15 时我们可以轻松的算出 25 。由 <a href="https://en.wikipedia.org/wiki/Bertrand%27s_postulate" target="_blank" rel="noopener">Bertrand’s postulate</a> 这个数学结论得出相邻两个质数相差不会超过两倍，所以我们只需将数组维持在当前检查的数的两倍即可。这样空间复杂度就将为了 O(N) 。 这个标记需要干什么，它需要帮助我们在拿到一个数时迅速找出它的p和f。我们用一个数组保存当前被检查的数的最小质因子在质数表的位置即可。这样比如我们在拿到 15 时，我们找到它的最小质因子p为 3 ，15/3 算出 f 为 5，我们就可以用 f 乘下一个质数去找到 25 划掉它并继续传递标记了。标记从每个偶数处（因为第一个素数为 2 ）产生的，到列末尾消失（p 最大增长到 f 的最小质因子）。 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/DtN2WPpppf/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/DtN2WPpppf/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bengalloun</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        flag[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//假设它为质数</span></span><br><span class="line">        flag[i * <span class="number">2</span>] = <span class="literal">false</span>;    <span class="comment">//偶数一定为合数</span></span><br><span class="line">        lpfindex[i * <span class="number">2</span>] = <span class="number">0</span>;    <span class="comment">//建立列首标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">            primes[nPrimes++] = i;  <span class="comment">//如果还没被筛掉加入质数表</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;      <span class="comment">//如果是合数</span></span><br><span class="line">            <span class="keyword">int</span> u = lpfindex[i];</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];  </span><br><span class="line">            <span class="keyword">int</span> f = i / p;      <span class="comment">//计算p和f</span></span><br><span class="line">            <span class="keyword">if</span>(f % p != <span class="number">0</span>)&#123;     <span class="comment">//如果没有到列尾就传递标记</span></span><br><span class="line">                <span class="keyword">int</span> j = primes[u + <span class="number">1</span>] * f;</span><br><span class="line">                flag[j] = <span class="literal">false</span>;</span><br><span class="line">                lpfindex[j] = u + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>与思想与简易欧拉筛相同，依然为O(N)。因为要为增量式运行做准备实际要比简易欧拉筛多花一倍的时间。 </p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>flag和lpfindex数组都为O(N)的复杂度。总体空间复杂度为O(N)。</p><hr><h1 id="分段式筛法"><a href="#分段式筛法" class="headerlink" title="分段式筛法"></a>分段式筛法</h1><p>对于现代计算机运算速度越来越快，时间复杂度可能问题不大，但空间复杂度是个问题。分段式筛法就是要解决这个问题。<br>分段式筛法是在埃式筛法的基础上改进的，</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/HzTG6HrbV2/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/HzTG6HrbV2/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segmented_eratosthenes</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sqrtN = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="keyword">int</span> n = eratosthenes(sqrtN);</span><br><span class="line">    <span class="keyword">int</span> nPrimes = n;</span><br><span class="line"><span class="comment">// 使用埃式筛法求出前 √N 内的质数。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = sqrtN;<span class="comment">// 分段求，L 为每段长度，取 √N</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> start = sqrtN + <span class="number">1</span>; start &lt;= N; start += L)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start + L &gt; N) L = N - start + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">true</span>, L * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];</span><br><span class="line">            <span class="keyword">if</span>(p * p &gt;= start + L) <span class="keyword">break</span>; <span class="comment">// 枚举本段上限以内的质数</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = (p - start % p) % p; i &lt; L; i += p)&#123;</span><br><span class="line">                flag[i] = <span class="literal">false</span>;<span class="comment">// 划掉本段中能被 p 整除的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]) primes[nPrimes++] = start + i; </span><br><span class="line">            <span class="comment">// 找到本段中没有被划掉的数并将其收集到质数表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="L-的取法"><a href="#L-的取法" class="headerlink" title="L 的取法"></a>L 的取法</h2><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p>\(\sqrt{N}\) 以内质数表占用了 \(O(\sqrt{N})\) 的空间。<br>flag 数组占用 \(O(L)\) 的空间。<br>若 \(L &gt; \sqrt{N}\) 空间复杂度将提高。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>若 \(L &lt; \sqrt{N}\)，当 p 接近 \(\sqrt{N}\) 时，删除 p 的倍数就容易“扑空”。</p><p>所以 \(L = \sqrt{N}\) 时刚好。</p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>本质上是埃式筛法，所以时间复杂度为 \(O(NloglogN)\)。<br>内存占用小，避免了缓存不命中，实际上比埃式筛法要快。</p><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>\(O(\sqrt{N})\)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;增量式筛法&quot;&gt;&lt;a href=&quot;#增量式筛法&quot; class=&quot;headerlink&quot; title=&quot;增量式筛法&quot;&gt;&lt;/a&gt;增量式筛法&lt;/h1&gt;&lt;p&gt;之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去
      
    
    </summary>
    
      <category term="算法" scheme="https://blog.pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="质数" scheme="https://blog.pazyx.xyz/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="求质数表" scheme="https://blog.pazyx.xyz/tags/%E6%B1%82%E8%B4%A8%E6%95%B0%E8%A1%A8/"/>
    
      <category term="优化" scheme="https://blog.pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="增量式筛法" scheme="https://blog.pazyx.xyz/tags/%E5%A2%9E%E9%87%8F%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
      <category term="分段式筛法" scheme="https://blog.pazyx.xyz/tags/%E5%88%86%E6%AE%B5%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「朝花夕拾」0x02 幻觉</title>
    <link href="https://blog.pazyx.xyz/2018/07/24/diary_2/"/>
    <id>https://blog.pazyx.xyz/2018/07/24/diary_2/</id>
    <published>2018-07-24T08:39:47.000Z</published>
    <updated>2019-12-06T17:15:20.136Z</updated>
    
    <content type="html"><![CDATA[<p>最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～</p><p>其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿了钱，我觉得这对我是一种侮辱，我下学期必将拿一次一等奖学金，之后随意～</p><p>我要学英语了，我觉得这对我很重要，如果英语搞定那后面的事情真是无法想象～ 事实上我高三就这么想了，结果高考英语考了 44 分，很醉。。。</p><p>高中啊，我不学英语是有原因的，因为我觉得其他的还能提高，而且更为高效～我干掉了最难的物理，之后一路还算顺风顺水，没吃什么苦也上了学。遗憾的是现在世道不一样了，我急需英语，我需要看英文的技术书籍，我需要看ACM题，但这些不是最重要的，最重要的是我现在学英语如果成了，我将无所不能～没有什么比这个重要的了，如果成了我相信大学后面几年一定顺风顺水。。。</p><p>我现在有很大的幻觉，我感觉我只需要半年，我看了一些知乎上的经验通常时间跨度都挺长的，那些都是笨蛋我只需要半年！</p><p>后面的事情还多啊，时间太少。数学建模的好东西都没搞定，特别是写论文用的排版语言，暑假还要学。ACM还要刷很多题，暑假还要看邓老师的算法课。我还计划总结一下C++的基础问题，开学当助教不能误人子弟啊。开学还有数学建模竞赛和ACM的网络赛～再参加一下蓝桥杯。大二的课程还是有些难度的，Java虽然我之前学过但还是需要写很多代码去熟练，学Java就伴随着还要看设计模式，汇编语言虽然自己也写过，但还是好难啊。。。还有那个阴差阳错选上的单片机，真是无力吐槽，还是虽然，虽然我是写过单片机的程序，但还是好难啊。。。</p><p>最后扯个淡，最近我想拍个大电影，真的～哪天我闲了就去拍，上传到YouTube上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～&lt;/p&gt;
&lt;p&gt;其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿
      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="记" scheme="https://blog.pazyx.xyz/tags/%E8%AE%B0/"/>
    
      <category term="英语" scheme="https://blog.pazyx.xyz/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="大电影" scheme="https://blog.pazyx.xyz/tags/%E5%A4%A7%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>「书摘」《深度探索 C++ 对象模型》（二）</title>
    <link href="https://blog.pazyx.xyz/2018/07/23/inside_cpp_obj_model_2/"/>
    <id>https://blog.pazyx.xyz/2018/07/23/inside_cpp_obj_model_2/</id>
    <published>2018-07-23T05:08:42.000Z</published>
    <updated>2018-12-21T12:28:50.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数语义学"><a href="#构造函数语义学" class="headerlink" title="构造函数语义学"></a>构造函数语义学</h1><p><strong>英文术语表</strong></p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>implicit</td><td>暗中的、隐式的（通常意指并非在程序源代码中出现的）</td></tr><tr><td>explicit</td><td>显式的（通常意指程序源代码中所出现的）</td></tr><tr><td>trivial</td><td>没用的</td></tr><tr><td>nontrivial</td><td>有用的</td></tr><tr><td>memberwise</td><td>对每个 member 施以……</td></tr><tr><td>bitwise</td><td>对每个 bit 施以……</td></tr><tr><td>semantics</td><td>语意</td></tr></tbody></table><p>关于 C++ ，最常听到的一个抱怨就是，编译器背着程序员做了太多事情。</p><p>关键词 <strong>explicit</strong> 之所以被导入这个语言，就是为了给程序员提供一种方法，使他们能够制止 “单一参数的 constructor“ 被当作一个 conversion 运算符。</p><p>“Schwarz Error” -&gt; <a href="/2018/06/29/cin-return/">basic_ios 如何穿上它的 bool</a></p><p>Conversion 运算符的引入应该是明智的，而其测试应该是严酷的，并且中程序一出现不寻常活动的第一个症候时，就发出疑问。</p><h2 id="Default-Constructor-的构造操作"><a href="#Default-Constructor-的构造操作" class="headerlink" title="Default Constructor 的构造操作"></a>Default Constructor 的构造操作</h2><p>程序的需要、编译器的需要。程序如果有需要，那是程序员的责任。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span> ( bar.val || bar.pnext )</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C++ Standard [ISO-C++95] Section 12.1 :<br>对于 class X，如果没用任何 user-declared constructor，那么会有一个 default constructor 被隐式的（ implicitly ）声明出来……一个被隐式声明出来的 default constructor 将是一个 trivial constructor……</p></blockquote><h3 id="“带有-Default-Constructor”-的-Member-Class-Object"><a href="#“带有-Default-Constructor”-的-Member-Class-Object" class="headerlink" title="“带有 Default Constructor” 的 Member Class Object"></a>“带有 Default Constructor” 的 Member Class Object</h3><p>如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor，那么这个 class 的 implicit default constructor 就是 “nontrivial” ，编译器需要为改 class 合成出一个 default constructor。<strong>不过这个合成操作只有中 constructor 真正需要被调用时才会发生。</strong></p><p>编译器如何避免合成出多个 default constructor ？<strong>把合成的 default constructor、copy constructor、destructor、assignment copy operator 都以 inline 的方式完成。</strong>如果函数太复杂，不适合做成 inline，就会合成出一个 explicit non-inline static 实例（4.5节有详细说明）</p><p>编译器会扩张已存在的 constructors，在其中安插一些代码，使得 user code 被执行之前，先调用必要的 default constructors。</p><p>C++ 语言要求以 “member objects 在 class 中的声明顺序” 来调用各个 constructors。</p><h3 id="“带有-Default-Constructor”-的-Base-Class"><a href="#“带有-Default-Constructor”-的-Base-Class" class="headerlink" title="“带有 Default Constructor” 的 Base Class"></a>“带有 Default Constructor” 的 Base Class</h3><p>如果一个没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。<strong>它将调用上一层 base classes 的 default constructor（根据它们的声明顺序）。对一个后继派生的 class 而言，这个合成的 constructor 和一个 “被显式提供的 default constructor” 没有什么差异。</strong></p><h3 id="“带有-Virtual-Function”-的-Class"><a href="#“带有-Virtual-Function”-的-Class" class="headerlink" title="“带有 Virtual Function” 的 Class"></a>“带有 Virtual Function” 的 Class</h3><p>当 class 声明（或继承）一个 virtual function ，需要合成 nontrivial 的 default constructor。</p><p>“带有 Virtual Function” 的 class 的 default constructor 会有两个扩张行动在编译期间发生：</p><ul><li>一个 virtual function table（在 cfront 中被称为 vtbl ）会被编译器产生出来，内放 class 的  virtual functions 地址。</li><li>在每一个 class object 中，一个额外的 pointer member（也就是 vptr ）会被编译器合成出来，内含相关之 class vtbl 的地址。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.flip() 的转变</span></span><br><span class="line">( *widget.vptr[<span class="number">1</span>] )( &amp;widget )</span><br><span class="line"><span class="comment">// *1 表示 filp() 在 virtual table 中的固定索引</span></span><br><span class="line"><span class="comment">// * &amp;widget 代表要交给“被调用的某个 flip() 函数实例”的this指针</span></span><br></pre></td></tr></table></figure><p>编译器必须为每一个 “带有 Virtual Function” 的 class 的 object 的 vptr 设定初值，放纵适当的 virual table 地址。对于这个 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情。 </p><h3 id="“带有-Virtual-Base-Class”-的-Class"><a href="#“带有-Virtual-Base-Class”-的-Class" class="headerlink" title="“带有 Virtual Base Class” 的 Class"></a>“带有 Virtual Base Class” 的 Class</h3><p>class 派生自一个继承串链，其中有一个或更多的 virtual base classes，需要合成 nontrivial 的 default constructor。</p><p>Virtual base class 的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共同点在于必须使 virtual base class 在其每一个 derived class object 中的位置，能够于执行期准备妥当。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> pubilc virual X &#123; <span class="keyword">public</span>: <span class="keyword">int</span> j; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> pubilc virual X &#123; <span class="keyword">public</span>: <span class="keyword">double</span> d; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="keyword">public</span>: <span class="keyword">int</span> k &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译时期决定（resolve）出 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo( <span class="keyword">new</span> A );</span><br><span class="line">    foo( <span class="keyword">new</span> C );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"><span class="comment">// __vbcX 表示编译器产生的指针，指向 virtual base class X。</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有 4 种情况，会造成“编译器必须为未声明 constructor 的 classes 合成一个 default constructor”。</p><ul><li>没有任何 constructor 的 class 内含一个有 default constructor 的 member object</li><li>没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class</li><li>当 class 声明（或继承）一个 virtual function</li><li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes</li></ul><p><strong>C++ Standard 把那些合成物称为 implicit nontrivial default constructors。</strong></p><p>C++ 新手两个常见误解：</p><ol><li>任何 class 如果没有定义 default constructor，就会被合成出一个来。</li><li>编译器合成出来的 default constructor 会显式设定 “class 内每一个 data member 的默认值”。</li></ol><h2 id="Copy-Constructor-的构造操作"><a href="#Copy-Constructor-的构造操作" class="headerlink" title="Copy Constructor 的构造操作"></a>Copy Constructor 的构造操作</h2><p>有三种情况，会以一个 object 的内容作为另一个 class object 的初值。<br><code>class X { ... };</code></p><ul><li><code>X xx = x</code></li><li>作为参数交给某个函数 <code>foo( xx );</code></li><li>作为函数返回值 <code>return xx;</code></li></ul><h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h3><p>Default constructors 和 copy constructors 在<strong>必要</strong>的时候<strong>才</strong>由编译器产生出来。<br>对于 copy constructors 必要的时候是指该 class 不展现 bitwise copy semantics 时。</p><p>C++ Standard 把 copy constructors 区分为 trivial 和 nontrivial 两种。只有 nontrivial 的实例被合成于程序之中。</p><h3 id="Bitwise-Copy-Semantics（位逐次拷贝）"><a href="#Bitwise-Copy-Semantics（位逐次拷贝）" class="headerlink" title="Bitwise Copy Semantics（位逐次拷贝）"></a>Bitwise Copy Semantics（位逐次拷贝）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitwise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Bitwise(<span class="keyword">int</span> a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明未展现出 bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBitwise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">string</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NonBitwise(v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于后者，编译器必须合成出一个 copy constructor，<strong>以便调用 member class string object 的 copy constructor</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">NonBitwise</span><span class="params">(<span class="keyword">const</span> NonBitwise&amp; nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.<span class="built_in">string</span>::<span class="built_in">string</span>(nb.b);</span><br><span class="line">    a = nb.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不要-Bitwise-Copy-Semantics-！"><a href="#不要-Bitwise-Copy-Semantics-！" class="headerlink" title="不要 Bitwise Copy Semantics ！"></a>不要 Bitwise Copy Semantics ！</h3><p>class 不展现出 ”bitwise copy semantics“ 的 4 种情况：</p><ul><li>当 class 内含一个 member object 而后者的 class 声明有一个 copy constructos 时（不论时被显式声明或是被合成而得）。</li><li>当 class 继承自一个 base class 而后者存在一个 copy constructor 时（不论时被显式声明或是被合成而得）。</li><li>当 class 声明了一个或多个 virtual functions 时。</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</li></ul><h3 id="重新设定-Virtual-Table-的指针"><a href="#重新设定-Virtual-Table-的指针" class="headerlink" title="重新设定 Virtual Table 的指针"></a>重新设定 Virtual Table 的指针</h3><p>当 class 声明了一个或多个 virtual functions 时，编译期间会有两个程序扩张操作：</p><ul><li>增加一个 virtual function table( vtbl )，内含每一个有作用的 virtual function 的地址。</li><li>一个指向 virtual function table 的指针（ vptr ），安插在每一个 class object 内。</li></ul><h3 id="处理-Virtual-Base-Class-Subobject"><a href="#处理-Virtual-Base-Class-Subobject" class="headerlink" title="处理 Virtual Base Class Subobject"></a>处理 Virtual Base Class Subobject</h3><p>如果一个 class 以另一个 object 作为初值，而后者有一个 virtual base class subobject，那么也会使 “bitwise copy semantics” 失效。</p><p>每一个编译器对于虚拟继承的支持承诺，都代表必须让“derived class object 中 virtual base class subobject 位置” 在执行期就准备妥当。维护“位置的完整性”是编译器的责任。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B ba;</span><br><span class="line">B bb = ba;</span><br><span class="line"><span class="comment">// 这种情况使用 bitwise 就够了</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C ca;</span><br><span class="line">B bb = ca;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器需要合成一个 copy constructor，安插一些代码以设定 virtual base class pointer/offser 的初值（或只是简单地确定它没有被抹消），对每一个 memberwise 执行必要的初始化操作，以及执行其他的内存相关工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="程序转化语意学（Program-Transformation-Semantics）"><a href="#程序转化语意学（Program-Transformation-Semantics）" class="headerlink" title="程序转化语意学（Program Transformation Semantics）"></a>程序转化语意学（Program Transformation Semantics）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"X.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个假设：</p><ul><li>每次 <code>foo()</code> 被调用，就传回 <code>xx</code> 的值。</li><li>如果 <code>class X</code> 定义了一个 copy constructor，那么当 <code>foo()</code> 被调用时，保证该 copy constructor 也会被调用。</li></ul><ul><li>第一个假设的真实性，必须视 <code>class X</code> 如何定义而定。</li><li>第二个假设的真实性，虽然也部分地必须视 <code>class X</code> 如何定义而定，但最主要的还是视你的 C++ 编译器所提供的进取性优化层级（degree of aggressive optimization）而定。</li></ul><h3 id="显式的初始化操作（Explicit-Initialization）"><a href="#显式的初始化操作（Explicit-Initialization）" class="headerlink" title="显式的初始化操作（Explicit Initialization）"></a>显式的初始化操作（Explicit Initialization）</h3><p>在严谨的 C++ 用词中，“定义” 是指 “占用内存” 的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">x1</span><span class="params">( x0 )</span></span>;</span><br><span class="line">X x2 = x0;</span><br><span class="line">X x3 = X( x0 );</span><br></pre></td></tr></table></figure><p>转化为 -&gt; </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X x1;</span><br><span class="line">X x2;</span><br><span class="line">X x3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器安插 X copy construction 的调用操作</span></span><br><span class="line">X1.X::X( x0 );</span><br><span class="line">X2.X::X( x0 );</span><br><span class="line">X3.X::X( x0 );</span><br></pre></td></tr></table></figure><h3 id="参数的初始化（Argument-Initialization）"><a href="#参数的初始化（Argument-Initialization）" class="headerlink" title="参数的初始化（Argument Initialization）"></a>参数的初始化（Argument Initialization）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( X x0 )</span></span>;</span><br><span class="line"></span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">foo( xx );</span><br></pre></td></tr></table></figure><p><strong>第一种编译器实现的转化代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line"></span><br><span class="line">__temp0.X::X( xx );</span><br><span class="line">foo( __temp0 );</span><br></pre></td></tr></table></figure></p><p>要求局部实例（local instance）x0 以 memberwise 的方式将 xx 当做初值。导入临时性 object，并调用 copy constructor 将它初始化，然后将此临时性 object 交给函数。但这里 <code>foo()</code> 函数声明将改变为 <code>void foo( X&amp; x0 )</code>。在函数执行完成后 <code>class X</code> 的 destrucor 将会被调用，对付那个临时性的 object 。</p><p><strong>第二种编译器实现</strong><br>以 “拷贝建构”（copy construct）的方式把实际参数直接建构在其应该的位置上。</p><h3 id="返回值的初始化（Return-Value-Initialization）"><a href="#返回值的初始化（Return-Value-Initialization）" class="headerlink" title="返回值的初始化（Return Value Initialization）"></a>返回值的初始化（Return Value Initialization）</h3><h4 id="cfront-中的双阶段转化"><a href="#cfront-中的双阶段转化" class="headerlink" title="cfront 中的双阶段转化"></a>cfront 中的双阶段转化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    </span><br><span class="line">    xx.X::X();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    __result.X::X(xx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>X xx = bar();</code> 的操作将被转化为 <code>X xx; bar( xx );</code>。</p><p><code>bar().memfunc();</code> 可能被转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">( bar( __temp0 ), __temp0 ).memfunc();</span><br></pre></td></tr></table></figure></p><h3 id="在使用者层面做优化（Optimization-at-the-User-Level）"><a href="#在使用者层面做优化（Optimization-at-the-User-Level）" class="headerlink" title="在使用者层面做优化（Optimization at the User Level）"></a>在使用者层面做优化（Optimization at the User Level）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bar()</code> 函数会要求 <code>xx</code> 被 “memberwise” 地拷贝到编译器所产生的 <code>__result</code> 之中。<br><em>Jonathan Shopiro</em> 提出定义另一个 constructor，可以直接计算 <code>xx</code> 的值。<br>上面的代码转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X( y,z );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器会将其转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( X &amp;__result, <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__result.X::X( y,z );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>__result</code> 被直接计算出来，而不是经由 copy constructor 拷贝而得！</p><h3 id="在编译器层面做优化（Optimization-at-the-Compiler-Level）"><a href="#在编译器层面做优化（Optimization-at-the-Compiler-Level）" class="headerlink" title="在编译器层面做优化（Optimization at the Compiler Level）"></a>在编译器层面做优化（Optimization at the Compiler Level）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __result.X::X();</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种优化，有时候被称为 Named Return Value ( NRV ) 优化。NRV 优化如今被视为标准 C++ 编译器的一个义不容辞的优化操作。</p><p>// 本书对 NRV 的优化性能测试有一些错误，这部分不做摘录。</p><p>NRV 优化的争议：</p><ul><li>优化由编译器完成，而它是否真的被完成，并不是十分清楚。</li><li>一旦函数变得比较复杂，优化也会变得比较难以实施。</li><li>程序员不能够安全地规划自己的 copy constructor 的副作用。</li></ul><p>一般而言，面对 “以一个 class object 作为另一个 class object 的初值” 的情形，语言允许编译器有大量的自由发挥空间。</p><h3 id="Copy-Constructor：要还是不要？"><a href="#Copy-Constructor：要还是不要？" class="headerlink" title="Copy Constructor：要还是不要？"></a>Copy Constructor：要还是不要？</h3><p>class 的 default copy constructor 被视为 trivial 的情况下不声明 explicit copy constructor 既快速又安全。在需要 NRV 优化时，可以考虑实现 copy constructor，可以使用 <code>memcpy()</code> 来拷贝提高效率。</p><p>不管使用 <code>memcpy()</code> 还是 <code>memset()</code>，都只有在“classes 不含任何由编译器产生的那部 members ” 时才能有效运行。</p><h2 id="成员们的初始化队伍（Member-Initialization-List）"><a href="#成员们的初始化队伍（Member-Initialization-List）" class="headerlink" title="成员们的初始化队伍（Member Initialization List）"></a>成员们的初始化队伍（Member Initialization List）</h2><p>必须使用 member initialization list 的情况</p><ul><li>当初始化一个 reference member 时；</li><li>当初始化一个 const member 时；</li><li>当调用一个 base class 的 constructor，而它拥有一组参数时；</li><li>当调用一个 member class 的 constructor，而它拥有一组参数时。</li></ul><p>编译器会一一操作 initialization list，以适当顺序中 constructor 之内安插初始化操作，并且<strong>在任何 explicit user code 之前</strong>。</p><p>在 initialization list 中使用 member function 使用是合法的，这是因为和此 object 相关的 this 指针已经被建构妥当。</p><p>如果在 initialization list 中调用 derived class member function ，其返回值被当做 base class constructor 的一个参数。那不一定是个好主意，因为 derived class member function 可能要用到的 derived class member 在 base class 的 constructor 之后才被初始化。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/autosar/archive/2011/10/09/2204181.html" target="_blank" rel="noopener">关于NRV优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数语义学&quot;&gt;&lt;a href=&quot;#构造函数语义学&quot; class=&quot;headerlink&quot; title=&quot;构造函数语义学&quot;&gt;&lt;/a&gt;构造函数语义学&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;英文术语表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;t
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="构造函数" scheme="https://blog.pazyx.xyz/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="拷贝构造函数" scheme="https://blog.pazyx.xyz/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="缺省构造函数" scheme="https://blog.pazyx.xyz/tags/%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="编译器优化" scheme="https://blog.pazyx.xyz/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="Virtual Class" scheme="https://blog.pazyx.xyz/tags/Virtual-Class/"/>
    
      <category term="Virtual Base Class" scheme="https://blog.pazyx.xyz/tags/Virtual-Base-Class/"/>
    
      <category term="NRV优化" scheme="https://blog.pazyx.xyz/tags/NRV%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>macOS 灾难</title>
    <link href="https://blog.pazyx.xyz/2018/07/21/mac_os_disaster/"/>
    <id>https://blog.pazyx.xyz/2018/07/21/mac_os_disaster/</id>
    <published>2018-07-21T10:52:18.000Z</published>
    <updated>2018-07-21T14:19:51.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="macOS-10-14-beta3"><a href="#macOS-10-14-beta3" class="headerlink" title=" macOS 10.14 beta3 "></a><center> macOS 10.14 beta3 </center></h1><h4 id="灾难性的数据丢失事故，博客数据险些全部丢失！"><a href="#灾难性的数据丢失事故，博客数据险些全部丢失！" class="headerlink" title=" 灾难性的数据丢失事故，博客数据险些全部丢失！ "></a><center> 灾难性的数据丢失事故，博客数据险些全部丢失！ </center></h4><h4 id="2018-7-21-凌晨"><a href="#2018-7-21-凌晨" class="headerlink" title=" 2018.7.21 凌晨 "></a><center> 2018.7.21 凌晨 </center></h4><p><img src="/2018/07/21/mac_os_disaster/disaster.png" alt=""></p><p>博客数据在废纸篓里找到了，历劫度人。。。<br>调整一下<strong>继续～</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;macOS-10-14-beta3&quot;&gt;&lt;a href=&quot;#macOS-10-14-beta3&quot; class=&quot;headerlink&quot; title=&quot; macOS 10.14 beta3 &quot;&gt;&lt;/a&gt;&lt;center&gt; macOS 10.14 beta3 &lt;/cent
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="灾难" scheme="https://blog.pazyx.xyz/tags/%E7%81%BE%E9%9A%BE/"/>
    
      <category term="MacOS" scheme="https://blog.pazyx.xyz/tags/MacOS/"/>
    
  </entry>
  
</feed>
