<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「笔记」Oracle Database 期中考笔记]]></title>
    <url>%2F2019%2F11%2F06%2Foracle_midterm_notes%2F</url>
    <content type="text"><![CDATA[DDL建表1234567891011121314CREATE TABLE staff ( PRIMARY KEY (staff_num), staff_num INTEGER DEFAULT 1 NOT NULL, first_name VARCHAR2(100) NOT NULL, leader_num INTEGER NOT NULL, CONSTRAINT staff_first_name_uq UNIQUE (first_name), CONSTRAINT staff_leader_num_ck CHECK(leader_num &gt;= 1 AND leader_num &lt; 100), CONSTRAINT staff_leader_fk FOREIGN KEY(first_name) REFERENCES staff2(first_name)); 只复制表结构1CREATE TABLE staff_temp like staff; 复制表结构及数据1CREATE TABLE staff_temp as select * from staff; 删表1DROP TABLE staff; 修改表添加列12ALTER TABLE staffADD new_column_name INTEGER; 删除列12ALTER TABLE staffDROP COLUMN drop_column_name; 修改列12ALTER TABLE staffMODIFY modify_column_name INTEGER; 添加约束1234567891011121314151617181920-- 添加 CHECK 约束ALTER TABLE staffADD CONSTRAINT staff_first_name_ck CHECK (first_name in (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));-- 添加 UNIQUE 约束ALTER TABLE staffADD CONSTRAINT staff_first_name_uq UNIQUE (first_name);-- 添加 FOREIGN KEY 约束ALTER TABLE staffADD CONSTRAINT staff_leader_fk FOREIGN KEY(first_name) REFERENCES staff2(first_name); -- 添加 NOT NULL 约束 (使用 MODIFY !!!)ALTER TABLE staffMODIFY first_name CONSTRAINT staff_first_name_nn NOT NULL;ALTER TABLE staffMODIFY first_name NOT NULL; 删除、禁用、启用约束1234567891011-- 删除ALTER TABLE staffDROP CONSTRAINT staff_first_name_nn;-- 禁用ALTER TABLE staffDISABLE CONSTRAINT staff_first_name_nn;-- 启用ALTER TABLE staffENABLE CONSTRAINT staff_first_name_nn; 清空表DELETE 12DELETE staff;COMMIT; TRUNCATE 1TRUNCATE TABLE staff; TRUNCATE DELETE 清空表格 T F 语句类型 DDL DML 自动提交 T F 可回滚 F T 释放储存空间 T F 推荐使用 T F 注释12345COMMENT ON TABLE table_name is &apos;表注释&apos;;COMMENT ON TABLE staff is &apos;员工表&apos;;COMMENT ON COLUMN column_name is &apos;列注释&apos;;COMMENT ON COLUMN staff_num is &apos;员工号&apos;; 重命名表1RENAME staff TO staff2; DML查询基本顺序1234567SELECT avg(group_column) FROMtable_a INNER JOIN table_bUSING(join_column)WHERE join_column &gt; 1GROUP BY group_columnHAVING avg(group_column) &gt; 10ORDER BY oreder_column DESC; WITH123456789101112131415161718WITH t AS ( SELECT equipment_name,damage*speed*(1+durability/100) val FROM equipments WHERE durability IS NOT NULL AND attack_id IS NOT null UNION ALL SELECT equipment_name,durability*dr_ratio*2 FROM equipments WHERE durability IS NOT null AND attack_id IS NULL)SELECT equipment_name,valFROM tWHERE val &gt; ( SELECT AVG(val) FROM t)ORDER BY val DESC; IN TABLE1234567SELECT npc_name,attack_type,npc_hpFROM npcs inner join attack_types USING(attack_id)WHERE (attack_id,npc_hp) in ( SELECT attack_id,max(npc_hp) FROM npcs GROUP BY attack_id); 连接1234567891011-- 内连接FROM products INNER JOIN product_typesUSING (product_type_id);-- 外连接FROM products (LEFT | RIGHT | FULL) OUTER JOIN product_typesUSING (product_type_id);-- 自连接FROM employees w INNER JOIN employees mON w.manager_id = m.employee_id; 杂项12345where equipment_name like &apos;%铁_&apos;group by cid,cnamenvl(gname,&apos;无&apos;) 函数插入数据12INSERT INTO staff VALUES(1,&apos;fn&apos;,10);INSERT INTO staff(staff_num,first_name,leader_num) VALUES(1,&apos;fn&apos;,10); 删除数据12DELETE FROM staffWHERE staff_num = 1; 修改数据12UPDATE staff SET staff_num = 3, first_name = &apos;xxx&apos;WHERE staff_num = 1; PL/SQL1234567891011121314151617181920212223set serveroutput ondeclarecursor c_countries IS select cname,cid from countries;v_cid countries.cid%type;v_city_cnt integer;v_gener_cnt integer;begin for v_c IN c_countries LOOP v_cid := v_c.cid; select count(*) into v_city_cnt from cities where cid = v_cid; select count(*) into v_gener_cnt from generals where cid = v_cid and cityid is not null; IF gener_cnt &gt; 2 THEN DBMS_OUTPUT.PUT_LINE(v_c.cname ||&apos;有&apos;||v_city_cnt||&apos;座城市，&apos;||v_gener_cnt||&apos;名现役武将&apos;); END IF; END LOOP;end;/]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
        <tag>PL/SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache2 服务器配置 HTTPS]]></title>
    <url>%2F2019%2F08%2F18%2Fssl%2F</url>
    <content type="text"><![CDATA[概述由于多次配置 SSL 证书，每次间隔时间较长，每次都忘记怎么搞。。。特地总结一下，延缓阿兹海默。 这份教程只针对 Apache2 服务器，且已写好配置文件的选手。 大概分以下几个步骤： 申请证书 验证域名所有权 下载证书转换格式 将证书传入服务器 修改配置文件 载入配置文件 重启 Apache 申请证书推荐 FreeSSL，其中有两款免费证书：TrustAsia 的一年单域名证书、Let’s Encrypt的 90 天通配符证书。 如果子域名较少推荐选择前者，我用的子域名比较多选择后者，文件较少但 90 天要配置一次。 验证域名所有权根据 FreeSSL 网站的提示，在解析域名的网站按要求添加 TXT 记录即可。 下载证书转换格式下载到证书后会发现是三个文件，而 Apache2 只需要两个文件，最终需要一个 .key 和一个 .pem的文件。 你将下载到如下三个文件： .key文件，证书私钥 CA_xxx.crt，CA 中间证书 域名.crt，服务器证书 其中 .key 文件就是最终需要的 .key 文件，而 .pem 文件需要自己创建再将 CA_xxx.crt 和 域名.crt 按顺序粘贴进去。 将证书传入服务器使用 scp 将证书上传至服务器，当然这需要配置好 ssh。 命令格式和示例如下：12scp file_source file_targetscp ./pazyx_xyz.pem git@pazyx.xyz:~/ 我一般是将文件传入 home 目录后再 ssh登录到服务器将文件从 home 目录放到 /etc/apache2/ssl/ 目录下，以免权限受限。 修改配置文件配置文件为 /etc/apache2/site-available/default-ssl.conf如何配置略，因为我也忘了，随便改一改就是了。 载入配置文件1a2ensite default-ssl 重启 Apache1sudo service apache2 restart 参考资料 Apache配置ssl 免费证书下载的两个文件的说明]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>HTTPS</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题解」kuangbin 最小生成树]]></title>
    <url>%2F2019%2F04%2F29%2Fkuangbin_MST%2F</url>
    <content type="text"><![CDATA[概述 POJ-1251 Jungle Roads (水题，%c) POJ-1287 Networking (水) POJ-2031 Building a Space Station (%f浮点数尴尬精度，两球间距离) POJ-2421 Constructing Roads (一些边已建好，简单处理一下) ZOJ-1586 QS Network (处理一下边权) HDU-1233 还是畅通工程 (水) HDU-1875 畅通工程再续 (浮点数，条件连边) HDU-1301 Jungle Roads (重复 -&gt; POJ-1251) POJ-2349 Arctic Network (第 K 大边) POJ-1751 Highways (求最小生成树的边，加 0 权边) UVA-10147 Highways (多组的 POJ-1751) + POJ-1258 Agri-Net (水) POJ-3026 Borg Maze (BFS + Kruskal，用最短路建图，垃圾输入) POJ-1789 Truck History (Prim，Kruskal 超时) POJ-1679 The Unique MST (次小生成树) 代码最后附简单题解 模板Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * Kruskal 算法求 MST */#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125; Prim12345678910111213141516171819202122232425262728293031323334/* * Prim 求 MST * 耗费矩阵 cost[][]，标号从 0 开始，0∼n-1 * 返回最小生成树的权值，返回 -1 表示原图不连通 */#include &lt;string.h&gt;const int INF = 0x3f3f3f3f;const int MAXN = 110;bool vis[MAXN];int lowc[MAXN];//点是 0 n-1int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); vis[0] = true; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; //原图不连通 ans += minc; vis[p] = true; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; &#125; return ans;&#125; SecondMST (Prim)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* * 次小生成树 * 求最小生成树时，用数组 Max[i][j] 来表示 MST 中 i 到 j 最大边权 * 求完后，直接枚举所有不在 MST 中的边，替换掉最大边权的边，更新答案 * 点的编号从 0 开始 */#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 110;const int INF = 0x3f3f3f3f;bool vis[MAXN];int lowc[MAXN];int pre[MAXN];int Max[MAXN][MAXN];// Max[i][j] 表示在最小生成树中从 i 到 j 的路径中的最大边权bool used[MAXN][MAXN];int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); memset(Max, 0, sizeof(Max)); memset(used, false, sizeof(used)); vis[0] = true; pre[0] = -1; for (int i = 1; i &lt; n; i++) &#123; lowc[i] = cost[0][i]; pre[i] = 0; &#125; lowc[0] = 0; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; ans += minc; vis[p] = true; used[p][pre[p]] = used[pre[p]][p] = true; for (int j = 0; j &lt; n; j++) &#123; if (vis[j] &amp;&amp; j != p) Max[j][p] = Max[p][j] = max(Max[j][pre[p]], lowc[p]); if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) &#123; lowc[j] = cost[p][j]; pre[j] = p; &#125; &#125; &#125; return ans;&#125;int smst(int cost[][MAXN], int n, int ans) &#123; int Min = INF; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) if (cost[i][j] != INF &amp;&amp; !used[i][j]) &#123; Min = min(Min, ans + cost[i][j] - Max[i][j]); &#125; if (Min == INF) return -1; //不存在 return Min;&#125; 代码POJ-1251 Jungle Roads1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// POJ-1251 Jungle Roads// https://vjudge.net/problem/POJ-1251#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; for (int i = 0; i &lt; n - 1; i++) &#123; char x; int m; scanf(" %c%d", &amp;x, &amp;m); for (int j = 0; j &lt; m; j++) &#123; char y; int w; scanf(" %c%d", &amp;y, &amp;w); addedge(x - 'A', y - 'A', w); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// 裸题，scanf %c 读入尴尬// scanf(" %c%d", &amp;x, &amp;m); POJ-1287 Networking1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// POJ-1287 Networking// https://vjudge.net/problem/POJ-1287#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int main() &#123; int n, m; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// 裸题 POJ-2031 Building a Space Station12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// POJ-2031 Building a Space Station// https://vjudge.net/problem/POJ-2031#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;double len(double x, double y, double z, double xx, double yy, double zz) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y) + (zz - z) * (zz - z));&#125;double cirlen(double x, double y, double z, double r, double xx, double yy, double zz, double rr) &#123; double ll = len(x, y, z, xx, yy, zz); if (ll - r - rr &lt; 1e-5) &#123; return 0; &#125; else &#123; return ll - r - rr; &#125;&#125;double xp[MAXN];double yp[MAXN];double zp[MAXN];double rp[MAXN];int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;xp[i], &amp;yp[i], &amp;zp[i], &amp;rp[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; addedge(i, j, cirlen(xp[i], yp[i], zp[i], rp[i], xp[j], yp[j], zp[j], rp[j])); &#125; &#125; double ans = Kruskal(n); printf("%.3f\n", ans); &#125; return 0;&#125;// 浮点数的最小生成树，球之间的距离，距离小于零，就建一条权为 0 的边// POJ尴尬精度 %f POJ-2421 Constructing Roads12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// POJ-2421 Constructing Roads// https://vjudge.net/problem/POJ-2421#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int mapx[MAXN][MAXN];int main() &#123; int N; scanf("%d", &amp;N); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; scanf("%d", &amp;mapx[i][j]); &#125; &#125; int Q; scanf("%d", &amp;Q); for (int i = 0; i &lt; Q; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); mapx[a][b] = 0; mapx[b][a] = 0; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = i + 1; j &lt;= N; j++) &#123; if (i == j) continue; addedge(i, j, min(mapx[i][j], mapx[j][i])); &#125; &#125; int ans = Kruskal(N); printf("%d\n", ans);&#125;// 有一些路已建好，把边权改为 0 就好了 ZOJ-1586 QS Network1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ZOJ-1586 QS Network// https://vjudge.net/problem/ZOJ-1586#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 1100; //最大点数const int MAXM = 2000000; //最大边数int F[MAXN]; //并查集使用int codec[MAXN]; // *&amp;*struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; tol = 0; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;codec[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int w; scanf("%d", &amp;w); if (i &lt; j) addedge(i, j, w + codec[i] + codec[j]); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// 加边时，加一下适配器的价格 HDU-1233 还是畅通工程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// HDU-1233 还是畅通工程// https://vjudge.net/problem/HDU-1233#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; int m = n * (n - 1) / 2; for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); addedge(a, b, w); &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// 裸题 HDU-1875 畅通工程再续12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// HDU-1875 畅通工程再续// https://vjudge.net/problem/HDU-1875#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 310; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); if (n == 0) break; tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); if (xly &gt;= 10 &amp;&amp; xly &lt;= 1000) addedge(i, j, xly * 100); &#125; &#125; double ans = Kruskal(n); if (ans &gt; 0) &#123; printf("%.1f\n", ans); &#125; else &#123; printf("oh!\n"); &#125; &#125; return 0;&#125;// 浮点数，条件连边 HDU-1301 Jungle Roads123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// HDU-1301 Jungle Roads// https://vjudge.net/problem/HDU-1301#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; for (int i = 0; i &lt; n - 1; i++) &#123; char x; int m; scanf(" %c%d", &amp;x, &amp;m); for (int j = 0; j &lt; m; j++) &#123; char y; int w; scanf(" %c%d", &amp;y, &amp;w); addedge(x - 'A', y - 'A', w); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// 竟然有重复的题，一模一样 -&gt; POJ-1251// 裸题，scanf %c 读入尴尬// scanf(" %c%d", &amp;x, &amp;m); POJ-2349 Arctic Network123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// POJ-2349 Arctic Network// https://vjudge.net/problem/POJ-2349#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 510; //最大点数const int MAXM = 250000; //最大边数int F[MAXN]; //并查集使用vector&lt;double&gt; vd;struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans = max(ans, w); vd.push_back(w); // ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; vd.clear(); int n, s; scanf("%d%d", &amp;s, &amp;n); if (n == 0) break; tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); addedge(i, j, xly); &#125; &#125; double ans = Kruskal(n); ans = vd[vd.size() - s]; printf("%.2f\n", ans); &#125; return 0;&#125;// 最小生成树的第 K 大边 POJ-1751 Highways123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// POJ-1751 Highways// https://vjudge.net/problem/POJ-1751#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1000; //最大点数const int MAXM = 1000000; //最大边数vector&lt;int&gt; vx;vector&lt;int&gt; vy;int F[MAXN]; //并查集使用struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; if (w &gt; 1e-5) &#123; vx.push_back(u); vy.push_back(v); &#125; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int n; scanf("%d", &amp;n); tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); addedge(i, j, xly * 100); &#125; &#125; int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); addedge(a, b, 0); &#125; double ans = Kruskal(n); for (int i = 0; i &lt; vx.size(); i++) &#123; printf("%d %d\n", vx[i], vy[i]); &#125; return 0;&#125;// 求最小生成树的边，加 0 权边 UVA-10147 Highways123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// UVA-10147 Highways// https://vjudge.net/problem/UVA-10147#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1000; //最大点数const int MAXM = 1000000; //最大边数vector&lt;int&gt; vx;vector&lt;int&gt; vy;int F[MAXN]; //并查集使用struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//传入点数，返回最小生成树的权值，如果不连通返回 -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; if (w &gt; 0) &#123; vx.push_back(u); vy.push_back(v); &#125; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; vx.clear(); vy.clear(); int n; scanf("%d", &amp;n); tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); addedge(i, j, xly * 100); &#125; &#125; int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); addedge(a, b, 0); &#125; double ans = Kruskal(n); for (int i = 0; i &lt; vx.size(); i++) &#123; printf("%d %d\n", vx[i], vy[i]); &#125; if (vx.size() == 0) printf("No new highways need\n"); if (T != 0) printf("\n"); &#125; return 0;&#125;// 求最小生成树的边，加 0 权边 POJ-1258 Agri-Net12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// POJ-1258 Agri-Net// https://vjudge.net/problem/POJ-1258#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //最大点数const int MAXM = 10000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; tol = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int w; scanf("%d", &amp;w); addedge(i, j, w); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// 裸题 POJ-3026 Borg Maze123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// POJ-3026 Borg Maze// https://vjudge.net/problem/POJ-3026#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 1100; //最大点数const int MAXM = 1000000; //最大边数int F[MAXN]; //并查集使用struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //排序函数，讲边按照权值从小到大排序bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 else return ans;&#125;int mapx[MAXN][MAXN];int dirx[10] = &#123;0, 1, 0, -1&#125;;int diry[10] = &#123;1, 0, -1, 0&#125;;int n, m;void bfs(int x, int y) &#123; bool vis[MAXN][MAXN]; memset(vis, false, sizeof(vis)); queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; Q; Q.push(make_pair(make_pair(x, y), 0)); vis[x][y] = true; while (!Q.empty()) &#123; int xt = Q.front().first.first; int yt = Q.front().first.second; int times = Q.front().second; Q.pop(); if (mapx[x][y] != mapx[xt][yt] &amp;&amp; mapx[xt][yt] != 0) &#123; addedge(mapx[x][y], mapx[xt][yt], times); &#125; for (int i = 0; i &lt; 4; i++) &#123; int tx = xt + dirx[i]; int ty = yt + diry[i]; if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &lt; m &amp;&amp; !vis[tx][ty]) &#123; if (mapx[tx][ty] != -1) &#123; Q.push(make_pair(make_pair(tx, ty), times + 1)); vis[tx][ty] = true; &#125; &#125; &#125; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); char str[100]; while (T--) &#123; tol = 0; memset(mapx, -1, sizeof(mapx)); int cnt = 0; scanf("%d%d", &amp;n, &amp;m); gets(str); for (int i = 0; i &lt; m; i++) &#123; gets(str); for (int j = 0; j &lt; n; j++) &#123; if (str[j] == 'A' || str[j] == 'S') &#123; mapx[i][j] = ++cnt; &#125; else if (str[j] == ' ') &#123; mapx[i][j] = 0; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (mapx[i][j] &gt; 0) &#123; bfs(i, j); &#125; &#125; &#125; int ans = Kruskal(cnt); printf("%d\n", ans); &#125; return 0;&#125;// BFS + Kruskal// 用无权图最短路权值加边// 一开始 MAXN 和 MAXM 开小了，wa...wa...wa... POJ-1789 Truck History12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// POJ-1789 Truck History// https://vjudge.net/problem/POJ-1789#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 2010; //最大点数const int INF = 0x3f3f3f3f;bool vis[MAXN];int lowc[MAXN];int cost[MAXN][MAXN];//点是 0 n-1int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); vis[0] = true; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; //原图不连通 ans += minc; vis[p] = true; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; &#125; return ans;&#125;char str[MAXN][10];int len(int a, int b) &#123; int ans = 0; for (int i = 0; i &lt; 7; i++) &#123; if (str[a][i] != str[b][i]) &#123; ans++; &#125; &#125; return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", str[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == j) continue; cost[i][j] = len(i, j); &#125; &#125; int ans = Prim(cost, n); printf("The highest possible quality is 1/%d.\n", ans); &#125; return 0;&#125;// Kruskal 超时，用 Prim ! POJ-1679 The Unique MST123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// POJ-1679 The Unique MST// https://vjudge.net/problem/POJ-1679#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 110;const int INF = 0x3f3f3f3f;bool vis[MAXN];int lowc[MAXN];int pre[MAXN];int Max[MAXN][MAXN];// Max[i][j] 表示在最小生成树中从 i 到 j 的路径中的最大边权bool used[MAXN][MAXN];int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); memset(Max, 0, sizeof(Max)); memset(used, false, sizeof(used)); vis[0] = true; pre[0] = -1; for (int i = 1; i &lt; n; i++) &#123; lowc[i] = cost[0][i]; pre[i] = 0; &#125; lowc[0] = 0; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; ans += minc; vis[p] = true; used[p][pre[p]] = used[pre[p]][p] = true; for (int j = 0; j &lt; n; j++) &#123; if (vis[j] &amp;&amp; j != p) Max[j][p] = Max[p][j] = max(Max[j][pre[p]], lowc[p]); if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) &#123; lowc[j] = cost[p][j]; pre[j] = p; &#125; &#125; &#125; return ans;&#125;int smst(int cost[][MAXN],int n,int ans)&#123; int Min=INF; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) if(cost[i][j]!=INF &amp;&amp; !used[i][j]) &#123; Min=min(Min,ans+cost[i][j]-Max[i][j]); &#125; if(Min==INF)return -1;//不存在 return Min;&#125;int costx[MAXN][MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; memset(costx, 0x3f, sizeof(costx)); int n, m; scanf("%d%d", &amp;n, &amp;m); int sum = 0; for (int i = 0; i &lt; n; i++) costx[i][i] = 0; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); a--; b--; costx[a][b] = c; costx[b][a] = c; &#125; int ans = Prim(costx, n); int ansMST = smst(costx, n,ans); if (ans == ansMST) &#123; printf("Not Unique!\n"); &#125; else &#123; printf("%d\n", ans); &#125; &#125; return 0;&#125;// 次小生成树，不知道为什么最小生成树计数不行// kuangbin 题解：https://www.cnblogs.com/kuangbin/p/3147329.html]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DFS</tag>
        <tag>Dijkstra</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题解」kuangbin 最短路]]></title>
    <url>%2F2019%2F04%2F29%2Fkuangbin_short_path%2F</url>
    <content type="text"><![CDATA[概述 POJ-2387 Til the Cows Come Home（水） POJ-2253 Frogger（浮点数，尴尬精度） POJ-1797 Heavy Transportation（求所有路径中最大边权的最小值） POJ-3268 Silver Cow Party（求往返最短路，反向连边） POJ-1860 Currency Exchange（换汇问题，最长路判断正环） POJ-3259 Wormholes（判断负值圈） POJ-1502 MPI Maelstrom（所有点最短路中的最长路） POJ-3660 Cow Contest（传递闭包 floyd 或 DFS） POJ-2240 Arbitrage（判断正环） POJ-1511 Invitation Cards（求往返最短路，反向连边） POJ-1847 Tram（水） POJ-1062 昂贵的聘礼* POJ-3159 Candies（伪差分约束系统（裸最短路）+ 输入输出挂） POJ-2502 Subway（建图麻烦） POJ-3169 Layout（差分约束系统，输出差值） LightOJ-1074 Extended Traffic（判断所有负环） HDU-4725 The Shortest Path in Nya Graph（建图技巧） HDU-3416 Marriage Match IV（最短路 + 最大流 找出最短路经过的边） 代码最后附简单题解 模板Dijkstra_simple123456789101112131415161718192021222324252627282930313233343536373839/* * 单源最短路径，Dijkstra 算法，邻接矩阵形式，复杂度为O(n^2) * 求出源 beg 到所有点的最短路径，传入图的顶点数，和邻接矩阵 cost[][] * 返回各点的最短路径 lowcost[], 路径 pre[].pre[i] 记录 beg 到 i * 路径上的父结点，pre[beg]=-1 * 可更改路径权类型，但是权值必须为非负 */const int MAXN = 1010;#define typec intconst typec INF = 0x3f3f3f3f;bool vis[MAXN];int pre[MAXN];void Dijkstra(typec cost[][MAXN], typec lowcost[], int n, int beg) &#123; for (int i = 0; i &lt; n; i++) &#123; lowcost[i] = INF; vis[i] = false; pre[i] = -1; &#125; lowcost[beg] = 0; for (int j = 0; j &lt; n; j++) &#123; int k = -1; int Min = INF; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; lowcost[i] &lt; Min) &#123; Min = lowcost[i]; k = i; &#125; &#125; if (k == -1) break; vis[k] = true; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i]) &#123; lowcost[i] = lowcost[k] + cost[k][i]; pre[i] = k; &#125; &#125; &#125;&#125; Dijkstra_set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 使用优先队列优化 Dijkstra 算法 * 复杂度 O(ElogE) * 注意对 * vector&lt;Edge&gt;E[MAXN] 进行初始化后加边 */#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125; Bellman_Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * 单源最短路 bellman_ford 算法，复杂度 O(VE) * 可以处理负边权图。 * 可以判断是否存在负环回路。返回 true, 当且仅当图中不包含从源点可达的负权回路 * vector&lt;Edge&gt;E; 先 E.clear() 初始化，然后加入所有边 * 点的编号从 1 开始 (从 0 开始简单修改就可以了) */#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 550;int dist[MAXN];struct Edge &#123; int u, v; int cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E;//点的编号从 1 开始bool bellman_ford(int start, int n) &#123; for (int i = 1; i &lt;= n; i++) dist[i] = INF; dist[start] = 0; //最多做 n-1 次 for (int i = 1; i &lt; n; i++) &#123; bool flag = false; for (int j = 0; j &lt; E.size(); j++) &#123; int u = E[j].u; int v = E[j].v; int cost = E[j].cost; if (dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; flag = true; &#125; if (!flag) return true; &#125; &#125; for (int j = 0; j &lt; E.size(); j++) &#123; if (dist[E[j].v] &gt; dist[E[j].u] + E[j].cost) &#123; return false; &#125; &#125; return true;&#125; SPFA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * 单源最短路 SPFA * 时间复杂度 0(kE) * 这个是队列实现，有时候改成栈实现会更加快，很容易修改 * 这个复杂度是不定的 */#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125; Floyd12345678910111213#include &lt;algorithm&gt;using namespace std;const int MAXN = 105;int dist[MAXN][MAXN];void floyd(int n) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dist[i][j] = min(dist[i][j], dist[i][k] + dist[j][k]); &#125; &#125; &#125;&#125; 输入输出挂123456789101112131415161718192021#include &lt;cstdio&gt;int Scan() &#123; //输入外挂 int res = 0, flag = 0; char ch; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125;void Out(int a) &#123; //输出外挂 if (a &lt; 0) &#123; putchar('-'); a = -a; &#125; if (a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125; 代码POJ-2387 Til the Cows Come Home123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// POJ-2387 Til the Cows Come Home// https://vjudge.net/problem/POJ-2387#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int T, N; while (~scanf("%d%d", &amp;T, &amp;N)) &#123; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; for (int i = 0; i &lt; T; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; Dijkstra(N, 1); printf("%d\n", dist[N]); &#125;&#125;// 裸的 dji_set，坑：多组输入！ POJ-2253 Frogger12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// POJ-2253 Frogger// https://vjudge.net/problem/POJ-2253#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v; double c; qnode(int _v = 0, double _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v; double cost; Edge(int _v = 0, double _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];double dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; double cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; max(dist[u], cost)) &#123; dist[v] = max(dist[u], cost); que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, double w) &#123; E[u].push_back(Edge(v, w)); &#125;double tone_x[MAXN], tone_y[MAXN];double len(int a, int b) &#123; return sqrt((tone_x[a] - tone_x[b]) * (tone_x[a] - tone_x[b]) + (tone_y[a] - tone_y[b]) * (tone_y[a] - tone_y[b]));&#125;int main() &#123; int N; int CNT = 1; while (~scanf("%d", &amp;N)) &#123; if (N == 0) break; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; for (int i = 1; i &lt;= N; i++) &#123; scanf("%lf%lf", &amp;tone_x[i], &amp;tone_y[i]); &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; if (i == j) continue; addedge(i, j, len(i, j)); &#125; &#125; Dijkstra(N, 1); printf("Scenario #%d\n", CNT++); printf("Frog Distance = %.3lf\n\n", dist[2]); &#125;&#125;// 最短路变形，大坑：POJ选择C++才能过？？？ POJ-1797 Heavy Transportationdij_set1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// POJ-1797 Heavy Transportation// https://vjudge.net/problem/POJ-1797#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 10000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &lt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = 0; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = INF; que.push(qnode(start, dist[start])); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &lt; min(dist[u], cost)) &#123; dist[v] = min(dist[u], cost); que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int T, CNT = 1; scanf("%d", &amp;T); while (CNT &lt;= T) &#123; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); addedge(a, b, w); addedge(b, a, w); &#125; Dijkstra(n, 1); printf("Scenario #%d:\n%d\n\n", CNT++, dist[n]); &#125; return 0;&#125;//求 1 - n 中所有路径中最大边权的最小值 dij_simple123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// POJ-1797 Heavy Transportation// https://vjudge.net/problem/POJ-1797#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;#define typec intconst typec INF = 0x3f3f3f3f;int xcost[MAXN][MAXN];int dist[MAXN];bool vis[MAXN];void Dijkstra(typec cost[][MAXN], typec lowcost[], int n, int beg) &#123; for (int i = 0; i &lt; n; i++) &#123; lowcost[i] = 0; vis[i] = false; &#125; lowcost[beg] = INF; for (int j = 0; j &lt; n; j++) &#123; int k = -1; int Min = 0; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; lowcost[i] &gt; Min) &#123; Min = lowcost[i]; k = i; &#125; &#125; if (k == -1) break; vis[k] = true; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; min(lowcost[k], cost[k][i]) &gt; lowcost[i]) &#123; lowcost[i] = min(lowcost[k], cost[k][i]); &#125; &#125; &#125;&#125;int main() &#123; int T, CNT = 1; scanf("%d", &amp;T); while (CNT &lt;= T) &#123; memset(xcost, 0, sizeof(xcost)); memset(dist, 0, sizeof(dist)); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); a--; b--; xcost[a][b] = xcost[b][a] = max(w, xcost[a][b]); &#125; Dijkstra(xcost, dist, n, 0); printf("Scenario #%d:\n%d\n\n", CNT++, dist[n - 1]); &#125; return 0;&#125;//求 1 - n 中所有路径中最大边权的最小值 Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// POJ-1797 Heavy Transportation// https://vjudge.net/problem/POJ-1797#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 2005; //最大点数const int MAXM = 2000005; //最大边数int F[MAXN];struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //存储边的信息，包括起点/终点/权值int tol; //边数，加边前赋值为 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;// 排序函数，讲边按照权值从大到小排序bool cmp(Edge a, Edge b) &#123; return a.w &gt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;int xans;// 传入点数，返回最小生成树的权值，如果不连通返回 -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //计算加入的边数 int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; xans = min(xans, w); F[t1] = t2; cnt++; &#125; //---------------------------------------------------------------- int x1 = find(1); int xn = find(n); if (x1 == xn) break; //---------------------------------------------------------------- // 1-n连接后就不需贪心 if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //不连通 return ans;&#125;int main() &#123; int T, CNT = 1; scanf("%d", &amp;T); while (CNT &lt;= T) &#123; tol = 0; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); addedge(a, b, w); // addedge(b, a, w); &#125; xans = 0x3f3f3f3f; Kruskal(n); printf("Scenario #%d:\n%d\n\n", CNT++, xans); &#125; return 0;&#125;//求 1 - n 中所有路径中最大边权的最小值 POJ-3268 Silver Cow Party123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// POJ-3268 Silver Cow Party// https://vjudge.net/problem/POJ-3268#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 10000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int u, v, cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];vector&lt;Edge&gt; Etmp;bool vis[MAXN];int dist[MAXN];int tdist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(u, v, w)); &#125;int main() &#123; int n, m, x; scanf("%d%d%d", &amp;n, &amp;m, &amp;x); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); Etmp.push_back(Edge(a, b, c)); &#125; Dijkstra(n, x); for (int i = 1; i &lt;= n; i++) &#123; tdist[i] = dist[i]; E[i].clear(); &#125; for (int i = 0; i &lt; m; i++) &#123; addedge(Etmp[i].v, Etmp[i].u, Etmp[i].cost); &#125; int ans = 0; Dijkstra(n, x); for (int i = 1; i &lt;= n; i++) &#123; tdist[i] += dist[i]; ans = max(ans, tdist[i]); &#125; printf("%d\n", ans); return 0;&#125;// 从 x 向所有点跑一次 dij，将边反向再来一次，求往返距离 POJ-1860 Currency Exchange1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// POJ-1860 Currency Exchange// https://vjudge.net/problem/POJ-1860#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int N, M, S;double V;const int MAXN = 1010;const int INF = 10000;struct Edge &#123; int v; double cost; double c; Edge(int _v = 0, double _cost = 0, double _c = 0) : v(_v), cost(_cost), c(_c) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, double w, double c) &#123; E[u].push_back(Edge(v, w, c));&#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数double dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = 0; vis[start] = true; dist[start] = V; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &lt; (dist[u] - E[u][i].c) * E[u][i].cost) &#123; dist[v] = (dist[u] - E[u][i].c) * E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return true; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return false;&#125;int main() &#123; scanf("%d%d%d%lf", &amp;N, &amp;M, &amp;S, &amp;V); for (int i = 0; i &lt; M; i++) &#123; int a, b; double rab, cab, rba, cba; scanf("%d%d%lf%lf%lf%lf", &amp;a, &amp;b, &amp;rab, &amp;cab, &amp;rba, &amp;cba); addedge(a, b, rab, cab); addedge(b, a, rba, cba); &#125; if (SPFA(S, N)) &#123; printf("YES"); &#125; else &#123; printf("NO"); &#125; printf("\n"); return 0;&#125;// 换汇问题，最长路判断正环 POJ-3259 Wormholes12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// POJ-3159 Candies// https://vjudge.net/problem/POJ-3159#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int Scan() &#123; //输入外挂 int res = 0, flag = 0; char ch; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125;void Out(int a) &#123; //输出外挂 if (a &lt; 0) &#123; putchar('-'); a = -a; &#125; if (a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125;const int INF = 0x3f3f3f3f;const int MAXN = 30005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int n, m; n = Scan(); m = Scan(); // scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; a = Scan(); b = Scan(); c = Scan(); // scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; Dijkstra(n, 1); Out(dist[n]); // printf("%d\n", dist[n]);&#125;// 伪装的差分约束系统（裸的最短路），输入输出TLE，上输入输出挂 POJ-1502 MPI Maelstrom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// POJ-1502 MPI Maelstrom// https://vjudge.net/problem/POJ-1502#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;// #include &lt;sstream&gt;// #include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int n; scanf("%d", &amp;n); char str[100]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; // string s; // cin &gt;&gt; s; // if (s[0] == 'x') continue; // stringstream ss; // ss &lt;&lt; s; // ss &gt;&gt; tmp; scanf("%s", str); if (str[0] == 'x') continue; int tmp = atoi(str); addedge(i, j, tmp); addedge(j, i, tmp); &#125; &#125; Dijkstra(n, 1); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, dist[i]); &#125; printf("%d\n", ans); return 0;&#125;// 从 1 出发最短路中的最长路 POJ-3660 Cow ContestFloyd12345678910111213141516171819202122232425262728293031323334353637383940414243444546// POJ-3660 Cow Contest// https://vjudge.net/problem/POJ-3660#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int MAXN = 105;int dist[MAXN][MAXN];void floyd(int n) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dist[i][j] = (dist[i][j] || (dist[i][k] &amp;&amp; dist[k][j])); &#125; &#125; &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); memset(dist, 0, sizeof(dist)); for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); dist[a][b] = 1; &#125; floyd(n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; for (int j = 1; j &lt;= n; j++) &#123; if (dist[i][j] || dist[j][i]) cnt++; &#125; if (cnt &gt;= n - 1) &#123; ans++; &#125; &#125; printf("%d\n", ans); return 0;&#125;// 传递闭包 DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// POJ-3660 Cow Contest// https://vjudge.net/problem/POJ-3660#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 105;int n, m;vector&lt;int&gt; ed[MAXN];int vis[MAXN][MAXN]; // vis[i][j]表示i-&gt;j可达void dfs(int s) //普通的dfs算法&#123; int num = n; stack&lt;int&gt; st; st.push(s); vis[s][s] = 1; while (!st.empty()) &#123; int now = st.top(); st.pop(); int len = ed[now].size(); for (int i = 0; i &lt; len; ++i) &#123; if (vis[s][ed[now][i]] == 0) &#123; st.push(ed[now][i]); vis[s][ed[now][i]] = 1; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); ed[a].push_back(b); // vis[a][b] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; dfs(i); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) continue; if (vis[i][j] || vis[j][i]) cnt++; &#125; if (cnt &gt;= n - 1) &#123; ans++; &#125; &#125; printf("%d\n", ans); return 0;&#125;// 传递闭包 POJ-2240 Arbitrage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// POJ-2240 Arbitrage// https://vjudge.net/problem/POJ-2240#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; double cost; Edge(int _v = 0, double _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, double w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数double dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) dist[i] = 0; vis[start] = true; dist[start] = 100; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &lt; dist[u] * E[u][i].cost) &#123; dist[v] = dist[u] * E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int Case = 1; while (true) &#123; int n; cin &gt;&gt; n; if (n == 0) break; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; map&lt;string, int&gt; name; for (int i = 1; i &lt;= n; i++) &#123; string str; cin &gt;&gt; str; name[str] = i; &#125; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; string a, b; double x; cin &gt;&gt; a &gt;&gt; x &gt;&gt; b; addedge(name[a], name[b], x); &#125; cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": "; if (!SPFA(1, n)) &#123; cout &lt;&lt; "Yes"; &#125; else &#123; cout &lt;&lt; "No"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;// SPFA 判断正环 POJ-1511 Invitation Cards12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// POJ-1511 Invitation Cards// https://vjudge.net/problem/POJ-1511#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int u, v, cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];vector&lt;Edge&gt; Etmp;bool vis[MAXN];int dist[MAXN];int tdist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(u, v, w)); &#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); Etmp.clear(); for (int i = 1; i &lt;= n; i++) &#123; E[i].clear(); &#125; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); Etmp.push_back(Edge(a, b, c)); &#125; Dijkstra(n, 1); long long int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += dist[i]; E[i].clear(); &#125; for (int i = 0; i &lt; m; i++) &#123; addedge(Etmp[i].v, Etmp[i].u, Etmp[i].cost); &#125; Dijkstra(n, 1); for (int i = 1; i &lt;= n; i++) &#123; sum += dist[i]; &#125; printf("%lld\n", sum); &#125; return 0;&#125;// 求 1 到所有点再返回的最短路径长度求和，sum需要 long long// 与 POJ-3268 Silver Cow Party 类似，将边反向再求一次即可 POJ-1847 Tram12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// POJ-1847 Tram// https://vjudge.net/problem/POJ-1847#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int N, A, B; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); for (int i = 1; i &lt;= N; i++) &#123; int ct, a; scanf("%d%d", &amp;ct, &amp;a); addedge(i, a, 0); for (int j = 1; j &lt; ct; j++) &#123; scanf("%d", &amp;a); addedge(i, a, 1); &#125; &#125; SPFA(A, N); if (dist[B] != INF) &#123; printf("%d\n", dist[B]); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125;// 裸最短路，SPFA，Dij 都可以 POJ-1062 昂贵的聘礼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// POJ-1062 昂贵的聘礼// https://vjudge.net/problem/POJ-1062#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int M, N;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;long long degree[MAXN];bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数long long dist[MAXN];bool SPFA(int start, int n, int a, int b) &#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (degree[v] &lt; a || degree[v] &gt; b) &#123; continue; &#125; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; scanf("%d%d", &amp;M, &amp;N); for (int i = 0; i &lt;= N; i++) &#123; E[i].clear(); &#125; long long mind = 100000, maxd = 0; for (int i = 1; i &lt;= N; i++) &#123; int w, X; scanf("%d%lld%d", &amp;w, &amp;degree[i], &amp;X); mind = min(mind, degree[i]); maxd = max(maxd, degree[i]); addedge(0, i, w); for (int j = 0; j &lt; X; j++) &#123; int T, V; scanf("%d%d", &amp;T, &amp;V); addedge(T, i, V); &#125; &#125; long long ans = E[0][0].cost; for (int i = degree[1] - M; i &lt;= degree[1]; i++) &#123; SPFA(0, N, i, i + M); ans = min(ans, dist[1]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; POJ-3159 Candies12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// POJ-3159 Candies// https://vjudge.net/problem/POJ-3159#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int Scan() &#123; //输入外挂 int res = 0, flag = 0; char ch; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125;void Out(int a) &#123; //输出外挂 if (a &lt; 0) &#123; putchar('-'); a = -a; &#125; if (a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125;const int INF = 0x3f3f3f3f;const int MAXN = 30005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int n, m; n = Scan(); m = Scan(); // scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; a = Scan(); b = Scan(); c = Scan(); // scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; Dijkstra(n, 1); Out(dist[n]); // printf("%d\n", dist[n]);&#125;// 伪装的差分约束系统（裸的最短路），输入输出TLE，上输入输出挂 POJ-2502 Subway123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// POJ-2502 Subway// https://vjudge.net/problem/POJ-2502#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v; double c; qnode(int _v = 0, double _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v; double cost; Edge(int _v = 0, double _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];double dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, double w) &#123; E[u].push_back(Edge(v, w)); &#125;double xx[300];double yy[300];double len(int a, int b) &#123; return sqrt((xx[a] - xx[b]) * (xx[a] - xx[b]) + (yy[a] - yy[b]) * (yy[a] - yy[b]));&#125;int main() &#123; int cnt = 1; scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt]); cnt++; scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt]); cnt++; while (~scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt])) &#123; vector&lt;int&gt; subway; subway.push_back(cnt); cnt++; while (xx[cnt - 1] != -1 &amp;&amp; yy[cnt - 1] != -1) &#123; scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt]); subway.push_back(cnt); cnt++; &#125; cnt--; for (int i = 0; i &lt; subway.size() - 2; i++) &#123; addedge(subway[i], subway[i + 1], len(subway[i], subway[i + 1]) / 40 * 60); addedge(subway[i + 1], subway[i], len(subway[i], subway[i + 1]) / 40 * 60); &#125; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; if (i == j) continue; addedge(i, j, len(i, j) / 10 * 60); &#125; &#125; Dijkstra(cnt, 1); printf("%d\n", int(dist[2] / 1000 + 0.5));&#125;// 水题，连边麻烦一点，输入也麻烦// 地铁只能一站一站的走// 结果要输出整数，竟然要四舍五入！！！ POJ-3169 Layout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// POJ-3169 Layout// https://vjudge.net/problem/POJ-3169#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int N, ML, MD; scanf("%d%d%d", &amp;N, &amp;ML, &amp;MD); for (int i = 0; i &lt; ML; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; for (int i = 0; i &lt; MD; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(b, a, -c); &#125; if (SPFA(1, N)) &#123; if (dist[N] == INF) &#123; printf("-2"); &#125; else &#123; printf("%d", dist[N]); &#125; &#125; else &#123; printf("-1"); &#125; printf("\n");&#125;// 差分约束系统// A - B &lt;= D -&gt; add(A，B，D)// A - B &gt;= D -&gt; 同乘 - 1得 B - A &lt;= -D -&gt; add(B，A，-D) LightOJ-1074 Extended Traffic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// LightOJ-1074 Extended Traffic// https://vjudge.net/problem/LightOJ-1074#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; if (++cnt[v] &gt; n) &#123; dist[v] = -INF; &#125; else &#123; que.push(v); &#125; // cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125;int arr[MAXN];int main() &#123; int T; scanf("%d", &amp;T); for (int Case = 1; Case &lt;= T; Case++) &#123; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; printf("Case %d:\n", Case); int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int m; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); addedge(a, b, (arr[b] - arr[a]) * (arr[b] - arr[a]) * (arr[b] - arr[a])); &#125; bool flag = SPFA(1, n); int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; int x, ans; scanf("%d", &amp;x); if (dist[x] == INF || dist[x] &lt; 3) &#123; printf("?\n"); &#125; else &#123; printf("%d\n", dist[x]); &#125; &#125; &#125;&#125;// SPFA 判断**所有负环** HDU-4725 The Shortest Path in Nya Graph1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// HDU-4725 The Shortest Path in Nya Graph// https://vjudge.net/problem/HDU-4725#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 300005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int arr[MAXN];int flag[MAXN];int main() &#123; int T; scanf("%d", &amp;T); for (int Case = 1; Case &lt;= T; Case++) &#123; int N, M, C; scanf("%d%d%d", &amp;N, &amp;M, &amp;C); memset(flag, 0, sizeof(flag)); for (int i = 1; i &lt;= N * 3; i++) &#123; E[i].clear(); &#125; for (int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;arr[i]); flag[arr[i]]++; addedge(i, arr[i] + N + 1 + 1, 0); addedge(i, arr[i] + N + 1 - 1, 0); addedge(arr[i] + N + 1, i, C); &#125; for (int i = 0; i &lt; M; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); addedge(b, a, c); &#125; Dijkstra(N * 3, 1); printf("Case #%d: ", Case); if (dist[N] == INF) &#123; printf("%d\n", -1); &#125; else &#123; printf("%d\n", dist[N]); &#125; &#125;&#125;// 建图困难一些的最短路问题，如果完全按题意建图会超时// 将层抽象成虚点，点到相邻层的虚点连一条 0// 边权的虚边，虚点到当前层的点连一条 C 边权的边 HDU-3416 Marriage Match IV123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179// HDU-3416 Marriage Match IV// https://vjudge.net/problem/HDU-3416#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 2000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int u, v, cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];vector&lt;Edge&gt; Ex;bool vis[MAXN];int dist[MAXN];//点的编号从 1 开始void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(u, v, w)); &#125;const int MAXM = 1200010;struct Edgef &#123; int to, next, cap, flow;&#125; edge[MAXM];int tol;int head[MAXN];void init() &#123; tol = 2; memset(head, -1, sizeof(head));&#125;void addedge(int u, int v, int w, int rw) &#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];int dep[MAXN], cur[MAXN], sta[MAXN];bool bfs(int s, int t, int n) &#123; int front = 0, tail = 0; memset(dep, -1, sizeof(dep[0]) * (n + 1)); dep[s] = 0; Q[tail++] = s; while (front &lt; tail) &#123; int u = Q[front++]; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] == -1) &#123; dep[v] = dep[u] + 1; if (v == t) return true; Q[tail++] = v; &#125; &#125; &#125; return false;&#125;int dinic(int s, int t, int n) &#123; int maxflow = 0; while (bfs(s, t, n)) &#123; for (int i = 0; i &lt; n; i++) &#123; cur[i] = head[i]; &#125; int u = s, tail = 0; while (cur[s] != -1) &#123; if (u == t) &#123; int tp = INF; for (int i = tail - 1; i &gt;= 0; i--) &#123; tp = min(tp, edge[sta[i]].cap - edge[sta[i]].flow); &#125; maxflow += tp; for (int i = tail - 1; i &gt;= 0; i--) &#123; edge[sta[i]].flow += tp; edge[sta[i] ^ 1].flow -= tp; if (edge[sta[i]].cap - edge[sta[i]].flow == 0) tail = i; &#125; u = edge[sta[tail] ^ 1].to; &#125; else if (cur[u] != -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 == dep[edge[cur[u]].to]) &#123; sta[tail++] = cur[u]; u = edge[cur[u]].to; &#125; else &#123; while (u != s &amp;&amp; cur[u] == -1) &#123; u = edge[sta[--tail] ^ 1].to; &#125; cur[u] = edge[cur[u]].next; &#125; &#125; &#125; return maxflow;&#125;int distA[MAXN];int distB[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; init(); Ex.clear(); for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); Ex.push_back(Edge(a, b, c)); addedge(a, b, c); &#125; int A, B; scanf("%d%d", &amp;A, &amp;B); Dijkstra(n, A); memcpy(distA, dist, sizeof(dist)); for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; for (int i = 0; i &lt; Ex.size(); i++) &#123; addedge(Ex[i].v, Ex[i].u, Ex[i].cost); &#125; Dijkstra(n, B); memcpy(distB, dist, sizeof(dist)); for (int i = 0; i &lt; Ex.size(); i++) &#123; if (distA[Ex[i].u] + distB[Ex[i].v] + Ex[i].cost == distA[B]) &#123; addedge(Ex[i].u, Ex[i].v, 1, 0); &#125; &#125; int ans = dinic(A, B, n); printf("%d\n", ans); &#125;&#125;// 求最短路的条数（无公共边）// 找出最短路经过的边，跑最大流]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DFS</tag>
        <tag>Dijkstra</tag>
        <tag>SPFA</tag>
        <tag>Kruskal</tag>
        <tag>Floyd</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路算法2——SPFA]]></title>
    <url>%2F2019%2F02%2F02%2Fspfa%2F</url>
    <content type="text"><![CDATA[概述在最短路算法1——Dijkstra中，我介绍了 Dijkstra 算法，其中给出了一种奇怪的优先队列优化，优化后的代码其实有点不像 Dijkstra 算法，而更像今天要介绍的 SPFA（Shortest Path Faster Algorithm） 算法。SPFA 算法也是一种单源最短路算法，实际上是 Bellman-Ford 算法的队列优化，它最大的特点是它可处理有负权边的图，并可以判断是否存在负值圈。 思想SPFA 算法采用动态逼进法，使用队列保存待优化的顶点，从队列中取出一点对其邻接点进行优化，若有调整则将其入队等待调整。反复取出队首更新最短路，直至队列为空。 实现12345678910111213141516171819202122232425262728293031323334const int MAX_N = 100;struct edge &#123; int next, weight;&#125;;vector&lt;edge&gt;G[MAX_N]; bool inq[MAX_N];int dist[MAX_N];void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; inq[s] = true; queue&lt;int&gt; que; que.push(s); while (!que.empty()) &#123; int u = que.front(); que.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &lt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; que.push(v); inq[v] = true; &#125; &#125; &#125; &#125;&#125; G 邻接表 inq 标示顶点是否已入队 dist 保存起始点到各个点的距离 que 保存等待优化的顶点 应用负值圈判断在 SPFA 算法中增加 cnt 数组记录顶点入队次数，如果入队次数大于顶点总数 n 说明存在负值圈。 补充后部分代码： 1234567891011121314151617181920212223queue&lt;int&gt; que;que.push(s);cnt[s]++; // **while (!que.empty()) &#123; int u = que.front(); que.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &lt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; que.push(v); cnt[v]++; // ** inq[v] = true; if(cnt[v] &gt; n)&#123; // ** cout &lt;&lt; "存在负值圈" &lt;&lt; endl; return; &#125; &#125; &#125; &#125;&#125; 最长路方法 1将边权取相反数，跑完算法后，dist 数组的值为距离的相反数。 方法 2 将更新操作改为的条件 dist[u] + G[u][i].weight &gt; dist[v] 初始化 dist 数组时给予极小值如 0xbf 1234memset(dist, 0xbf, sizeof(dist));...if (dist[u] + G[u][i].weight &gt; dist[v])... 差分约束系统如果一个不等式组由 $n​$ 个变量和 $m​$ 个约束条件组成，且每个约束条件都是形如 $x_j - x_i \leq k, 1 \leq i,j \leq n​$ 的不等式，则称其为差分约束系统。 $x_j - x_i \leq k$ 对应于最短路网络中的三角不等式 $dist_v - dist_u \leq w_{&lt;u,v&gt;}$，即 $dist_v + w_{&lt;u,v&gt;} \leq dist_u$。用最短路算法得到答案 $dist_i$，也就求出了不等式组的一个解。 增加一个超级源 $s$ ，$s$ 连接其余每个顶点，边权均为 $0$。执行 SPFA 算法，如果未出现负值圈 dist 数组即满足条件的一组解，反之不等式组无解。 由于差分约束系统可能出现负权边和负值圈，所以基本只能用 SPFA 算法解决。 $x_j - x_i \leq k​$ 求最短路变形为 $x_i +k \geq x_j​$ 从 $i​$ 到 $j​$ 连一条权值为 $k​$ 的边 求最短路变形为 $x_j - k \leq x_i$ 从 $j$ 到 $i$ 连一条权值为 $-k$ 的边 优化SPFA 算法有两种优化方式 SLF：Small Label First 策略 LLL：Large Label Last 策略 SLF 可使速度提升 $15\sim20\%$；SLF + LLL 可提高约 $50\%$ SLF设要入队的顶点为 $j$ ，队首元素为 $i$ ，若 $dist[j] &lt; dist[i]$ ，则将 $j$ 从队首入队，反之从队尾入队。 实现上需要在队首插入元素，需要将容器从 queue 改为 deque 双端队列。 代码1234567891011121314151617181920212223242526272829void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; inq[s] = true; deque&lt;int&gt; que; que.push_back(s); while (!que.empty()) &#123; int u = que.front(); que.pop_front(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &gt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; if(dist[i] &lt; dist[que.front()])&#123; que.push_front(v); &#125;else&#123; que.push_back(v); &#125; inq[v] = true; &#125; &#125; &#125; &#125;&#125; LLL设队首元素为 $i$ ，队列中所有最短距离值的平均值为 $x$ ，若 $d[i] &gt; x$ 则将其插入到队尾，查找下一个元素，直到找到某一顶点 $i$ 使得 $d[i] &lt; x$ ，则将 $i$ 出队进行松弛操作。 代码12345678910111213141516171819202122232425262728293031323334void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); int sum = 0,cnt = 1; // ** dist[s] = 0; inq[s] = true; deque&lt;int&gt; que; que.push_back(s); while (!que.empty()) &#123; int u = que.front(); que.pop_front(); inq[u] = false; if(dist[u] * cnt &gt; sum)&#123; que.push_back(u); continue; &#125; sum -= dist[u]; // ** cnt--; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &gt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; que.push_back(v); inq[v] = true; sum += dist[v]; // ** cnt++; &#125; &#125; &#125; &#125;&#125; SLF + LLL综合 SLF 策略和 LLL 策略 1234567891011121314151617181920212223242526272829303132333435363738void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); int sum = 0,cnt = 1; dist[s] = 0; inq[s] = true; deque&lt;int&gt; que; que.push_back(s); while (!que.empty()) &#123; int u = que.front(); que.pop_front(); inq[u] = false; if(dist[u] * cnt &gt; sum)&#123; // LLL que.push_back(u); continue; &#125; sum -= dist[u]; cnt--; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &gt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; // SLF if(dist[i] &lt; dist[que.front()])&#123; que.push_front(v); &#125;else&#123; que.push_back(v); &#125; inq[v] = true; sum += dist[v]; cnt++; &#125; &#125; &#125; &#125;&#125; 复杂度分析设 $V$ 代表结点的个数，$E$ 代表边的个数。 空间复杂度除去邻接表的空间占用，SPFA 算法额外空间开销显然为 $O(V)$ 时间复杂度如果顶点的平均入队次数为 $k$ ，则 SPFA 算法的时间复杂度为 $O(kE)$，对于较为随机的稀疏图，根据经验 $k$ 一般不超过 $4$ 。 SPFA 的本质是 Bellman-Ford 算法的队列优化，本质上没有改变 Bellman-Ford 算法的时间复杂度，对于稠密图来说，SPFA 最坏仍是 $O(VE)$ 的时间复杂度，远差于 Dijkstra 算法的 $O( (V + E) \log V )$ 复杂度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>优先队列</tag>
        <tag>SPFA</tag>
        <tag>Bellman-Ford</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「书摘」《深度探索 C++ 对象模型》（三）]]></title>
    <url>%2F2018%2F12%2F21%2Finside_cpp_obj_model_3%2F</url>
    <content type="text"><![CDATA[Data 语意学 (The Semantics of Data)1234class X &#123;&#125;;class Y : public virtual X&#123;&#125;;class Z : public virtual X&#123;&#125;;class A : public Y, public Z&#123;&#125;; Y 和 Z 的大小与机器（字长）有关，也和编译器有关，具体受以下三个因素的影响： 语言本身所造成的额外负担（overhea） 编译器对于特殊情况所提供的优化处理 Alignment 的限制 class A 的大小由下列几点决定： 被大家共享的唯一一个 class X 实例，大小为 1 byte。 Base class Y 和 Base class Y 的大小，减去“因 virtual base class X 而配置” 的大小，结果式 4 bytes。 class A 自己的大小：0 byte。 class A 的 alignment 数量（如果有的化）。结果为 12 bytes ”特别对 empty virual base class 做了处理“ 的编译器，class X 实例的那 1 byte 将被拿掉，class A 的大小将是 8 bytes。 继承得到的数据的存放顺序，C++标准没有强制定义其间的排列顺序。 Data Member 的绑定 (The Binding of a Data Member)123456789101112extern int x;class Point3d&#123;public: ... // 对于函数本体的分析将延迟，直至 class 声明的右大括号出现才开始。 float X() const &#123; return x; &#125;private: float x; ...&#125;;// 分析在这里进行 member function 的 argument list 会在第一次遭遇时被适当地决议完成。extern 和 nested type names 之间的非直觉绑定操作还是会发生。1234567891011typedef int length;class Point3d&#123;public: void mumble( length val ) &#123; _val = val; &#125; // length 为 int length mumble() &#123; return _val; &#125;private: typedef float length; length _val;&#125;; 采用防御性程序风格改进后123456789101112typedef int length;class Point3d&#123;private: typedef float length;public: void mumble( length val ) &#123; _val = val; &#125; // length 为 float length mumble() &#123; return _val; &#125;private: length _val;&#125;; 请总是把 “nested type 声明” 放在 class 的起始处。 Data Member 的布局 (Data Member Layout)C++ Standard 要求，在同一个 access section（也就是 private。public，protected 等区段）中，members 的排列只需符合“较晚出现的 members 在 class object 中有较高的地址”这一条件即可。 判断哪个 section 先出现的 template function：12345678910template &lt; class class_type, class data_type1, class data_type2 &gt;const char* access_order( data_type1 class_type::*mem1, data_type2 class_type::*mem2 )&#123; assert (mem1 != mem2); return mem1 &lt; mem2 ? "member 1 occurs first" : "member 1 occurs first";&#125; 调用：access_order( &amp;Point3d::z, &amp;Point3d::y ); Data Member 的存取12Point origin;Point *pt = &amp;origin; 12origin.x = 0.0;pt-&gt;x = 0.0; 通过 origin 存取，和通过 pt 存取的差异将在本节得出答案。 Static Data Member每个 static member 的存取许可，以及与 class 的关联，并不会招致任何空间上或执行时间上的额外负担，不论是在个别的 class objects 还是在 static data member 本身。 Nonstatic Data MemberNonstatic Data Member 直接存放在每一个 class object 之中。除非经由显式的（explicit）或隐式的（implicit）class object，否则没有办法直接存取它们。 123456Point 3dPoint 3d::translate( const Point3d &amp;pt)&#123; x += pt.x; y += pt.y; z += pt.z;&#125; 表面上所看到的对于 x,y,z 的直接存取，事实上是经由一个“implicit class object”（由 this 指针表达）完成的。事实上这个函数的参数是：123456Point 3dPoint 3d::translate( Point3d *const this, const Point3d &amp;pt)&#123; this-&gt;x += pt.x; this-&gt;y += pt.y; this-&gt;z += pt.z;&#125; 欲对一个 nonstatic data member 进行存取操作，编译器需要把 class object 的起始地址加上 data member 的偏移位置（offset）。origin._y = 0.0; 会转化为 &amp;origin + (&amp;Point3d::_y - 1);。请注意其中的 -1操作。指向 data member 的指针，其 offset 值总是被加上 1，这样可以使编译系统区分出“一个指向 data member 的指针，用以指出 class 的第一个 member” 和 “一个指向 data members 的指针，没有指出任何 member” 两种情况。 每一个 nonstatic data member 的偏移位置（offset）在编译时期即可获知，甚至如果 member 属于一个 base class subobject（派生自单一或多重继承串链）也是一样的。存取一个 nonstatic data member ，其效率和存取一个 C struct member 或 一个 nonderived class 的 member 是一样的。 Nonstatic Data Member 在虚拟继承中虚拟继承将为“经由 base class subobject 存取 class member“ 导入一层新的间接性：12Point3d *pt3d;pt3d-&gt;_x = 0.0; 其执行效率在 _x 是一个 struct member、一个 class member、单一继承、多重继承的情况下都完全相同。但如果 _x 是一个 virtual base class 的 member ，存取速度会稍慢一点。 origin._y = 0.0; 会转化为 &amp;origin + (&amp;Point3d::_y - 1);当 Point3d 是一个 derived class，而其继承结构中有一个 virtual base class，并且被存取的 member（如本例的 x ）是一个从该 virtual base class 继承而来的 member 时，就会有重大的差异。这时候我们不能说 pt 必然指向哪一种 class type（因此，我们也就不知道编译时期这个 member 真正的 offset 位置），所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。但如果使用 origin ，就不会有这些问题，members 的 offset 位置在编译时期就固定了。 “继承” 与 Data Memberderived class members 和 base class(es) members 的排列顺序，则并未在 C++ Standard 中强制指定；理论上编译器可以自由安排。在大多数编译器上头，base class members 总是先出现，但属于 virtual base class 的除外（一般而言，任何一条通则一旦碰上 virtual base class 就没辙了，这里亦不例外）。 只要继承不要多态 (Inheritance without Polymorphism)一般而言，具体继承（concrete inheritance）相对虚拟继承（virtual inheritance）并不会增加空间或存取时间上的额外负担。 C++语言保证“出现在 derived class 中的 base class subobject 有其完整原样性”。因为要保证 bitwise 拷贝的正确性。 123456class Concrete&#123; int val; char c1; char c2; char c3;&#125;; val 占用 4 bytes； c1、c2和c3 各占用 1 bytes； alignment（调整到 word 边界）需要 1 byte。 12345678910class Concrete1 &#123; int val; char c1;&#125;;class Concrete2 : public Concrete1 &#123; char c2;&#125;;class Concrete3 : public Concrete2 &#123; char c3;&#125;; Concrete1 占用 8 bytes，包括填补用的 3 bytes。 Concrete2 占用 12 bytes，填补 3 bytes。 Concrete3 占用 16 bytes，填补 3 bytes。 加上多态 (Adding Polymorphism)Polymorphism 带来空间和存取时间上的额外负担 导入一个 virtual table，用来存取它所声明的每一个 virtual functions 的地址。这个 table 的元素个数一般而言是被声明的 virtual functions 的个数，再加上一个或两个 slots（用以支持 runtime tyoe identifition）。 在每一个 class object 中导入一个 vptr，提供执行器的链接，使每一个 object 能够找到相应的 virtual table。 加强 constructor，使它能够为 vptr 设定初值，让它指向 class 所对应的 virtual table。这可能意味着在 derived class 和每一个 base class 的 constructor 中，重新设定 vptr 的值。其情况视编译器优化的积极性而定。 加强 destructor，使它能够抹消“指向 class 之相关 virtual table” 的 vptr。vptr 很可能已经在 derived class destructor 中被设定为 derived class 的 virtual table 的地址。destructor 的调用的顺序上反向的：从 derived class 到 base class，一个积极的优化编译器可以压抑那些大量的制定操作。 vptr 放在前端，代价是丧失了 C 语言兼容性。 多重继承 (Multiple Inheritance)…… 虚拟继承 (Virtual Inheritance)虚拟继承的两个问题 每一个对象必须针对其每一个 virtual base class 背负一个额外的指针，然而理想上我们希望 class object 有固定负担，不因为其 virtual base classes 的个数而有所变化。 由于虚拟继承串链的加长，导致间接存取层次的增加。我们希望有固定的存取时间，不因为虚拟派生的深度而改变。 第一个问题两种解决办法： Microsoft 编译器引入的 virtual base class table。 在 virtual function table 中放置 virtual base class 的 offset（不是地址），在 Sun 编译器中，virtual function table 可经由正值或负值来索引，如果是正值索引到 virtual function ，如果是负值索引到 virtual base class offset。 第二个问题，它们经由拷贝操作取得所有的 nested virtual base class 指针，放到的 derived class object 之中。 对象成员的效率 (Object Member Efficiency)聚合（aggregtion）封装（encapsulation）继承（inheritance） 不断加强抽象化程度后，数据的存取效率 优化 未优化 个别的局部变量 0.80 1.42 局部数组 CC 0.80 2.55 NCC 0.80 1.42 struct 之中有 public 成员 0.80 1.42 class 之中有 inline Get 函数 CC 0.80 2.56 NCC 0.80 3.10 class 之中有 inline Get &amp; Set 函数 CC 0.80 1.74 NCC 0.80 2.87 如果把优化开关打开，“封装”就不会带来执行器的效率成本，使用 inline 存取函数亦然。 为什么在 CC 之下存取数组，几乎比 NCC 慢两倍？12345678// CC assembler output# 13 pB[ x ] = pA[ x ] - pB[ x ]; add $25, $sp, 20 1.s $f4, 0($25) addu $24, $sp, 8 1.s $f6, 8($24) sub.s $f8, $f4, $f6 s.s $f8, 0($24) 123456// NCC assembler output# 13 pB[ x ] = pA[ x ] - pB[ x ]; 1.s $f4, 20($25) 1.s $f6, 16($24) sub.s $f8, $f4, $f6 s.s $f8, 0($24) 1.s 加载一个单精度浮点数 s.s 存储一个单精度浮点数 sub.s 将两个单精度浮点数相减 在继承模型之下的数据存取 优化 未优化 单一继承 直接存取 0.80 1.42 使用 inline 函数 CC 0.80 2.55 NCC 0.80 3.10 虚拟继承（单层） 直接存取 1.60 1.94 使用 inline 函数 CC 1.60 2.75 NCC 1.60 3.30 虚拟继承（双层） 直接存取 CC 2.25 2.74 NCC 3.04 3.68 使用 inline 函数 CC 2.25 3.22 NCC 2.50 3.81 指向 Data Member 的指针 (Pointer to Data Members)1234567class Point3d&#123;public: virtual ~Point3d(); static Point3d origin; float x, y, z;&#125;;&amp;Point3d::z // 得到 z 在 class object 中的 offset 输出 offset123printf("%p\n",&amp;Point3d::x);printf("%p\n",&amp;Point3d::y);printf("%p\n",&amp;Point3d::z); 早期一些编译器 &amp;Point3d::z 这个操作的值为 z 的 offset + 1。123float Point3d::*p1 = 0;float Point3d::*p2 = &amp;Point3d:x;// Point3d::* 的意思是 "指向 Point3d data member" 的指针类型 1234if(p1 == p2) &#123; cout &lt;&lt; " p1 &amp; p2 contain the same value -- "; cout &lt;&lt; " they must address the same member!" &lt;&lt; endl;&#125; 对 offset 加 1，方便区分 NULL 和第一个 data member。 1234567891011121314151617struct Base1&#123; int val1; &#125;;struct Base2&#123; int val2; &#125;;struct Derived : Base1, Base2&#123;&#125;;void func1( int Derived::*dmp, Derived *pd)&#123; pd-&gt;*dmp;&#125;void func2( Derived *pd)&#123; // bmp 为 1 int Base2::*bmp = &amp;Base2::val2; // bmp == 1 // 但在 Derived 中， val2 == 5 func1(bmp,pd);&#125; 12// 经由编译器内部转换func1( bmp + sizeof( Base1 ), pd ); 一般而言，我们不能够保证 bmp 不是 0，因此必须注意这一点：1func1( bmp ? bmp + sizeof( Base1 ) : 0, pd ); 我的测试程序：1234567891011121314151617181920212223242526272829struct Base1&#123; int val1; &#125;;struct Base2&#123; int val2; &#125;;struct Derived : Base1, Base2&#123;&#125;;int func1( int Derived::*dmp, Derived *pd)&#123; printf("%p\n",dmp); return pd-&gt;*dmp;&#125;int func2( Derived *pd)&#123; int Base2::*bmp = &amp;Base2::val2; printf("%p\n",bmp); return func1(bmp,pd);&#125;int main()&#123; Derived xx; xx.val1 = 11; xx.val2 = 22; cout &lt;&lt; func2(&amp;xx) &lt;&lt; endl; return 0;&#125; “指向 Data Member 的指针” 的效率问题存取 Nonstatic Data Member 优化 未优化 直接存取 0.80 1.42 指针指向已绑定的 Member 0.80 3.04 指针指向 Data Member CC 0.80 5.34 NCC 4.04 5.34 “指向 Data Member 的指针”存取方式 优化 未优化 没有继承 0.80 5.34 单一继承（三层） 0.80 5.34 虚拟继承（单层） 1.60 5.44 虚拟继承（双层） 2.14 5.51 在两个编译器中，每次存取 Point::x，像这样： pB.*bx 会被转换为：1&amp;pB-&gt;__vbcPoint + ( bx - 1 ) 而不是转换为最直接的：1&amp;pB + ( bx - 1 ) 额外的间接性会降低“把所有的处理都搬移到寄存器中执行”的优化能力。]]></content>
      <categories>
        <category>泛 - 书摘</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」《Effective C++》 读书笔记（三）]]></title>
    <url>%2F2018%2F12%2F19%2Feffective-cpp03%2F</url>
    <content type="text"><![CDATA[注意！这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。 资源管理条款 13：以对象管理资源123456void f()&#123; Investment* pInv = creteInvestment(); // 调用 factory 函数 ... delete pInv; // 释放 pInv 所指对象&#125; ... 可能存在过早的 return 语句，或抛出某些异常，delete 语句将不会被执行。类似的 goto 语句或循环中的 continue 和 break。 使用智能指针，利用栈中对象的析构函数自动对其 delete。 123456void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); ...&#125; 获得资源后立刻放进管理对象（managing object） 管理对象（managing object）运用析构函数确保资源被释放 常使用的 RAII classes ：tr1::shared_ptr 和 auto_ptr 。 条款 14：在资源管理类中小心 copying 行为12345678910111213class Lock&#123;public: explicit Lock(Mutex* pm) : mutexPtr(pm) &#123; lock(muterPtr); &#125; ~Lock() &#123; unlock(mutexPtr); &#125;private: Mutex *mutexPtr;&#125; 1234Mutex m;Lock ml1(&amp;m);Lock ml2(ml1); RAII classes 应被禁止复制或采用“引用计数法（reference-count）”。 禁止复制1234class Lock: private Uncopyable&#123; ...&#125; “引用计数法”（reference-count）123456789class Lock&#123;public: explicit Lock(Mutex* pm) : mutexPtr(pm, unlock) &#123; lock(muterPtr.get()); &#125;private: std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;&#125; 进行“深度拷贝”，复制底部资源 转移底部资源的拥有权，如：auto_ptr Coping 函数包括 copy 构造函数和 copy assignment操作符。 条款 15：在资源管理类中提供对原始资源的访问每个 RAII class 应该提供一个 “取得其所管理之资源” 的方法。对原始资源的访问可能经由显式转换或隐式转换。显式转换比较安全，但隐式转换对客户比较方便。 条款 16：成对使用 new 和 delete 时要采取相同形式使用 new 要严格搭配 delete，如使用 delete[] 为未定义的行为，可能多次调用析构函数。使用 new[] 要严格搭配 delete[]。谨慎对数组类型 typedef 。 条款 17：以独立语句将 newed 对象置入智能指针12int priority();void processWidget(std::tr1::shared_ptr&lt;Widget&gt;, priority()); 12345processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());// 进入函数前做了以下三件事// 执行 "new Widget"// 调用 tr1::shared_ptr 构造函数// 调用 priority() 编译器对这三件事的完成次序上弹性很大。如在 priority() 抛出了异常，new Widget 返回的指针将可能遗失，因为它尚未被置入 std::tr1::shared_ptr 内。 避免这类问题只需分离语句，控制执行顺序。12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority);]]></content>
      <categories>
        <category>泛 - 笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>读书</tag>
        <tag>笔记</tag>
        <tag>Effective C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「书摘」《自控力》]]></title>
    <url>%2F2018%2F12%2F12%2Fbooks-1%2F</url>
    <content type="text"><![CDATA[我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？ 研究表明，自诩意志坚定的人反而最容易在诱惑面前失控。比如，自信能抵制诱惑的戒烟者最容易在4个月后故态复萌，过于乐观的节食者最不容易减肥成功。这是为什么呢？因为他们无法预测自己在何时何地、会由于何种原因失控。 每个人都在以某种方式抵制诱惑、癖好、干扰和拖延。这不是个体的弱点或个人的不足，而是普遍的经验，是人所共有的状态。 “说不”属于意志力的一部分，而且是不可或缺的一部分。 牢记自己真正想要的是什么 前额皮质并不是挤成一团的灰质，而是分成了三个区域，分管“我要做”“我不要”和“我想要”三种力量。 如果没有了欲望，人们就会变得沮丧；如果没有了恐惧，人们就没法保护自己、远离伤害。 在意志力挑战中获胜的关键，在于学会利用原始本能，而不是反抗这些本能。 注意力分散的人更容易向诱惑屈服。 如果你想有更强的自控力，就得有更多的自我意识。 只要她能意识到自己在做什么，就有可能停下来。 观察自己究竟是怎样屈服于冲动的。 神经学家发现，如果你经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你集中注意力、管理压力、克制冲动和认识自我的能力。一段时间之后，你的大脑就会变成调试良好的意志力机器。 不仅要关注自己能否将注意力集中到呼吸上，还要注意观察，这种训练在其他时候是否影响了你的选择。 在冥想训练里做的事正是他在生活中也要面对的——把自己的注意力收回，专注于最初的目标。（在冥想训练中，目标就是专注呼吸。） 意志力的本能：人生来就能抵制奶酪蛋糕的诱惑 自控力不仅和心理有关，更和生理有关。只有在大脑和身体同时作用的瞬间，你才有力量克服冲动。 应激反应是一种管理能量的本能，这种本能决定了你将如何利用有限的体力和脑力。 我们总觉得诱惑和麻烦来自外部世界，比如危险的甜甜圈、罪恶的香烟、充满诱惑的网络。但自控力告诉我们，问题出在我们自己身上，是我们的思想、欲望、情绪和冲动出了问题。 “三思而后行”反应和应激反应有一处关键的区别：前者的起因是你意识到了内在的冲突，而不是外在的威胁。 最有效的做法就是先让自己放慢速度，而不是给自己加速（比如应激反应）。“三思而后行”反应就是让你慢下来。当你意识到内在冲突的时候，大脑和身体会做出反应，帮助你放慢速度、抑制冲动。 当人们感到压力时，交感神经系统会控制身体。这种生理学现象让你能够战斗或者逃跑。心率升高，心率变异度就会降低。此时，由于伴随应激反应产生的焦虑或愤怒，心率会被迫保持在较高的水平上。相反，当人们成功自控的时候，副交感神经系统会发挥主要作用，缓解压力，控制冲动行为。心率降低，心率变异度便会升高。此时，人们能更好地集中注意力并保持平静。 心率变异度较高的人能更好地集中注意力、避免及时行乐的想法、更好地应对压力。 有很多因素会影响到意志力储备，比如你吃什么（以植物为原材料的、未经加工的食物有助于提高心率变异度，垃圾食品则会降低心率变异度）或是住在哪里（糟糕的空气质量会降低心率变异度）。任何给你的身心带来压力的东西都会影响自控力的生理基础，甚至会摧毁你的意志力。焦虑、愤怒、抑郁和孤独都与较低的心率变异度和较差的自控力有关。慢性疼痛和慢性疾病则会消耗身体和大脑的意志力储备。 将呼吸频率降低到每分钟4-6次，也就是每次呼吸用10-15秒时间，比平常呼吸要慢一些。只要你有足够的耐心，加上必要的练习，这一点不难办到。放慢呼吸能激活前额皮质、提高心率变异度，有助于你的身心从压力状态调整到自控力状态。这样训练几分钟之后，你就会感到平静、有控制感，能够克制欲望、迎接挑战。 滥用药物或患有创伤后应激障碍症的成年人，每天进行20分钟放慢呼吸的练习，就能提高心率变异度，降低欲望和抑郁程度。 锻炼能提高心率变异度的基准线，从而改善自控力的生理基础。 改善心情、缓解压力的最有效的锻炼是每次5分钟，而不是每次几小时。 任何能让你离开椅子的活动，都能提高你的意志力储备。 如果你觉得锻炼太累了，或是没有时间锻炼，那么不妨将锻炼当做恢复体能和意志力的方法。 长期睡眠不足让你更容易感到压力、萌生欲望、受到诱惑。你还会很难控制情绪、集中注意力，或是无力应付“我想要”的意志力挑战。 如果睡眠不足的人补上一个好觉，他的前额皮质就会恢复如初。实际上，他的大脑和休息良好的人的大脑会完全一样。 如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。 自控需要大量能量，很多科学家都认为，长时间的自控就像慢性压力一样，会削弱免疫系统的功能，增大患病的概率。 正如适度的压力是有意义的健康生活不可缺少的一部分，适当的自控也是必需的。但是正如慢性压力会影响健康一样，试图控制所有的思想、情绪和行为也是一剂毒药，会给你带去过重的生理负担。 为了能够保持健康、维持幸福生活，你需要放弃对意志力的完美控制。 从压力和自控力中恢复的最佳途径就是放松。放松，即便只放松几分钟，都能激活副交感神经系统，舒缓交感神经系统，从而提高心率变异度。它还能把身体调整到修复和自愈状态、提高免疫功能、降低压力荷尔蒙分泌。 能提高意志力的“放松”是真正意义上的身心休整。哈佛医学院心脏病专家赫伯特·本森（Herbert Benson）称之为“生理学放松反应”。你的心率和呼吸速度会放缓，血压会降低，肌肉会放松。你的大脑不会去规划未来，也不会去分析过去。想要激发这种放松反应，你需要躺下来，用枕头垫着膝盖，腿稍稍抬起（或者，你可以选择任何一个你觉得舒服的姿势）。闭上眼睛，做几次深呼吸，感觉你的腹部有起伏。如果你觉得身体某处很紧张，你可以有意识地挤压或收缩肌肉，然后就不要再去管它了。比如，如果你发现手掌和手指很紧张，那么就攥一下拳头，然后张开手掌。如果你发现前额和下巴很紧张，那么就挤挤眼、皱皱眉，然后张大嘴巴，放松整个面部。保持这种状态5-10分钟，试着享受这种除了呼吸什么都不用想的状态。如果你担心会睡着，那就先设定好闹钟。 意志力是一种不断进化的能力，是每个人都有的本能。它详细地记录了身体和大脑的状态。 意志力会受到多方面的影响，比如睡眠不足、饮食不良、久坐不动和各种消耗能量的事情，或是身心长期处于压力状态之下。 从长远的角度看，没有什么比压力更消耗意志力了。压力和自控的生理学基础是互相排斥的。 压力让你关注即时的、短期的目标和结果，自控力则需要你的大脑有更广阔的视野。 学会如何更好地管理压力，是提高意志力的重要组成部分。 儿童多动症的概率急剧攀升很可能和这种睡眠习惯有关，因为儿童往往受成人睡眠习惯的影响，而且儿童需要更多的睡眠。 我们的坏习惯（比如过度饮食和睡眠不足）不仅反映了我们缺乏自控力，还消耗了我们的体力，带来了更多的压力，偷走了我们的自控力。 当我们面对的意志力挑战过于强大时，我们很容易给自己下这样的结论——我是个软弱、懒惰、毫无意志力的废物。但通常的情形是，我们的大脑和身体并未处于自控状态。当我们处在慢性压力中时，迎接意志力挑战的是最冲动的自己。想要赢得意志力挑战，我们需要调整到正确的身心状态，用能量去自控，而不是自卫。这就意味着，我们需要从压力中恢复过来，保证有能量做最好的自己。 意志力是种生理本能，它和压力一样，通过不断进化来保护我们不受自身伤害。 累到无力抵抗：为什么自控力和肌肉一样有极限？ 似乎我们只有一定量的意志力，一旦你将它消耗殆尽，你在诱惑面前就会毫无防备力，至少会处于下风。 人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。 时间过长，注意力训练就不仅会分散注意力，还会耗尽身体的能量。控制情绪不仅会导致情绪失控，还会促使人们购买他们本不需要的东西。抵抗甜食的诱惑不仅会让人更想吃巧克力，还会导致拖延症。 资源不足时，大脑会选择满足当下的需求；资源充足时，大脑则会转向选择长期的投资。 更好的方法是保证你的身体有足够的食物供应，这样能给你更持久的能量。大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。 这些研究中训练的“肌肉”不是为了让你在规定期限前完成任务、用左手开门或不说脏话，而是让你养成习惯、关注自己正在做的事情、选择更难的而不是最简单的事。通过每一次意志力练习，大脑开始习惯于三思而后行。 我们总是在意志力真正耗尽之前就感到无法坚持了。从某种程度上说，我们应该感谢大脑帮助我们保存能量。正如大脑担心体能枯竭时会告诉肌肉放慢速度一样，大脑也会对大量消耗前额皮质中能量的活动喊“停”。这并不意味着我们用光了意志力，我们只是需要积攒使用意志力的动力罢了。 知道我们的意志力比想象中多得多，这确实是件令人开心的事。或许我们也可以像运动员一样，挺过意志力消耗殆尽的感觉，冲过意志力挑战的终点。 容忍罪恶：为何善行之后会有恶行？ 心理学家一直认为，当你表达一种态度时，你更可能按这种准则行事。毕竟，谁愿意做伪君子？但普林斯顿的心理学家揭示了一个例外，这和我们对表里如一的渴望背道而驰。当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。 明确驳斥性别歧视和种族歧视言论的学生，觉得自己已经获得了道德许可证。他们已经向自己证明了，他们没有性别歧视或种族歧视。这就让他们在心理学家所谓的“道德许可”（moral licensing）面前不堪一击。当你做善事的时候，你会感觉良好。这就意味着，你更可能相信自己的冲动。而冲动常常会允许你做坏事。 “道德许可”不仅会批准我们做坏事，也会让我们错失做善事的机会。 如果你去锻炼了就说自己很“好”，没去锻炼就说自己很“坏”，那么你很可能因为今天去锻炼了，明天就不去了。如果你去处理了一个重要项目就说自己很“好”，拖延着不去处理就说自己很“坏”，那么你很可能因为早上取得了进步，下午就变懒散了。简单说来，只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。 任何让你对自己的美德感到满意的事，即便只是想想你做过的善事，都会允许我们冲动行事。 “道德许可”最糟糕的部分并不是它可疑的逻辑，而是它会诱使我们做出背离自己最大利益的事。 不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。 大部分人认为，取得进步会刺激我们获得更大的成功。但心理学家知道，我们总是把进步当做放松的借口。 芝加哥大学商学院研究生院的教授阿耶莱特·费什巴赫（Ayelet Fishbach）和耶鲁大学管理学教授拉维·多尔（Ravi Dhar）已经证明了，在完成某个目标过程中取得的进步，会刺激人们做出妨碍完成目标的行为 应该想着“我做这件事是因为我想要……” 有时候，大脑会对能完成目标的可能性感到兴奋，它错把可能性当成真正完成了目标。 对未来的乐观主义精神，不仅会影响我们自己的决定，还会影响我们究竟会不会按自己所说的去做。心理学家已经证明了，我们错误地认为自己明天会比今天有更多的空闲时间。 人们是为理想世界作出预估，却在现实世界生活了两周。 当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。 你明知道应该做一件事情却拖延不做时，不要问自己“我是想今天做还是明天做？”，而要问自己“我是不是想承担永远拖延下去的恶果？” 研究表明，选择健康主食的人，通常会在饮料、配菜和甜点上纵容自己。 托儿所会让晚接孩子的父母交罚款，但这种制度实际上增加了晚接孩子的概率。家长可以购买晚接孩子的权利，以此来消除自己的罪恶感。 从本质上看，道德许可就是一种身份危机。我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。 在追求自控的过程中，我们不应该把所有的意志力挑战都放在道德标准的框架中。我们总是轻易地认为，自己做过的善行，或是仅仅考虑要去做的善行，给了我们道德上的许可。如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。 明天和今天毫无区别。当你想改变行为的时候，试着减少行为的变化性，而不是减少某种行为。 取消许可，牢记理由。下一回，当你发现自己在用曾经的善行为放纵辩护的时候，停下来想一想你做“好”事的原因，而不是你应不应该得到奖励。 大脑的弥天大谎：为什么我们误把渴望当幸福 多巴胺会告诉大脑其他的部分它们需要注意什么，怎样才能让贪婪的我们得手。大量的多巴胺并不能产生快乐的感觉，那种感觉更像是一种激励。我们会觉得警醒、清醒、着迷。我们发现了如何才能得到快乐，而且愿意为了获得这种感觉付出努力。 这些设备就这样俘获了我们，让我们不断要求更多。在我们所处的时代里，奖励的承诺可以用我们上网时的行为来打比方——我们搜索，再搜索，搜索更多的。我们点击鼠标，就像笼子里的小白鼠想再感受一次电击一样。我们追寻着难以捉摸的奖励，直到最终觉得满意。 手机、互联网和其他社交媒体可能是无意中激活了我们的奖励系统，但电脑和电子游戏的设计者是有意识地控制了人们的奖励系统，让玩家上钩。“升级”和“获胜”随时可能出现，游戏就这样激发了人们的兴趣。这也是人们很难戒掉游戏的原因。 2005年，28岁的韩国锅炉修理工李承生在连续50个小时奋战“星际争霸”之后死于心血管衰竭。他不吃不睡，只想继续玩游戏。听到这件事的时候，我们很难不联想到奥尔兹和米尔纳实验中力竭而亡的小白鼠。 多巴胺在我们上瘾时会发挥某些作用。最令我们吃惊的是它在帕金森患者治疗过程中发挥的作用。帕金森症是一种常见的神经退化性疾病，病因是脑细胞中缺少多巴胺。多巴胺在刺激行为中起的作用主要表现在：减缓或减少运动、抑郁以及间歇性紧张症。标准的帕金森治疗方式是同时服用两种药物：左旋多巴和多巴胺受体激动剂。前者可以帮助大脑产生多巴胺，后者能刺激大脑中的多巴胺腺体，模仿多巴胺的行为。当病人刚开始接受药物治疗时，大脑中多巴胺的含量会比往常多。这就减轻了帕金森的主要症状，但同时带来了难以预料的新问题。 当多巴胺给我们的大脑安排寻找奖励的任务时，我们就展现了自己最敢于冒险、最冲动、最失控的一面。 更重要的是，如果奖励迟迟没有到来的话，奖励的承诺（和一想到要停下来就不断增长的焦虑）足以让我们一直上瘾。如果你是实验室里的小白鼠，你就会一次次地去按杠杆，直到力竭而亡或被饿死。如果你是人类，你就会掏空钱包、填满肚子——这还是好的。如果严重的话，你会发现自己患上了强迫症。 当奖励的承诺释放多巴胺的时候，你更容易受到其他形式的诱惑。 大量分泌的多巴胺会放大“及时行乐”的快感，让你不再关心长期的后果。 如果你咬了一口店里新推出的肉桂卷，你就会发现自己又往购物车里多放了几件东西。即便你抵挡住了样品的诱惑，你也会因为大脑释放了更多的多巴胺而去寻找一些东西，以满足你奖励的承诺。 大脑的奖励系统对新鲜感和多样性也会有反应。你的多巴胺神经元会对熟悉的奖励反应较少 虽然我们所处的世界总让我们产生欲望，但我们只要用心观察，就能看透一些东西。知道那是怎么一回事并不能完全消除你的欲望，但它能让你至少有机会抗争一下，锻炼一下“我不要”力量。 我们的奖励系统面对可能获得的大奖会更加兴奋。它会促使我们去做任何可能获奖的事。这就是为什么人们宁愿买乐透彩票，也不愿意把钱存到银行里 我的学生通过使用音乐、时尚杂志和电视，让自己在做通常会推迟的任务时，产生更多多巴胺，帮助他们找到了解决办法，比如带上可怕的文书工作走进自己喜欢的咖啡厅，边喝热巧克力边完成工作，或是极富创意地买一堆刮刮乐彩票，把它们放在你想拖延的项目周围。还有一些人想象自己努力工作后取得的最佳结果，让未来的奖励显得更加真实。如果有什么事让你觉得很不愉快，所以你总是拖延着不去做，你能不能把它和能让多巴胺神经元燃烧的事联系在一起，从而促使自己去做呢？ 如果我们能够停下来观察一下，自己在有所渴望的时候，大脑和身体中究竟发生了什么事情，我们就会发现，奖励的承诺带给我们的压力和快乐几乎不分上下。渴望并不是总能让我们感觉良好。有时候，它会让我们觉得自己堕落了。这是因为，多巴胺的首要功能是让我们追求快乐，而不是让我们快乐。它并不介意给我们来点压力，即便这会让我们在追求快乐的时候觉得不快乐。 大部分人会更关注对快乐的承诺，而不关注多巴胺刺激欲望时感觉到的不快乐。 我们误把渴望的感觉当做了快乐的保证。 我们误以为的快乐源泉，其实正是痛苦的根源。 当我们的奖励系统平静下来时，我们并不会感到满足，而更可能表现得冷漠。这就是为什么很多帕金森病人会觉得抑郁，而不是安宁，因为他们的大脑无法产生足够的多巴胺。 我们需要奖励的承诺，让我们保持对生活的兴趣，并继续生活下去。如果我们幸运的话，奖励系统会继续这样为我们服务下去。同时，我们也希望它不要和我们作对。我们所处的世界充满了科学技术、广告和各种各样的机会，我们总是产生欲望，却很少得到满足。如果我们想拥有自控力，就需要区分让我们的生活有意义的真实奖励，和让我们分散精力、上瘾的虚假奖励。学会区分这两种奖励，也许是我们能做到的最好的事了。 欲望没有绝对的好坏之分，重要的是欲望将我们引向哪个方向，以及我们是否足够明智，知道什么时候该听从欲望的声音。 “那又如何”：情绪低落为何会使人屈服于诱惑？ 在研究压力、焦虑、罪恶感对自控力的影响时，我们发现，情绪低落会使人屈服，而且经常是以令人吃惊的方式屈服。令人恐惧的吸烟警示会让烟民更渴望香烟，经济危机会让人更想购物，晚间新闻会让人吃得更多。 当你感到压力时，你的大脑就会指引着你，让你去做它认为能带给你快乐的事情。 神经科学家证明了，压力包括愤怒、悲伤、自我怀疑、焦虑等消极情绪，会使你的大脑进入寻找奖励的状态。只要你的大脑和奖励的承诺联系起来，你就会渴望得到那个“奖励”。 奖励的承诺和缓解压力的承诺会导致各种各样不合逻辑的行为。比如，一项经济学研究发现，那些对自己的经济状况表示担忧的女性，会通过购物来排解内心的焦虑和压抑。 有效和无效的策略最主要的区别是什么？真正能缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质，如血清素、γ-氨基丁酸和让人感觉良好的催产素。这些物质还会让大脑不再对压力产生反应，减少身体里的压力荷尔蒙，产生有治愈效果的放松反应。 根据“恐惧管理”理论，当人类想到自己的死亡时，很自然会觉得害怕。我们可以暂时避开危险，但终究逃不过宿命。每当我们想起自己不可能永生时（比如，看晚间新闻的时候，每29秒我们就会有一次这样的想法），大脑就会产生恐惧的反应。我们并非总能意识到这一点，因为焦虑可能还没有浮出水面，还没有产生强烈的不适感，或者我们并不知道这是为什么。即使我们意识不到这种恐惧，它还是会让我们立即作出回应，对抗自己的无力感。我们会去寻找保护伞，寻找任何能让自己觉得安全、有力量、得到安慰的东西 研究发现，当我们意识到自己不会永生时，我们会更容易屈服于各种诱惑，就像是在奖励和减压的承诺里寻找希望和安全感一样。 一项调查发现，新闻中的死亡报道会让观众对豪华轿车、劳力士手表等彰显身份地位的东西产生更积极的回应。这并不是说，我们认为一块劳力士手表就能让自己不被导弹打中，而是这些商品提升了我们的自我形象，让我们感到充满力量。对很多人来说，购物是让自己更乐观、更有掌控感的快速途径。这就是美国人为什么在“9·11”事件后如此愿意接受小布什总统的提议：“我和我夫人鼓励美国人购物。” “恐惧管理”的方法能让我们不去想那个不可避免的死亡。但当我们在诱惑中寻找慰藉的时候，我们是在不自觉地加速迈向坟墓的脚步。 有时候，“恐惧管理”带来的不是诱惑，而是拖延。我们最想拖延的很多事情，都和死亡有或多或少的关联，比如预约看医生，按处方开药，遵医嘱服药，保管法律文件和写遗嘱，存钱养老，甚至是扔掉自己绝不会用到的东西和不合身的衣服。 远离那些会让你产生恐惧的电视新闻、访谈节目、杂志或网页。 毫无意外，头天晚上喝了太多酒的人第二天早上会感到痛苦，会觉得头疼、恶心、疲倦。但他们的痛苦不仅仅源于宿醉。很多人还感到罪恶和羞愧。这才是真正让人感到困扰的。当被试者因为前一晚饮酒过量而情绪低落时，他们更可能在当天晚上或以后喝更多的酒。罪恶感驱使他们再度饮酒。 屈服会让你对自己失望，会让你想做一些改善心情的事。那么，最廉价、最快捷的改善心情的方法是什么？往往是做导致你情绪低落的事。 关键是，导致更多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。一旦你陷入了这样的循环，似乎除了继续做下去，就没有别的出路了。当你（又一次）责备自己（又一次）屈服于诱惑的时候，往往会带来更多意志力的失效，造成更多的痛苦。但是，你寻求安慰的东西并不能中断这个循环，它只会给你带来更深切的罪恶感。 我们可能会想，罪恶感会促使我们改正错误，但其实这正是“情绪低落让我们屈服于诱惑”的另一个表现方式。 众多研究显示，自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。它不仅耗尽了“我要做”的力量，还耗尽了“我想要”的力量。相反，自我同情则会提升积极性和自控力，比如，在压力和挫折面前支持自己、对自己好一些。 出人意料的是，增强责任感的不是罪恶感，而是自我谅解。研究人员发现，在个人挫折面前，持自我同情态度的人比持自我批评的态度的人更愿意承担责任。他们也更愿意接受别人的反馈和建议，更可能从这种经历中学到东西。 自我谅解能帮助人们从错误中恢复过来，因为它能消除人们想到失败时的羞愧和痛苦。 如果你觉得遇到挫折意味着你将一事无成、只会把事情搞糟，那么反思这个挫折只会让你在痛苦中更讨厌自己。你最紧迫的目标是安抚这种感觉，而不是吸取教训。 你只是个凡人。每个人都会遇到意志力挑战，每个人都有失去自控的时候。这只是人性的组成部分，挫折并不意味着你本身有问题。想一想这些说法是不是真的。你能想象你尊敬、关心的其他人也经历过同样的抗争和挫折吗？这个视角会让自我批评和自我怀疑的声音变得不那么尖锐。 压力会引起欲望，让我们的大脑更容易受到诱惑。如果有东西提醒我们不能永生，就会让我们从食物、购物或香烟中寻找慰藉。那么罪恶感和自我批评呢？它们会让你立刻想到“那又如何，我还不如再放纵一下自己呢”。 发誓改变会让我们充满希望。我们喜欢想象改变后的生活，幻想改变后的自己。研究显示，节食计划会让人感觉更有力量，运动计划会让人觉得自己更高大。（当然，这些幻想不一定会实现。） 不幸的是，就像奖励的承诺和缓解压力的承诺一样，改变的承诺也很少能朝我们希望的方向发展。不切实际的乐观可能给我们一时的快乐，但接下来我们就会感到失落。 当我们第一次面对挫折时，失望就会取代最初决定改变时的良好感觉。没能达到预期目标会再度引发曾经的罪恶感、抑郁和自我怀疑，而承诺改变的情绪慰藉作用也消失了。这时，大多数人会彻底放弃努力。只有当我们感觉失控，需要再次拥有希望的时候，我们才会再次发誓作出改变。于是，这个循环又开始了。 我们需要相信，改变是可能做到的。如果失去了希望，我们就会听天由命了。但是，我们必须避免常见的意志力陷阱，即用“改变的承诺”而不是“改变”来改善我们的心情。否则，这种看似意志力的东西就会把我们变成按压杠杆的小白鼠，觉得这个东西能让我们获得奖励。 乐观给我们动力，但少许的悲观能帮我们走向成功。研究发现，如果能预测自己什么时候、会如何受到诱惑和违背承诺，你就更有可能拥有坚定的决心。 为了避免压力导致的意志力失效，我们需要找到能让我们真正快乐的东西，而不是虚假的奖励承诺，也不是空洞的改变承诺。我们需要允许自己去做真正让自己快乐的事，远离那些与我们生活无关的压力根源。当我们遭遇挫折时（这种情况是难以避免的），我们需要原谅曾经的失败，不要把它们作为屈服或放弃的借口。想要增强自控力，自我同情比自我打击有效得多。 出售未来：及时享乐的经济学 如果我们处在最佳状态，人类控制冲动的能力让其他物种自惭形秽。但通常情况下，我们想象力丰富的大脑不会作出最有战略性的决定，而是让我们表现得像是失去了理性。这是因为，前额皮质最擅长的不是自控。它会为错误的决定寻找借口，向我们承诺明天会更好。你可以肯定，那些黑猩猩不会对自己说：“我现在要吃2颗葡萄，因为我还有下一次可以等着吃6颗葡萄。”但人类总有各种各样的花招，让自己相信抵抗诱惑是明天的事情。因此，拥有巨大前额皮质的我们，会一再屈服于即刻的满足感。 为了迅速得到瞬间的快感，他们忘记了自己真正想要的东西。 经济学家称之为“延迟折扣”。也就是说，等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。 当诱惑真实存在时，我们的大脑就进入了“搜寻奖励”模式，确保我们不会错过任何奖励。 当我们和诱惑正面交锋的时候，我们只愿意选择短期的、即时的奖励，这种欲望是无可抵挡的。这就带来了“有限意志力”。也就是说，到我们真的需要自控力之前，我们一直拥有自控力。 我们在权衡“即时奖励”和“未来奖励”时，大脑处理选项的方式相当不一样。“即时奖励”会激活更古老、更原始的奖励系统，刺激相应的多巴胺产生欲望。“未来奖励”则不太能激活这个奖励系统。 对那些想延迟快感的人来说，这是个好消息。只要你能创造一点距离，就会让拒绝变得容易起来。 当他对自己的欲望直截了当地说“不”时，那句“好，但要等10分钟”减少了一部分的恐惧和压力，让他等起来更轻松。几次之后，他就能转移注意力，忘掉吸烟的冲动了。 当你觉得自己无法做到“不会有下一次”的时候，不妨用“10分钟延迟法则”来增强你的自控力。 1231. 当你受到诱惑要做与长期利益相悖的事时，请想象一下，这个选择就意味着，你为了即时的满足感放弃了更好的长期奖励。2. 想象你已经得到了长期的奖励。想象未来的你正在享受自控的成果。3. 然后扪心自问：你愿意放弃它，来换取正在诱惑你的短暂快感吗？ 大脑会把未来的自己当成别人，这种习惯对自控力影响极大。研究发现，当你想到未来的自己时，大脑中越是想不到自己，你就越可能对未来的自己说“去你的”，也就越可能对即时的满足感说“好”。 当我们思考未来时，我们能预测到未来的自己和想象中有什么不同。未来的奖励似乎并不那么有诱惑力，所以我们选择了即时的满足感。我们无法预测自己会怎么受到诱惑、怎么被分散注意力，所以我们无法坚定自己的目标。如果我们想作出更明智的决定，就要更好地理解和支持未来的自己。我们还需要记住，为现在的行为承担后果的，看似是未来的自己，实际上还是我们自己。未来的自己会对我们现在的付出感激不尽。 传染：为什么意志力会传染？ 意志力薄弱可能会传染，但你仍然可以获得自控力。 我们有模仿别人行动的本能，这就意味着，当你看到别人去拿零食、饮料或信用卡的时候，你自己也会无意识地模仿他们的行为。同时，你也会失去自己的意志力。 当我们想象别人想要什么的时候，他们的欲望就会引发我们的欲望，他们的食欲也会引发我们的食欲。 有时候，我们感染的不是某种具体的目标，比如吃零食、花钱、诱惑陌生人，而是和我们的冲动一致的、更普遍的目标。 人们感染的目标是做自己想做的事，而不是自己应该做的事。 为什么在关系密切的人中间，行为会传染得这么严重呢？我们可以用免疫系统作个类比。只有当免疫系统发现那些人“和我们不同”时，它才会拒绝他们的目标和行为。毕竟，我们体内的免疫系统不会攻击自身的细胞。只要它能辨别出那是自己的东西，它就不会作出任何反应。 当我们想到我们喜爱、尊重的人和感觉相似的人时，我们的大脑会像对待自己一样对待他们，而不会把他们视为“别人”。 当他们认识到自己的行为与信仰不符时，鼓励他们去制订改变行为的计划。相信好的基督徒应该减肥和锻炼身体，这是强有力的“社会认同”，远比检测出高胆固醇后医生的严厉警告来得有效。 如果我们想让别人更有意志力，就要让他们相信自控是个社会规范。 2010年《内科医学档案》中的一份报告指出，有37%的人在被临床诊断为肥胖后，不仅认为自己并不胖，还相信自己变胖的风险很低。 在说到“社会认同”的时候，我们认为别人做的事比别人实际做的更重要。比如，大学生对身边同学普遍作弊的情况估计过高。要想知道一个学生有没有作弊，要看他是否相信别人也在作弊，而不是看作弊的惩罚是否严厉，也不是看他是否认为自己会被抓。当他们相信自己的同学作了弊时，原本诚实的班级也会变成所有学生都在考试中发短信、传答案的班级。（是的，我曾抓到一个学生抄别人答案。） 如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。 自豪和羞愧依赖大脑皮层的情绪区，而不是用来作逻辑分析的前额皮层。社会情感可能进一步帮助我们作出选择，让我们在自己的群体里站稳脚跟。 实验研究发现，表现出内疚感会减少心率的变化，降低意志力的生理储备。反之，自豪感会保持甚至增加这种储备。 为了让自豪感发挥作用，我们必须认为别人都在监视自己，或我们有机会向别人报告自己的成功。 让自己坚定决心的有效策略是——公开你的意志力挑战 研究显示，人一旦被踢出群体，意志力就会耗竭。举个例子，当人们被社会拒绝时，他们就很难抵制新鲜出炉的曲奇饼干，面对具有挑战性的任务会很快放弃，在需要精神集中的实验里也更容易分心。 研究也显示，少数族群越是受到歧视，自我控制能力就越差。这只是提醒少数族群，歧视会耗尽他们的意志力。只要我们觉得被排斥或被冒犯，我们就有可能屈服于自己最糟糕的冲动。 值得注意的是，我们的大脑会把别人的目标、信念和行为整合到自己的决策中。当我们跟别人在一起时，或者只是简单地想到他们时，在我们的脑海里，别人就会成为另一个“自我”，并且和“自我”比赛自控。反之亦然：我们的行为也影响了其他无数人，我们做的每个选择对别人来说也是一种鼓舞或诱惑。 别读这章：“我不要”力量的局限性 没法不去想白熊，这或许不是最糟糕的意志力失效的案例。但正如我们所见，越是不让我们想一件事，我们就会越去想它。对焦虑、沮丧、节食、上瘾的最新调查证实，把“我不要”的力量用在涉及思想、情感的内心世界，它就会失效。当深入内心世界时，我们会发现，我们需要给自控一个全新的定义，给放弃自控留出一点空间来。 当人们试图摆脱某种想法时，它却像回飞镖一样“嗖”地飞回来了。 压抑人的本能时，就会产生这种讽刺性反弹效应。 韦格纳认为，这和大脑如何处理“不要去想”这个指令有关。大脑把这个指令分为两部分，分别由两个不同系统去执行。大脑的一部分负责将人的注意力从被禁止的想法那里引开，就像韦格纳第一个实验中那位设法不去想白熊的女士一样，“我试着去想白熊以外的其他所有东西……嘿，看看这面棕色的墙”。韦格纳将这个过程称为“操作”。“操作”依靠大脑的自控系统来完成。和所有需要付出努力的自我控制一样，这需要耗费大量的精力和能量。大脑的另一部分则负责寻找证据，证明你没有去想、去感觉、去做你不该去想、去感觉、去做的事，就像那位年轻的女士观察到的：“我想呀想呀想……每当我试着不去想白熊的时候，我其实总是想着它。”韦格纳将这个过程称为“监控”。“监控”和“操作”不同，它自动运行，无须耗费大量精力。“监控”与大脑的自动危险检测系统的联系更紧密。自动自控！这听起来可能很棒，但如果你认识到了“操作”与“监控”的配合有多重要，你就不会这么想了。无论基于什么原因，只要“操作”减弱了，“监控”就会成为自控的噩梦。 疲惫的“操作”和精力充沛的“监控”造成了大脑的不平衡，这会带来问题。当“监控”寻找被禁的内容时，它会让人不断想起要寻找的目标。神经学家指出，大脑的潜意识不断想到被禁止的内容。这么做的结果是，你会想到、感觉到或去做自己正在努力避免的事。 无论你想摆脱哪种恐惧或欲望，它们最后都会变得更让人信服，更引人注目。 怎么才能找到摆脱这种困境的方法呢？韦格纳提出了一种对抗讽刺性反弹的方法。这个方法本身就很有讽刺意味——这个方法就是放弃自控。当人们不再试图控制那些不希望出现的想法和情绪时，它们也就不会再来烦你了。 结果证明，这种方法对消除许多不好的内心感受都有用，它的适用范围大得令人吃惊。去想自己所想，追随自己的感觉（你不必相信它是真的，不要觉得必须采取行动），这是治疗焦虑、抑郁、嗜食和各种上瘾症状的有效方法。我们通过这些证据可以看到，放弃控制内心感受，反而能让我们更好地控制外在行为。 如果不和焦虑对抗，焦虑就会自然离去。 忠于你的感受，但别相信你所有的想法 直面自身欲望，但不要付诸行动。 当冲动占据你的头脑时，花至少一分钟去感觉自己的身体。你的冲动是什么样的？是热的还是冷的？身体有没有感到不舒服？心率、呼吸或内脏有什么变化？保持这个状态至少一分钟。看看这些感觉在强度或特性上有什么变化。 驾驭冲动不只适用于戒除癖好，还能帮助你掌控有害的冲动。 对内接受自我，对外控制行动。 抑制欲望的反面不是自我放纵。 结语 我们天生就有自控的能力，即便有时我们不太会运用这种能力。它们帮我们找到失败的原因，为我们指出可行的解决方法。它们甚至告诉我们，做人意味着什么。 在未来的人生道路上，请保持科学家的心态。尝试新鲜事物，收集自己的数据，根据证据作出判断。对出人意料的想法保持开放的心态，从失败和成功中汲取经验教训。坚持有效的方法，和他人分享你了解的知识。面对复杂的人性和现代社会的诱惑，我们最好能做到这几点。但是，如果我们能保持好奇心和自我同情，那对付它们就绰绰有余了。]]></content>
      <categories>
        <category>泛 - 书摘</category>
      </categories>
      <tags>
        <tag>自控力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃草 - 打铁]]></title>
    <url>%2F2018%2F11%2F06%2F2018_icpc_qingdao_regional%2F</url>
    <content type="text"><![CDATA[The 2018 ACM-ICPC Asia Qingdao Regional Contest试题 | 终榜 三题残酷打铁Problem C. Flippy Sequence Problem J. Books Problem M. Function and Function 铁牌区的友谊 燃烧我的判题机(BURN MY OJ) 🤝 猛吃草(VnEpCxmR) 《打铁归来》 由著名波普艺术家赵砚潇拍摄的大电影《打铁归来》将在近日登陆 YouTube，敬请期待。 “输入理想程序，输出快乐人生。” 谢谢大家！]]></content>
      <categories>
        <category>泛 - 纪念</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>纪念</tag>
        <tag>ICPC</tag>
        <tag>青岛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「记」0x03 二零一八年十月二十九日凌晨人民喝不到冰镇可乐]]></title>
    <url>%2F2018%2F10%2F29%2Fweekly_3%2F</url>
    <content type="text"><![CDATA[二零一八年十月我因为半夜出去买可乐已经刷了四次晚归，然而五次就要记过… 我们没有办法，只能痛苦的入睡…]]></content>
      <categories>
        <category>泛 - 记</category>
      </categories>
      <tags>
        <tag>记</tag>
        <tag>可乐</tag>
        <tag>自由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法训练营解题总结（第二周）//ToDo]]></title>
    <url>%2F2018%2F08%2F12%2Falgor_club_code_2%2F</url>
    <content type="text"><![CDATA[题目大意 &amp; 代码实现排序给出n个整数，将它们从小到大排序后输出。 对于前30%的数据，n ≤ 100，给出的n个整数的绝对值不超过10； 对于前60%的数据，n ≤ 5000，给出的n个整数的绝对值不超过10^9； 对于另20%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^5； 对于100%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^9。 时间：2 sec空间：256 MB 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;//#include &lt;algorithm&gt;//#include &lt;vector&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); vector&lt;int&gt; a; for (int i = 0; i &lt; n; ++i) &#123; int x; scanf("%d", &amp;x); a.push_back(x); &#125; sort(a.begin(),a.end()); //a = getAnswer(n, a); for (int i = 0; i &lt; n; ++i) printf("%d%c", a[i], " \n"[i == n - 1]); return 0;&#125; 分组有n个正整数排成一排，你要将这些数分成m份（同一份中的数字都是连续的，不能隔开），同时数字之和最大的那一份的数字之和尽量小。 对于50%的数据，n ≤ 100，给出的n个正整数不超过10； 对于100%的数据，m ≤ n ≤ 300000，给出的n个正整数不超过1000000。 时间：4 sec空间：512 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */bool check( long long d, int n, int m, vector&lt;int&gt; &amp;a )&#123; long long sum = 0; int cnt = 1; for( int i = 0; i &lt; n; ++i) &#123; if( a[i] &gt; d ) return false; sum += a[i]; if( sum &gt; d ) &#123; cnt++; i--; sum = 0; &#125; &#125; if(cnt &gt; m)&#123; return false; &#125; return true;&#125;// 将所给数组分成连续的m份，使得数字之和最大的那一份的数字之和最小// n：数组大小// m：题中的m// a：所给数组，大小为n// 返回值：最优方案中，数字之和最大的那一份的数字之和long long getAnswer(int n, int m, vector&lt;int&gt; a) &#123; /* 请在这里设计你的算法 */ long long l = 1, r = 0; for( int i = 0; i &lt; n; ++i) r += a[i]; while( l &lt;= r ) &#123; long long mid = (l + r) &gt;&gt; 1; if(check(mid, n, m, a)) r = mid - 1; else l = mid + 1; &#125; return r + 1;&#125;// ================= 代码实现结束 =================int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; a; a.resize(n); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); printf("%lld\n", getAnswer(n, m, a)); return 0;&#125; 大转盘邓老师有一个大转盘，被平分成了 2^n 份。邓老师还有一个长度为 2^n 的数组 a（下标从 0 开始），其中的每个元素都是 0 或 1。于是邓老师就可以选择大转盘上的一个位置，将 a[0] 填入其中，然后按顺时针顺序依次将 a[1],a[2],…,a[2^n-1] 填入。对于大转盘上的一个指定位置，邓老师可以从它开始，取出顺时针方向的 n 个位置，并将它们按原顺序拼接起来，得到一个长度为 n 的 01 串，也就是一个 n 位二进制数。我们把这个二进制数称作从这个位置开始的幸运数。显然地，大转盘上共有 2^n 个位置可以获得幸运数，而巧合的是 n 位二进制数恰好也有 2^n 个，所以邓老师希望这些所有的幸运数包含了所有的 n 位二进制数。请输出一个数组 a，使其满足邓老师的要求。（如果有多解，输出任一即可） 本题包含 16 个测试点。对于第 i 个测试点（1&lt;=i&lt;=16），满足 n=i。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//#include &lt;bits/stdc++.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */int allOne;vector&lt;bool&gt; vis[2];string ans;int twoPow(int x)&#123; return 1 &lt;&lt; x;&#125;void dfs(int u)&#123; for( int i = 0; i &lt; 2; ++i ) &#123; if(!vis[i][u])&#123; int v = ((u &lt;&lt; 1) | i) &amp; allOne; vis[i][u] = 1; dfs(v); ans.push_back('0' + i); &#125; &#125;&#125;// 本函数求解大转盘上的数，你需要把大转盘上的数按顺时针顺序返回// n：对应转盘大小，意义与题目描述一致，具体见题目描述。// 返回值：将大转盘上的数按顺时针顺序放到一个string中并返回string getAnswer(int n) &#123; /* 请在这里设计你的算法 */ allOne = twoPow(n - 1) - 1; ans = ""; for( int i = 0; i &lt; 2; ++i ) vis[i].resize(twoPow(n - 1), 0); dfs(0); return ans;&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); cout &lt;&lt; getAnswer(n) &lt;&lt; endl; return 0;&#125; 象棋你有足够多的象棋“车”，在一个n×n的棋盘上你能放多少个“车”呢？注意，所给棋盘上有些位置不能放任何东西。同时，某一行（列）最多只能存在一个“车”。 对于30%的数据，n ≤ 5； 对于60%的数据，n ≤ 20； 对于100%的数据，n ≤ 500。 时间：2 sec空间：256 MB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;//#include &lt;string.h&gt;//#include &lt;vector&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */const int N = 505 * 2, M = N * N;struct E &#123; int next, to;&#125; e[M];int cnt, ihead[N], mc[N];bool vis[N];void add(int x, int y)&#123; ++cnt; e[cnt].next = ihead[x]; e[cnt].to = y; ihead[x] = cnt;&#125;bool dfs(int x)&#123; for( int i = ihead[x]; i; i = e[i].next )&#123; int y = e[i].to; if(!vis[y])&#123; vis[y] = true; if(mc[y] == 0 || dfs(mc[y]))&#123; //3 mc[x] = y; mc[y] = x; return true; &#125; &#125; &#125; return false;&#125;// 求解棋盘上最多能放多少个“车”// n：棋盘的大小为n×n的// board：所给棋盘，对于某个位置上的数：若值为1表示可以放“车”；若值为0表示不能放“车”// 返回值：能放“车”的最大个数int getAnswer(int n, vector&lt;vector&lt;int&gt; &gt; board) &#123; /* 请在这里设计你的算法 */ cnt = 0; for( int i = 1; i &lt;= n * 2; i++)&#123; ihead[i] = 0; mc[i] = 0; &#125; for( int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; //1 if(board[i-1][j-1] == 1) add(i,j+n); &#125; &#125; int ans = 0; for( int i = 1; i &lt;= n; i++)&#123; if(!mc[i])&#123; memset(vis,0,sizeof(bool) * (n * 2 + 1)); if(dfs(i))&#123; ans++; &#125; &#125; &#125; return ans;&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;vector&lt;int&gt; &gt; e; for (int i = 0; i &lt; n; ++i) &#123; vector&lt;int&gt; t; for (int j = 0; j &lt; n; ++j) &#123; int x; scanf("%d", &amp;x); t.push_back(x); &#125; e.push_back(t); &#125; printf("%d\n", getAnswer(n, e)); return 0;&#125; 序列计数给定一个n个整数的序列以及一个非负整数d，请你输出这个序列中有多少个连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d。 对于60%的数据，n ≤ 5000； 对于100%的数据，n ≤ 300000。 保证所有整数的绝对值不超过10^9，d不超过2×10^9。 时间：10 sec空间：512 MB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;//#include &lt;cmath&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */const int N = 300005;int n,d,max_value[N],min_value[N];vector&lt;int&gt; a;long long solve(int l, int r)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1;//中点 long long ans = solve(l,mid)+solve(mid+1,r);//分治求出左右两半的值 for( int i = mid + 1; i &lt;= r; i++)&#123; min_value[i] = (i == mid + 1) ? a[i] : min(min_value[i - 1], a[i]); max_value[i] = (i == mid + 1) ? a[i] : max(max_value[i - 1], a[i]); &#125; int mn = 0, mx = 0, pos = r; for( int i = mid; i &gt;= l &amp;&amp; pos &gt; mid; i--)&#123; //3 mn = (i==mid)?a[i]:min(mn,a[i]); mx = (i==mid)?a[i]:max(mx,a[i]); for(; pos &gt; mid &amp;&amp; max(mx,max_value[pos]) - min(mn,min_value[pos]) &gt; d; pos--); ans += pos - mid;//更新答案 &#125; return ans;&#125;// 求出有多少个a数组中的连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d// n：a数组的长度// d：所给d// a：数组a，长度为n// 返回值：满足条件的连续子序列的个数long long getAnswer(int n, int d, vector&lt;int&gt; a) &#123; /* 请在这里设计你的算法 */ ::n = n; ::d = d; ::a = a; return solve(0,n-1);&#125;// ================= 代码实现结束 =================int main() &#123; int n, d; scanf("%d%d", &amp;n, &amp;d); vector&lt;int&gt; a; a.resize(n); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); printf("%lld\n", getAnswer(n, d, a)); return 0;&#125; 最小交换给定一个 1 到 n 的排列（即一个序列，其中 [1,n] 之间的正整数每个都出现了恰好 1 次）。你可以花 1 元钱交换两个相邻的数。现在，你希望把它们升序排序。求你完成这个目标最少需要花费多少元钱。 对于 20% 的数据，保证 n&lt;=7。 对于 60% 的数据，保证 n&lt;=1,000。 对于 100% 的数据，保证 n&lt;=200,000。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// #include &lt;bits/stdc++.h&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */vector&lt;int&gt; seq, seqTemp;long long cnt;void mergeSort(int l, int r)&#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; mergeSort(l, mid); mergeSort(mid+1,r); int p = l, q = mid + 1; for( int i = l; i &lt;= r; i++)&#123; if(q &gt; r || p &lt;= mid &amp;&amp; seq[p] &lt;= seq[q]) seqTemp[i] = seq[p++]; else&#123; seqTemp[i] = seq[q++]; cnt += (mid - p + 1); &#125; &#125; for( int i = l; i &lt;= r; i++) seq[i] = seqTemp[i];&#125;// 这个函数的功能是计算答案（即最少花费的金钱）// n：表示序列长度// a：存储整个序列 a// 返回值：最少花费的金钱（需要注意，返回值的类型为 64 位有符号整数）long long getAnswer(int n, vector&lt;int&gt; a) &#123; /* 请在这里设计你的算法 */ seq = a; seqTemp.resize(n); cnt = 0; mergeSort(0, n - 1); return cnt;&#125;// ================= 代码实现结束 =================int main() &#123; int n, tmp; vector&lt;int&gt; a; a.clear(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;tmp); a.push_back(tmp); &#125; long long ans = getAnswer(n, a); cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125; 楼尔邦德给定包含 n 个数的序列 A。再给出 Q 个询问，每个询问包含一个数 x，询问的是序列 A 中不小于 x 的最小整数是多少（无解输出-1）。 对于 50% 的数据，保证 n&lt;=2000。 对于 100% 的数据，保证 n&lt;=300,000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;// #include &lt;cstdio&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;iostream&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */// 本函数传入数组 a 及所有询问，你需要求解所有询问并一并返回// n：序列 a 的长度// a：存储了序列 a// Q：询问个数// query：依次存储了所有询问的参数 x// 返回值：一个 vector&lt;int&gt;，依次存放各询问的答案vector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; a, int Q, vector&lt;int&gt; query) &#123; /* 请在这里设计你的算法 */ vector&lt;int&gt; ans; ans.clear(); sort(a.begin(), a.end()); for( int i = 0; i &lt; Q; i++)&#123; int key = query[i]; int l = -1,r = n,mid; while(l+1 &lt; r)&#123; mid = (l + r) &gt;&gt; 1; if(a[mid] &lt; key) l = mid; else r = mid; &#125; int pos = r; if(pos &gt;= n) ans.push_back(-1); else ans.push_back(a[pos]); &#125; return ans;&#125;// ================= 代码实现结束 =================int main() &#123; int n, Q, tmp; vector&lt;int&gt; a, query; a.clear(); query.clear(); scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;tmp); a.push_back(tmp); &#125; scanf("%d", &amp;Q); for (int i = 0; i &lt; Q; ++i) &#123; scanf("%d", &amp;tmp); query.push_back(tmp); &#125; vector&lt;int&gt; ans = getAnswer(n, a, Q, query); for (int i = 0; i &lt; Q; ++i) printf("%d\n", ans[i]); return 0;&#125; 最短路给定一张 n 个点的无向带权图，节点的编号从 1 至 n，求从 S 到 T 的最短路径长度。 本题共设置 12 个测试点。 对于前 10 个测试点，保证 n&lt;=2500，m&lt;=6200，对于每条边有 w&lt;=1000。这部分数据有梯度。 对于所有的 12 个测试点，保证 n&lt;=100,000，m&lt;=250,000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;//#include &lt;set&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */const int MAX_N = 100050;struct edge &#123; int next, weight; edge(int ne,int we):next(ne),weight(we)&#123;&#125;&#125;;typedef pair&lt;int ,int&gt; P;vector&lt;edge&gt;G[MAX_N]; //邻接表表示的图int dist[MAX_N];//int path[MAX_N];bool collected[MAX_N]; //标记每个顶点是否被收录void Dijkstra(int start)&#123; memset(dist,0x3f,sizeof(dist)); memset(collected,0,sizeof(collected)); set&lt;P, less&lt;P&gt; &gt; min_heap; //用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。 dist[start] = 0; min_heap.insert(make_pair(0, start)); collected[start] = true; while(min_heap.size())&#123; //如果堆为空，说明所有点都已被收录，结束该算法 auto iter = min_heap.begin(); int v = iter-&gt;second; min_heap.erase(*iter); collected[v] = true; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(!collected[e.next] &amp;&amp; dist[e.next] &gt; dist[v] + e.weight) &#123; min_heap.erase(make_pair(dist[e.next], e.next)); dist[e.next] = dist[v] + e.weight; //path[e.next] = v; min_heap.insert(make_pair(dist[e.next], e.next)); &#125; &#125; &#125;&#125;// 这个函数用于计算答案（最短路）// n：节点数目// m：双向边数目// U,V,W：分别存放各边的两端点、边权// s,t：分别表示起点、重点// 返回值：答案（即从 s 到 t 的最短路径长度）int shortestPath(int n, int m, vector&lt;int&gt; U, vector&lt;int&gt; V, vector&lt;int&gt; W, int s, int t) &#123; /* 请在这里设计你的算法 */ for( int i = 0; i &lt; m; i++)&#123; G[U[i]].push_back(edge(V[i],W[i])); G[V[i]].push_back(edge(U[i],W[i])); &#125; Dijkstra(s); return dist[t];&#125;// ================= 代码实现结束 =================int main() &#123; int n, m, s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); vector&lt;int&gt; U, V, W; U.clear(); V.clear(); W.clear(); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); U.push_back(u); V.push_back(v); W.push_back(w); &#125; printf("%d\n", shortestPath(n, m, U, V, W, s, t)); return 0;&#125; 收获二分思想涉及题目： 分组 序列计数 楼尔邦德 Dijkstra 的局限之前只认为，Dijkstra 算法不可以处理带有负值圈的图。实际上 Dijkstra 在处理有复值边权的图时很可能不正确。 例：12341 -&gt; 2 w = 11 -&gt; 3 w = 22 -&gt; 4 w = 13 -&gt; 2 w = -2 正确答案为 1，Dijkstra 给出的答案为 2 。 一些算法 二分图最大匹配 求欧拉回路 归并排序求逆序对 ToDo排序手动实现 冒泡排序 插入排序 选择排序 快速排序 最小交换使用树状数组优化求逆序对的暴力算法，达到与归并排序相同的复杂度。 总结欧拉回路算法 欧拉回路 计蒜客 总结匈牙利算法 匈牙利算法 计蒜客 二分学习使用 std::lower_bound ，注意边界。 实现 Bellman-Ford 算法伪代码123456789初始化 mind 数组mind[0] : 0for round 1 to n 枚举所有边 (u,v,len) mind[v] : min(min[v],mind[u]+len) if 本轮中没有点被更新 break; if round == n+1 无解]]></content>
      <categories>
        <category>泛 - 计算机</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>Bellman-Ford</tag>
        <tag>ToDo</tag>
        <tag>二分</tag>
        <tag>匈牙利算法</tag>
        <tag>排序</tag>
        <tag>归并排序</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法训练营解题总结（第一周）//ToDo]]></title>
    <url>%2F2018%2F08%2F04%2Falgor_club_code_1%2F</url>
    <content type="text"><![CDATA[题目大意 &amp; 代码实现栈简单的栈实现，我使用数组实现，可以使用 vector 代替数组。日常可以直接使用 STL 库中的 stack 类，但其无法进行 “call by rank” 的访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;string&gt;//#include &lt;cstdio&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */int mtop = -1;string mstack[100005];// 压入栈顶// name：被压入的人的姓名void push(string name) &#123; mtop++; mstack[mtop] = name; /* 请在这里设计你的算法 */&#125;// 弹出栈顶// 返回值：被弹出人的姓名string pop() &#123; if(mtop &gt; -1)&#123; mtop--; &#125; return mstack[mtop+1]; /* 请在这里设计你的算法 */&#125;// 询问栈中某个位置上的人的姓名（栈底位置为1，向栈顶方向的位置依次递增）// pos：询问的位置// 返回值：pos位置上人的姓名string query(int pos) &#123; /* 请在这里设计你的算法 */ return mstack[pos-1];&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); char name[20]; for (; n--; ) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%s", name); push(name); &#125; else if (op == 2) &#123; printf("%s\n", pop().c_str()); &#125; else &#123; int pos; scanf("%d", &amp;pos); printf("%s\n", query(pos).c_str()); &#125; &#125; return 0;&#125; 队列简单的队列实现，这个队列问题很大，就是元素出队后的空间无法回收，造成无法持续使用，占用空间大的问题。题目要求较低。应该使用链表或循环数组实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;string&gt;//#include &lt;cstdio&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */int q = 0;int h = 0;string mque[100005];// 队尾入队// name：入队人的姓名void enqueue(string name) &#123; mque[h] = name; h++; /* 请在这里设计你的算法 */&#125;// 队首出队// 返回值：队首的姓名string dequeue() &#123; q++; /* 请在这里设计你的算法 */ return mque[q-1];&#125;// 询问队列中某个位置上的人的姓名（队首位置为1，往后位置依次递增）// pos：询问的位置// 返回值：pos位置上人的姓名string query(int pos) &#123; return mque[q+pos-1]; /* 请在这里设计你的算法 */&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); char name[20]; for (; n--; ) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%s", name); enqueue(name); &#125; else if (op == 2) &#123; printf("%s\n", dequeue().c_str()); &#125; else &#123; int pos; scanf("%d", &amp;pos); printf("%s\n", query(pos).c_str()); &#125; &#125; return 0;&#125; 二叉树实现并维护二叉搜索树，并输出其前序和后序遍历。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;//#include &lt;cstdio&gt;//#include &lt;iostream&gt;//#include &lt;vector&gt;//#include &lt;string.h&gt;using namespace std;const int N = 100005;struct node &#123; int val; node* l; node* r; node():val(0),l(nullptr),r(nullptr)&#123;&#125; &#125;;node* root = nullptr;void insert(int v, node*&amp; x)&#123; if(x == 0)&#123; x = new node(); //cout &lt;&lt; x &lt;&lt; endl; x-&gt;l = nullptr; x-&gt;r = nullptr; x-&gt;val = v; return; &#125; if (v &lt;= x-&gt;val) &#123; insert(v,x-&gt;l); &#125; else if (v &gt; x-&gt;val) &#123; insert(v,x-&gt;r); &#125; return;&#125;void dlr( node* x, vector&lt;int&gt; &amp;ans) &#123; if(x)&#123; ans.push_back(x-&gt;val); dlr(x-&gt;l,ans); dlr(x-&gt;r,ans); &#125;&#125;void lrd( node* x, vector&lt;int&gt; &amp;ans)&#123; if(x)&#123; lrd(x-&gt;l,ans); lrd(x-&gt;r,ans); ans.push_back(x-&gt;val); &#125;&#125;vector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; sequence) &#123; for( int i = 0; i &lt; int(sequence.size()); ++i) insert(sequence[i],root); vector&lt;int&gt; ans; dlr(root,ans); lrd(root,ans); return ans;&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;int&gt; sequence; for (int i = 0; i &lt; n; ++i) &#123; int x; scanf("%d", &amp;x); sequence.push_back(x); &#125; vector&lt;int&gt; ans = getAnswer(n, sequence); //cout &lt;&lt; ans.size() &lt;&lt; endl; for (int i = 0; i &lt; n; ++i)&#123; printf("%d%c", ans[i], " \n"[i == n - 1]); &#125; for (int i = 0; i &lt; n; ++i)&#123; printf("%d%c", ans[n + i], " \n"[i == n - 1]); &#125; return 0;&#125; 数字盒子Hash Map 实现，由于我的问题，没有去实现，使用了STL库中的 map 类，周末会补充 Hash Map 的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;//#include &lt;map&gt;using namespace std;// ================= 代码实现开始 =================typedef long long ll;/* 请在这里定义你需要的全局变量 */// 执行操作时会调用这个函数// op：对应该次操作的 op（具体请见题目描述）// x：对应该次操作的 x（具体请见题目描述）// 返回值：如果输出为"Succeeded"，则这个函数返回 1，否则返回 0map&lt;ll,bool&gt; Map;bool check(int op, ll x) &#123; if(op == 1)&#123; if(Map[x])&#123; return false; &#125;else&#123; Map[x] = true; return true; &#125; &#125;else&#123; if(Map[x])&#123; Map[x] = false; return true; &#125; return Map[x]; &#125; /* 请在这里设计你的算法 */&#125;// ================= 代码实现结束 =================int main() &#123; int Q, op; ll x; scanf("%d", &amp;Q); while (Q--) &#123; scanf("%d%lld", &amp;op, &amp;x); puts(check(op, x) ? "Succeeded" : "Failed"); &#125; return 0;&#125; 重编码哈夫曼编码问题，合并森林。与 POJ 3253 Fence Repair 相似。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;//#include &lt;queue&gt;using namespace std;// ================= 代码实现开始 =================typedef long long ll;/* 请在这里定义你需要的全局变量 */// 这是求解整个问题的函数// w：题目描述中的 w（所有）// n：题目描述中的 n// 返回值：答案priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q; ll getAnswer(int n, vector&lt;ll&gt; w) &#123; for( int i = 0; i &lt; n; i++)&#123; //把n块木板的长度入队 q.push(w[i]); &#125; ll sum = 0; while(q.size() &gt; 1)&#123; //如果还没有合成一块木板就继续合并 ll minOne,minTwo; minOne = q.top(); q.pop(); minTwo = q.top(); q.pop(); //从队头拿出两个最短的木板 sum += (minOne + minTwo); //加上这次合并的开销 q.push(minOne+minTwo); //将合并后的木板入队 &#125; return sum;&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;long long&gt; w; for (int i = 0; i &lt; n; ++i) &#123; long long x; scanf("%lld", &amp;x); w.push_back(x); &#125; printf("%lld\n", getAnswer(n, w)); return 0;&#125; 成绩排序排序并输出逆序对数目，使用冒泡排序在每次交换记数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */// 这是进行排序的函数// n：题目描述中的 n// A：各同学的算法训练营成绩// DS：各同学的数据结构训练营成绩// 返回值：将要输出的数字依次加入到返回值的数组中class student&#123;public: int id; int algorithm,dataStruct; int score; student()&#123;&#125; student(int i,int a,int d):id(i),algorithm(a),dataStruct(d),score(a+d)&#123;&#125;&#125;;bool operator &lt; (student a,student b)&#123; if(a.score &lt; b.score)&#123; return true; &#125;else if(a.score == b.score)&#123; if(a.algorithm &lt; b.algorithm)&#123; return true; &#125; &#125; return false;&#125;int BubbleSort(vector&lt;student&gt; &amp;a,int size)&#123; int cnt = 0; for( int i = size-1; i &gt;= 0; i--)&#123; bool flag = false; //记录在一趟排序中是否有交换 for( int j = 0; j &lt; i; j++)&#123; if(a[j] &lt; a[j+1])&#123; student temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; //swap(a[j],a[j+1]); flag = true; cnt++; &#125; &#125; if(!flag) break; &#125; return cnt;&#125;vector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; A, vector&lt;int&gt; DS) &#123; /* 请在这里设计你的算法 */ vector&lt;int&gt; ans; vector&lt;student&gt; temp; for( int i = 0; i &lt; n; i++)&#123; temp.push_back(student(i+1,A[i],DS[i])); &#125; int cnt = BubbleSort(temp,n); for(int i = 0; i &lt; n; i++)&#123; ans.push_back(temp[i].id); ans.push_back(temp[i].score); ans.push_back(temp[i].algorithm); ans.push_back(temp[i].dataStruct); &#125; ans.push_back(cnt); return ans;&#125;// ================= 代码实现结束 =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;int&gt; A, DS; for (int i = 0; i &lt; n; ++i) &#123; int a, ds; scanf("%d%d", &amp;a, &amp;ds); A.push_back(a); DS.push_back(ds); &#125; vector&lt;int&gt; ans = getAnswer(n, A, DS); int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; printf("%d %d %d %d\n", ans[cnt], ans[cnt + 1], ans[cnt + 2], ans[cnt + 3]); cnt += 4; &#125; printf("%d\n", ans[cnt]); return 0;&#125; 等式来源：NOI 2015 day1 T1 程序自动分析简单并查集题目，主意一下检查应该留到最后检查即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;// ================= 代码实现开始 =================/* 请在这里定义你需要的全局变量 */// 给定n个变量以及m个约束，判定是否能找出一种赋值方案满足这m个约束条件// n：如题意// m：如题意// A：大小为m的数组，表示m条约束中的a// B：大小为m的数组，表示m条约束中的b// E：大小为m的数组，表示m条约束中的e// 返回值：若能找出一种方案，返回"Yes"；否则返回"No"（不包括引号）。int pre[500005];void init()&#123; for( int i = 1; i &lt;= 500004; i++)&#123; pre[i] = i; &#125;&#125;int get(int x)&#123; if(pre[x] == x)&#123; //x 节点就是根节点 return x; &#125; return pre[x] = get(pre[x]); //返回父节点的根节点，并另当前节点父节点直接为根节点&#125;void merge(int x,int y)&#123; x = get(x); y = get(y); if(x != y)&#123; // 不住同一个集合 pre[y] = x; &#125;&#125;string getAnswer(int n, int m, vector&lt;int&gt; A, vector&lt;int&gt; B, vector&lt;int&gt; E) &#123; /* 请在这里设计你的算法 */ init(); vector&lt;int&gt; zero; for( int i = 0; i &lt; m; i++)&#123; if(E[i])&#123; merge(A[i],B[i]); &#125;else&#123; zero.push_back(i); &#125; &#125; for( int i = 0; i &lt; zero.size(); i++)&#123; if(get(A[zero[i]]) == get(B[zero[i]]))&#123; return "No"; &#125; &#125; return "Yes";&#125;// ================= 代码实现结束 =================int main() &#123; int T; for (scanf("%d", &amp;T); T--; ) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; A, B, E; for (int i = 0; i &lt; m; ++i) &#123; int a, b, e; scanf("%d%d%d", &amp;a, &amp;b, &amp;e); A.push_back(a); B.push_back(b); E.push_back(e); &#125; printf("%s\n", getAnswer(n, m, A, B, E).c_str()); &#125; return 0;&#125; 道路升级最大生成树问题，与最小生成树一样。使用 Kruskal 算法解决，需要简单实现一下并查集。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstring&gt;//#include &lt;algorithm&gt;using namespace std;const int MAX_N = 200050;const int MAX_M = 400050;struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a)const &#123; return w &gt; a.w; &#125;&#125; e[MAX_M];int fa[MAX_N], n, m;int get(int x)&#123; if(fa[x] == x)&#123; return fa[x]; &#125; return fa[x] = get(fa[x]);&#125;vector&lt;int&gt; getAnswer(int n, int m, vector&lt;int&gt; U, vector&lt;int&gt; V) &#123; vector&lt;int&gt; re; for( int i = 0; i &lt; m; ++i)&#123; e[i].u = U[i]; e[i].v = V[i]; e[i].w = i+1; &#125; sort(e,e+m); for( int i = 1; i &lt;= n; ++i)&#123; fa[i] = i; &#125; for( int i = 0; i &lt; m; ++i)&#123; int x = get(e[i].u), y = get(e[i].v); if(x != y)&#123; fa[x] = y; re.push_back(e[i].w); &#125; &#125; sort(re.begin(), re.end()); return re;&#125;// ================= 代码实现结束 =================int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; U, V; for (int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); U.push_back(u); V.push_back(v); &#125; vector&lt;int&gt; ans = getAnswer(n, m, U, V); printf("%d\n", int(ans.size())); for (int i = 0; i &lt; int(ans.size()); ++i) printf("%d\n", ans[i]); return 0;&#125; 收获输入输出挂输入输出挂是真的快！ 简单的数字输入输出挂，完整的见 -&gt; 这里1234567891011121314151617#include &lt;cstdio&gt; int Scan() &#123; //输入外挂 int res = 0, flag = 0; char ch; if((ch = getchar()) == '-') flag = 1; else if(ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125; void Out(int a) &#123; //输出外挂 if(a &lt; 0) &#123; putchar('-'); a = -a; &#125; if(a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125; 输入输出分离助教给的解题模板真舒服，可以不用考虑输出问题，专心实现算法～～～代码可读性也提高不少，但竞赛中打的时间也许会增加一些，复杂度也会增加一些。 哈夫曼编码 &amp; POJ 3253哈夫曼编码就是贪心～在《挑战程序设计竞赛(第2版) 》中讲解的 POJ 3253 现在一看真是醍醐灌顶～～～ 学到一些算法实现 二叉树 Kruskal 算法 哈夫曼编码的 \(O(n)\) 实现 题目中数据范围分析技巧计算机每秒运算 \(10^8\) \(n = 10^6\) -&gt; \(O(n)\) \(n = 5 \times 10^5\) -&gt; \(O(n log n)\) \(n = 10^4\) -&gt; \(O(n^2)\) ToDoHash Map 的实现… 哈夫曼编码的 \(O(n)\) 实现使用栈和队列优化 成绩排序 优化\(O(n^2)\) -&gt; \(O(n log n)\) 排序 -&gt; 快排排序、归并排序求逆序对 -&gt; 归并排序、树状数组辅助统计 重编码 -&gt;【NOI2015】荷马史诗不同进制下的哈夫曼编码。【NOI2015】荷马史诗 参考资料 输入输出外挂 输入输出外挂总结 二叉树的C++简单实现]]></content>
      <categories>
        <category>泛 - 计算机</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>队列</tag>
        <tag>栈</tag>
        <tag>二叉树</tag>
        <tag>哈夫曼编码</tag>
        <tag>Kruskal</tag>
        <tag>Hash Map</tag>
        <tag>输入输出挂</tag>
        <tag>ToDo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求质数表3——高级筛法]]></title>
    <url>%2F2018%2F07%2F26%2Fisprimes-3%2F</url>
    <content type="text"><![CDATA[增量式筛法之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去，如试除法就是增量式运行的。 增量式算法可以在简易欧拉筛进行改进的。简易欧拉筛限制它不能增量式运行的问题是在于它的空间。比如增量式运行筛选到 11 时你需要划掉 121 ，这样你就需要维持 N^2 的空间，这样就很成问题，想象如果 N 到1亿时，那空间将是不可接受的。我们将不再枚举p和f，而是依次检查每个数，检查到一个数时划去下一个数，并再下一个数处做标记。比如我们检查到 10 ，我们通过某种方式计算出它的下一个要被划掉的数为 15 ，我们划掉 15 并在 15 处做标记，保证检查到 15 时我们可以轻松的算出 25 。由 Bertrand’s postulate 这个数学结论得出相邻两个质数相差不会超过两倍，所以我们只需将数组维持在当前检查的数的两倍即可。这样空间复杂度就将为了 O(N) 。 这个标记需要干什么，它需要帮助我们在拿到一个数时迅速找出它的p和f。我们用一个数组保存当前被检查的数的最小质因子在质数表的位置即可。这样比如我们在拿到 15 时，我们找到它的最小质因子p为 3 ，15/3 算出 f 为 5，我们就可以用 f 乘下一个质数去找到 25 划掉它并继续传递标记了。标记从每个偶数处（因为第一个素数为 2 ）产生的，到列末尾消失（p 最大增长到 f 的最小质因子）。 代码Ubuntu Pastebin : https://paste.ubuntu.com/p/DtN2WPpppf/1234567891011121314151617181920212223242526int bengalloun(int N)&#123; int nPrimes = 0; flag[2] = true; for( int i = 2; i &lt;= N; i++)&#123; flag[i * 2 - 1] = true; //假设它为质数 flag[i * 2] = false; //偶数一定为合数 lpfindex[i * 2] = 0; //建立列首标记 if(flag[i])&#123; primes[nPrimes++] = i; //如果还没被筛掉加入质数表 &#125;else&#123; //如果是合数 int u = lpfindex[i]; int p = primes[u]; int f = i / p; //计算p和f if(f % p != 0)&#123; //如果没有到列尾就传递标记 int j = primes[u + 1] * f; flag[j] = false; lpfindex[j] = u + 1; &#125; &#125; &#125; return nPrimes;&#125; 复杂度分析时间复杂度与思想与简易欧拉筛相同，依然为O(N)。因为要为增量式运行做准备实际要比简易欧拉筛多花一倍的时间。 空间复杂度flag和lpfindex数组都为O(N)的复杂度。总体空间复杂度为O(N)。 分段式筛法对于现代计算机运算速度越来越快，时间复杂度可能问题不大，但空间复杂度是个问题。分段式筛法就是要解决这个问题。分段式筛法是在埃式筛法的基础上改进的， 代码Ubuntu Pastebin : https://paste.ubuntu.com/p/HzTG6HrbV2/123456789101112131415161718192021222324252627int segmented_eratosthenes(int N)&#123; int sqrtN = (int) sqrt(N); int n = eratosthenes(sqrtN); int nPrimes = n;// 使用埃式筛法求出前 √N 内的质数。 int L = sqrtN; // 分段求，L 为每段长度，取 √N for( int start = sqrtN + 1; start &lt;= N; start += L)&#123; if(start + L &gt; N) L = N - start + 1; memset(flag, true, L * sizeof(bool)); for( int u = 0; u &lt; n; u++)&#123; int p = primes[u]; if(p * p &gt;= start + L) break; // 枚举本段上限以内的质数 for( int i = (p - start % p) % p; i &lt; L; i += p)&#123; flag[i] = false; // 划掉本段中能被 p 整除的数 &#125; &#125; for( int i = 0; i &lt; L; i++)&#123; if(flag[i]) primes[nPrimes++] = start + i; // 找到本段中没有被划掉的数并将其收集到质数表中 &#125; &#125; return nPrimes;&#125; L 的取法空间\(\sqrt{N}\) 以内质数表占用了 \(O(\sqrt{N})\) 的空间。flag 数组占用 \(O(L)\) 的空间。若 \(L &gt; \sqrt{N}\) 空间复杂度将提高。 时间若 \(L &lt; \sqrt{N}\)，当 p 接近 \(\sqrt{N}\) 时，删除 p 的倍数就容易“扑空”。 所以 \(L = \sqrt{N}\) 时刚好。 复杂度分析时间复杂度本质上是埃式筛法，所以时间复杂度为 \(O(NloglogN)\)。内存占用小，避免了缓存不命中，实际上比埃式筛法要快。 空间复杂度\(O(\sqrt{N})\)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>质数</tag>
        <tag>求质数表</tag>
        <tag>优化</tag>
        <tag>增量式筛法</tag>
        <tag>分段式筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「记」0x02 幻觉]]></title>
    <url>%2F2018%2F07%2F24%2Fweekly_2%2F</url>
    <content type="text"><![CDATA[最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～ 其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿了钱，我觉得这对我是一种侮辱，我下学期必将拿一次一等奖学金，之后随意～ 我要学英语了，我觉得这对我很重要，如果英语搞定那后面的事情真是无法想象～ 事实上我高三就这么想了，结果高考英语考了 44 分，很醉。。。 高中啊，我不学英语是有原因的，因为我觉得其他的还能提高，而且更为高效～我干掉了最难的物理，之后一路还算顺风顺水，没吃什么苦也上了学。遗憾的是现在世道不一样了，我急需英语，我需要看英文的技术书籍，我需要看ACM题，但这些不是最重要的，最重要的是我现在学英语如果成了，我将无所不能～没有什么比这个重要的了，如果成了我相信大学后面几年一定顺风顺水。。。 我现在有很大的幻觉，我感觉我只需要半年，我看了一些知乎上的经验通常时间跨度都挺长的，那些都是笨蛋我只需要半年！ 后面的事情还多啊，时间太少。数学建模的好东西都没搞定，特别是写论文用的排版语言，暑假还要学。ACM还要刷很多题，暑假还要看邓老师的算法课。我还计划总结一下C++的基础问题，开学当助教不能误人子弟啊。开学还有数学建模竞赛和ACM的网络赛～再参加一下蓝桥杯。大二的课程还是有些难度的，Java虽然我之前学过但还是需要写很多代码去熟练，学Java就伴随着还要看设计模式，汇编语言虽然自己也写过，但还是好难啊。。。还有那个阴差阳错选上的单片机，真是无力吐槽，还是虽然，虽然我是写过单片机的程序，但还是好难啊。。。 最后扯个淡，最近我想拍个大电影，真的～哪天我闲了就去拍，上传到YouTube上。]]></content>
      <categories>
        <category>泛 - 记</category>
      </categories>
      <tags>
        <tag>记</tag>
        <tag>英语</tag>
        <tag>大电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「书摘」《深度探索 C++ 对象模型》（二）]]></title>
    <url>%2F2018%2F07%2F23%2Finside_cpp_obj_model_2%2F</url>
    <content type="text"><![CDATA[构造函数语义学英文术语表 英文 中文 implicit 暗中的、隐式的（通常意指并非在程序源代码中出现的） explicit 显式的（通常意指程序源代码中所出现的） trivial 没用的 nontrivial 有用的 memberwise 对每个 member 施以…… bitwise 对每个 bit 施以…… semantics 语意 关于 C++ ，最常听到的一个抱怨就是，编译器背着程序员做了太多事情。 关键词 explicit 之所以被导入这个语言，就是为了给程序员提供一种方法，使他们能够制止 “单一参数的 constructor“ 被当作一个 conversion 运算符。 “Schwarz Error” -&gt; basic_ios 如何穿上它的 bool Conversion 运算符的引入应该是明智的，而其测试应该是严酷的，并且中程序一出现不寻常活动的第一个症候时，就发出疑问。 Default Constructor 的构造操作程序的需要、编译器的需要。程序如果有需要，那是程序员的责任。 12345678910class Foo &#123; public: int val; Foo *pnext; &#125;;void foo_bar()&#123; Foo bar; if ( bar.val || bar.pnext ) // ... do something // ... &#125; C++ Standard [ISO-C++95] Section 12.1 :对于 class X，如果没用任何 user-declared constructor，那么会有一个 default constructor 被隐式的（ implicitly ）声明出来……一个被隐式声明出来的 default constructor 将是一个 trivial constructor…… “带有 Default Constructor” 的 Member Class Object如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor，那么这个 class 的 implicit default constructor 就是 “nontrivial” ，编译器需要为改 class 合成出一个 default constructor。不过这个合成操作只有中 constructor 真正需要被调用时才会发生。 编译器如何避免合成出多个 default constructor ？把合成的 default constructor、copy constructor、destructor、assignment copy operator 都以 inline 的方式完成。如果函数太复杂，不适合做成 inline，就会合成出一个 explicit non-inline static 实例（4.5节有详细说明） 编译器会扩张已存在的 constructors，在其中安插一些代码，使得 user code 被执行之前，先调用必要的 default constructors。 C++ 语言要求以 “member objects 在 class 中的声明顺序” 来调用各个 constructors。 “带有 Default Constructor” 的 Base Class如果一个没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。它将调用上一层 base classes 的 default constructor（根据它们的声明顺序）。对一个后继派生的 class 而言，这个合成的 constructor 和一个 “被显式提供的 default constructor” 没有什么差异。 “带有 Virtual Function” 的 Class当 class 声明（或继承）一个 virtual function ，需要合成 nontrivial 的 default constructor。 “带有 Virtual Function” 的 class 的 default constructor 会有两个扩张行动在编译期间发生： 一个 virtual function table（在 cfront 中被称为 vtbl ）会被编译器产生出来，内放 class 的 virtual functions 地址。 在每一个 class object 中，一个额外的 pointer member（也就是 vptr ）会被编译器合成出来，内含相关之 class vtbl 的地址。 1234// widget.flip() 的转变( *widget.vptr[1] )( &amp;widget )// * 1 表示 filp() 在 virtual table 中的固定索引// * &amp;widget 代表要交给“被调用的某个 flip() 函数实例”的this指针 编译器必须为每一个 “带有 Virtual Function” 的 class 的 object 的 vptr 设定初值，放纵适当的 virual table 地址。对于这个 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情。 “带有 Virtual Base Class” 的 Classclass 派生自一个继承串链，其中有一个或更多的 virtual base classes，需要合成 nontrivial 的 default constructor。 Virtual base class 的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共同点在于必须使 virtual base class 在其每一个 derived class object 中的位置，能够于执行期准备妥当。 12345678910111213class X &#123; public: int i; &#125;;class A : pubilc virual X &#123; public: int j; &#125;;class B : pubilc virual X &#123; public: double d; &#125;;class C : public A, public B &#123; public: int k &#125;;// 无法在编译时期决定（resolve）出 pa-&gt;X::i 的位置void foo( const A* pa) &#123; pa-&gt;i = 1024; &#125;int main()&#123; foo( new A ); foo( new C );&#125; 相当于下面的代码12void foo( const A* pa) &#123; pa-&gt;__vbcX-&gt;i = 1024; &#125;// __vbcX 表示编译器产生的指针，指向 virtual base class X。 总结有 4 种情况，会造成“编译器必须为未声明 constructor 的 classes 合成一个 default constructor”。 没有任何 constructor 的 class 内含一个有 default constructor 的 member object 没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class 当 class 声明（或继承）一个 virtual function class 派生自一个继承串链，其中有一个或更多的 virtual base classes C++ Standard 把那些合成物称为 implicit nontrivial default constructors。 C++ 新手两个常见误解： 任何 class 如果没有定义 default constructor，就会被合成出一个来。 编译器合成出来的 default constructor 会显式设定 “class 内每一个 data member 的默认值”。 Copy Constructor 的构造操作有三种情况，会以一个 object 的内容作为另一个 class object 的初值。class X { ... }; X xx = x 作为参数交给某个函数 foo( xx ); 作为函数返回值 return xx; Default Memberwise InitializationDefault constructors 和 copy constructors 在必要的时候才由编译器产生出来。对于 copy constructors 必要的时候是指该 class 不展现 bitwise copy semantics 时。 C++ Standard 把 copy constructors 区分为 trivial 和 nontrivial 两种。只有 nontrivial 的实例被合成于程序之中。 Bitwise Copy Semantics（位逐次拷贝）1234567// 以下声明展现了 bitwise copy semanticsclass Bitwise&#123;int a;public: Bitwise(int a);&#125;; 12345678// 以下声明未展现出 bitwise copy semanticsclass NonBitwise&#123;int a;string b;public: NonBitwise(v);&#125;; 对于后者，编译器必须合成出一个 copy constructor，以便调用 member class string object 的 copy constructor。123456// C++ 伪码inline NonBitwise(const NonBitwise&amp; nb)&#123; b.string::string(nb.b); a = nb.a;&#125; 不要 Bitwise Copy Semantics ！class 不展现出 ”bitwise copy semantics“ 的 4 种情况： 当 class 内含一个 member object 而后者的 class 声明有一个 copy constructos 时（不论时被显式声明或是被合成而得）。 当 class 继承自一个 base class 而后者存在一个 copy constructor 时（不论时被显式声明或是被合成而得）。 当 class 声明了一个或多个 virtual functions 时。 当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。 重新设定 Virtual Table 的指针当 class 声明了一个或多个 virtual functions 时，编译期间会有两个程序扩张操作： 增加一个 virtual function table( vtbl )，内含每一个有作用的 virtual function 的地址。 一个指向 virtual function table 的指针（ vptr ），安插在每一个 class object 内。 处理 Virtual Base Class Subobject如果一个 class 以另一个 object 作为初值，而后者有一个 virtual base class subobject，那么也会使 “bitwise copy semantics” 失效。 每一个编译器对于虚拟继承的支持承诺，都代表必须让“derived class object 中 virtual base class subobject 位置” 在执行期就准备妥当。维护“位置的完整性”是编译器的责任。 123456789class A&#123;...&#125;;class B : public virtual A&#123;...&#125;;class C : public B&#123;...&#125;; 123B ba;B bb = ba;// 这种情况使用 bitwise 就够了 12345C ca;B bb = ca;/*编译器需要合成一个 copy constructor，安插一些代码以设定 virtual base class pointer/offser 的初值（或只是简单地确定它没有被抹消），对每一个 memberwise 执行必要的初始化操作，以及执行其他的内存相关工作。*/ 程序转化语意学（Program Transformation Semantics）12345678#include "X.h"X foo()&#123; X xx; // ... return xx;&#125; 两个假设： 每次 foo() 被调用，就传回 xx 的值。 如果 class X 定义了一个 copy constructor，那么当 foo() 被调用时，保证该 copy constructor 也会被调用。 第一个假设的真实性，必须视 class X 如何定义而定。 第二个假设的真实性，虽然也部分地必须视 class X 如何定义而定，但最主要的还是视你的 C++ 编译器所提供的进取性优化层级（degree of aggressive optimization）而定。 显式的初始化操作（Explicit Initialization）在严谨的 C++ 用词中，“定义” 是指 “占用内存” 的行为。 123X x1( x0 );X x2 = x0;X x3 = X( x0 ); 转化为 -&gt; 12345678X x1;X x2;X x3;// 编译器安插 X copy construction 的调用操作X1.X::X( x0 );X2.X::X( x0 );X3.X::X( x0 ); 参数的初始化（Argument Initialization）12345void foo( X x0 );X xx;// ...foo( xx ); 第一种编译器实现的转化代码1234X __temp0;__temp0.X::X( xx );foo( __temp0 ); 要求局部实例（local instance）x0 以 memberwise 的方式将 xx 当做初值。导入临时性 object，并调用 copy constructor 将它初始化，然后将此临时性 object 交给函数。但这里 foo() 函数声明将改变为 void foo( X&amp; x0 )。在函数执行完成后 class X 的 destrucor 将会被调用，对付那个临时性的 object 。 第二种编译器实现以 “拷贝建构”（copy construct）的方式把实际参数直接建构在其应该的位置上。 返回值的初始化（Return Value Initialization）cfront 中的双阶段转化123456X bar()&#123; X xx; // ... return xx;&#125; 转化为 -&gt;12345678910void bar( X&amp; __result )&#123; X xx; xx.X::X(); // ... __result.X::X(xx); return;&#125; X xx = bar(); 的操作将被转化为 X xx; bar( xx );。 bar().memfunc(); 可能被转化为 -&gt;12X __temp0;( bar( __temp0 ), __temp0 ).memfunc(); 在使用者层面做优化（Optimization at the User Level）123456X bar( const T &amp;y, const T &amp;z )&#123; X xx; // ... return xx;&#125; bar() 函数会要求 xx 被 “memberwise” 地拷贝到编译器所产生的 __result 之中。Jonathan Shopiro 提出定义另一个 constructor，可以直接计算 xx 的值。上面的代码转化为 -&gt;1234X bar( const T &amp;y, const T &amp;z)&#123; return X( y,z );&#125; 编译器会将其转化为 -&gt;12345X bar( X &amp;__result, const T &amp;y, const T &amp;z)&#123; __result.X::X( y,z ); return;&#125; __result 被直接计算出来，而不是经由 copy constructor 拷贝而得！ 在编译器层面做优化（Optimization at the Compiler Level）123456X bar()&#123; X xx; // ... return xx;&#125; 转化为 -&gt;123456void bar( X&amp; __result )&#123; __result.X::X(); // ... return;&#125; 这种优化，有时候被称为 Named Return Value ( NRV ) 优化。NRV 优化如今被视为标准 C++ 编译器的一个义不容辞的优化操作。 // 本书对 NRV 的优化性能测试有一些错误，这部分不做摘录。 NRV 优化的争议： 优化由编译器完成，而它是否真的被完成，并不是十分清楚。 一旦函数变得比较复杂，优化也会变得比较难以实施。 程序员不能够安全地规划自己的 copy constructor 的副作用。 一般而言，面对 “以一个 class object 作为另一个 class object 的初值” 的情形，语言允许编译器有大量的自由发挥空间。 Copy Constructor：要还是不要？class 的 default copy constructor 被视为 trivial 的情况下不声明 explicit copy constructor 既快速又安全。在需要 NRV 优化时，可以考虑实现 copy constructor，可以使用 memcpy() 来拷贝提高效率。 不管使用 memcpy() 还是 memset()，都只有在“classes 不含任何由编译器产生的那部 members ” 时才能有效运行。 成员们的初始化队伍（Member Initialization List）必须使用 member initialization list 的情况 当初始化一个 reference member 时； 当初始化一个 const member 时； 当调用一个 base class 的 constructor，而它拥有一组参数时； 当调用一个 member class 的 constructor，而它拥有一组参数时。 编译器会一一操作 initialization list，以适当顺序中 constructor 之内安插初始化操作，并且在任何 explicit user code 之前。 在 initialization list 中使用 member function 使用是合法的，这是因为和此 object 相关的 this 指针已经被建构妥当。 如果在 initialization list 中调用 derived class member function ，其返回值被当做 base class constructor 的一个参数。那不一定是个好主意，因为 derived class member function 可能要用到的 derived class member 在 base class 的 constructor 之后才被初始化。 参考资料 关于NRV优化]]></content>
      <categories>
        <category>泛 - 书摘</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>构造函数</tag>
        <tag>拷贝构造函数</tag>
        <tag>缺省构造函数</tag>
        <tag>编译器优化</tag>
        <tag>Virtual Class</tag>
        <tag>Virtual Base Class</tag>
        <tag>NRV优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 灾难]]></title>
    <url>%2F2018%2F07%2F21%2Fmac_os_disaster%2F</url>
    <content type="text"><![CDATA[macOS 10.14 beta3 灾难性的数据丢失事故，博客数据险些全部丢失！ 2018.7.21 凌晨 博客数据在废纸篓里找到了，历劫度人。。。调整一下继续～]]></content>
      <categories>
        <category>泛 - 纪念</category>
      </categories>
      <tags>
        <tag>灾难</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 指南]]></title>
    <url>%2F2018%2F07%2F15%2Fmarkdown_guide%2F</url>
    <content type="text"><![CDATA[Markdown 是什么？ Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML ）文档”。 注意！Markdown是标记语言，而不是样式表。它只是在标注说明文本中每一块是什么。比如标题、引用、代码。最终它显示的是什么样子的取决于你浏览它的工具，如果转成 HTML 那就由浏览器决定，你想改变它的样式就需要添加 CSS（层叠样式表）。 我为什么学 Markdown？主要是博客写作需要用到，用 Markdown 写作最大的好处是自由，你的文本是独立的。如果你使用WordPress 自带的编辑器写作，它的可移植性是很低的，导出 XML 文件后转换成其他格式后很多地方都需要手动调整。还有就是项目中 Readme 文件一般用 Markdown 写，你写作时不需要任何鼠标操作。 语法标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 文本基础样式加粗1**加粗** 效果：**加粗** 斜体1**斜体** 效果：*斜体* 斜体加粗1***斜体加粗*** 效果：***斜体加粗*** 删除1~~删除~~ 效果：删除 引用123&gt; 引用的内容&gt;&gt; 引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用的内容 效果： 引用的内容 引用的内容 引用的内容 可以多级嵌套引用 分割线1234-------******** 效果： 超链接1234[超链接名](超链接地址 "超链接title")title可缺省**效果：**[Home](https//pazyx.xyz "pazyx") 效果：Home 图片1234![图片alt](图片地址 ''图片title'')title可缺省**效果：**![logo](/markdown_basic/logo.png ''blogLogo'') 效果：图片地址可以是相对地址也可以是超链接 列表无序列表123- 列表内容+ 列表内容* 列表内容 效果： 列表内容 列表内容 列表内容 有序列表1231.列表内容2.列表内容3.列表内容 效果： 1.列表内容2.列表内容3.列表内容 列表嵌套1234- 一级列表内容 - 二级列表内容 - 三级列表内容 - 四级列表内容 效果： 一级列表内容 二级列表内容 三级列表内容 四级列表内容 两级之间差两个空格即可 表格1234|表头|表头|表头|| - | :-: | :- ||内容|内容|内容||内容|内容|内容| 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。 代码行内代码1行内 `code` 行内 效果： 行内 code 行内 代码块123456789\`\`\`cpp#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World." &lt;&lt; endl; return 0;&#125;\`\`\` 效果： 1234567#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World." &lt;&lt; endl; return 0;&#125; 参考资料 markdown基本语法 Markdown插入表格语法 Markdown维基百科 Markdown中文官网]]></content>
      <categories>
        <category>泛 - 计算机</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>标记语言</tag>
        <tag>写作工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学建模——动态规划]]></title>
    <url>%2F2018%2F07%2F14%2Fmathematical_modeling_dp%2F</url>
    <content type="text"><![CDATA[概述之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺，大多数时候我都是靠直觉推状态转移方程的。这篇我希望从数学建模的角度重新总结一下动态规划（算法中的动态规划也会继续更新，最近将更新状压DP）。算法竞赛和数学建模竞赛中动态规划，在数据和方程的表示上有很大不同。算法竞赛中一般以数组单元的形式表示一个状态并用其推导状态转移方程，并且不对指标函数与最优值函数的单独推导。其形式更接近伪代码，方便将模型快速转换为代码。数学建模竞赛中步骤相当严谨很多，各个方程相互独立，各个方程也更注重数学的严谨性。 标准步骤 阶段 状态变量（无后效性） \(s_k\) 决策变量 \(x_k\) 状态转移方程 \(s_{k+1} = T_k(s_k,x_k)\) 指标函数 \(V_{k,n} = V_{k,n}(s_k,x_k,s_{k+1},…,s_{n+1},k = 1,2,…,n\) 最优值函数 \[f_k(s_k) = \max_{\{x_k,…,x_n\}} V_{k,n}\] 边界条件 例题一个简单的完全背包问题，其算法我在动态规划B2——完全背包给出。 有一个容量为 V 的背包和 N 种物品。每种物品的价值为 \(W_k\) 体积为 \(C_k\) ，每种物品有无限件，问最大背包价值。 阶段N 种物品按编号排序，视为 N 个阶段。 状态变量\(s_k\) 第 k 阶段初可装载的质量 决策变量装入第k种物品的数量：\(x_i\) 状态转移方程\[s_{k+1} = s_k - C_kx_k\] 指标函数装入的第 k 种物品到第 N 种物品总价值：\(v_k\) 最优值函数\[f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\ \ (k = 1…n)\] 边界条件 \(s_1 = V\) \(f_{n+1}(s_{n+1}) = 0\) 与算法竞赛中的动态规划对比 算法竞赛\[F[i, v] = max \{ F[i − 1, v − kC_i] + kW_i \ \ 0 ≤ kC_i ≤ v \} \] 数学建模竞赛$$\begin{cases}f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\} &amp;\text{(k = 1…n)} \\f_{n+1}(s_{n+1}) = 0\end{cases}$$ 连续型动态规划在大多数算法竞赛的题目中，决策点都是离散的。而在数学建模竞赛中可能出现连续型的动态规划问题，这种题目写出具体算法相当困难，多大需要笔算。 例题100 台某种机器可在高低两种不同的负荷下进行生产，设机器在高负荷下生产的产量函数为 g = 9x ，其中 x 为投入生产的机器数量，季度完好率为 a = 0.65 。在低负荷下生产的产量函数为 h = 4y ，其中 y 为投入生产的机器数量,季度完好率为 b = 0.95 。 建模 把4个季度看成是4个阶段，用k表示。 状态变量\(s_k\)：表示第k季度初拥有的完好机器数量。(\(s_1\) = 100) 决策变量\(x_k\)：表示第k季度分配高负荷下生产的机器数量，于是\(s_k-x_k\)为该季度分配在低负荷下生产的机器数量。\(s_k\),\(x_k\)为连续变量，其小数部分表示一台机器正常工作时间所占的比例。允许决策集合:\(D_k(s_k) = \{ x_k \ \ |\ \ 0≤x_k≤s_k \}\) 状态转移方程：\[s_{k+1} = ax_k + b( s_k - x_k ) = 0.65x_k + (s_k - x_k ) \ \ (k = 1,2,3,4) \] 指标函数：\(v_k\) 表示第 k 季度的产量 \(v_k = 9x_k + 4(s_k+x_k)\) 最优值函数：$$\begin{cases}f_k(s_k) = \max_{0≤x_k≤s_k} \{ v_k + f_{k+1}(s_{k+1}) \} = \max_{0≤x_k≤s_k} \{ 9x_k + 4(s_k-x_k) + f_{k+1}(s_{k+1}) \}\\f_5(s_5) = 0\end{cases}$$ 解当 k = 4 时 $$\begin{align}f_4(s_4)&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) + f_5(s_5) \} \\&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) \} \\&amp; = \max_{0≤x_4≤s_4} \{ 5x_4 + 4s_4 \}\end{align}$$\[x^*_4 = s_4 ,f_4(s_4) = 9s_4\] 当 k = 3 时 $$\begin{align}f_3(s_3)&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3) + f_4(s_4) \} \\&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3)+9[0.65x_3+0.95(s_3-x_3)] \} \\&amp; = \max_{0≤x_3≤s_3} \{ 2.3x_3 + 12.55s_3 \}\end{align}$$\[x^*_3 = s_3 ,f_3(s_3) = 14.85s_3\] 当 k = 2 时 $$\begin{align}f_2(s_2)&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2) + f_3(s_3) \} \\&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2)+14.85[0.65x_2+0.95(s_2-x_2)] \} \\&amp; = \max_{0≤x_2≤s_2} \{ 0.545x_2 + 18.1075s_3 \}\end{align}$$\[x^*_2 = s_2 ,f_2(s_2) = 18.6525s_2\] 当 k = 1 时 $$\begin{align}f_1(s_1)&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1) + f_2(s_2) \} \\&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1)+18.6525[0.65x_1+0.95(s_1-x_1)] \} \\&amp; = \max_{0≤x_1≤s_1} \{ -0.596x_1 + 21.72s_1 \}\end{align}$$ \[ x^*_1 = 0 , s_1 = 100 , y^*_1 = s_1 - x^*_1 = 100 , f_1(s_1) = 21.72s_1 = 2172 \] 反推 $$\begin{cases}s_2 &amp; = 0.65x_1 + 0.95(s_1 - x_1) = 95; x_2^* = s_2 = 95,y_2^* = 0 \\s_3 &amp; = 0.65x_2 + 0.95(s_2 - x_2) = 61.75,取整得61,x_3^* = s_3 = 61,y_3^* = 0 \\s_4 &amp; = 0.65x_3 + 0.95(s_3 - x_3) = 39.65,取整得39,x_4^* = s_4 = 39,y_4^* = 0\end{cases}$$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>动态规划</tag>
        <tag>连续型动态规划</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3254 Corn Fields（状压DP）]]></title>
    <url>%2F2018%2F07%2F07%2Fpoj-3254-corn-fields%2F</url>
    <content type="text"><![CDATA[题目链接：http://poj.org/problem?id=3254 Corn FieldsTime Limit: 2000MS Memory Limit: 65536K DescriptionFarmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. InputLine 1: Two space-separated integers: M and NLines 2..M+1: Line i+1 describes row i of the pasture with N space-separated integers indicating whether a square is fertile (1 for fertile, 0 for infertile) OutputLine 1: One integer: the number of ways that FJ can choose the squares modulo 100,000,000. Sample Input1232 31 1 10 1 0 Sample Output19 HintNumber the squares as follows: 121 2 3 4 There are four ways to plant only on one squares (1, 2, 3, or 4), three ways to plant on two squares (13, 14, or 34), 1 way to plant on three squares (134), and one way to plant on no squares. 4+3+1+1=9. 题解题目大意有 M×N 的玉米地，但其中有些是不肥沃的，不能种植。用 1 来代表肥沃，0 代表不肥沃。另外奶牛不喜欢挨着吃玉米，也就是说要间隔着种植，求有几种种植方式，并将计算结果对 100000000 取模。 解题思路状压DP入门题目。题目中要求不能挨着种，也就是行内不允许有相邻的地，行内比较好控制，而行间思考一下其实只需要考虑相邻两行的玉米地是否有冲突。使用一个二进制数表示一行的玉米种植情况状态：某行的玉米地分布情况 转移方程：dp[i][j] = (dp[i][j] + dp[i - 1][k])%mod第 i 行种植方案为 j 的种植方式数为等于其本身加上第 i-1 行种植方案为 k 的种植方式数，j 和 k 方案不冲突，且 j 和 k 方案本身行内不冲突，且种植土地都为肥沃的土地。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;const int MAX_N = 20;const int MAX_M = 20;int state[MAX_N + 1];int dp[MAX_N + 1][1 &lt;&lt; MAX_M];const int mod = 100000000;bool fit(int now, int flag)&#123; return (now | flag) == flag;&#125; //是否都是肥沃的土地bool ok (int x) &#123; return (x &amp; (x / 2)) == 0;&#125; //判断行内是否冲突bool not_intersect(int now,int prev)&#123; return (now &amp; prev) == 0;&#125; //判断两行间是否冲突int main() &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for( int i = 1; i &lt;= n; ++i)&#123; for( int j = 0; j &lt; m; ++j)&#123; int flag; cin &gt;&gt; flag; state[i] |= (1 &lt;&lt; j) * flag; &#125; &#125; for( int i = 0; i &lt;= 20; i++)&#123; if(ok(i)) dp[0][i] = 1; &#125; for( int i = 1; i &lt;= n; ++i)&#123; for( int j = 0; j &lt; (1 &lt;&lt; m); ++j)&#123; //枚举当前行 if(!ok(j) || !fit(j,state[i]))&#123; continue; &#125; for( int k = 0; k &lt; (1 &lt;&lt; m); ++k)&#123; //枚举下一行 if(ok(k) &amp;&amp; fit(k,state[i-1]) &amp;&amp; not_intersect(j,k))&#123; dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod; &#125; &#125; &#125; &#125; int ans = 0; for( int i = 0; i &lt; (1 &lt;&lt; m); ++i)&#123; ans = (ans + dp[n][i]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>POJ</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「记」0x01 可乐]]></title>
    <url>%2F2018%2F07%2F04%2Fweekly_1%2F</url>
    <content type="text"><![CDATA[考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下事实上我今天想写一写 可乐 我本想写的正经一点 因为我要发到我的博客上 一直以来我希望我的博客能够严谨认真 写完一篇检查多次 有什么错误马上打开电脑修改提交今天我觉得既然要谈自由 我就自由一点吧 我也不想写什么标点符号 随便写写 反正这是我的博客 我来决定它的风格 我也不分段落和什么乱七八糟的 markdown 语法了 就按我想的来吧 其中可能有错别字（我已经看到了）我也不想改了 一切都波普 说到可乐 我已经在很多地方写过很多篇了 我想在这里总结一下 别回来都没了 2017年8月28日 23:23 去楼下超市买罐装可乐 发现罐装的雪碧和芬达都在唯独少了我的可乐 我很难过 之后我在罐装的雪碧芬达面前犹豫了一会儿 又看了看瓶装的可乐 我感觉那些都不是我想要的 你们知道我是个贵族非常讲究 瓶装和罐装的可乐完全是两个味儿 我走出那个超市决定去远方那个超市闯荡一次 之后我探访了两家超市结果它们只有瓶装的 最后我鼓足勇气走进了一家火锅店 问老板有罐装的可乐吗 他犹豫了一下说只有…… 说到这儿我心凉了 心想肯定是只有瓶装的 交谈间老板带着我走到了冰柜前 老板愣了一下说只有绿茶 他估计是在想怎么瓶装的可乐也没了 突然 我看到了冰柜上层的北冰洋 我想去他妈的罐装可乐 真够麻烦的 给我来瓶北冰洋 我喝着我的北冰洋走上了回家的路 感觉味道还可以 只是我感觉今天我有点儿不讲究了 所以说今天我这个贵族落魄了 我们等待明天 明天我带你们看看我的罐装可乐 带你们体验那种自由的味道 2017年10月24日 11:25 自由的阳光 自由的可乐 军训让我体验了自由 唯一的遗憾就是为什么中区食堂的党员示范岗窗口的菜最好吃 我想如果我再多吃几天 也许我也能发现它不如人意的一面 2018年3月16日 知乎问题：为什么有人愿意买 2.5 元 330ml 的易拉罐汽水，而不买 3 元 500ml 的瓶装？回答 太巧了？我就是你说的那种买罐装可乐的人，而且我只买罐装的，更夸张的是我们学校罐装和瓶装都是3块。每次我买瓶装可乐都会剩一半以上后扔掉。我想说啊，罐装的和瓶装的可乐它完全是两个味道。罐装的一般你需要一次喝完，汽很足。而瓶装的，打开放半个小时那口感是完全不能被接受的，只能扔掉。对于我每天在食堂吃饭的情况来说，一罐罐装的可乐刚刚好，而瓶装的500ml显得略多，我还需要把它带回宿舍并且不能马上扔掉，因为那显得我很浪费。那样我就需要把它放上一段时间（一般是几个小时）得到一个足以安慰我内心的理由（它真的没汽了）再把它扔掉。我这个人很懒，不想那么麻烦。还有就是在我喝完罐装可乐并扔掉罐的时候，我会有一种奇妙的感觉，就是我感觉到了自由。因为它不像瓶装可乐每次剩下的那些给我一种束缚感，我不需要为它找一个理由再扔掉。要知道自由在我们这个社会是很稀缺的，我很享受这种感觉，我很需要罐装可乐。注意！我之前说的瓶装都是指塑料瓶装的，玻璃瓶装的那真是好味道，我可以保证它比塑料瓶装的和罐装的都更好喝并且更能让你感觉到那种自由的状态。 2018年6月27日 我想这可乐可能也没多自由 我一想象到可口可乐中国公司里的党支部开会的场面就浑身难受 这可乐代表不了自由 考完试我一定去买一瓶进口可乐感受一下自由 此刻请让我在外面溜达一会儿 让我吹一吹太平洋的风 今晚就是我的波普时间 要说我最喜欢这其中的哪篇 我觉得是第一篇 那篇写的很自由 很有现场感 也很有Andy Warhol的风格 而且它象征着我会写故事了好了 言归正传 可乐为什么能代表自由？ 我也纳闷 我仔细回忆了一下应该是我瞎编的吧 高中我看了一些Andy Warhol的书他说啊 What’s great about this country is America started the tradition where the richest consumers buy essentially the same things as the poorest. You can be watching TV and see Coca-Cola, and you can know that the President drinks Coke, Liz Taylor drinks Coke, and just think, you can drink Coke, too. A Coke is a Coke and no amount of money can get you a better Coke than the one the bum on the corner is drinking. All the Cokes are the same and all the Cokes are good.翻译：这个国家的伟大之处在于，美国开始了这样的传统:最富有的消费者买的东西基本上和最穷的人买的一样。你可以看电视，看可口可乐，你可以知道总统喝可乐，莉兹·泰勒喝可乐，想想，你也可以喝可乐。可口可乐就是可乐，再多的钱也买不到比街角的流浪汉喝的更好的可乐。所有的可乐都是一样的，所有的可乐都一样好。 现实 表面 瞬间 感性 快乐 平等 简单 机械 重复 大众 这是波普精神 可乐全占了 但就是没有自由 我也不知道 这个精神是谁想的 要是我就给它加上自由写到这儿我大概明白了 可乐代表自由也许是因为快乐 我在自由的时刻最快乐 而且喝可乐也许这世上最简单的自由方式了 电影 肖申克的救赎 里他们在监狱房顶喝着啤酒 感受到了难得的自由我想我喝可乐的时候跟他们一样 我感觉这个社会管得实在是太多了 各种网络社交媒体不能评论 不能发不能发的 各种好的网站都需要翻墙 媒体都在宣传正能量 说点其他都不行 我讨厌政治 但现在哪都是政治 可能我写了这一段我的网站就被封禁了 而且它们是合法的 因为我没备案 反正啊 我是托管在国外服务器上的 域名也是在国外买的也没备案 我也有了自己的梯子 封了我也可以自己写自己看我还是希望人民们意识到自己的自由在一点一点被剥夺 实际上我们也无力反抗 如果不能像安迪一样逃出肖申克的话 还是与我一起共饮可乐吧]]></content>
      <categories>
        <category>泛 - 记</category>
      </categories>
      <tags>
        <tag>记</tag>
        <tag>可乐</tag>
        <tag>自由</tag>
        <tag>波普</tag>
        <tag>Andy Warhol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」《Effective C++》 读书笔记（二）]]></title>
    <url>%2F2018%2F07%2F03%2Feffective-cpp02%2F</url>
    <content type="text"><![CDATA[注意！这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。 构造 / 析构 / 赋值运算条款05：了解 C++ 默默编写并调用哪些函数一个 class 如果没有声明任何构造函数和析构函数，编译器会帮你声明以下的函数 default 构造函数 copy 构造函数 copy assignment 操作符 析构函数所有这些编译器为你生成的函数都是 public 的、大多数都是 inline 的（ Effective C++ 写的是都是 inline ），且只在需要时生成。 当你声明了任何一个构造函数，编译器将不再为你声明 default 构造函数。 对于两个要做拷贝的函数，它们可能是 bitwise 或者 memberwise。具体的 Effective C++ 只做了简略的解释。想深入了解的可以看《深度探索C++对象模型》，之后我也会写读书笔记或书摘。 如果类中存在不可重新赋值的成员将报错。 比如下面的类 12345678template&lt;class T&gt;class NamedObject &#123;public: NamedObject(std::string&amp; name, const T&amp; value):nameValue(name),objectValue(value)&#123;&#125;private: std::string&amp; nameValue; const T objectValue;&#125;; 引用类型和 const 修饰的成员不可被重新赋值，如果存在两个 NamedObject&lt;int&gt; 类的对象 a 和 b ，做 a = b 将直接报错。编译器无法为它声明拷贝函数。如果基类的 copy assignment 操作符被声明为 private 也是会导致编译失败。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝可以将构造函数声明为 private 禁止调用。比如有些类不希望被拷贝，可以将 copy 构造函数和 copy assignment 操作符声明为 private 。12345678class Uncopyable&#123;protected: Uncopyable()&#123;&#125; ~Uncopyable()&#123;&#125;private: Uncopyable(const Uncopyable&amp;); Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;; 也可以让不希望被拷贝的类直接继承 Uncopyable 类。Boost 库中也提供了名为 noncopyable 的class 保证被继承的类不被拷贝。 条款07：为多态基类声明 virtual 析构函数基类无虚析构函数，会导致向上造型后被部分销毁导致内存泄露。 谨慎继承不带虚析构函数的类，如：string、STL 库中的所有容器… 不是所有的类都需要虚析构函数，vptr 和 vtbl 会占有大量空间，且降低了可移植性（不可传给其他语言）。 许多人的心得时：只有当 class 内含至少一个 virtual 函数 才为它声明 virtual 析构函数。 条款08：别让异常逃离析构函数C++ 不能同时处理多个异常，主要原因是被抛出的元素的内存空间是分配在栈区的，抛出异常后会跳出那一层括号，栈区应该被清理。如果你在存在一个异常的情况下去处理另一个异常很可能会覆盖掉之前异常抛出的元素，导致程序过早结束或出现不明确行为。如果你的类中析构会抛出异常，那这个类的容器或数组在析构时很可能遇到多个异常，造成严重的后果。 有时我们类的析构函数必须执行一个可能抛出异常的行为时怎么办？比如关闭各种连接。书中提供了三种方案1234try&#123; A.close(); &#125;catch(...)&#123; std::abort();&#125; //调用 abort 结束程序 1234try&#123; A.close(); &#125;catch(...)&#123; //记下运转记录，记下对 close 的调用失败&#125; //吞下异常 123456789101112void close()&#123; db.close(); closed = true;&#125;//析构if(!closed)&#123; try&#123; db.close(); &#125; catch(...)&#123; //记下运转记录，记下对 close 的调用失败 &#125;&#125; 第三种就是直接将 close 函数开放给使用者，让使用者在析构前调用。 条款09：绝不在构造和析构过程中调用 virtual 函数在构造函数和析构函数中调用虚成员函数，可能得不到你想要的结果，它实际上会调用基类的那个函数。 解释构造过程构造过程进入基类的构造函数时，派生类的成员还没被初始化，如果调用派生类的虚函数可能会用到派生类部分的成员，所以编译器将构造过程中的对象当做 当前进入的构造函数所属的类的一个对象，当然只能调用与当前构造函数同属一个类的函数了。 析构过程进入析构函数，先销毁掉派生类的成员，在刚进入析构函数时这个对象已经不是完整的一个派生类的对象了，编译器只能把它当做它的基类的一个对象来看待。 在构造和析构期间不要调用 virtual 函数，因为这个类调用从不下降至 drived class (比起当前执行构造函数和析构函数的那层)。 条款10：令 operator= 返回一个 reference to *this返回 *this 的引用，可以让你的类的对象实现连锁赋值。如：x = y = z = 15; 条款11：在 operator= 中处理“自我赋值”如果类中存在一个指向堆中元素的成员，那就要注意赋值时的自我赋值。123456789101112class A&#123;public: string *s; A():s(new string())&#123;&#125; A&amp; operator= (const A rhs) &#123; delete s; s = new string(*rhs.s); return *this; &#125;&#125;; 如果 this 和 &amp;rhs 相等就尴尬了，它会先 delete 自己的 s ，实际上 *this 和 rhs 里的 s 指向的 string 对象都被销毁了。数据丢失而去之后也没办法使用成员 s 了。 相对安全的版本是1234567891011121314class A&#123;public: string *s; A():s(new string())&#123;&#125; A&amp; operator= (const A&amp; rhs) &#123; if(this == &amp;rhs) return *this; delete s; s = new string(*rhs.s); return *this; &#125;&#125;; 加入认同测试，保证了 “自我赋值” 的安全性，但还不具备 “异常安全性”。如果在 s = new string(*rhs.s); 这一步导致异常，那 s 将指向一块已被删除的 string 。12345678A&amp; operator= (const A&amp; rhs)&#123; string* pOrig = pb; s = new string(*rhs.s); delete pOrig; return *this;&#125; 这样即使抛出异常，赋值失败也不会造成其他副作用，可以将 s 保持原状。 copy and swap 技术123456789void swap(A&amp; rhs); //交换*this 和 rhs 的数据 见条款29A&amp; operator= (const A&amp; rhs)&#123; A temp(rhs); swap(temp); return *this;&#125; by value 传值方式的 copy and swap 技术12345678void swap(A&amp; rhs); //交换*this 和 rhs 的数据 见条款29A&amp; operator= (const A rhs)&#123; swap(rhs); return *this;&#125; 条款12：复制对象时勿忘其每个成分12345678910111213141516171819202122232425class A&#123;private: int a;public: A()&#123;&#125; A(A &amp;rhs):a(rhs.a)&#123;&#125; A&amp; operator= (A &amp;rhs)&#123; a = rhs.a; return *this; &#125; &#125;;class B : public A&#123;private: int b;public: B()&#123;&#125; B(B &amp;rhs):b(rhs.b)&#123;&#125; B&amp; operator= (B &amp;rhs)&#123; b = rhs.b; return *this; &#125; &#125;; 小心这样的代码，B 的两个 Copying 函数，都没有拷贝基类的数据( int a )。 Copying 函数应该确保赋值“对象内的所有成员变量” 及 “所有 base class 成分”。 12345678910111213class B : public A&#123;private: int b;public: B()&#123;&#125; B(B &amp;rhs):b(rhs.b),A(rhs)&#123;&#125; // + ! B&amp; operator= (B &amp;rhs)&#123; A::operator=(rhs); // + ! b = rhs.b; return *this; &#125; &#125;; 两个 Copying 函数一般有相近的代码，但不要在一个 Copying 函数内调用另一个 Copying 函数。 应该将共同机能放进第三个函数中，并由两个 Copying 函数共同调用。]]></content>
      <categories>
        <category>泛 - 笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>读书</tag>
        <tag>笔记</tag>
        <tag>构造函数</tag>
        <tag>运算符重载</tag>
        <tag>Effective C++</tag>
        <tag>拷贝构造函数</tag>
        <tag>缺省构造函数</tag>
        <tag>virtual 函数</tag>
        <tag>自我赋值</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 与 C++ 细节差异 （一）]]></title>
    <url>%2F2018%2F07%2F01%2Fcpptojava%2F</url>
    <content type="text"><![CDATA[注释相比 C++，Java提供了三种注释方式分别为 // 单行注释 /* ... */ 多行注释 /** ... */ 文档注释前两种与 C++ 相同，最后一种可以自动将注释内容生成文档。供使用者直接查看。 基本数据类型整数 Java 存储空间 C++ 存储空间 int 4 字节 int 至少 4 字节，且大于等于 short short 2 字节 short 至少 2 字节 long 8 字节 long 至少 4 字节，且大于等于 int byte 1 字节 long long 至少 8 字节，且大于等于 long Java 提供了 4 种整数类型，与 C++ 相比 Java 的规范更为严格。可以看出 C++ 更在乎效率，而 Java 更在乎可移植性。 十六进制数和八进制数两种语言均可以使用 0x 和 0 为前缀来表示，而 Java 还提供了前缀 0b 来表示二进制数。 浮点数 Java 存储空间 C++ 存储空间 float 4 字节 float 4 字节 double 8 字节 double 8 字节 long double ( Intel ) 16 字节 两者都遵循 IEEE-754 标准 C++ 直接提供了 80 位的扩展精度浮点数，而 Java 没有提供。Java 没有提供的原因还是对可移植性的考虑，值得注意的是如果 JVM 运行在 Intel 的处理器上时，浮点数的中间运算结果默认是采用扩展精度存储的。这是因为截断会使效率大幅降低，但 Java 也提供了截断的可能性，使用 strictfp 关键字标记的方法（函数）必须严格的对中间结果截断，保证在任何处理器环境的结果的一致性。例：public static strictfp void main(String[] args) 初始化Java 禁止使用未初始化的本地变量，C++ 可以。 常量修饰符不同，Java 使用 final 修饰常量，但 const 也是 Java 的保留字。 Java C++ final type const type 常量可以不在定义出初始化，但必须保证在第一次使用前被初始化，且只初始化一次。 数组Java 没有 C++ 中在栈区分配到数组，你不可以写出这样的代码1int a[10]; 所有的数组，都需要使用 new 在堆上分配空间。 Java 提供了两种定义数组的方式12int[] a = new int[size];int a[] = new int[size]; 如果你没有初始化数组，Java 会帮你做数组的初始化。数字数组将所有元素初始化为 0 ，boolean 数组初始化为 false，对象数组初始化为 null 。 Java 中 []运算符被定义为检查数组边界，而且 Java 没有指针运算，不可以通过 a + 1 得到下一个元素。 命名规则 Java C++ 一个以字母开头的由字母或数字组成的序列，字母包括{‘A’ ~ ‘Z’、’a’ ~ ‘z’、’_’、’$’ 或在某种语言中代表字母的任何 Unicode 字符 }。 一个由数字，下划线，小写和大写拉丁字母，和大多数 Unicode 字符组成的任意长度的序列。有效的标识符必须以一个非数字字符（拉丁语字母，下划线或 Unicode 非数字字符）开头。 注：Java 中在某种语言中代表字母的任何 Unicode 字符，比如德国用户可以用 ä 。可以使用 Character 类的 isJavaIdentifierStart 和 isJavaIdentifierPart 方法检测。 C++ 中大多数 Unicode 字符是指除下表中的字符以外的 Unicode 字符。 代码点 说明 U+0300 - U+036F 组合用抑音符 - 组合用拉丁文小写字母 X U+1DC0 - U+1DFF 组合用带点抑音符 - 组合用下右箭头尖和向下箭头尖 U+20D0 - U+20FF 组合用上左鱼叉 - 组合用上星号 U+FE20 - U+FE2F 组合用连字左半 - 组合用西里尔文 Titlo 右半 重名问题在 C++ 中你可以写出这样的代码12345int a;&#123; int a;&#125; 这样进入大括号后，外层的整数 a 就被隐藏了，看不到了无法访问了，出大括号就可以继续访问外层的整数 a 了。 而在 Java 中编译器是不允许你写出这样的代码的。Java 和 C++ 大体上相同，本地变量的生存期是由其所在的大括号决定的。它们两者的不同之处在于 Java 是完全不允许在一个变量的生存期内出现另一个重名的变量，而 C++ 允许在内层定义新的重名变量隐藏外层变量。 例：12int a;int a; 这样的代码在两种语言中都是错误的。 12345&#123; int a;&#125;int a; 这样的代码在两种语言中都是正确的。 二者唯一的差别就是我在最开始的那个例子，Java 在外层 a 的生存期还没结束前不可以定义新的重名变量，而 C++ 可以。 String 与 stringString 和 string 分别为 Java 和 C++ 库里的字符串，虽然只是差一个字母大小写，实际上它们有着巨大的差异。string 更像是 char 的数组，它的每个单位都是可以直接这样 s[index] 访问的，而且可以进行修改。String 就没有那么方便了，Java 没有运算符重载只能通过 s.charAt( index ) 来转换成 char 再读。注意！String 没有提供写操作的方法。String 在 Java 中是一种不可修改的字符串。 这实际上是效率优化上的不同想法，C++ 中每个 string 的对象都独占一块内存空间，Java 的 String 不可修改就可以将多个相同的字符串变量共享一块内存空间，复制操作效率也变得很高。但这样就要在字符串比较时特别注意，Java 的对象变量都是对象的管理者，且 Java 没有运算符重载，如果你有两个 String 的对象 a 和 b ，a == b 只是在判断它们管理的是不是一块内存空间。Java 相同字符串的共享内存空间的分配方案也不是 100% 的，它只是在合适的情况下共享空间，所以两个内容相同的字符串也不一定指向同一个内存空间。它的比较有时相等有时不相等都是很有可能的，所以不要那么做！比较操作 a.equals(b) 使用 String 的 equals 方法即可。 那到底怎么修改字符串呢？你可以使用 + 运算符和 substring 方法进行拼接和切割字符串最后再赋值给原字符串。但这会有很大的开销，因为中间结果要生成很多不可改变的 String 对象。可以使用 StringBuilder 或者 StringBuffer。 参考资料C++ 基础类型标准C++ 标识符标准The Java® Language SpecificationJava 核心技术 卷I —— Cay S. Horstmann、Gary Cornell深入理解 Java 虚拟机 —— 周志明]]></content>
      <categories>
        <category>编程语言 - Java</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>浮点数</tag>
        <tag>Java</tag>
        <tag>整数</tag>
        <tag>命名规则</tag>
        <tag>String</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[basic_ios 如何穿上它的 bool]]></title>
    <url>%2F2018%2F06%2F29%2Fcin-return%2F</url>
    <content type="text"><![CDATA[为什么可以 while( cin &gt;&gt; n ) ？这个问题困扰了我很久。每次写出那行代码都在为什么没有输入时它会停，为什么可以这样写，每次写时都有些虚。为了保持我的自信，我想象了很多情况来安抚自己。起初我类比 C 语言，想着应该是 cin 这个鬼东西返回了一个 bool 类型的值。之后在学习了类与对象后，发现 cin 不过是个对象不可能返回什么值。我又给出了新的解释：也许 cin &gt;&gt; n 这个表达式是个 bool 类型的值吧。再之后我看运算符重载时，刚刚的解释也凉了。表达式 cin &gt;&gt; n 的值是 &lt;&lt; 的运算符重载函数返回的一个 basic_istream 类的对象而已。 我的想象力有一些枯竭了 … … 直到这几天我在看《深度探索C++对象模型》书时，书中的例子中提到了 basic_ios 的类型转换函数，又让我想起了之前的问题。我查阅了大量资料，大致搞清楚了 究竟为什么可以？和 解决方案的演变过程。 while 的括号里能放什么？ 任何能按语境转换为 bool 的表达式，或带花括号或等号初始化器的单个变量声明。每次迭代前求值此表达式，而若它产出 false ，则退出循环。若此为声明，则每次迭代前求值初始化器，且若被声明变量的值转换为 false ，则退出循环。 什么可以转换为 bool？对于原始数据类型，适用于C++ 标准中的布尔转换规则规则如下： 整数、浮点、无作用域枚举、指针和指向成员指针类型的纯右值能转换成 bool 类型纯右值。值零（对于整数、浮点和无作用域枚举）、空指针值和空成员指针值变为 false 。所有其他值变为 true 。std::nullptr_t 类型纯右值，包括 nullptr ，能在直接初始化的语境中转换成 bool 类型纯右值。结果值为 false 。(C++11 起) 对于用户定义类型，则需要给出 类型转换函数 或 以目标类型为参数的构造函数。 究竟为什么可以？我直接给出答案：basic_istream 的基类 basic_ios 类有一个 bool( ) 的运算符重载函数，也就是类型转换函数。12explicit operator bool() const; // C++11 //若流无错误则为 true ，否则为 false 。 这样就解决了上述问题，表达式 cin &gt;&gt; n 的值被转换为 bool 类型当然可以放在 while 的括号内没有任何问题。 演变过程上面的只是 C++11 标准库的解决方案。其实更有意思的是 basic_istream 的对象转换到 bool 类型在实现上的一些历史演变过程。 operator int() const;由于 C++ 早期是没有 bool 类型的，iostream 库的构建者 Jerry Schwarz 希望通过为 basic_ios 类编写一个类型转换函数，提供将 basic_ios 类转换为 int 类型的方式，实现 while( cin &gt;&gt; n )。可这样写后他发现一个问题，就是有人可能写出下面这种代码：1cin &lt;&lt; intValue; // 正确的应该为 cin &gt;&gt; Value; 由于 &lt;&lt; 和 &gt;&gt; 运算符很容易让程序员用乱，有的人可能会写出上面的错误代码，但当时的编译器没有报错。因为编译器发现 cin 是没有重载 &lt;&lt; ，但 int 是可以做左移 ( &lt;&lt; ) 的，程序将 basic_ios 的对象转换为 int 又进行了左移操作。这算不上错误，但至少将大部分程序员的错误隐藏了，让人难以定位错误。这个错误之后被戏称为“Schwarz Error”，在这之后 Jerry Schwarz 用下面的函数取代了 operator int () const; operator void*() const;C++ 的标准中 void* 能隐式转换为 bool 类型，Jerry Schwarz 想到了这种方式，并且还为 basic_ios 类重载了 ! 运算符，以支持 while( ! ( cin &gt;&gt; n ) )。这个函数一直维持到 C++11 的出现。 explicit operator bool() const;之前的 operato void*() const; 其实是有安全风险的。你可以直接给一个 void* 类型的变量赋一个 basic_ios 类的对象，并且没有任何的错误或警告。这是不安全的，这种类型转换应该是显性的才安全。C++11 改变了隐式转换的一些规则，解决了安全 bool 问题。C++11 之前在类型转换运算符重载函数前加上 explicit 关键字，声明它必须显式使用，以强制类型转换的形式去操作。比如：bool b = (bool)cin 才可以使用类型转换函数，而不能做 bool b = cin 这样的操作。而 C++11 标准对目标为 bool 类型的转换，改变了标准。 具体标准如下： 下列语境中，期待类型 bool ，而若声明 bool t(e); 为良式则进行隐式转换（即考虑如 explicit T::operator bool() const; 的隐式转换函数）。我们说这种表达式 e 可按语境转换为 bool。 if 、 while 、 for 的控制表达式； 内建逻辑运算符 ! 、 &amp;&amp; 和 || 的运算数； 条件运算符 ?: 的首个运算数； static_assert 声明中的谓词；(C++11起) noexcept 指定符中的表达式； explicit 指定符中的表达式；(C++20 起) 契约属性 的谓词。(C++20 起) 这样在非上述语境下转换为 bool 类型就需要显式转换，而在控制表达式中可以自动的隐式转换。增强安全性的同时也保证向前兼容。 参考资料 隐式转换 std::basic_ios std::basic_ios::operator bool explicit 指定符 while 循环 if 语句 《深度探索C++对象模型》—— Stanley B. Lippman 《C++语言的设计与演化》—— Bjarne Stroustrup]]></content>
      <categories>
        <category>编程语言 - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>bool</tag>
        <tag>basic_ios</tag>
        <tag>运算符重载</tag>
        <tag>类型转换</tag>
        <tag>Cpp演化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System.in]]></title>
    <url>%2F2018%2F06%2F16%2FSystem-in%2F</url>
    <content type="text"><![CDATA[Scanner in = new Scanner(System.in) 2018.6.10]]></content>
      <categories>
        <category>泛 - 纪念</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>纪念</tag>
        <tag>省赛</tag>
        <tag>ACM题目</tag>
        <tag>Java</tag>
        <tag>Scanner</tag>
        <tag>System.in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC LD DD 命令选项]]></title>
    <url>%2F2018%2F05%2F11%2Fgcc-ld-dd-cmd%2F</url>
    <content type="text"><![CDATA[概述此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。 GCC -c 进行预处理、编译、汇编，生成目标代码文件，不进行链接 -S 仅进行预处理、编译，生成汇编代码文件 -E 仅进行预处理 -o file 指定输出文件名 GCC 8.1 manuals 摘录 -I (大写 i ) 指定头文件位置 -L (大写 L ) 指定库文件位置 -l (小写 L) 指定库名字 -I -L -l 选项的详解分别在 GCC 8.1 manuals 的第 200、201、195 页 -Wall 开启大部分警告，列表如下。一些不常用的警告可加 -Wextra 选项配合 - Wall 全部打开 选项 -Waddress -Warray-bounds=1 (only with ‘-O2’) -Wbool-compare -Wbool-operation -Wc++11-compat -Wc++14-compat -Wcatch-value (C++ and Objective-C++ only) -Wchar-subscripts -Wcomment -Wduplicate-decl-specifier (C and Objective-C only) -Wenum-compare (in C/ObjC; this is on by default in C++) -Wformat -Wint-in-bool-context -Wimplicit (C and Objective-C only) -Wimplicit-int (C and Objective-C only) -Wimplicit-function-declaration (C and Objective-C only) -Winit-self (only for C++) -Wlogical-not-parentheses -Wmain (only for C/ObjC and unless ‘-ffreestanding’) -Wmaybe-uninitialized -Wmemset-elt-size -Wmemset-transposed-args -Wmisleading-indentation (only for C/C++) -Wmissing-attributes -Wmissing-braces (only for C/ObjC) -Wmultistatement-macros -Wnarrowing (only for C++) -Wnonnull -Wnonnull-compare -Wopenmp-simd -Wparentheses -Wpointer-sign -Wreorder -Wreorder -Wrestrict -Wreturn-type -Wsequence-point -Wsign-compare (only in C++) -Wsizeof-pointer-div -Wsizeof-pointer-memaccess -Wstrict-aliasing -Wstrict-overflow=1 -Wswitch -Wtautological-compare -Wtrigraphs -Wuninitialized -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value -Wunused-variable -Wvolatile-register-var -fno-builtin 不承认不以 __builtin_ 开头的内建 ( built-in ) 函数。 -ggdb 生成用于GDB的调试信息 -gstabs 使用stabs格式生成调试信息， -nostdinc 不搜索头文件的标准系统目录 -fno-stack-protector 禁用堆栈保护机制 GNU linker ( ld ) 命令选项 -m emulation 模拟仿真链接器 如：-m elf_i386 -nostdlib 只用在命令行中显式指定的搜索库目录 -N 设置代码段和数据段均可读写 -e 指定入口 -Ttext 连接时重定向初始地址 dd 命令参数 if 代表输入文件。如果不指定if，默认就会从stdin中读取输入。 of 代表输出文件。如果不指定of，默认就会将stdout作为默认输出。 bs 代表字节为单位的块大小。 count 代表被复制的块数。 /dev/zero 是一个字符设备，会不断返回0值字节（\0） 参考资料 GCC 8.1 manuals ld GNU Development Tools ( man ld ) Linux dd 命令详解]]></content>
      <categories>
        <category>泛 - 计算机</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
        <tag>gcc</tag>
        <tag>ld</tag>
        <tag>dd</tag>
        <tag>操作系统</tag>
        <tag>linker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X86 计算机启动流程]]></title>
    <url>%2F2018%2F05%2F03%2Fx86-cpu-boot%2F</url>
    <content type="text"><![CDATA[硬件加电后寄存器初始值加电后 CPU 进入实模式（为了兼容早期的8086处理器），实模式下 CPU 只有 1M 的寻址空间，地址计算为: $EA = Base + EIP$ 即加电后的起始地址为 $CS:EIP = FFFF0000H+0000FFF0H = FFFFFFF0H$ 从 FFFFFFF0H 到 00007C00HFFFFFFF0H 中有什么呢？这里放着的是 CPU 要执行的第一条指令，通常是一条长跳转指令，它会设置 CS 和 EIP 将控制权交给 BIOS 做初始化工作。 BIOS 的执行过程 硬件自检 检测关键部件的存在和工作状态 查找并执行接口卡的 BIOS 进行设备初始化 执行系统 BIOS 进行系统检测，检测和配置即插即用设备 更新 CMOS 的扩展系统配置数据 ESCD (系统配置表) 按指定顺序从软盘、硬盘或光驱启动 读取主引导扇区代码，拿到主引导记录 主引导扇区代码读取活动分区的引导扇区代码 活动分区的引导扇区代码读取文件系统的加载程序到内存中的 00007C00H 处 将 CS:EIP 设置为 00007C00H 控制权交给加载程序( bootloader ) 至此计算机的控制权已经交给操作系统的 bootloader 程序。 bootloader 启动过程 切换到保护模式，启用分段机制 读磁盘中 ELF 执行文件格式的操作系统到内存 显示字符串信息 把控制权交给操作系统 bootloader 代码ucore asm.h bootasm.S bootmain.c xv6 bootasm.S bootmain.c]]></content>
      <categories>
        <category>泛 - 计算机</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>寄存器</tag>
        <tag>CPU</tag>
        <tag>硬件</tag>
        <tag>bootloader</tag>
        <tag>BIOS</tag>
        <tag>启动流程</tag>
        <tag>X86</tag>
        <tag>Intel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AT&T 与 Intel 汇编主要语法差异]]></title>
    <url>%2F2018%2F04%2F23%2Fatt-intel-differents%2F</url>
    <content type="text"><![CDATA[操作数顺序在一般的二元指令（如 mov、add …）中，两个操作数分为源操作数和目的操作数。AT&amp;T 与 Intel操作数的顺序正好相反。 “Op-code dst src” in Intel syntax. “Op-code src dst” in AT&amp;T syntax. 寄存器名称AT&amp;T 语法中寄存器名称需要加前缀 ’%’ ，而 Intel 不需要。 立即数AT&amp;T 语法中立即数需要加前缀 ’$’ ，对于静态 ‘C’ 变量也一样。Intel的语法标准不需要。 操作数大小AT&amp;T 语法中，操作数大小由指令的最后一个字符决定，“b”、“w” 和 “l” 的指令后缀分别表示字节(8位)、word(16位)和长(32位)内存引用。 Intel 语法中，由操作数的前缀 ’byte ptr’, ’word ptr’, 和 ’dword ptr’ 决定。 “mov al, byte ptr foo” in Intel syntax “movb foo, %al” in AT&amp;T syntax 寻址方式AT&amp;T 语法中基指寄存器被 ( ) 括起来，而 Intel 语法中使用 [ ] 。 地址表示： section:[base + index*scale + disp] in Intel syntax section:disp(base, index, scale) in AT&amp;T syntax section：段地址 disp：偏移地址 index：变址 scale：比例因子 计算公式：[EA = base + ( index * scale ) + disp] 对比 Intel Code AT&amp;T Code mov eax,1 movl $1,%eax mov ebx,0ffh movl $0xff,%ebx int 80h int $0x80 mov ebx,eax movl %eax,%ebx mov eax,[ecx] movl (%ecx),%eax mov eax,[ebx+3] movl 3(%ebx),%eax mov eax,[ebx+20h] movl 0x20(%ebx),%eax add eax,[ebx+ecx*2h] addl (%ebx,%ecx,0x2),%eax lea eax,[ebx+ecx] leal (%ebx,%ecx),%eax sub eax,[ebx+ecx*4h-20h] subl -0x20(%ebx,%ecx,0x4),%eax 参考资料 GCC-Inline-Assembly-HOWTO : http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s3]]></content>
      <categories>
        <category>编程语言 - Assembly</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类与对象总结（四）访问属性]]></title>
    <url>%2F2018%2F04%2F15%2Fcpp-class-4%2F</url>
    <content type="text"><![CDATA[概述C++的访问属性我在本系列的第一篇 C++类与对象总结（一） 已经有了一些介绍，但那时没有介绍继承中的访问属性问题，而且最近对 C++的保护模型也有了一些新的理解。此篇为 C++类与对象总结（一） 在访问属性方面的补充。 概念在 C++ 语言中有 public、protected 和 private 这三种访问属性。 public：任何地方都可以访问 protected：只有这个类和它的派生类可以访问 private：只有这个类可以访问 概念 1 保护是通过编译时的机制提供的，目标防止发生意外事件，而不是防止欺骗或者有意侵犯。 2 保护的单位是类，而不是某个对象。 3 受控制的是访问权，而不是可见性。 这其中的前两条我已经在 C++类与对象总结（一） 中讲解并搭配了实验。 讲解清楚第三条之前，我们需要弄清楚什么是可见性。 可见性： 这个概念很常见，比如下面的代码：123456789101112#include &lt;iostream&gt;using namespace std;int i = 1;int main()&#123; int i = 2; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; 这段程序的输出显然是 2，因为在 main 函数中第 4 行的全局的整数 i 是不可见的，它被第 8 行的局部整数 i 所遮蔽了。 我们再来看这个程序12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a = 2;class AA&#123;private: int a;&#125;;class AAB : public AA&#123;public: void fun() &#123; a = 1; &#125;&#125;;int main()&#123; AAB x; x.fun(); cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; 在 AA 类中有一个私有的成员 a ，AAB 类 public 继承了 AA 类。显然现在 AAB 类的对象有了一个私有成员 a ，但这个 a 是 AA 类私有的，a 对于 AAB 类的 fun 函数有可能是不可见的，也有可能是不可访问的。 如果是不可见的：我们可以看到代码中有一个全局变量 a ，不可见的话 fun 函数中会修改全局的 a 。 如果是不可访问的：那编译应该通不过，因为它在访问修改一个 private 的成员。 尝试编译得到下面的结果12345temp.cpp: In member function &apos;void AAB:fun()&apos;:temp.cpp:17:3 error: &apos;int AA:a&apos; is private within this context a = 1;temp.cpp:9:6: note: declared private here; int a; 它说 AA 类中的 a 是私有的。所以说这三个关键字限制的是访问属性而不是可见性。 访问权限究竟是在限制谁？它是在限制该类后续的使用者，而不是在限制该类现在的设计者！在后面的组合和继承中的访问权限会出现访问权限的多次限制，很多初学者会分不清楚类内和类外访问权限的区别，所以在这里先说明一下。访问权限我们关心的是我们做的这个类在未来的使用者手中的访问权限。因为三种访问权限均允许在类内访问，类内的访问权限只由其中的成员之前设计访问权限有关，与当前要设计的类赋予的访问权限无关。 类会在哪些地方被使用？ 作为变量被使用 在其派生类中被使用 向上造型，是否可以做指针或引用的类型转换 对象组合中的访问属性问题在讲继承中的访问权限之前我想先介绍组合中的访问权限。它们很相近，区别也会在下面讲到。1234567891011class AA&#123;public: int a;&#125;;class AAB&#123;private: AA b;&#125;; 如果在 AAB 类外访问成员 b 中的成员的 a，会怎么样呢？当然是编译错误。因为在访问成员 b 中的成员 a 实际上是在访问成员 b ，而成员 b 是私有的不可访问。 这里访问权限发生了叠加，成员 a 的访问权限 AA 类赋予它的 public 再加上 AAB 类赋予成员 b 的 private 。这里发生了访问权限的叠加。 访问权限叠加时会怎么样？ 我们再来看一下这三种访问权限的特点，从 public 任何地方都可以访问，上升到 protected 只能在类内和其子子孙孙的类中可以访问，再上升到 private 只能在类内访问。不难发现这三种访问权限的严格程度逐级递增，在发生访问权限叠加时应选择最严格的访问权限声明去限制其访问权限。因为访问是逐层进行的。 这就比如你现在需要乘坐很多种交通工具回家，假设一路上要乘坐船、地铁、飞机、汽车。你的行李中有一个打火机，你会想一下坐飞机不让携带打火机而选择不带它，而不会因为坐船、汽车、地铁都可以携带打火机而带上它。因为是否可以携带这些行李取决于你这一路上要接受的所有安检中最严格的那一个。 继承中的访问属性问题常见三种继承就对应于这三种访问权限，继承的分类也由这三种访问属性产生的。1234567891011121314151617181920212223242526272829303132class Base1&#123;private: int a1;protected: int b1;public: int c1;&#125;;class Base2&#123;private: int a1;protected: int b1;public: int c1;&#125;;class Base3&#123;private: int a1;protected: int b1;public: int c1;&#125;;class Y : public Base1, protected Base2, private Base3&#123;&#125;; 我们讨论这段代码中 Y 类每个成员的范围属性。 再次提醒初学者！我们讨论的是在之后用到 Y 类时的访问属性，比如：从由 Y 类所定义的对象对其中成员的访问、在 Y 类的派生类中对其成员的访问。初学者可能会想知道在 Y 类内部对这些成员的访问属性问题。这里说明一下在 Y 类内部访问继承得到的成员是否受限与继承方式无关，只与基类声明的访问属性有关。比如在 Y 类内部访问成员 c3 是可以的，因为在 Base3 中声明其是 public 的访问属性，而这与它是以 private 方式继承无关。 这就与对象组合中的访问属性问题很相似了，我们再来看一段代码。123456789class Y&#123;public: Base1 a;protected: Base2 b;private: Base3 c;&#125;; 如果把 Y 类改写成这个样子，其所有成员的访问属性与之前的 Y 类相同。虽然它们的访问属性是一致的，但因为现在 Y 类不再是三个Base类的派生类了，所以在 Base 类中访问属性为 protected 的成员将不能在 Y 类和其派生类中被访问。 判断一个成员在继承过程中的访问属性时，可以通过将其转变为对象组合时的访问属性问题判断。注意这样判断的是它究竟是哪种访问属性，而不是它能不能被访问。能不能被访问应根据访问属性和是否为派生类判断。 其他问题向上造型 这里要分为两个位置： 一、在该类的 public 派生类中 public：可以 protected：可以 private：当做无子父类关系，无法做指针或引用的类型转换 二、在其他位置 public：可以 protected：当做无子父类关系，无法做指针或引用的类型转换 private：当做无子父类关系，无法做指针或引用的类型转换 内部类问题 在内部类中对该类中的成员访问与在该类的成员函数访问一致，与内部类声明的访问属性无关。 模板类问题 模板类只是声明，编译器会根据每次指定的类型每次定义一个新的类，所以同一个模板是使用两个不同的类型定义的类是属于两个不同的类。1234567891011121314151617181920template&lt;typename T&gt;class X&#123;private: int member;public: template&lt;typename U&gt; void Method(X&lt;U&gt;&amp; y) &#123; &amp;y.member; &#125;&#125;;int main()&#123; X&lt;int&gt; x; X&lt;float&gt; y; x.Method(x); // 可以 x.Method(y); // 不可以&#125; 这里的 18 和 19 行作为对比，x 的 Method 传入它自己（相同类型）访问其 private 成员不会报错，而 x 的 Method 传入它的模板根据 float 定义的对象 y 再访问其 private 成员则会报错。]]></content>
      <categories>
        <category>编程语言 - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>访问属性</tag>
        <tag>对象组合</tag>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>可见性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「公告」 近期文章中的错误and博客计划]]></title>
    <url>%2F2018%2F04%2F06%2Fnotice-1%2F</url>
    <content type="text"><![CDATA[最短路算法1——Dijkstra描述不清楚： 在时间复杂度最后的总结中，我之前提到“对于稠密图来说有时不优化比利用最小堆优化更高效”。实际上一般的图，甚至是完全图，利用最小堆优化效率都是优于不优化的。只有一种情况是相反的，就是边确实特别多，是顶点数的高次幂（3以上）的情况。一般来说这种图很少见，完全图的边数也就是顶点数的平方量级的，出现高次幂量级的边只有可能是有存在大量重边，在这里我们处理的是最短路问题我们可以只保留两个顶点之间最短的边，以消除重边。 补充： 一般的最短路算法，还有一种问法就是最长路问题。这个可以把所有的边权值都取相反数，初始化时将dist数组初始化为最小值，一般为INT_MIN。将比较符合取相反，结果取相反数。 C/C++程序中的内存分配错误： 我在“运行中的内存分配回收时机”中提到，代码段、数据段和BSS段在程序刚开始运行时分配。 实际上代码段准确的说是在编译时刻分配，其中的数据写在二进制文件中。数据段和BSS段中的局部静态变量是在第一次运行到定义位置分配，这个我在下文提到。 错误原因： 自己想的不够清晰，表达时不够严谨。 动态规划B1——01背包和动态规划B2——完全背包错误： 存在一些字母大小写问题，引起伪代码歧义。 串匹配算法2——KMP展示问题： 例子中的字符串对齐我采用了空格和tab对齐，在一些低分辨率的设备上可能对齐会有错误，影响理解。 我本想以图片形式展示，但考虑到例子较多、图片排版不美观等问题，暂时还是以现在这种形式，之后发现什么好的方式我再修改。 博客计划德州扑克的学习笔记一再delay，下周前一定更新。 希望写一些面向对象程序设计的文章。准备写几篇Java面向对象程序设计的文章，关注设计模式和一些实现手法。而C++主要还是想研究一下它的底层实现和准确的标准定义细节问题。结合Java 和 C++学习面向对象的设计模式。 数据结构和算法方面，我的计划是先学习一些对ACM题目实用的算法，对图论和动态规划有些兴趣。基础的数据结构（链表、树…）已经有一定了解，暂时先用STL苟住，之后再研究其各种实现细节。一些高级数据结构广泛了解一下。 题解，一直没更的原因是一直没有写过题了，由于时间不够由于懒惰。之前想写一类题目搞成一整篇发出去。但同一类题我能找到的有限感觉不成篇幅，就先存着草稿了。之后我计划是对于难度较高和有思考难度的题目单独发，简单的算法只给出简单思路和代码写成一整篇打包发。之后我还计划参加一些线上的竞赛，写一些竞赛中的经验体会。 娱乐节目，之前买了一堆可乐准备做个可乐大评测。一直没有写也没有喝，原因在于我一直发现有新的可乐，总想及其后一起体验。我想我估计是集不齐了，实在不行我就开个系列慢慢体验。这个也不是什么大事，我就看看什么时候有时间有心情，写一些吧。 书摘和笔记，我爱什么时候写什么时候写！ 淘宝店计划，店已经开好了，纸还没搞到。大概依旧是性冷淡风，反正也没人买，我就开个玩一下。]]></content>
      <categories>
        <category>泛 - 公告</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>动态规划</tag>
        <tag>完全背包</tag>
        <tag>算法</tag>
        <tag>背包问题</tag>
        <tag>01背包</tag>
        <tag>公告</tag>
        <tag>C</tag>
        <tag>计划</tag>
        <tag>Dijkstra</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++程序中的内存分配]]></title>
    <url>%2F2018%2F04%2F03%2Fccppmemory%2F</url>
    <content type="text"><![CDATA[C/C++程序中内存分为五个区域名称及其储存的数据如下 代码段：可执行代码、字符串常量 数据段：已初始化的全局变量（包括所有静态变量）、常量 BSS段：未初始化的全局变量（包括所有静态变量）、常量 栈：局部变量（包括函数参数） 堆：动态内存分配 需要注意这其中的代码段是只读的，其他区域都是可读可写的。 比如这种操作就是错误的！ 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; char *s = "Hello"; //char ss[] = "Hello"; printf("%s",s); s[1] = 'E'; printf("%s",s); return 0;&#125; 在Unix-like的系统中运行时会产生 Bus error: 10 的错误，原因就在于”Hello”为字符串常量它在代码段，它是不可写的。 第 7 行中给出了另一种的写法，这种写法就不会有问题，原因是编译器会给这个数组在栈中分配一块内存把代码段中的”Hello”拷贝过来。 运行中的内存分配回收时机代码段的空间在编译时刻分配，数据段和BSS段中的全局变量在程序开始运行时被分配，而栈、堆和静态变量的内存分配就会相对复杂一些。 栈123456789101112131415#include &lt;iostream&gt;using namespace std;int f(int b)&#123; int c = 1; return b + c;&#125;int main()&#123; int a; a = f(2); return 0;&#125; 比如这段程序中所有的变量都为局部变量，都存放在栈区。栈区的内存分配发生在进大括号时，回收发生在出大括号时。 变量 a 在 12 行被定义，而它的内存空间已经在 11 行进大括号时就分配好了，内存的回收会在 main 函数结束前的 14 行发生。 f 函数中的参数变量 b 在 13 行分配空间并初始化，在离开 f 函数时回收空间。 变量 c 在第 6 行被定义，它的内存分配和回收与变量 a 类似。 临时变量 b + c 作为返回值在第 13 行调用 f 函数时分配，回收应在出 main 函数结束前。（临时变量的地址，可通过 C++11 的右值引用查看。） static局部变量1234void f()&#123; static int c = 2;&#125; 像这样的静态局部变量 c 它的内存分配只会在第一次进入 f 函数时分配，内存回收与已初始化的全局变量一样放在全局数据区（数据段）中（若未初始化或初始化的值在编译时刻不可得到则在分配在BSS段中），它的内存回收与其他全局变量一致在程序结束之前回收。关于如何保证局部静态变量只初始化一次的问题可以看这里：https://www.cnblogs.com/novice-dxx/p/7094690.html vector的内存回收vector可以通过 clear() 函数清空，但其内存空间却并没有回收。根据栈中内存回收的机制，我们可以以下面这种方式进行内存回收。123456vector&lt;int&gt; v;&#123; vector&lt;int&gt; x; v.swap(x);&#125; 在内层括号中定义一个空 vector x 交换两者后，出括号后临时的 vector x会析构并回收内存空间。 堆堆中的内存用于动态内存分配，动态申请像 C 中的 malloc 和 C++中的 new 运算符都可完成。 堆中的内存分配只发生在调用内存申请函数或使用 new 运算符时 堆中的内存回收在 delete 时或程序结束时发生 测试代码Ubuntu Pastebin : https://paste.ubuntu.com/p/WXScjfWQ3z/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;using namespace std;int global_initialized_0 = 0;int global_initialized_1 = 0;int global_0;int global_1;int main()&#123; char *const_string_0 = "Hello"; char *const_string_1 = "World"; static int static_local_initialized_0 = 0; static int static_local_initialized_1 = 0; static int static_local_0; static int static_local_1; int local_0; int local_1; int *p_0 = new int [100]; int *p_1 = new int [100]; printf("代码段:\n"); printf("main = %p\n",main); printf("const_string_0 = %p\n",const_string_0); printf("const_string_1 = %p\n",const_string_1); printf("\n"); printf("数据段:\n"); printf("global_initialized_0 = %p\n",&amp;global_initialized_0); printf("global_initialized_1 = %p\n",&amp;global_initialized_1); printf("static_local_initialized_0 = %p\n",&amp;static_local_initialized_0); printf("static_local_initialized_1 = %p\n",&amp;static_local_initialized_1); printf("\n"); printf("BSS:\n"); printf("global_0 = %p\n",&amp;global_0); printf("global_1 = %p\n",&amp;global_1); printf("static_local_0 = %p\n",&amp;static_local_0); printf("static_local_1 = %p\n",&amp;static_local_1); printf("\n"); printf("堆:\n"); printf("p_0 = %p\n", p_0); printf("p_1 = %p\n", p_1); printf("\n"); printf("栈:\n"); printf("local_0 = %p\n", &amp;local_0); printf("local_1 = %p\n", &amp;local_1); printf("\n"); delete[] p_0; delete[] p_1; return 0;&#125; Mac OS 64bit 输出结果Ubuntu Pastebin : https://paste.ubuntu.com/p/5z3Kb5SZrk/123456789101112131415161718192021222324代码段:main = 0x1066afb80const_string_0 = 0x1066afe56const_string_1 = 0x1066afe5c数据段:global_initialized_0 = 0x1066b0028global_initialized_1 = 0x1066b002cstatic_local_initialized_0 = 0x1066b0038static_local_initialized_1 = 0x1066b003cBSS:global_0 = 0x1066b0030global_1 = 0x1066b0034static_local_0 = 0x1066b0040static_local_1 = 0x1066b0044堆:p_0 = 0x7fcd6f4028f0p_1 = 0x7fcd6f402a80栈:local_0 = 0x7ffee95507e4local_1 = 0x7ffee95507e0]]></content>
      <categories>
        <category>编程语言 - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>C</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路算法1——Dijkstra]]></title>
    <url>%2F2018%2F03%2F23%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[概述最短路径问题有众多的算法，对于无权图的最短路径 DFS与BFS 就可以轻松解决。而对于有权图来说就相对复杂一些，接下来要介绍的就是一种求有权图的单源最短路径的算法—— Dijkstra 算法。需要注意的是这里的 Dijkstra 算法要求图中不能出现负值圈和负权边，出现负值圈在 Dijkstra 算法的某些优化下会造成程序的无限循环（可处理），而出现负权边会得出错误结果。 负权边的错例：Dijkstra 的局限 思想无权图可以认为是特殊的有权图，只是它的边权全都为 $1$ 。想一想 BFS 是怎么找到最短路径的，它是通过一层一层的扩展，按照非递减的顺序去收录每个点。Dijkstra 算法的思想也是按照非递减的顺序收录每个点，最终找到最短路径。 与 BFS 不同的是，有权图中什么算一层呢？实际上 BFS 说是按层扩展，另一种理解可以是按照距离的从近到远去扩展。Dijkstra 算法就是每次收录一个距离最近且未被收录的点。这里还有一些小问题，比如收进来的点会不会影响其他点到起始点的距离？怎么初始化？怎么找出最近的点？我们先上代码之后给出答案。 实现代码：Ubuntu Pastebin : https://pastebin.ubuntu.com/p/vfwbH7QHF3/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int MAX_N = 100;int map[MAX_N][MAX_N]; // 使用邻接矩阵表示图bool collected[MAX_N]; // 每个结点是否被收录int dist[MAX_N]; // 每个结点到起始点的距离int path[MAX_N]; // 最短路径中的每个结点的上一个节点的下标int n; // 结点个数void init() // 初始化&#123; memset(collected,false,sizeof(collected)); memset(dist,0x7f,sizeof(dist)); memset(path,-1,sizeof(path));&#125;void Dijkstra(int start)&#123; init(); dist[start] = 0; while(true)&#123; int min = INT_MAX; int min_index = -1; for( int i = 1; i &lt;= n; i++)&#123; if(min &gt; dist[i] &amp;&amp; !collected[i])&#123; min = dist[i]; min_index = i; &#125; &#125; //找出最近的未被收录的点 if(min_index == -1)&#123; //如果找不到，跳出循环 break; &#125; collected[min_index] = true; //将该点收录， for( int i = 1; i &lt;= n; i++)&#123; //遍历该点的邻接点 if(map[min_index][i] != -1 &amp;&amp; !collected[i])&#123; int temp = dist[min_index] + map[min_index][i]; if(temp &lt; dist[i])&#123; dist[i] = temp; path[i] = min_index; &#125; &#125; &#125; &#125;&#125; 核心步骤 初始化（包含更新起始点 dist 值） 找到并收录最近的未被收录的点 更新该点的邻接点 循环 $1,2$ 直至所有连通点均被收录 dist 数组中保存着什么？它保存的是从起点开始经过已被收录的点到达每个点的最短距离，初始状态下没有任何点被收录所以全为正无穷。 当程序将一个最近的点收录进来时，该点是有可能会影响其他的点到起始点的距离。比如这个图，从 $1$ 走到 $3$。我们先收录了 $1$ 点，更新 $2$ 的距离为 $1$ ，$3$ 的距离为 $5$，下一步我们将收录 $2$ ，收录之后就会影响到它的邻接点（也就是 $3$ ）的距离。我们会把 $3$ 的距离更新为 $2$ 。这就是 36-44 行的意义。 初始化问题： 一开始将所有点的距离初始化为正无穷，将路径数组初始化为 $-1$。如果最终某点的距离仍为正无穷或路径数组仍为 $-1$，说明该点到起始点之间不连通。 重边问题：如果图用邻接表来表示的话不会有重边问题，而邻接矩阵的话如果两点间有很多条边，它只会保存最后插入的边。如果是最短路问题的话我们可以在插入边时检查当前这条边的权重是否小于之前插入的边，是则插入覆盖，否则不插入当前边。 输出路径问题：一般的可以用一个栈依次压入 path 数组中的值，再将它们依次弹出输出。有些题目给的是一个无向图且只问起点与终点的最短路径，这样的话我们可以颠倒起点和终点，path 数组也就被颠倒就不用栈就输出最短路径了。 优化我们上面的代码最浪费时间的就是找出未收录的点中最近的点的操作，每次都要遍历所有的点去查找。我们可以用一个优先队列或最小堆去优化它。接下来我先给出利用优先队列优化后的代码，此代码将用邻接表来保存图以区别于之前的代码，帮助大家更好的了解 Dijkstra 算法的各种实现。 利用STL库中的优先队列优化代码：Ubuntu Pastebin : https://paste.ubuntu.com/p/ttngrNMyf7/123456789101112131415161718192021222324252627282930313233343536373839const int MAX_N = 100;struct edge &#123; int next, weight;&#125;;typedef pair&lt;int ,int&gt; P;vector&lt;edge&gt;G[MAX_N]; //邻接表表示的图int dist[MAX_N];int path[MAX_N];void Dijkstra(int start)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;que; //建立一个以小数值为高优先级的的优先队列 dist[start] = 0; que.push(P(0,start)); //将起始点入队 while(!que.empty())&#123; //如果队列为空，说明所有点都已被收录，结束该算法 P p = que.top(); que.pop(); int v = p.second; if(dist[v] &lt; p.first)&#123; //如果找到的节点不符合非递减规则，找下一个队列中的节点 continue; &#125; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(dist[e.next] &gt; dist[v] + e.weight)&#123; dist[e.next] = dist[v] + e.weight; path[e.next] = v; que.push(P(dist[e.next],e.next)); //将邻接点入队 &#125; &#125; &#125;&#125; 这里我们看到跟之前的代码逻辑可能有一些不太一样，按照之前的逻辑 while 循环应该按下面的方式实现。1234567891011121314151617181920212223while(!que.empty())&#123; //如果队列为空，说明所有点都已被收录，结束该算法 P p = que.top(); que.pop(); int v = p.second; collected[v] = true; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(!collected[e.next] &amp;&amp; dist[e.next] &gt; dist[v] + e.weight) &#123; dist[e.next] = dist[v] + e.weight; path[e.next] = v; if(!in_que[e.next])&#123; //在定义一个全局的bool数组标记点是否入队 que.push(P(dist[e.next],e.next)); //将邻接点入队 in_que[e.next] = true; &#125; &#125; &#125;&#125; 这是很常见的一种错误优化，我之前也写出过这样的代码。错误是因为已入队的元素是无法实时更新，无法保证更新 dist 数组时同时更新队列中的元素，所以我们改为允许结点多次入队不收录它，像之前的代码虽然效率有所下降但保证了代码的正确性。 利用最小堆优化使用优先队列优化时遇到的问题是不能及时更新队列中元素的信息，而最小堆可以快速的查找删除再插入可以随时更新想更新的结点的信息，解决之前使用STL库中的优先队列所遇到的问题。代码：Ubuntu Pastebin : https://paste.ubuntu.com/p/thKfPjDRvd/12345678910111213141516171819202122232425262728293031323334353637383940const int MAX_N = 100;struct edge &#123; int next, weight;&#125;;typedef pair&lt;int ,int&gt; P;vector&lt;edge&gt;G[MAX_N]; //邻接表表示的图int dist[MAX_N];int path[MAX_N];bool collected[MAX_N]; //标记每个顶点是否被收录void Dijkstra(int start)&#123; set&lt;P, less&lt;P&gt; &gt; min_heap; //用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。 dist[start] = 0; min_heap.insert(make_pair(0, start)); collected[start] = true; while(min_heap.size())&#123; //如果堆为空，说明所有点都已被收录，结束该算法 auto iter = min_heap.begin(); int v = iter-&gt;second; min_heap.erase(*iter); collected[v] = true; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(!collected[e.next] &amp;&amp; dist[e.next] &gt; dist[v] + e.weight) &#123; min_heap.erase(make_pair(dist[e.next], e.next)); //删除之前插入堆中的数据 dist[e.next] = dist[v] + e.weight; path[e.next] = v; min_heap.insert(make_pair(dist[e.next], e.next)); //更新之后重修插入该结点 &#125; &#125; &#125;&#125; 时间复杂度分析$V$ 代表结点的个数，$E$ 代表边的个数。 完全没有优化：每个顶点被收录一次，所以外层的 while 循环是 $O(V)$ 的，while中每次需要遍历一次所有的顶点，又是一个 $O(V)$ 的扫描。再加上每条边都要被访问一次时间复杂度为 $O(V^2 + E)$。 利用优先队列优化：虽然节点会多次入队，但每条边最多导致一次入队，所以其时间复杂度为 $O( E \log E )$。 利用最小堆优化：利用最小堆之后我们不用在内层需要进行 $O(V)​$ 的扫描了，获得最近的结点的操作时间复杂度变为 $O(\log V)​$，而每次更新 dist 数组的操作因为要删除再插入堆中复杂度从 $O(1)​$ 变为 $O(\log V)​$。总体的时间复杂度为 $O( (V + E) \log V )​$。 对于一个稀疏图来说利用最小堆做优化后效率会高很多，而对于一个稠密图来说两者效率是差不多的。利用优先队列的优化方式编程复杂度相对最小堆优化的方式会低一些，方便快速实现该算法。 Demo &amp; Keynote我讲解 Dijkstra 算法用的课件中附有算法的动画演示，希望对大家理解 Dijkstra 算法有所帮助。HTML版本在 GitHub Pages 托管，可 在线放映 或 下载。如需 Keynote 版本请联系我 pazyx728@gmail.com课件采用署名(BY)-非商业性(NC)-相同方式分享(SA)协议发布，请大家维护互联网底线。 参考资料 [1]邓俊辉.数据结构（C++语言版）[M].北京:清华大学出版社,2013. [2]陈越.最短路径算法-讲义.[DB/OL].数据结构（浙江大学）,2018. [3]郭炜.程序设计与算法（二）算法基础[EB/OL].uml,2017-11-13/2018-11-30.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>优化</tag>
        <tag>Dijkstra</tag>
        <tag>优先队列</tag>
        <tag>最短路径</tag>
        <tag>最小堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」《Effective C++》 读书笔记（一）]]></title>
    <url>%2F2018%2F03%2F16%2Feffective-cpp01%2F</url>
    <content type="text"><![CDATA[注意！这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。 让自己习惯C++条款01：视 C++ 为语言联邦C++ 是一个多重范型编程语言，一个同时支持过程形式、对象形式、函数形式、泛型编程、元编程形式的语言。 将 C++ 的理解为一个由相关语言组成的联邦而非单一语言。记住以下四个次语言你就会发现C++p容易理解很多。 C++ 主要的四种次语言： C：C++以C为基础，基本的语句、基础数据类型、预处理器等等都来自于 C，许多时候 C++ 对问题的解法其实不过就是高级的C语言解法。 Objective-Oriented C++：C++ 诞生之初就是想在 C 语言高效的基础上，增加 Simula 语言的特性。Class、封装、继承、多态、virtual 函数等等，改善了 C 的代码可读性、并发性、编译错误的提示等等。 Template C++：泛型编程，大多数程序员经验最少的部分。它带来的崭新的编程范型，所谓的模板元编程。TMP 相关规则很少与 C++ 主流编程互相影响。 STL：STL 是个 Template 程序库。它对容器、迭代器、算法、函数对象的规约有极佳的紧密配合与协调。STL有自己特殊的办事方式，当你同 STL 一起工作，你必须遵守它的规约。 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。 条款02：尽量以 const、enum、inline 替换 #define降低对编译预处理的使用。 #define 的缺点： 让编译器的错误提示不易定位 缺乏类型检查 不重视作用域，除非在某处 #undef，不能用来定义class专属常量，不能提供任何封装 未记入符号表，增大目标代码文件 旧式的编译器不支持“in-class 初值设定”，可以用枚举来替换常量。 相比 const，enum 更像 #define，可以对 const 常量取地址，而不可以对 enum 的地址。如果不想用指针和引用值指向你的某个常量，enum 可以帮助你实现这个约束。 对于宏函数，可读性差、写宏函数时需要小心注意带上很多括号，一不小心就会出现难以检查的错误。我们可以使用 inline 关键词代替宏函数，提高代码可读性和安全性。 对于单纯常量，最好以 const 对象或 enums 代替 #defines。 对于形似函数的宏，最好改用 inline 函数替换 #defines。 条款03：尽可能使用 const令函数的返回值为 const ，往往可以降低因用户错误而造成的意外，而又不至于放弃安全性和高效性。 两个成员函数如果只是常量性不同可以被重载，传入函数参数是 const 和非 const 时要区分处理，如在重载运算符 [] 时，非 const 要返回其单元的引用，const 时要返回其单元的 const 引用。 成员函数是 const 意味着它在某种程度上是不可以修改对象中的任何成员变量，但对于成员变量是指针时，它不能保证该成员函数不修改指针成员指向位置的数据。 可以使用 mutable（可变的）释放掉非 staic 成员变量的 bitwise constness 约束。 为 const 重载的函数，会造成代码复制的情况。可以通过单独写一个私有函数运行不冲突的部分，只重载与 const 相关的部分。也可以通过在 non-const里用 const_cast 去除 const 属性再返回的方式减少代码复制。但不要用在 const 函数中调 non-const 函数再返回的方式实现，这样会违背你在 const 版本中绝不改变其对象的逻辑状态的承诺，因为 non-const 版本没有做过此承诺。 将某些东西声明为 const 可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数主体。 编译器强制实施 bitwise constness ，但你变形程序时应该使用“概念上的常量性”（conceptual constness）。 当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。 条款04：确定对象被使用前已先被初始化不要混淆赋值和初始化，一定要在初始化列表中初始化成员。在我之前的博文 C++类与对象总结（二）构造函数 中对构造函数中的赋值和初始化问题有一定的解释。 继承关系的初始化顺序：基类（base classes）更早于其派生类（derived classes）被初始化。 对于某个编译单元内的某个 non-local static 对象的初始化动作使用了另一个编译单元内的某个 non-local static 对象，它所用到的这个对象可能尚未被初始化，因为 C++ 对“定义于不同编译单元内的 non-local static 对象” 的初始化次序并无明确定义。可以将有初始化依赖的几个 non-local static 对象放在一个编译单元解决。 书中的解决方案为：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static ）。这些函数返回一个 reference 指向它所含的对象。我们将这些函数称为 reference-returning 函数。 为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。 构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。 为免除“跨编译单元之初始化次序”问题，请以 local staic 对象替换 non-local static 对象。]]></content>
      <categories>
        <category>泛 - 笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>读书</tag>
        <tag>笔记</tag>
        <tag>Effective C++</tag>
        <tag>多重范型</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求质数表2——线性筛法]]></title>
    <url>%2F2018%2F03%2F09%2Fisprimes-2%2F</url>
    <content type="text"><![CDATA[合数的标准分解每个合数可以分解质因数，对于 60，最小质因子（LPF）为 2，最大质因子（GPF）为 5。 根据 LPF 和 GPF，可以将 60 分解为 2 * 30 或 5 * 12。这里的 30 为 LPF 的补，12 为GPF的补。 欧拉筛对于 60 之前的埃氏筛法最大的问题就是在 2、3、5 都会划去一次，浪费了很多时间。欧拉筛的改进方法就是保证每个合数只被划掉一次。 枚举最小质因子（LPF），把它与未筛掉的各数相乘，筛掉乘积。 那怎么找到未筛掉的数呢？我们不能再用一个 bool 数组来保存是否被筛掉了，因为那样你依然是在遍历数组看看那个数是否被划掉，如果没有的话就将它与最小质因子的积划掉。这样还是遍历了所有的数，我们只想要遍历没有被划掉的数。 我们需要一个数据结构可以高效的进行遍历、查找、删除操作。链表的遍历和删除都可以满足我们的需求，但查找过慢。 我们用数组模拟链表来保证这三个操作的高效。12345678910int prev[MAX_N + 2]; //保存每个节点的前一个节点的值int next[MAX_N + 2]; //保存每个节点的后一个节点的值for( int i = 2; i &lt;= N; i++)&#123; //初始化 prev[i] = i - 1; prev[i] = i + 1;&#125;next[prev[x]] = next[x];prev[next[x]] = prev[x]; //删除 x 节点的操作 数组模拟的链表的实现及相关操作解决“链表”问题后，我们在埃氏筛法的基础上改进划掉的操作就可以。 代码Ubuntu Pastebin : https://paste.ubuntu.com/p/CCWTJHjSYJ/123456789101112131415161718192021222324int prev[MAX_N + 2];int next[MAX_N + 2];int euler(int N)&#123; for( int i = 2; i &lt;= N; i++)&#123; prev[i] = i - 1; prev[i] = i + 1; &#125; int nPrimes = 0; for( int p = 2; p * p &lt;= N; p = next[p])&#123; for( int f = p; p * f &lt;= N; f = next[f])&#123; int x = p * f; next[prev[x]] = next[x]; prev[next[x]] = prev[x]; &#125; &#125; for( int p = 2; p &lt;= N; p = next[p])&#123; primes[nPrimes++] = p; &#125; return nPrimes;&#125; 但此代码有个大BUG，因为我们在选定一个 p 时想划去的是当时在它之后没有被划掉的数与它的积，但选定 p 是在找没有被划掉的数之前的。会发生这样的事情，比如我们 p 为 2，我们划掉了 4，那我们就没办法通过 2 * 4 划掉 8。 为了解决这个问题，人们想出了两种解决方案。 第一种：从大到小的去划掉需要划掉的数，这个方案需要解决的问题是需要定位链表的最后一个节点。 第二种：为什么 8 不能通过 2 * 4 划掉，因为 8 存在多个质因子为 2，所以我们在划去p * f时，可以顺便划掉p * p * f，p * p * p * f…… 解决。 第一种Ubuntu Pastebin : https://paste.ubuntu.com/p/4cPKvKw6ys/ 12345678910111213141516171819202122232425262728int prev[MAX_N + 2];int next[MAX_N + 2];int euler(int N)&#123; for( int i = 2; i &lt;= N; i++)&#123; prev[i] = i - 1; prev[i] = i + 1; &#125; int nPrimes = 0; for( int p = 2; p * p &lt;= N; p = next[p])&#123; primes[nPrimes++] = p; int f = p; while(p * next[f] &lt;= N)&#123; //遍历链表找到最大的f f = next[f]; &#125; while(f &gt;= p)&#123; //反向遍历链表划去p * f int x = p * f; next[prev[x]] = next[x]; prev[next[x]] = prev[x]; f = prev[f]; &#125; &#125; return nPrimes;&#125; 第二种Ubuntu Pastebin :https://paste.ubuntu.com/p/rnjmh7vTPF/1234567891011121314151617181920212223242526int prev[MAX_N + 2];int next[MAX_N + 2];int euler(int N)&#123; for( int i = 2; i &lt;= N; i++)&#123; prev[i] = i - 1; prev[i] = i + 1; &#125; int nPrimes = 0; for( int p = 2; p * p &lt;= N; p = next[p])&#123; for( int f = p; p * f &lt;= N; f = next[f])&#123; for( int x = p * f; ; x *= p)&#123; next[prev[x]] = next[x]; prev[next[x]] = prev[x]; if(x &gt; N / p) break; //x增长较快，防止x溢出 &#125; &#125; &#125; for( int p = 2; p &lt;= N; p = next[p])&#123; primes[nPrimes++] = p; &#125; return nPrimes;&#125; 时间复杂度每个数只被划掉一次所以是 \(O(N)\)。但划掉的速度要通过链表，其实导致速度通常还不如埃氏筛法。 空间复杂度只开了两个链表的数组和一个primes数组，\(O(N)\)。 简易欧拉筛再考虑欧拉筛的缺点，它时间复杂度已经达到线性，但链表操作太慢。怎么可以不使用链表实现欧拉筛呢？ 我们为什么要用到链表？因为 f 是动态变化的。我们换一种方式，考虑枚举LPF的补也就是先枚举 p （从质数表 primes 数组中取即可）再枚举 f 。根据LPF的定义我们给定 p 后，f 只需枚举到第一个整除 p 的数。 代码Ubuntu Pastebin : https://paste.ubuntu.com/p/xfVS3ctQWr/12345678910111213141516171819202122232425bool flag[MAX_N + 1];int simple_euler(int N)&#123; memset(flag, true, (N + 1) * sizeof(bool)); int nPrimes = 0; for( int f = 2; f &lt;= N / 2; f++)&#123; if(flag[f])&#123; primes[nPrimes++] = f; &#125; for( int u = 0; u &lt; nPrimes; u++)&#123; int p = primes[u]; if(p * f &gt; N) break; flag[p * f] = false; if(f % p == 0) break; &#125; &#125; for( int i = N / 2 + 1; i &lt;= N; i++)&#123; if(flag[i])&#123; primes[nPrimes++] = i; &#125; &#125; return nPrimes;&#125; 时间复杂度依然是 \(O(N)\)，但没有了复杂操作，效率优于之前的埃氏筛和枚举LPF的欧拉筛。 空间复杂度： \(O(N)\) 与欧拉筛相同。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>质数</tag>
        <tag>求质数表</tag>
        <tag>优化</tag>
        <tag>欧拉筛法</tag>
        <tag>简易欧拉筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求质数表1——朴素算法]]></title>
    <url>%2F2018%2F03%2F08%2Fisprimes-1%2F</url>
    <content type="text"><![CDATA[试除法对每个整数 i ，用 2 到 \(\sqrt{i}\) 的所有质数去试除它。 代码Ubuntu Pastebin : https://paste.ubuntu.com/p/wmGwPfGvGW/12345678910111213141516171819int primes[MAX_PRIMES];int trial_division(int N)&#123; int nPrimes = 0; for( int i = 2; i &lt;= N; i++)&#123; bool ok = true; for( int u = 0; u &lt; nPrimes; u++)&#123; int p = primes[u]; if(p * p &gt; i) break; if(i % p == 0)&#123; ok = false; break; &#125; &#125; if(ok) primes[nPrimes++] = i; &#125; return nPrimes;&#125; 时间复杂度\(O(\frac{N\sqrt{N}} { (logN)^2})\) 检查N个数每个数检查到它的平方根，\(\frac{1}{logN}\) 是质数的密度，只用质数去试除所以乘 \(\frac{1}{logN}\)，只有质数可以完全经受住考验再乘 \(\frac{1}{logN}\)。$$O(\frac{N\sqrt{N}} { (logN)^2}) ≈ N^{1.5}$$ 空间复杂度N以内质数的密度为 \(\frac{1}{logN}\) ，所以 primes 数组需要开到 \(\frac{N}{logN}\)。 埃氏筛法埃拉托色尼筛选法(the Sieve of Eratosthenes)简称埃氏筛法，是古希腊数学家埃拉托色尼(Eratosthenes 274B.C.～194B.C.)提出的一种筛选法。 枚举每个因子，看哪些数可以整除它，划掉它。 动画演示图片来自维基百科 代码Ubuntu Pastebin : https://paste.ubuntu.com/p/cymfGPHgMW/123456789101112131415161718192021bool flag[MAX_N + 1];int eratosthenes(int N)&#123; memset( flag, true, (N + 1) * sizeof(bool)); for( int p = 2; p * p &lt;= N; p++)&#123; if(flag[p])&#123; for( int x = p * p; x &lt;= N; x += p)&#123; flag[x] = false; &#125; &#125; &#125; int nPrimes = 0; for( int i = 2; i &lt;= N; i++)&#123; if(flag[i])&#123; primes[nPrimes++] = i; &#125; &#125; return nPrimes;&#125; 为什么 x 从 p * p 开始呢？因为数 p * (p-i) ( 1 ≤ i ≤ p ) 已经在之前划掉过了，比如在检查 3 时，不需要划掉 3 * 2 因为在检查 2 的时候已经划过了。 为什么 p 到 \(\sqrt{N}\) 截止？ 因为内层循环中的 x 是从 p * p 开始的，\( p &gt; sqrt{N}\) 时就不能划掉更多的数了，没有意义。 时间复杂度$$\frac{N}{2} + \frac{N}{3} + \frac{N}{5} + \frac{N}{7} + …… = O( N loglogN ) $$ 证明参考 https://www.zhihu.com/question/21105642 https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes 空间复杂度N 个单位的 bool 数组，空间复杂度为 \(O(N)\) 。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>质数</tag>
        <tag>求质数表</tag>
        <tag>试除法</tag>
        <tag>埃氏筛法</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类与对象总结（三）析构函数]]></title>
    <url>%2F2018%2F03%2F07%2Fcpp-class-3%2F</url>
    <content type="text"><![CDATA[析构函数Destructor析构函数与构造函数相似，都是特殊的成员函数。不同在于构造函数用于对象的初始化，析构函数用于对象的清理工作。 名称为~加类的名称，不可以重载，无返回类型。12345678class A&#123;private: int a;public: A():a(10)&#123;&#125; //A的构造函数 ~A()&#123;&#125; //A的析构函数&#125; 与构造函数相似，如果我们没有定义析构函数，编译器会自动生成一个什么都不做的析构函数。 析构函数的调用时机 栈中定义的对象，离开作用域前或程序结束前调用。 堆中定义的对象，在delete时调用。 析构的顺序对于栈中直接定义的对象，析构顺序由构造顺序决定。顺序是一种栈的思想，先构造的对象后析构。12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123;private: int a;public: A(int i):a(i)//A的构造函数 &#123; cout &lt;&lt; a &lt;&lt; " Constructor" &lt;&lt; endl; &#125; ~A()//A的析构函数 &#123; cout &lt;&lt; a &lt;&lt; " Destructor" &lt;&lt; endl; &#125;&#125;;int main()&#123; A a(1); A b(2); return 0;&#125; 输出信息为：12341 Constructor2 Constructor2 Destructor1 Destructor 可以看出它是一种“先进后出”的顺序去构造和析构。 对于没有构造的对象，不会进行析构。 delete与delete[]1234int *p = new int[10];delete p;delete[] p; 对于上面代码中基础数据类型的数组的回收空间来说，后面两行的delete效果是一样的。 但如果是用户定义的类型就会有所不同。 1234A *p = new A[10];delete p;delete[] p; 像这样的情况下，第三行的delete和第四行的delete[]都会回收new时分配的空间，但第三行的delete只会调用一次A的析构函数，而第四行的delete[]会调用10次A的析构函数。 delete和delete[]都会回收空间，但delete[]会逐个调用每个对象的构造函数。特别是对于成员函数中有new操作的类来说，必须在析构函数中去delete，delete时要注意区分delete和delete[]，否则可能会造成内存泄漏。]]></content>
      <categories>
        <category>编程语言 - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>析构函数</tag>
        <tag>delete</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」许岑：有效训练你的研究能力]]></title>
    <url>%2F2018%2F03%2F07%2Fxcxx-02%2F</url>
    <content type="text"><![CDATA[研究和学习的区别依靠模仿而进行的学习或者说练习，最高境界也就是达到跟你的学习对象一样好，而要超越它，就需要研究能力了。 有时候是获取更扎实的知识，有时候是掌握更先进的技能。 与学习相比，研究不包含练习，研究需要更加主动，研究的文本更加宽泛。研究仅仅对文本进行剖析，而不用去掌握文本。 三种意识 作品意识：建立研究的驱动，作品意识是研究精神的起点。告诉自己“我要从事这件事了”，不是做这件事，而是从事。 目标意识：研究的过程当中要时刻盯住自己初始的研究目标，并时刻问自己，我正在做的事情会不会影响研究的主线。用一种上帝的视角来俯视整个事情的全貌，才能守住目标不跑偏。 局外意识：避免过度沉溺于文本；对人的研究要去粉丝化；避免情绪化。 搜集资料：足量，但节制足量 主动性是足量的保障 宽泛性能让你评判足量的程度 研究资料的搜集做不到足量，往往是研究者自己的主动性不够。超强的主动性是资料搜集做到足量的保障。 跳出单一维度，带有目标意识的多 节制 避免过度沉溺于文本，避免跑题 对人进行研究的时候，一定要去粉丝行为。在搜集资料的时候要多视角，求客观 “无情”是做研究的高贵品质，情绪化是做研究的天敌 处理资料把握好两个重要的方向，一个是抓本质，另一个就是找规律。 抓本质就是找不同，要找不同就需要做对比；给你的研究对象树立一个相似对象或者是竞争对手，去找研究对象和类似对象的不同。通过不同认清事物的本质。 找规律则是求相似，要求相似就需要做类比。求相似，是为了提高效率，确保自己接下来在面对这样的事物和类似事物的时候能更快地把握。找到规律以求更快地认清它们。 创造输出如果研究让你有了新的发现和收获，应该把它写成一篇系统的、有文本支持的、逻辑论证严密的好文章。这对你和别人都有非常大的价值。 用写作促进你的研究 用学术的标准来要求自己。学术性的三个基本的特征，足够系统、有相关的文本支撑、有严密的逻辑论证。 储存信息量要足够大，所以说信息搜集要“足量”。 学术性需要文本支持。在研究的过程中要有自己的判断，但这种判断不能是凭想象的。 好文章要有严密的逻辑论证。 给你的写作找一个“导师”，导师在学术研究中的作用是什么，一方面是他比你的学术信息量和文本支持能力更大，另一方面他会在你的逻辑论证过程中指出你的错误。]]></content>
      <categories>
        <category>泛 - 笔记</category>
      </categories>
      <tags>
        <tag>许岑</tag>
        <tag>美貌大王</tag>
        <tag>学习</tag>
        <tag>研究</tag>
        <tag>搜集资料</tag>
        <tag>创造</tag>
        <tag>输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「公告」关于采用CC协议的说明]]></title>
    <url>%2F2018%2F03%2F01%2Fcc-by-nc-sa%2F</url>
    <content type="text"><![CDATA[本博客将采用署名(BY)-非商业性(NC)-相同方式分享(SA)协议发布，并注明于关于…页面。 为什么采用CC协议？之前的文章 动态规划B1——完全背包 中引用了《背包问题九讲》中的一些内容。因为其采用了署名(BY)-非商业性(NC)-相同方式分享(SA)发布，为了遵守SA条款，同时也是为了保护我的版权，本博客将采用CC协议发布。 协议所有允许的行为 分享 – 在任何媒介或格式下再分发、传播本创作。 修改 – 重混、转换、依据本创作进行再创作。 只要遵守条款规定，授权人将不能撤回你使用本创作的自由。 协议所有限制的行为 署名（BY） – 你必须以给予姓名标注，并提供本许可证的链接。同时你需要声明公开的创作是否经过修改。你可以采用恰当的形式将相关信息表述出来，但不得以任何形式暗示授权人已正式认可了你以及你的使用行为。 非商业性（NC） – 你不得将本创作运用于商业目的。 相同方式共享（SA） – 如果你对本创作进行了重混、转换、依据本创作进行再创作，你必须依据本创作采用的许可证来分发你的创作。 不得增加额外限制 – 你不能增设任何法律限制或是技术限制，来限制他人进行本许可证已经允许的行为。]]></content>
      <categories>
        <category>泛 - 公告</category>
      </categories>
      <tags>
        <tag>公告</tag>
        <tag>CC协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划B2——完全背包]]></title>
    <url>%2F2018%2F03%2F01%2Fcp-bp%2F</url>
    <content type="text"><![CDATA[问题有一个容量为 V 的背包和 N 种物品。每种物品的价值为 \(W_i\) 体积为 \(C_i\) ，每种物品有无限件，问最大背包价值。 分析此问题与01背包的差别只在于物品是无限件的，但由于背包容量 V 的限制，实际上物品依然可以理解为有限件，只是件数不再是1而是\( ⌊V/C_i⌋\) 件。 由 动态规划B0——01背包 中给出的状态转移方程加以修改就可以得出完全背包的状态转移方程。\[F[i, v] = max{ F[i − 1, v − kC_i] + kW_i \ \ |\ \ 0 ≤ kC_i ≤ v }\]只需在01背包代码的基础上加一层循环即可，对于状态 \(F[i, v]\) 求解的时间复杂度为 \(O(V/C_i)\) 所以总的时间复杂度为 \(O(N\sum V/C_i)\) ，这种解法实际上就是把每种物品拆分为多个物品转化为01背包。 优化0 预处理数据若两件物品 i、j 满足 \(C_i ≤ C_j 且 W_i ≥ W_j\) ，则将可以将物品 j 直接去掉，不用考虑。在进入主算法前预处理一遍物品数据即可。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 1 二进制思想任何二进制可以表示任何十进制的数，我们可以想一下二进制是如何转成十进制的呢？ 101001 如果你拿到一个这样的二进制数，只需将二进制第 k 位的数乘 2 的 k-1 次方再求和即可。这样我们可以发现所有的数都可以拆分为若干个 2 的 k 次方的和。 有了上面的理论支持，我们可以不必将物品一个一个拆开放入背包，我们可以将它们拆成若干个2的k次方个物品打包放入。 这样我们可以将时间复杂度优化到 \(O(log ⌊V/C_i⌋ )\) ，比之前的 \(O(N\sum V/C_i)\) 好了很多。 之后的多重背包也有基于此思想的优化。 2 O(VN)伪代码12for i 1 -&gt; N for j Ci -&gt; V F[i][j] = max&#123;F[j], F[j-Ci] + Wi&#125; 看上去好像与 01 背包的伪代码几乎一样，只是第二次循环的方向做了变化。 起初我在写背包题目时在网上看到这个算法时，很是不理解。之后在看完 《背包问题九讲》 的讲解和自己手动调试几次后感觉很深刻。我觉得对此算法不理解的可以在充分理解 01 背包算法后手动调试运行这个算法去理解。 背包九讲中的解释我很喜欢，以我现在的文采我感觉不足以写出更好的解释，我在此引用其中的一段。 为什么这个算法就可行呢？首先想想为什么 01 背包中要按照 v 递减的次序来循环。 让 v 递减是为了保证第 i 次循环中的状态 \(F[i, v]\) 是由状态 \(F[i − 1, v − Ci]\) 递推而来。 换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 i 件物品”这件策略时，依据的是一个绝无已经选入第 i 件物品的子结果 \(F[i − 1, v − Ci]\)。而现在完全背 包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 i 种物品”这种策略时，却正需要一个可能已选入第 i 种物品的子结果 \(F[i, v − Ci]\)，所以就可以并且必须采用 v 递增的顺序循环。这就是这个简单的程序为何成立的道理。 背包问题九讲 2.0 beta1.2 第6页 这个解释我认为只是在人的思维层面的解释，真正要理解它的运行过程我觉得没有什么比自己跑几遍来的实在。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>完全背包</tag>
        <tag>算法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划B1——01背包]]></title>
    <url>%2F2018%2F02%2F23%2F01-bp%2F</url>
    <content type="text"><![CDATA[问题有一个容量为 V 的背包和 N 件物品。每件物品的价值为 \(W_i\) 体积为 \(C_i\) ，问最大背包价值。 分析此问题的特点是每件物品只有一件，只能选择放或不放。 动态规划设计有一定的模式，一般分为以下几个步骤，我们按照一般的模式解决此问题。 划分阶段：分解为小的子问题，用 \(F[i, v]\) 表示前 i 件物品放入一个容量为 v 的背包可以获得的最大价值。 选择状态：对第 i 件物品是否放入选择。 确定状态转移方程：\(F[i, v] = max{ F[i−1, v], F[i−1, v − C_i] + W_i } \) 确定边界：对于每个物品我们只需要更新大于等于其体积的背包容量的状态。 具体实现由状态转移方程，我们可以得出它有两个状态参数，显然我们开一个二维数组记录每个状态的值。 两层循环，外层循环遍历N物品，内层背包容量状态。 伪代码12for i 1 -&gt; N for j Ci -&gt; V F[i][j] = max&#123;F[i-1][j], F[i-1][j-Ci] + Wi&#125; 优化简单分析上面的伪代码可以得出时间复杂度和空间复杂度都为 O(NV)，对于空间复杂度我们还可以优化到 O(V)。 我们观察状态转移方程，发现当前需要更新的状态只与 \(i - 1\) 行的一个状态有关，我们只需保留 \(i - 1\) 行中的数据即可。 也就是我们只需要一个一维大小为 \(V + 1\) 的数组，我们不断的维护它就可以得到最终答案。这样空间复杂度就可以降到 O(V)。 这里需要注意的是这样优化后我们要以递减的顺序去遍历这个数组。因为我们需要 \(v - C_i\) 的状态，这个状态是在当前 v 之前的，我们以递减顺序去更新它才能取到 \(i - 1\) 行的 \(v - C_i\) 的状态数据。 伪代码12for i 1 -&gt; N for j V -&gt; Ci F[j] = max&#123;F[j], F[j-Ci] + Wi&#125; 初始化问题对于背包问题一般会有两种情况，一种是有要求背包“恰好放满”的，另一种是没有要求的。 没有此要求的我们把F数组全部初始化为 0，因为初始时也就是不放任何东西时，任何容量的背包价值都为 0。 要求“恰好放满”的，我们将 F0 初始化为 0，其他的单元初始化为 -∞。负无穷表示不能恰好放满。因为不放任何东西时，容量为 0 的背包价值刚刚好为 0，其他的都不能放满。 为什么是 -∞ 而不是 -1 呢？这个问题可以自己模拟运行理解。 这里的初始化方案适用于大多数背包问题，之后的背包问题讲解将不再说明初始化方式。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法</tag>
        <tag>背包问题</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串匹配算法2——KMP]]></title>
    <url>%2F2018%2F02%2F22%2Fstrkmp-2%2F</url>
    <content type="text"><![CDATA[概述之前的蛮力匹配法效率太低，这里我们介绍一种更好的串匹配算法。KMP算法，它由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故以三人姓氏命名此算法。它即便是在最坏的情况下时间复杂度也可以保证在线性以内。 我将从之前的蛮力算法开始，分析蛮力算法的不足，改进它引出KMP算法。文章会有一些串的术语，我在之前的一篇文章 串匹配算法0——蛮力匹配 中已经有所介绍。 为什么慢？人们是怎样匹配的？文本串：00000000…00000001 模式串：00001 这是蛮力算法中最坏情况的例子，蛮力算法在匹配这一组字符串时，大部分时间都消耗在了模式串中的前四个0中了，每轮匹配都会在正确匹配四个0后因为最后那个1而失败。 我们再来看一个例子 文本串：abcabcabcabcabcabcabcdabcabc 模式串：abcd 如果现在让你来匹配这组字符串你会怎么匹配呢？你会像蛮力算法一样去逐个比对尝试吗？我想大多数人不会，大多数人会发现文本串中有很多abc的重复，而不去比对abc直接去找d去匹配它。当然你还是要扫描过一边文本串，这样比蛮力算法省时间的原因是在于你不用在逐个的比对前三个abc，而且每次右移3个单位，可以将模式串快速右移而且省去很多比对操作。 我们再再来看一个例子 文本串：abcdabcfghijk 模式串：abcdaf 我们现在用蛮力算法来匹配这组字符串，我们以开始假设文本串中第一个a为模式串的头，逐个去比对后续字符，我们可以想到模式串会在第二个b处比对失败，接下去我们会假设文本串中的第一个b为模式串的头再去逐个比对。实际上没有必要，我们在之前的比对中已经遍历了文本串中的前五个字符，已经知道它们都是什么了，为什么还要去尝试b呢？聪明的人应该直接假设文本串中第二个a为模式串的头再去逐个比对。 计算机的记忆力计算机毕竟不是人，那我们来分析人是怎样做到快速匹配的，能否让计算机模仿人的思维去改进之前的算法呢？ 文本串：abcdabcfghijk 模式串：abcdaf 还是这个的例子，为什么不用再去将bcd假设为模式串的头了呢？这个显而易见，当然是因为bcd不是a呗。这个很简单计算机也是知道的啊，为什么它没有跳过呢？因为计算机记不住啊，它记忆力太差，在蛮力算法的过程中计算机只关注当前比对的两个字符，其他的一概不关心。在要选择向右移几个单位时，它想了想说“我也不知道，保险一点移动一个单位试一下吧。” 作为人类，我们当然可以赋予计算机记忆力，它已经有了优越的条件（很大的内存），只需要我们帮助它一下，要求它记住这些东西就好了。 我们观察 abcda 这个字符串，它的前缀a和后缀a是一样的，如果计算机知道这件事，它就可以将两个字符串向下面的位置对其继续比对，从b开始比对，因为在 abcda 中有一个相同的前缀后缀。 abcdabcfghijk ——-abcdaf 怎么让计算机知道这件事呢？我们开一个数组int next[P.length()]，每个单元保存该字符前的字符串的最大相同前后缀的长度，对于刚刚那个模式串的第5号位b在next数组中的值就应该为1。 在比对之前我们只需要预处理模式串得到next数组的值即可。为什么只需要处理模式串？有些人会想我们明明是在文本串中比对为什么只需要预处理模式串。我们来看上面绿色标注的位置，在文本串和模式串中两者是一模一样的，因为它们是比对成功的部分，我们只需要处理模式串就可以知道应该将模式串的头移到文本串的什么位置。 怎样预处理呢？只需要模式串自己和自己做一次匹配即可，具体的等接下来上了代码再做介绍。 到此我们已经大概了解了KMP算法的思想和大致实现方式。 少废话，上代码Ubuntu Pastebin : https://paste.ubuntu.com/p/9wZ3gyZCnP/12345678910111213141516171819202122232425262728293031323334int* buildNext(string P) &#123; int size_n = P.length(), j = 0; //主指针 int* N = new int[size_n]; //建表 int t = N[0] = -1; //模式串指针（p[-1]为通配符） while(j &lt; size_n -1)&#123; if(0 &gt; t || P[j] == P[t])&#123; N[++j] = ++t; &#125;else&#123; t = N[t]; &#125; &#125; return N;&#125;int match(string P, string T)&#123; int *next = buildNext(P); //构造next表 int size_n = T.length(), i = 0; int size_m = P.length(), j = 0; while( j &lt; size_m &amp;&amp; i &lt; size_n)&#123; //从左向右逐个比对字符 if(0 &gt; j || T[i] == P[i])&#123; i++; j++;&#125; //若匹配，则转到下一个字符 else&#123; j = next[j];&#125; //否则，T不回退，文本串P右移 &#125; delete[] next; //销毁next表 return i - j;&#125; 对于主函数与蛮力匹配算法几乎是一样的，文本串P右移时用到了next数组。如果不理解这一步的话可以自己用纸笔模拟匹配，应该可以理解。 现在问题的关键在于构造next数组的buildNext这个函数的实现。 next数组的构造这里的思想与KMP的主函数思想是一致的，只不过这次匹配的字符串是两个一样的模式串。 我们采用递推策略，假设我们已经构造了next数组的前 j 项，如何计算它的 j+1 项呢？ 如果 P[j] == P[N[j]] ，说明前缀和后缀又比对上一项，N[j]就等于上一项的值加1。 如果 P[j] != P[N[j]] ，说明该后缀变短了，那应该怎么找下一个有可能成为相同前后缀的位置呢？这个如果现在t所指位置为一个前缀的末尾，该位置匹配失败了。我们应该保证 j 不动，将t替换为next[t]，也就是之前t所在前缀的前缀的末尾继续与 j 所指的位置比对。 哨兵大家或许有疑问，t为什么要初始化为0？if语句中0 &gt; t这个条件是什么意思？ 这个-1实际上是一个哨兵，我们想象next数组有next[-1]这个单元，它里面放着一个通配符。它可以帮助我们在程序里面省去一个判断分支。如果不理解一样是可以用纸笔模拟一下。 优化 优化 优化…我们再再再来看一个例子 文本串：000100001 模式串：00001 如果用之前给出的算法运行，它会在第一个1处匹配失败，之后再用前一个0比对依然失败，比对3次后遇到-1处的通配符后成功匹配，文本串和模式串的指针同时向右移动一位，再从文本串的第4个单元开始比对。 这个好像还是有点傻啊，人不会这样无用的用1和0比对3次。这3次比对实际上是可以优化掉的。实际上KMP算法主函数的主要是受next数组的影响的，我们只需要改进buildNext函数即可。改进后的bulidNext函数如下：Ubuntu Pastebin : https://paste.ubuntu.com/p/RftpTzKsVX/123456789101112131415161718int* buildNext(string P) &#123; int size_n = P.length(), j = 0; //主指针 int* N = new int[size_n]; //建表 int t = N[0] = -1; //模式串指针（p[-1]为通配符） while(j &lt; size_n -1)&#123; if(0 &gt; t || P[j] == P[t])&#123; j++; t++; N[j] = P[j] != P[t] ? t : N[t]; //* &#125;else&#123; t = N[t]; &#125; &#125; return N;&#125; 这样优化后对于上面的例子就不会出现多次的重复比对，一次比对失败后，模式串会整体右移4个单位继续比对。 整体复杂度分析主函数中的指向文本串的指针 i 一直在递增，即便是在最坏情况下主函数中的while循环不过执行了T.length()次，是线性的复杂度。 对于buildNext函数，它与主函数思想是一致的，复杂度也是线性的。 所以整体的复杂度就是 O(P.length() + T.length())。 一般 P.length() 是远远小于 T.length() 的所以它的复杂度可以忽略不计。最终复杂度为O(T.length())。得出结论：KMP算法在最坏情况下也能保证复杂度在线性以内。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>优化</tag>
        <tag>KMP</tag>
        <tag>串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串匹配算法1——蛮力匹配]]></title>
    <url>%2F2018%2F02%2F21%2Fstrma-1%2F</url>
    <content type="text"><![CDATA[概述串匹配问题有很多的算法，我们这里要介绍的蛮力匹配法在应用中一般不会用到，因为它的效率相对后面高级的算法是很低的。但后续高级的算法都可以理解为基于这种蛮力匹配算法的改进和优化，理解它才能更好的学习后续的算法。 我们首先介绍字符串相关的术语和它的基本接口，之后再介绍具体的算法。 术语 相等：长度相等，且每个对应字符都相等 子串：从S[I]起的连续k个字符 S.substr(i, k) 前缀：S中最靠前的k个字符 S.prefix(k) = S.substr(0, k) 后缀：S中最靠后的k个字符 S.suffix(k) = S.substr(n - k, k) 文本串P：需要被查找的字符串 模式串T：需要找的字符串（关键词） 接口 length() 返回串的长度 charAt(i) 返回给定下标位置的字符 substr(i, k) 截取 [i, i + k) 位置的字符串 prefix(k) S中最靠前的k个字符 suffix(k) S中最靠后的k个字符 concat(T) 在当前字符串后面连接一个字符串 equal(T) 比较两个字符串是否相等 问题 模式串是否出现？ 首次在哪里出现？ 总共出现几次？ 各出现在哪里？ 串匹配算法效率评测标准我们可以随机生成文本串和模式串进行匹配来评测串匹配算法的效率吗？ 我们应该将随机生成的数据的匹配结果分为匹配成功和匹配失败，分别测试。这是因为随机生成的数据对于串匹配来说失败的概率很大，失败时的效率会掩盖成功时的效率。随机生成的数据匹配成功与否一般还与字符的种类相关，比如二进制的字符串就比字母组合的字符串较容易匹配成功。 蛮力匹配算法对于有一定编程基础的人遇到这个问题，都很容易想到这个算法。很简单，我们需要假定文本串的某个位置是模式串的头，向后匹配两者，如果遇到不匹配的字符就说明这个头不对。我们遍历文本串上所有可能成为模式串头的位置（下标在S.length()-P.length()之前的字符），最终就可以得出结果。 版本1Ubuntu Pastebin : https://paste.ubuntu.com/p/y6QZ2sFY8Q/123456789101112131415int match(string P, string T)&#123; int size_n = T.length(), i = 0; int size_m = P.length(), j = 0; while( j &lt; size_m &amp;&amp; i &lt; size_n)&#123; //从左向右逐个比对字符 if(T[i] == P[i])&#123; i++; j++;&#125; //若匹配，则转到下一个字符 else&#123; i -= j-1; j = 0;&#125; //否则，模式串T回退，文本串P复位 &#125; return i - j;&#125; 如果匹配成功返回 i - j ，即模式串头在文本串中的位置下标。如果没有匹配成功，说明循环因为i &lt; size_n退出，此时i = size_n 而，返回值 i - j 将大于 size_n - size_m。调用者只需一步判断即可。 版本2Ubuntu Pastebin : https://paste.ubuntu.com/p/n88Jkz2ypM/1234567891011121314151617int match(string P, string T)&#123; int size_n = T.length(), i; int size_m = P.length(), j; for( i = 0; i &lt; size_n - size_m + 1; i++)&#123; //遍历所有可能成为模式串头的元素 for( j = 0; j &lt; size_m; j++)&#123; //假设T[i]为P[i]头逐个比对 if(T[i + j] != P[j]) break; //如果有一个失配，说明此假设不对 &#125; if(j &gt;= size_m) break; //找到匹配子串 &#125; return i;&#125; 版本2的实现更容易理解，它就如之前讲解的想法是一样的。 时间复杂度分析这两种实现其实思想和效率都是一样的。接下来我们分析一下它们的时间复杂度 最好情况（只经过一轮比对，即可确定匹配成功）：O(size_m) 最坏情况（每轮都对比至P的末字符，且反复如此）：O(m (size_n - size_m + 1)) 一般 m &lt;&lt; n 复杂度近似为 O(n m) 最坏情况是否会出现？这里举个例子： 文本串：00000000…00000001 模式串：00001 最坏情况的特点 最坏情况出现的概率与字母表的大小有关，字母表越小越容易出现局部匹配的情况导致浪费大量时间 size_m 越大，最坏情况出现的后果越严重]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」许岑：如何成为有效学习的高手]]></title>
    <url>%2F2018%2F02%2F18%2Fxcxx-01%2F</url>
    <content type="text"><![CDATA[自然主义与结构主义 自然主义核心它是模仿，遇到什么学什么，学习过程可以是碎片化的，积少成多，注重量的积累 比如：语言、乐器、书法 结构主义学东西更注重结构，体系化的去学，学会之后的目的是创造。为的是一种质变。选择了正确的学习方法之后，把这个目标拆碎，针对细节进行反复的练习 比如：医学、艺术、编程、经济学 速度和效率 避免无效学习 将目标拆碎，针对细节进行反复练习 不要一开始就照顾全局 碎片化学习 带着困惑和问题进行学习 基于搜索 最终的效果要把碎片链接起来 小孩子可能不适合碎片化学习 假的碎片化学习：收藏 驱动力 成年人的学习不需要培养兴趣，应该以任务为驱动 没有任务我们自己来制造任务 带着职业强迫去练习 自己聘请自己 以教为学，一方面可以是自己对自己设置的一个任务，设定的一个目标，解决了任务驱动的问题。另一方面，以教为学，其实会让你学的更好 拖延症 将任务“严峻化” 一生当中不可能只做自己喜欢的事，怎么把自己不喜欢，却必须要做的事给做了，才是我们需要解决的难题 你要向所有认识你的人交代 设定小目标，形成惯性 专注力培养 在平常的生活当中营造仪式感 购买昂贵的学习工具 便宜东西本来就不是靠专注力制造出来的，你把一样东西买来自己用，这样东西要使你感知到那种专注力，才能够对你自己的专注力形成一种训练。 图便宜绝对会分散我们的注意力。 如果我们有一笔钱用来买东西，买一样贵的东西，好处还有另外一个方面，就是我们没钱再去买那些便宜的东西了。也就是说，我们拥有的东西少一些，东西越多越不能使人专注 学会一个人好好吃饭 尽量吃点好的，少吃速食，少点外卖，尽量少吃自助餐 我们每个人真的要学会自己认认真真的吃一顿火锅。最好，能学会好好做一顿饭给自己吃。这是营造仪式感非常好的行为活动 使用射灯 进入高质量的睡眠 睡眠不够，人很难做到专注 不要已经困得不行了，还要硬撑着做事，这个效率是非常低的。不如立即进入到高质量的睡眠 运动 设定有效的目标 一定要有一个明确的目标，并且找准学习的切入点 直奔大师，不必从基础开始。当然这个大师在这里边它指代的是一种特定的一种情境，这个大师不一定是指一个人了，而是你的最终目标 要去到哪里就从哪里开始 怯场是最糟糕的自觉。一个人他胆子变的比之前大一点，能走的路可能就会长一点 对于要用结构主义方法去研究的东西，还是要踏踏实实从初级开始 反馈 自己给自己制造反馈 制造文字，语音和肢体的反馈 当学习特别容易犯错的东西时，最需要及时反馈 突破学习瓶颈 瓶颈不是极限 突破瓶颈可能是需要方法的调整，也可能是需要心态的调整。心态调整的好，做一些事会相对比较容易 增强信心 扩大涉猎范围 更加专注，请教名师 把注意力集中在一个更狭窄的范围内，以做到不去分心 有些事真的是一通百通，你把一个东西拿下了，再去拿别的，会相对比较容易。这可能是自信带来的幻觉，也可能不是幻觉。如果自信来自于自律，那就是扎扎实实的自信。如果自信来源于想象，那就是盲目自信了。]]></content>
      <categories>
        <category>泛 - 笔记</category>
      </categories>
      <tags>
        <tag>许岑</tag>
        <tag>美貌大王</tag>
        <tag>有效学习</tag>
        <tag>拖延症</tag>
        <tag>自然主义</tag>
        <tag>结构主义</tag>
        <tag>专注力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「书摘」《摩托车修理店的未来工作哲学》]]></title>
    <url>%2F2018%2F02%2F17%2Fbooks-0%2F</url>
    <content type="text"><![CDATA[手艺人的实用艺术 修理工在做每一件工作时，都要先抛开自己的想法，专注于要修理的东西上：他必须仔细去看、去听。 当我的电路安装工作完成得美观漂亮时，我总会感到自豪。也许某天会有其他电工看到我的工作成绩。 工匠的骄傲是有凭据的，完全不是教育者传授给学生的那种毫无根据的“自负”。 我曾不惜代价地自己做了一个红木的咖啡桌。当时我还没有想过要做父亲，但我却想象这个桌子能给我的孩子留下难以磨灭的印象，他会知道这是自己父亲的作品。 工匠惯有的偏差不是偏向新事物，而是偏向他的可观工艺标准。 技术型的体力劳动需要对物质世界有系统的了解，正是这种了解推动了自然科学的诞生和发展。 经验的缺乏削弱了我们全面审视公认事实的能力。 手工艺实践和手工艺消费的精神模式和象征模式代表了对程式化的、官僚主义化的工作新模式的补偿，一种调适。 在现实世界中，问题本身并不会被预先简化；通常会出现信息过多的情况，使人难以辨别哪些相关，哪些不相关。要懂得自己面对的是何种问题，也就意味着必须清楚哪些情况可以被忽略。 修理工的价值和工作稳定性就在于他拥有一手的知识和经验。 动手与动脑 工作的退化终究是认知问题，根植于动脑与动手的脱节。 木料不应该是机器的牺牲品，它特有的优点应该留给懂得如何雕琢它的人。 雇主们懂得要促使工人们更勤奋地工作，唯一的办法就是借助想象力，刺激新的需求和欲望。消费和生产一样，需要进行科学的欲望管理。 如果知识被集中到规模越来越小的精英手中，真正的知识工作数量就不是在增长，而是在萎缩。 导致判断力水平远低于专业人士的并不一定是利润因素，有时公共政策也会影响判断力。标准化考试让教师失去了对课程的判断力，严格的审判指导方针让法官失去了对违法行为的判断力。 创造力是精通的副产品，而精通只能通过长期的实践来培养。 做自己物品的主人 要做自己物品的主人，首先要有一定的勇气，然后还要有探索的精神。这是令人骄傲的事情，也是自力更生的基础。 通过借助某种费解的文化逻辑，傻瓜化变成了人人向往的东西。 直接与我们使用的机器打交道，虽然会把指甲弄脏，但会给我们带来一种主体感。然而随着科技进步，这种直接接触减少，尽管推动科技进步的初衷是增加自主权。这中间是否存在矛盾？ 选择、自由、没有极限的时间、超越可能性，以及消费主义其他令人陶醉的存在主义式口号引发的此起彼伏的压迫感，好像已经形成了一个戒律体系。不知何故，对自我实现和自由的追求，促使我们去购买新东西，扔掉旧东西。 在所有具有难度的专业领域，不管是园艺、结构工程还是俄语，人们都要屈服于该领域那些棘手的对象。 音响是一种设备，与身为物品的乐器不同。我所指的“物品”，其特性需要使用者去领悟和接触，需要一定的技巧，也需要积极地参与。“物品”必须被实践，而“设备”只需要被消费。物品具有指挥型的现实特征，而设备只有被支配型的现实特征。 个体的主体性可以通过一系列的选择得以实现，但是选择并不等于创造。 对于早期的哲学家海德格尔来说，“上手状态”是世界万物呈现在我们面前的最初模式：“最亲密的接触并非感性认知，而是去把玩、使用和照顾那些有自己‘知识’的东西。” 黑手的教育 优秀的钻石切割工人与优秀的训犬师在性情上肯定不同：前者非常谨慎，后者则更善于发号施令。 当年轻人思考他可以谋生的各种方法，以及这些方法如何能帮助他更好地生活时，最重要的问题也许并非他的智商有多高，而是像“他究竟是个谨慎的人，还是一个喜欢发号施令的人”这样的问题。如果他的目标是找到适合自己的工作，就应该在接受邀约之前停下来好好思考。 不同的工作会吸引不同的人，那么反过来工作也会塑造人。 机械艺术对我们这个时代而言具有特别的意义，因为它们培养的不是我们的创造力，而是注意倾听的能力。 物品需要修理和照顾，就像它需要被创造。 现代科学关于我们如何了解自然的观点脱离了我们所在的世界：通过思维结构来了解自然比通过物质世界更容易操作，而且可以用数学表达式进行验算。通过此类转换，我们成为了大自然的主人，但基于理想化的思考令我们失望，因为它没有充分考虑到细节问题。 修理工和医生每天都会与失败打交道，即使成为专家后也无法幸免；但建筑工不用，这是因为修理工和医生修理的东西并非由自己打造，所以他们无法全面或彻底地了解它。 规划是一个极其耗时的过程，而且难以确切地划分哪一段属于认真的装配工作，哪一段又属于规划工作，因为改造旧马达在一开始就涉及大量的测量和判断。 要想成为一名优秀的修理工，一方面，你必须真正地投入，从内心深处认同“我是一个修理工”；另一方面，你要有敏锐的感觉，能够突破自我的、独有的世界。 在寻找解决方案的过程中暂停一下，反思自己对问题的理解是否充分。 作为优秀的修理工，你必须不断留意自己犯错的可能性——这是一种美德。 任何处理可靠而独立的现实情况的学问，都需要诚实和谦虚。 从业余到专业 在这个世界上，想对一切事物正确地做出回应，就必须清晰明了地看穿它，而实现这点的前提是达到“无我”的境界。 独立工匠的生活美好而自由，让人开始思考自己要选择什么样的生活方式。 英文中的“自由”(liberal)一词，最早被用来区分“自由艺术”(liberal arts)和“功利艺术”(servile arts)。前者追求的是适合自由人的艺术，而后者被视为机械性的艺术。 修理摩托车的真实时间与应该收费的时间之间的差距，正是摩托车维修伦理道德发挥作用的地方。 修理工面临的挑战就是突破自己的想法。 好奇心受限于好奇对象，而好奇对象常常会被孤立起来考虑；好奇心引导我们去了解一些事情，就好像那些东西是我们在这世上唯一想要拥有的东西。 实践智慧需要“我们充分了解所处特定环境的显著的道德特色，对这些特色的了解将帮助我们做出正确的反应”。因此，要获得实践智慧，就要克服白痴般的自我专注，突破好奇之人的狭隘视线。 格子间的矛盾 你对特定状况的反应更多地出于自我意识，还是更多地为“做对事”？先彻底想清楚这个问题。如果你发现自己的反应背后是自我意识在作祟，那请将它放到一旁…… 高等教育的过度扩张导致劳动力市场供过于求，由此导致白领工人“薪水比待遇不错的劳动工人还差”。此外，“这可能会导致某种令人不安的失业情况。大学毕业生不一定能找到专业对口的工作，心理上却又无法接受体力工作”。 我们的适应能力极强，环境会产生自己的道德规范，而人们内心的道德准则会因某些敏感性和敏锐性做出让步。 人们的个性多种多样，并不是所有性格的人都适合上大学，事实上，有些非常聪明的人完全不适合接受高等教育，也不适合从事那些人们认为拥有学位的人应该从事的工作，但大家并未意识到这点。将每个人都送入大学会导致劳动力市场出现异常。 对文凭的要求越来越高，造成了“这是一个前所未有的知识化的社会，其成员的认知水准是他们那些没有上过学的父母们无法想象的。”的假象。 学校教育的形式特征（例如成绩、奖惩和学位等）变得比其本质特征更重要。在学校学习期间，争取奖励变得比切实学到东西更重要……教学被排到了学校排名的后面，后者的社会效应更为明显；打分更看重的是其社会影响，而非实现教学的目标。 人们常说的普及高等教育的理由是，社会对拥有丰富知识的员工的需求越来越迫切，其实这种情况基于一个反常的理由：大学让年轻人习惯于接受形式和内容的不匹配，接受官方言论和现实情况的不相符。 培养年轻人自尊，似乎是为了帮助他们适应缺少客观标准的工作，保证他们围着团队打转。当自尊是被人为培养出来时，就很容易被操纵。它是一种社会技巧的产物，而不是建立在自身成就上的一种保障。 孩子们得到的表扬越多，就越会努力维持自己心目中的自我形象；那些被他人称赞聪明的孩子在被分配新任务时，会选择相对简单的处理方法。他们会开始逃避风险，依赖他人。 边做边想 建立在通用、命题式知识上的职业含金量比较高，但也面临着来自全球的竞争，因为一方面，在全球经济中，书本知识的传播范围越来越广。另一方面，实用技术始终与个人的经验密切相连。它无法通过下载获得，只能从实践中获取。 通常情况下，我们不能对事物做到不偏不倚。原因很简单：那些与我们无关的事情不好引起我们的注意，而且我们的注意力也是有限的。 相互作用的变量数量太大，因此人脑无法同时正确处理……直觉判断是对直觉的因果关系的反应，这正是简单系统的特点。 国际象棋大师之所以是大师，并不是因为他记忆力比他人强，而是因为他们见过那些国际象棋的布局模式。 “行家们懂得去察觉那些新手们注意不到的事物，例如特定情况下的某些特征。” 在编写维修手册的人看来，修理工就是智力技术和相应的社会技术中的小齿轮，而不是独立思考的人。 编写维修手册的应该是那些同机器一起工作和生活的人。他们使用的语言让人感觉有一个真实的人存在，你愿意和他坐下来，向他学习。 技工为了把他的工作做好，有时候必须采取合理行动；而知识科技断言，用分工来取代个人知识是一种伪装的合理行动。 工作、休闲与全心投入 人们选择休闲活动常常是为了“追求真正的自我”。与此相应，所谓“好工作”就是能让人民拥有最大的财力，来追求那些能让生命变得有意义的休闲活动。 重要的不在于你能跑多快，而在于你用什么方法跑得快。 人类与动物的区别在于动物在一开始就知道预期要达到的效果，然后才会去寻找能满足要求的工具；而我们人类能够将所有东西视作潜在的工具。 猪喜欢在泥巴里打滚，海豚在水里嬉戏，这些看上去都像休闲活动。但许多动物做的事情很像工作，这些事情在改变着自然的形态，发挥着作用。 要想在活动中找到快乐，就要参与并全心投入活动中，这种投入是一心一意、全神贯注的，使整个活动值得被追求……如果只是在乎活动的工具价值……其对价值的关注就会从活动本身转移到预期结果上，即不再关心正在做什么。这种关注……让我们在活动中心不在焉，使活动变成一种负担。 如果我们让自己的行动回归根本，就能更好地理解什么是美好的生活。]]></content>
      <categories>
        <category>泛 - 书摘</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>工匠精神</tag>
        <tag>书摘</tag>
        <tag>摩托车修理店的未来工作哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类与对象总结（二）构造函数]]></title>
    <url>%2F2018%2F02%2F11%2Fcpp-class-2%2F</url>
    <content type="text"><![CDATA[构造器Constructor构造器(函数)一种特殊的成员函数，用于对象的初始化。名称与类的名称相同，可以重载，无返回类型。123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class A&#123; private: int a,b; public: A(int aa,int bb) &#123; a = aa; b = bb; &#125;&#125;;int main()&#123; A a(1,2); return 0;&#125; 在这里我们定义的A类的一个参数为两个int的构造函数，在main函数中a被创建时需要用括号传参。 初始化列表Initializer List对于上面的构造函数C++还有其他的做法，像下面代码中的构造函数。 初始化列表的动作是在构造函数体执行之前进行的，初始化顺序是按照成员变量的声明顺序进行的与初始化列表中的顺序无关。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class A&#123; private: int a,b; public: A(int aa,int bb):a(aa),b(bb)&#123;&#125;&#125;;int main()&#123; A a(1,2); return 0;&#125; 在这里你可以简单的认为两者效果是一致的，但如果成员不是基础数据类型两者就会有很大不同。 举个例子： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class B&#123; private: int a,b; public: B(int aa,int bb) &#123; a = aa; b = bb; &#125;&#125;;class A&#123; private: int a,b; B c; public: A(int aa,int bb) &#123; a = aa; b = bb; c(1,2); &#125;&#125;;int main()&#123; A a(1,2); return 0;&#125; 这里我们又声明了一个B类，在A类中添加了一个成员c为B类的对象。 我们用g++编译这个程序会得到这样的一条错误： error: constructor for ‘A’ must explicitly initialize the member ‘c’ which does not have a default constructor 它说我们必须显式初始化成员c，因为c没有缺省构造函数（缺省构造函数在下面会讲解）。 这个错误很奇怪，我们明明那么明显的初始化了c，它竟然说我们没有显式初始化，还要什么缺省构造函数。 这里的原因就在于它在进构造函数之前就要进行初始化，如果没有初始化列表编译器会去找缺省构造函数去初始化它。如果B类有缺省构造函数，这个代码仍然是错误的，因为在26行这个不是正确的初始化，初始化一个对象要么在初始化列表中，要么在它定义是地方初始化，26行这种方式编译器会去找()的运算符重载函数。12345678class A&#123; private: int a,b; B c; public: A(int aa,int bb):a(aa),b(bb),c(1,2)&#123;&#125;&#125;; 正确的A类的构造函数应该这样写，在初始化c时它会调用c的构造函数来初始化它。 特殊的构造函数缺省构造函数Default Constructor对于上面的A类来说如果需要创建一个A类的数组，我们需要这样一句话定义一个三单元的数组里面每个都要用括号给出参数。1A b[3] = &#123;A(1,2),A(2,3),A(3,4)&#125;; 如果我们要创建一个100单元的数组，如果是int的，我们一般是先定义好再用循环赋值。 我们想这样写：1A c[100]; 但对于A这样是不可以的，因为它的构造函数需要两个int作为参数而这里创建时并没有给出参数，在定义时它不能初始化这些对象。 我们需要另一种构造函数，缺省构造函数。只要是我们写的没有参数的构造函数就叫做缺省构造函数。1A()&#123;&#125; 重载构造函数就可以创建出c数组。 如果一个类没有声明任何构造函数，编译器会自动生成一个不接受任何参数不做任何操作的缺省构造函数。 拷贝构造函数Copy Constructor123A a(1,2);A b = a;// A b(a); 如果我们定义了a这个对象，如果在定义初始化b时想直接拿a的值来初始化b（需要明白这里的等号与括号初始化等价，与赋值无关），我们需要用到拷贝构造函数，拷贝构造函数需要拿另一个该类的对象（引用）作为参数，初始化时可以用等号或用括号。12345A(const A &amp;p)&#123; a = p.a; b = p.b;&#125; 对于A类简单的拷贝构造函数就是这样，拷贝构造函数只是说它的参数是该类的对象的引用，函数体里你可以做其他操作。 如果一个类没有声明拷贝构造函数，编译器会自动生成一个隐式的拷贝构造函数(Implicitly Copy Constructor)，它将对做成员拷贝（Memberwise Copy），如果成员是基础数据类型就是基本的初始化，如果成员是其他对象就调用那个对象的拷贝构造函数做初始化，C++中的隐式拷贝构造并不是位拷贝（Bitwise Copy）。 拷贝构造函数的参数为什么必须是引用？因为函数传值调用需要做一步拷贝构造，如果拷贝构造函数是传值调用，那么就会在传值时再次调用拷贝构造函数，就会引起无限的递归。 拷贝构造函数在哪里会被调用？ 对象初始化 函数的传值调用 函数的返回值 第一种情况前面已经有所介绍，后两种情况需要注意不同的编译器会有不同的表现，一般来说编译器会把很多不必要的拷贝构造优化掉。 比如这段代码：Ubuntu Pastebin : https://paste.ubuntu.com/=rCHw4pHhMn/123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int num = 0;class A&#123; private: int a,b; public: A()&#123;&#125; A(int aa,int bb):a(aa),b(bb)&#123;&#125; A(const A &amp;p) &#123; num++; cout &lt;&lt; num &lt;&lt; "copy" &lt;&lt; endl; a = p.a; b = p.b; &#125;&#125;;A f(A a) //1&#123; A re(a); //2 return re; //3&#125;int main()&#123; A a(1,2); A b = f(a); //4 cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; 如果是按刚刚讲的逻辑应该发生四次拷贝构造，我在代码中标注的四处。但如果你用不同编译器或者不同的编译选项编译都会有不同的结果，在这里我使用CentOS下的g++、MacOS下的g++和Windows 10下的DevC++（MinGW）测试的结果都为调用了两次。1234567[zyx@centos-linux c]$ g++ test.cpp[zyx@centos-linux c]$ ./a.out1copy2copy2//CentOS g++ 64bit 而在Windows 10的Visual Studio 2013的结果为三次。1234561copy2copy3copy3//Visual Studio 2013 64bit 对于Visual Studio 2017依然如此 1234561copy2copy3copy3//Visual Studio 2017 64bit Windows下CB的与g++和MinGW相同123451copy2copy2//CB 64bit 可以说明不同的编译器在拷贝构造上有不同的优化策略。 深入探究拷贝构造函数的编译器优化：之前说的调用拷贝构造的规则在编译器的优化面前好像就没了规则，为什么会这样呢？对于发生了三次和两次拷贝构造的情况它们究竟优化掉了哪一次或两次呢？ C++标准(N4527) § 12.8 Copying and moving class objects 第31条（P.293/294）中这样写到： When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side eﬀects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two diﬀerent ways of referring to the same object. If the ﬁrst parameter of the selected constructor is an rvalue reference to the object’s type, the destruction of that object occurs when the target would have been destroyed; otherwise, the destruction occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies): 这里只是说编译器可以在一些情况下不考虑副作用对拷贝或者移动构造函数进行优化，而且对于标准中的四种情况可以删除多份。 之后列举了四条基本情况，我们只关心第一和第三条： (31.1) — in a return statement in a function with a class return type, when the expression is the name of a nonvolatile automatic object (other than a function parameter or a variable introduced by the exceptiondeclaration of a handler (15.3)) with the same type (ignoring cv-qualiﬁcation) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function’s return value. (31.3) — when the exception-declaration of an exception handler (Clause 15) declares an object of the same type (except for cv-qualiﬁcation) as the exception object (15.1), the copy operation can be omitted by treating the exception-declaration as an alias for the exception object if the meaning of the program will be unchanged except for the execution of constructors and destructors for the object declared by the exception-declaration. [ Note: There cannot be a move from the exception object because it is always an lvalue. — end note ] 第一条：函数的 return 语句中的表达式是一个非 volatile 的对象，并且其非const&amp;volatile类型和函数返回值的非const&amp;volatile类型相同，此时可以省略一次拷贝或移动构造函数（移动构造函数为C++11的扩展）。 第三条：对于一个非const&amp;volatile的临时对象且没有绑定引用，它的复制/移动操作，可以省略。 对于第一条明确的标准几乎所有的编译器对此都做了优化，也就是代码中第3号点被优化掉了 对于第三条在G++和CB中第4号点因此被优化，也就是对象b的构造没有调用拷贝构造函数。g++提供了一个编译选项：-fno-elide-constructors 开启这个选项编译器会关闭上述关于拷贝和移动构造函数的优化。 123456789[zyx@centos-linux c]$ g++ -fno-elide-constructors test.cpp[zyx@centos-linux c]$ ./a.out1copy2copy3copy4copy4//CentOS g++ 64bit 运行结果确实是4次 这样我们可以通过对比汇编代码来看具体它在哪里优化了拷贝构造。 代码：默认优化Ubuntu Pastebin : https://paste.ubuntu.com/=Wm88H4Vhxf/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 .globl __Z1f1A .p2align 4, 0x90__Z1f1A: ## @_Z1f1A .cfi_startproc## BB#0: pushq %rbpLcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp subq $16, %rsp movq %rdi, %rax movq %rax, -8(%rbp) ## 8-byte Spill callq __ZN1AC1ERKS_ movq -8(%rbp), %rax ## 8-byte Reload addq $16, %rsp popq %rbp retq .cfi_endproc .globl __ZN1AC1ERKS_ .weak_def_can_be_hidden __ZN1AC1ERKS_ .p2align 4, 0x90_main: ## @main .cfi_startproc## BB#0: pushq %rbpLcfi6: .cfi_def_cfa_offset 16Lcfi7: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi8: .cfi_def_cfa_register %rbp subq $64, %rsp leaq -32(%rbp), %rdi movl $1, %esi movl $2, %edx movl $0, -20(%rbp) callq __ZN1AC1Eii leaq -48(%rbp), %rdi leaq -32(%rbp), %rsi callq __ZN1AC1ERKS_ leaq -40(%rbp), %rdi leaq -48(%rbp), %rsi callq __Z1f1A movq __ZNSt3__14coutE@GOTPCREL(%rip), %rdi movl _num(%rip), %esi callq __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi leaq __ZNSt3__14endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rdi movq %rax, -8(%rbp) movq %rdi, -16(%rbp) movq -8(%rbp), %rdi callq *-16(%rbp) xorl %edx, %edx movq %rax, -56(%rbp) ## 8-byte Spill movl %edx, %eax addq $64, %rsp popq %rbp retq .cfi_endproc 关闭优化Ubuntu Pastebin : https://paste.ubuntu.com/=7CV893KdNY/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 .globl __Z1f1A .p2align 4, 0x90__Z1f1A: ## @_Z1f1A .cfi_startproc## BB#0: pushq %rbpLcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp subq $32, %rsp movq %rdi, %rax leaq -8(%rbp), %rcx movq %rdi, -16(%rbp) ## 8-byte Spill movq %rcx, %rdi movq %rax, -24(%rbp) ## 8-byte Spill callq __ZN1AC1ERKS_ leaq -8(%rbp), %rsi movq -16(%rbp), %rdi ## 8-byte Reload callq __ZN1AC1ERKS_ movq -24(%rbp), %rax ## 8-byte Reload addq $32, %rsp popq %rbp retq .cfi_endproc .globl _main .p2align 4, 0x90_main: ## @main .cfi_startproc## BB#0: pushq %rbpLcfi6: .cfi_def_cfa_offset 16Lcfi7: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi8: .cfi_def_cfa_register %rbp subq $64, %rsp leaq -32(%rbp), %rdi movl $1, %esi movl $2, %edx movl $0, -20(%rbp) callq __ZN1AC1Eii leaq -56(%rbp), %rdi leaq -32(%rbp), %rsi callq __ZN1AC1ERKS_ leaq -48(%rbp), %rdi leaq -56(%rbp), %rsi callq __Z1f1A leaq -40(%rbp), %rdi leaq -48(%rbp), %rsi callq __ZN1AC1ERKS_ movq __ZNSt3__14coutE@GOTPCREL(%rip), %rdi movl _num(%rip), %esi callq __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi leaq __ZNSt3__14endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rdi movq %rax, -8(%rbp) movq %rdi, -16(%rbp) movq -8(%rbp), %rdi callq *-16(%rbp) xorl %edx, %edx movq %rax, -64(%rbp) ## 8-byte Spill movl %edx, %eax addq $64, %rsp popq %rbp retq .cfi_endproc 默认优化下程序在17和51行调用了A的拷贝构造函数，而在关闭拷贝构造后程序分别在20、23、55、61行调用了拷贝构造函数。这里分析可以发现编译器优化掉了 函数返回值的构造 和 对象b的构造。Visual Studio 2013 64bit 反汇编代码：Ubuntu Pastebin : https://paste.ubuntu.com/=h3mV88hjrn/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778A f(A a) //1&#123;00395850 55 push ebp 00395851 8B EC mov ebp,esp 00395853 81 EC D4 00 00 00 sub esp,0D4h 00395859 53 push ebx 0039585A 56 push esi 0039585B 57 push edi 0039585C 8D BD 2C FF FF FF lea edi,[ebp-0D4h] 00395862 B9 35 00 00 00 mov ecx,35h 00395867 B8 CC CC CC CC mov eax,0CCCCCCCCh 0039586C F3 AB rep stos dword ptr es:[edi] 0039586E A1 00 00 3A 00 mov eax,dword ptr ds:[003A0000h] 00395873 33 C5 xor eax,ebp 00395875 89 45 FC mov dword ptr [ebp-4],eax A re(a); //200395878 8D 45 0C lea eax,[a] 0039587B 50 push eax 0039587C 8D 4D F0 lea ecx,[re] 0039587F E8 37 BB FF FF call A::A (03913BBh) return re; //300395884 8D 45 F0 lea eax,[re] 00395887 50 push eax 00395888 8B 4D 08 mov ecx,dword ptr [ebp+8] 0039588B E8 2B BB FF FF call A::A (03913BBh) 00395890 8B 45 08 mov eax,dword ptr [ebp+8] &#125;int main()&#123;00F16060 55 push ebp 00F16061 8B EC mov ebp,esp 00F16063 81 EC F0 00 00 00 sub esp,0F0h 00F16069 53 push ebx 00F1606A 56 push esi 00F1606B 57 push edi 00F1606C 8D BD 10 FF FF FF lea edi,[ebp-0F0h] 00F16072 B9 3C 00 00 00 mov ecx,3Ch 00F16077 B8 CC CC CC CC mov eax,0CCCCCCCCh 00F1607C F3 AB rep stos dword ptr es:[edi] 00F1607E A1 00 00 F2 00 mov eax,dword ptr ds:[00F20000h] 00F16083 33 C5 xor eax,ebp 00F16085 89 45 FC mov dword ptr [ebp-4],eax A a(1, 2);00F16088 6A 02 push 2 00F1608A 6A 01 push 1 00F1608C 8D 4D F0 lea ecx,[a] 00F1608F E8 81 B3 FF FF call A::A (0F11415h) A b = f(a); //400F16094 83 EC 08 sub esp,8 00F16097 8B CC mov ecx,esp 00F16099 8D 45 F0 lea eax,[a] 00F1609C 50 push eax 00F1609D E8 19 B3 FF FF call A::A (0F113BBh) 00F160A2 8D 4D E0 lea ecx,[b] 00F160A5 51 push ecx 00F160A6 E8 6D B0 FF FF call f (0F11118h) 00F160AB 83 C4 0C add esp,0Ch cout &lt;&lt; num &lt;&lt; endl;00F160AE 8B F4 mov esi,esp 00F160B0 68 E8 13 F1 00 push 0F113E8h 00F160B5 8B FC mov edi,esp 00F160B7 A1 20 03 F2 00 mov eax,dword ptr ds:[00F20320h] 00F160BC 50 push eax 00F160BD 8B 0D A0 10 F2 00 mov ecx,dword ptr ds:[0F210A0h] 00F160C3 FF 15 94 10 F2 00 call dword ptr ds:[0F21094h] 00F160C9 3B FC cmp edi,esp 00F160CB E8 64 B2 FF FF call __RTC_CheckEsp (0F11334h) 00F160D0 8B C8 mov ecx,eax 00F160D2 FF 15 90 10 F2 00 call dword ptr ds:[0F21090h] 00F160D8 3B F4 cmp esi,esp 00F160DA E8 55 B2 FF FF call __RTC_CheckEsp (0F11334h) return 0;00F160DF 33 C0 xor eax,eax &#125; VS的反汇编代码中有C++代码注释，它分别在20、25、57行调用了A的拷贝构造函数，可以看出VS只是优化掉了对象b的构造。]]></content>
      <categories>
        <category>编程语言 - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>汇编语言</tag>
        <tag>构造函数</tag>
        <tag>拷贝构造函数</tag>
        <tag>缺省构造函数</tag>
        <tag>编译器优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS与BFS]]></title>
    <url>%2F2018%2F02%2F05%2Fdfs-bfs%2F</url>
    <content type="text"><![CDATA[简介DFS（深度优先搜索）和BFS（广度优先搜索）都是应用广泛的搜索算法，同属于图算法。两种算法实际上就是两种不同的搜索策略。 区别 DFS的访问顺序：1 -&gt; 2 -&gt; 4 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 6 BFS的访问顺序：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 DFS沿着一个分支一直递归到最后，而BFS从起点一层一层向外扩展。DFS用栈来实现，BFS用队列来实现。 实现下面给出两种算法的伪代码 DFS12345678910void dfs(int deep)&#123; if(到达边界)&#123; // 做一些处理后返回 &#125;else&#123; for(所有可能的选择)&#123; dfs(deep + 1); &#125; &#125;&#125; BFS1234567891011121314void bfs(起始点) &#123; 将起始点放⼊队列中; while(如果队列不为空)&#123; 访问队列中队⾸元素x; 删除队⾸元素; for(x 所有相邻点)&#123; if(该点未被访问过且合法)&#123; 将该点加⼊队列末尾; &#125; &#125; &#125; 队列为空，⼴搜结束;&#125; 例子为了便于理解这两种算法的优缺点，我在我的题库中给出一题“走迷宫”，此题为一道无权图的最短路题。 DFS和BFS算法都可以轻松解决此题，下面我直接给出代码后分析优缺点。 DFS实现Ubuntu Pastebin : https://paste.ubuntu.com/26527945/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;#define MAX_MAP 20int minP = INT_MAX;char map[MAX_MAP][MAX_MAP];bool collected[MAX_MAP][MAX_MAP];struct dir&#123; int x,y;&#125;dir[4] = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;struct point&#123; point()&#123;&#125; point(int xx,int yy,int s):x(xx),y(yy),step(s)&#123;&#125; int x; int y; int step;&#125;;void dfs(point now)&#123; if(map[now.x][now.y] == 'T')&#123; if(now.step &lt; minP)&#123; minP = now.step; &#125; return; &#125; collected[now.x][now.y] = true; for( int i = 0; i &lt; 4; i++)&#123; if(!collected[now.x+dir[i].x][now.y+dir[i].y])&#123; point next(now.x+dir[i].x,now.y+dir[i].y,now.step+1); dfs(next); &#125; &#125; collected[now.x][now.y] = false; return;&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for( int i = 0 ; i &lt; MAX_MAP; i++)&#123; for( int j = 0; j &lt; MAX_MAP; j++)&#123; map[i][j] = '#'; collected[i][j] = true; &#125; &#125; point begin; for( int i = 1; i &lt;= n; i++)&#123; for( int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; map[i][j]; if(map[i][j] != '#')&#123; collected[i][j] = false; &#125; if(map[i][j] == 'S')&#123; begin.x = i; begin.y = j; begin.step = 0; &#125; &#125; &#125; dfs(begin); if(minP &lt; INT_MAX)&#123; cout &lt;&lt; minP; &#125;else&#123; cout &lt;&lt; -1; &#125; return 0;&#125; BFS实现Ubuntu Pastebin : https://paste.ubuntu.com/26527953/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;#define MAX_MAP 20int n,m;char map[MAX_MAP][MAX_MAP];bool collected[MAX_MAP][MAX_MAP];struct Dir&#123; int x,y;&#125;dir[] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;struct point&#123; int x; int y; int step;&#125;;int bfs(point begin)&#123; queue&lt;point&gt; Q; collected[begin.x][begin.y] = true; Q.push(begin); while(!Q.empty())&#123; point temp = Q.front(); Q.pop(); if(map[temp.x][temp.y] == 'T')&#123; return temp.step; &#125; for( int i = 0; i &lt; 4; i++)&#123; int x = temp.x + dir[i].x; int y = temp.y + dir[i].y; if(!collected[x][y] &amp;&amp; map[x][y] != '#')&#123; collected[x][y] = true; point rd; rd.x = x; rd.y = y; rd.step = temp.step + 1; Q.push(rd); &#125; &#125; &#125; return -1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for( int i = 0; i &lt; MAX_MAP; i++)&#123; for( int j = 0; j &lt; MAX_MAP; j++)&#123; map[i][j] = '#'; collected[i][j] = true; &#125; &#125; point begin; for( int i = 1; i &lt;= n; i++)&#123; for( int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; map[i][j]; collected[i][j] = false; if(map[i][j] == 'S')&#123; begin.x = i; begin.y = j; begin.step = 0; &#125; &#125; &#125; cout &lt;&lt; bfs(begin); return 0;&#125; 在此题中BFS算法是很占优势的，因为它不需要枚举所有情况，如果在某一层遇到终点那最小步数必然是当前层数，而DFS算法需要枚举所有情况来更新最小步数最后才能确定。特殊情况下如果起点和终点是邻居，BFS只需一层搜索就可以解决，而DFS仍然需要枚举所有结果。当然DFS可以进行剪枝优化但在此题中效率明显是不如BFS的。 如果将此题改为问通过迷宫的方法数，那么此题就不能用BFS解决，因为BFS求的只是最短路并没有枚举所有的路线。此图中，如果题目问从1走到3有多少种方法。 如果是DFS它会找到两种路线：1 -&gt; 3 和 1 -&gt; 2 -&gt; 3。 而BFS在第一层时找到1 -&gt; 3这条路后就将3标记为已访问，之后所有点都已被访问就不存在第二层了也就不存在1 -&gt; 2 -&gt; 3这条路了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>题解</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>图搜索</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F01%2F31%2Funion-find-sets%2F</url>
    <content type="text"><![CDATA[概述并查集是一种树形数据结构，用于处理集合的合并及查询问题，常常以森林的形式表示。这里需要注意并查集虽然可以进行合并操作，但无法进行分割操作。 并查集一般用数组来实现，如果是无权并查集只需要一个保存每个节点的父节点的数组就可以实现。 接口并查集一般提供三个接口，初始化，查询，合并。 初始化初始状态时，每个元素各为一棵树，其父节点初始为它本身。（图1） 初始化函数代码123456void init()&#123; for( int i = 1; i &lt;= n; i++)&#123; pre[i] = i; &#125;&#125; pre数组保存每个元素的父节点。 查询查询是指查询给出节点所在的集合的根节点。 递归思想：如果它的父节点就是它本身，那当然它自己就是它的根节点。如果不是那它父亲的根节点就是它的跟节点。 查询函数代码123456789int get(int x)&#123; if(pre[x] == x)&#123; //x 节点就是根节点 return x; &#125; return get(pre[x]); //返回父节点的根节点&#125; 这里的查询函数（包括下面的合并函数）都可以用循环方式实现。 合并： 合并就是把两个集合合并成一个，也就是将两棵树合并为一棵树。 （图2） 合并函数代码12345678void merge(int x,int y)&#123; x = get(x); y = get(y); if(x != y)&#123; // 不住同一个集合 pre[y] = x; &#125;&#125; 这里我们先是找出两课树的根节点，再将一个节点的根节点的父节点设置为另一个节点的跟节点即可。 路径压缩并查集最重要的操作就是查找，我们关心的是每个节点在哪棵树上，并不需要知道树具体的形状，像图2中的6、5、7节点如果将6号节点继续和4或8号节点合并会产生一棵偏树，最坏情况下导致查询的时间复杂度达到O(n)。 我们可以将6、5、7号节点换为图3中的树效果是一样的。我们只需调整get函数，在每次调用get函数时压缩一次路径，不断的维护这个并查集。优化后的查询代码：123456789int get(int x)&#123; if(pre[x] == x)&#123; //x 节点就是根节点 return x; &#125; return pre[x] = get(pre[x]); //返回父节点的根节点，并另当前节点父节点直接为根节点&#125; 这样优化之后的并查集效率非常高。执行一次查询操作的时间复杂度仅为O(α(n))，这里的α(n)是阿克曼函数的反函数，总的时间复杂度将比O(logn)还要快。 带权并查集带权并查集是指存有权值的并查集，节点的权值一般保存与根节点的关系信息，比如权值可以保存该节点与跟节点的距离。这里为了便于讲解我们以一道题为例： POJ 1182 食物链题目链接：http://poj.org/problem?id=1182Ubuntu Pastebin : https://paste.ubuntu.com/26527937/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#define N 500000using namespace std;int pre[N],weight[N];int ans,c;int get(int x)&#123; if(x != pre[x]) &#123; int temp = pre[x]; pre[x] = get(temp); weight[x]=(weight[x] + weight[temp]) % 3; &#125; return pre[x];&#125;void merge(int x,int y)&#123; int xRoot = get(x); int yRoot = get(y); if(xRoot != yRoot)&#123; pre[xRoot] = yRoot; weight[xRoot] = (weight[y]-weight[x] + c + 3) % 3; &#125;else if((weight[x]-weight[y] + 3) % 3 != c)&#123; ans++; &#125;&#125;void init(int n)&#123; for( int i = 0; i &lt;= n+10; i++)&#123; pre[i] = i; weight[i] = 0; &#125; ans = 0; &#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); init(n); for( int i = 0; i &lt; m; i++)&#123; int a,b; scanf("%d%d%d",&amp;c,&amp;a,&amp;b); if(a &gt; n || b &gt; n || (c == 2 &amp;&amp; a == b) )&#123; ans++; &#125;else&#123; c--; merge(a,b); &#125; &#125; printf("%d\n",ans);&#125; 此题只需维护每个节点到其根节点的距离对3取余的结果即可，路径压缩时需要注意维护权值。 其他一些简单的并查集题目我会之后在我的vijos题库中给出作为练习。此题的详细题解我也许会之后在我的博客更新。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>优化</tag>
        <tag>POJ</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>带权并查集</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类与对象总结（一）]]></title>
    <url>%2F2018%2F01%2F26%2Fcpp-class-1%2F</url>
    <content type="text"><![CDATA[类与对象的关系类是一种标准，而对象是类的实体，就如int是一种数据类型（类），而int i;是int类型的一个实体变量（对象）。 成员变量与成员函数一个类中可以包含多个成员函数，类的每个对象可以包含多个成员变量（也可以是其他的类），比如下面的这个A类的声明中就声明了A类有一个成员函数b，它每个对象中包含一个int类型的变量i。1234class A&#123; int i; void b();&#125; 这里要注意的是成员函数是属于类的，成员变量（静态变量除外）是属于对象的。 访问属性在类声明中我们可以声明每个成员的访问属性（如果不声明其访问属性，默认为private），在C++中有 public、protected 和 private 这三种访问属性。声明的方法见代码1234567class A&#123;private: int i;public: void b();&#125;; public：任何地方都可以访问 protected：只有这个类和它的派生类可以访问 private：只有这个类可以访问 需要说明的是C++的这种访问限制是类的访问属性而不是对象的。1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class A&#123;private: int i;public: A()&#123;&#125; A(int i):i(i)&#123;&#125; void c(A *p) &#123; cout &lt;&lt; p-&gt;i &lt;&lt; endl; &#125;&#125;;int main()&#123; A a(1),b(2); a.c(&amp;b); //输出2 return 0;&#125; 像这段代码，我们拿到了b的地址就可以访问b的私有成员。 C++的这种访问限制只是编译器级别的限制，只是编译器在检查访问属性，如果骗过编译器一样可以访问其他类的对象的private的成员。Ubuntu Pastebin : https://paste.ubuntu.com/26535160/123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class B&#123;private: int i;public: B()&#123;&#125; B(int ii):i(ii)&#123;&#125;&#125;;class A&#123;private: int i;public: A()&#123;&#125; A(int ii):i(ii)&#123;&#125; void d(B *p) &#123; cout &lt;&lt; *(int*)p &lt;&lt; endl; &#125;&#125;;int main()&#123; A a(1); B b(3); a.d(&amp;b); //输出3 return 0;&#125; 这段代码中我们定义了两个类，我们把B类的对象b的地址传到A类的d函数中通过强制类型转换一样可以访问b的private的成员，这就说明了访问属性的限制只是编译器级别的，在运行时如果你拿到它的地址还是可以为所欲为的。 friend关键字上述非法的手段只是作为了解，如果在程序中确实有上面演示中的场景，C++也有其他的方案。Ubuntu Pastebin : https://paste.ubuntu.com/26535171/1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class B;class A&#123;private: int i;public: A()&#123;&#125; A(int ii):i(ii)&#123;&#125; void d(B *p) &#123; cout &lt;&lt; *(int*)p &lt;&lt; endl; &#125;&#125;;class B&#123;private: int i;public: B()&#123;&#125; B(int ii):i(ii)&#123;&#125; friend void A::d(B*p);&#125;;int main()&#123; A a(1); B b(3); a.d(&amp;b); //输出3 return 0;&#125; friend关键字可以声明别的类（也可以是别的函数或者别的类的成员函数）是你这个类的朋友，声明之后它就可以访问你这个类所有的成员。这样也就合法的实现了上面我们非法实现的功能。同样的friend的授权也是编译器级别的。 class和struct的区别struct在C语言中就存在，在C语言结构与数组类似，数组是存储多个相同类型的变量，结构可以存储不同类型的变量。而到了C++中struct有了更多的功能与class基本一致。只是在默认访问属性有所差别。如果在class中不声明访问属性则默认为private，在struct中默认为public。]]></content>
      <categories>
        <category>编程语言 - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>类成员</tag>
        <tag>访问属性</tag>
        <tag>类与对象</tag>
        <tag>class</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3253 Fence Repair（贪心）]]></title>
    <url>%2F2018%2F01%2F24%2Fpoj-3253-fence-repair%2F</url>
    <content type="text"><![CDATA[题目链接：http://poj.org/problem?id=3253 Fence RepairTime Limit: 2000MS Memory Limit: 65536K DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs _N_ (1 ≤ _N_ ≤ 20,000) planks of wood, each having some integer length _Li_ (1 ≤ _Li_ ≤ 50,000) units. He then purchases a single long board just long enough to saw into the _N_planks (i.e., whose length is the sum of the lengths _Li_). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too. FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw. Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the _N_-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents. Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the _N_ planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths. InputLine 1: One integer _N_, the number of planks Lines 2.._N_+1: Each line contains a single integer describing the length of a needed plank OutputLine 1: One integer: the minimum amount of money he must spend to make _N_-1 cuts Sample Input3858 Sample Output34 HintHe wants to cut a board of length 21 into pieces of lengths 8, 5, and 8. The original board measures 8+5+8=21. The first cut will cost 21, and should be used to cut the board into pieces measuring 13 and 8. The second cut will cost 13, and should be used to cut the 13 into 8 and 5. This would cost 21+13=34. If the 21 was cut into 16 and 5 instead, the second cut would cost 16 for a total of 37 (which is more than 34). 题解题目大意将一块木板切割成N块，每次切割木板时的开销为这块木板的长度。例如长度为21的木板要切成长度为5、8、8的三块木板。长21的木板切成为13和8的板时，开销为21。再将长度为13的板切成5和8的板时，开销是13。于是合计开销为34。求按照目标要求切割木板最小的开销。 解题思路可以逆向的组合木板，计算把输入的多个木板数据最终组合为一个长木板的开销，与切割开销相同。如果想要组合开销最小，每次从所有的木板中选择两个最短的组合即可。 代码Ubuntu Pastebin : https://paste.ubuntu.com/26527927/12345678910111213141516171819202122232425262728293031323334353637383940//POJ 3253 Fence Repair（贪心）//2018-01-24#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std; class Int &#123; public: int num; Int(int a):num(a) &#123;&#125; &#125;; bool operator &gt; (const Int &amp;t1, const Int &amp;t2) &#123; return t1.num &gt; t2.num; &#125; //定义一个Int类代替int，因为要将优先队列逆序需要做运算符重载int main()&#123; int n; cin &gt;&gt; n; priority_queue&lt;Int, vector&lt;Int&gt;, greater&lt;Int&gt; &gt; q; for( int i = 0; i &lt; n; i++)&#123; //把n块木板的长度入队 int temp; cin &gt;&gt; temp; q.push((Int)temp); &#125; long long sum = 0; //合计开销 while(q.size() &gt; 1)&#123; //如果还没有合成一块木板就继续合并 int minOne,minTwo; minOne = q.top().num; q.pop(); minTwo = q.top().num; q.pop(); //从队头拿出两个最短的木板 sum += (minOne + minTwo); //加上这次合并的开销 q.push((Int)(minOne+minTwo)); //将合并后的木板入队 &#125; cout &lt;&lt; sum; return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>DFS</tag>
        <tag>运算符重载</tag>
        <tag>POJ</tag>
        <tag>贪心法</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法1——冒泡排序]]></title>
    <url>%2F2018%2F01%2F18%2Fbubble-sort%2F</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序是一种实现起来很简单的排序算法，适合初学者入门。 由于它的时间复杂度较高在实际使用中很少用到。但它也有存在的价值，比如待排序列存储在一个单向链表中时其他的排序算法实现起来就相对比较困难，而且冒泡排序相等的元素不会进行交换所以它也是一种稳定的排序算法。 演示冒泡排序在每一趟排序中从上到下拿两个相同元素比较如果不符合我们的预期就交换它（比如要求从小到大排序，如果相邻两个元素不满足前面小后面大就交换它），在完成一趟排序后可以确定最下面的元素一定是最大的（按从小到大排序）。每一趟排序可以确定一个元素的位置，我们通过n-1趟排序就可以将数据排好序。 代码Ubuntu Pastebin : https://paste.ubuntu.com/26535079/1234567891011void BubbleSort(int a[],int size)&#123; for( int i = size-1; i &gt;= 0; i--)&#123; for( int j = 0; j &lt; i; j++)&#123; if(a[j] &gt; a[j+1])&#123; swap(a[j],a[j+1]); &#125; &#125; &#125;&#125; 实际上该代码还可以再进行优化，如果在一趟排序中没有交换过就说明序列已经有序，我们就不需要再比较下去。 优化后的代码Ubuntu Pastebin : https://paste.ubuntu.com/26535087/12345678910111213void BubbleSort(int a[],int size)&#123; for( int i = size-1; i &gt;= 0; i--)&#123; bool flag = false; //记录在一趟排序中是否有交换 for( int j = 0; j &lt; i; j++)&#123; if(a[j] &gt; a[j+1])&#123; swap(a[j],a[j+1]); flag = true; &#125; &#125; if(!flag) break; &#125;&#125; 由此我们可以分析得出最好情况（已有序）下其时间复杂度为O(n)，在最坏情况（逆序）下时间复杂度为O(n^2)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XUJCOJ 1065 走迷宫-2（BFS多状态无权图最短路径）]]></title>
    <url>%2F2018%2F01%2F16%2Fxujcoj-1065-maze2%2F</url>
    <content type="text"><![CDATA[题目链接：http://www.xujcoj.org/Home/Problems/status/pro_id/1065/ 走迷宫-2描述五毒教总坛有一个复杂的迷宫用于阻挡外人进入，但复杂的迷宫并不会阻碍草原教主通过。为了能够更快地穿越迷宫，除了走迷宫正常的上下左右四个方向一次移动一格外，草原教主随身带了一个火箭背包，可以让她能够跳过一格障碍（当然中间没有障碍也能跳），跳的方向可以是上下左右四个方向之一。例如在下图中，红色表示障碍，灰色表示通路，那么从A点可以跳到B点，也可以从A点跳到C点，但不能从C点跳到D点。不过火箭背包的能量有限，最多只能跳3次，并且火箭背包的质量很好，可以跳完一次以后立即跳下一次。假设走一格和跳一次花费的时间都是1秒，那么从指定的某个起点到达某个终点，最快需要花费多少秒时间？ 输入只有一组案例。 两个正整数m和n（m&lt;=100，n&lt;=100），表示迷宫的高度和宽度。 然后是m行数据，每行数据有n个整数，以空格相隔。每个数字代表的含义是：-1表示该点是障碍物，1表示该点是通路，0表示该点是起点或者终点。这m*n个数字中只会有2个数字是0。 输出一个整数，表示从起点到终点最快需要多少秒。如果从起点无法到达终点则输出-1。不要换行。 样例输入4 4 0 -1 1 1 1 -1 1 1 1 -1 -1 0 1 1 1 1 样例输出3 HINT从左上角的0处向右跳、向右、向下跳，到达终点。 题解解题分析此题难点在于节点有多种状态，在一个节点可能有不同的火箭背包数量。 解题思路如果没有火箭背包此题与最短路径题目差不多，对于有权图我们一般使用Dijkstra算法或SPFA算法，对于无权图我们可以考虑用BFS（广度优先搜索）去探索该图。对于节点的火箭状态在实现过程中我考虑将现实中的一个节点在程序中分为多个（在本题中为3个）递推。 代码Ubuntu Pastebin : https://paste.ubuntu.com/26527922/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//XUJCOJ 1065 走迷宫-2//2018-01-15#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int Y,X,rocket; //矩阵大小 火箭个数int map[210][210]; //节点是否有墙 可以改为bool优化内存bool collected[105][105][4]; //节点的火箭状态是否被收录struct quNode //声明一个结构方便节点的状态入队&#123; int r,c,rocketNums,time; //包含四个参数：位置rc、剩余火箭个数、已用时间 quNode(int rr,int cc,int timee,int rocketNumss):r(rr),c(cc),rocketNums(rocketNumss),time(timee) &#123; &#125;; quNode()&#123;&#125; //以上为该结构的构造函数&#125;;queue&lt;quNode&gt; Queue;struct Dir //四个方向方便后期用循环遍历一个节点的旁边的节点&#123; int dr,dc;&#125;dir[4] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;,dirJump[4] = &#123; &#123;0,2&#125;,&#123;0,-2&#125;,&#123;2,0&#125;,&#123;-2,0&#125;&#125;;//dir为走一格的情况 dirJump为跳一次的情况（走两个） int main()&#123; scanf("%d%d",&amp;Y,&amp;X); //输入矩阵大小 rocket = 3; //设置火箭个数 quNode origin,finish; //声明两个可入队节点保存起点和终点 memset(collected,true,sizeof(collected)); bool flag = true; //由于起点终点都为0 设个flag分开保存它们 for( int i = 1;i &lt;= Y; i++)&#123; for( int j = 1; j &lt;= X; j++)&#123; scanf("%d",&amp;map[i][j]); if(map[i][j] == 0 &amp;&amp; flag)&#123; //保存起点 origin = quNode(i,j,0,rocket); flag = false; &#125;else if(map[i][j] == 0 &amp;&amp; !flag)&#123; //保存终点 map[i][j] = 1; finish = quNode(i,j,-1,-1); &#125; for( int t = 0; t &lt;= rocket; t++) //初始化所有节点的所有状态都为未收录 collected[i][j][t] = false; &#125; &#125; collected[origin.r][origin.c][rocket] = true; //将起点收录 Queue.push(origin); //将起点入队 while(!Queue.empty())&#123; //如果队列为空说明图被完全遍历退出循环 quNode nowP = Queue.front(); //从队头拿一个节点 if( nowP.r == finish.r &amp;&amp; nowP.c == finish.c)&#123; //如果是终点则输出最短时间并结束程序 printf("%d",nowP.time); return 0; &#125; Queue.pop(); //队头元素出队 if( map[nowP.r][nowP.c] == -1 &amp;&amp; nowP.rocketNums == 0 ) continue; for( int i = 0;i &lt; 4; i++)&#123; //遍历该节点四个方向 //走一步 int newR = nowP.r + dir[i].dr; //四个方向的rc int newC = nowP.c + dir[i].dc; //如果该节点未被收录且不为墙 就录该节点 将time+1 将其入队 if(map[newR][newC] == 1 &amp;&amp; !collected[newR][newC][nowP.rocketNums])&#123; collected[newR][newC][nowP.rocketNums] = true; Queue.push(quNode(newR,newC,nowP.time+1,nowP.rocketNums)); &#125; //跳一步 int newRJump = nowP.r + dirJump[i].dr; int newCJump = nowP.c + dirJump[i].dc; //如果该节点未被收录且火箭还有剩余 就收录该节点 将time+1 将火箭数-1 将其入队 if((map[newRJump][newCJump] == -1 || map[newRJump][newCJump] == 1) &amp;&amp; nowP.rocketNums &gt; 0 &amp;&amp; !collected[newRJump][newCJump][nowP.rocketNums-1])&#123; collected[newRJump][newCJump][nowP.rocketNums-1] = true; Queue.push(quNode(newRJump,newCJump,nowP.time+1,nowP.rocketNums-1)); &#125; &#125; &#125; printf("%d",-1); //如果没有在while循环中return 说明没有遍历到终点 说明不连通 输出-1 return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>BFS</tag>
        <tag>图</tag>
        <tag>最短路径</tag>
        <tag>XUJCOJ</tag>
        <tag>多状态</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百练 2815 城堡问题（DFS极大连通子图）]]></title>
    <url>%2F2018%2F01%2F15%2Fbl-2815%2F</url>
    <content type="text"><![CDATA[题目链接：http://bailian.openjudge.cn/practice/2815/ 城堡问题总时间限制：1000ms 内存限制：65536kB 描述123456789101112131415 1 2 3 4 5 6 7 #############################1 # | # | # | | # #####---#####---#---#####---#2 # # | # # # # # #---#####---#####---#####---#3 # | | # # # # # #---#########---#####---#---#4 # # | | | | # # ############################# (图 1) # = Wall | = No wall \- = No wall 图 1 是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成mn(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 输入程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 输出城堡的房间数、城堡中最大房间所包括的方块数。结果显示在标准输出设备上。 样例输入4711 6 11 6 3 10 67 9 6 13 5 15 51 10 12 7 13 7 513 11 10 8 10 12 13 样例输出59 题解解题分析这是一个典型的求极大连通子图的问题，可以把每个方块当做一个图节点，没有墙的方向有一条边。 解题思路因为要求出极大连通子图的节点个数我们考虑用DFS（深度优先搜索）递归的去探索每个房间得出面积。探索完一个房间，看有没有未被访问过的方块，如果有说明一定存在另一个房间我们再用DFS的方法去探索它，直至所有的节点都被访问。 代码Ubuntu Pastebin : https://paste.ubuntu.com/26527902/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//百练 2815 城堡问题（DFS极大连通子图）//2018-01-15#include&lt;iostream&gt;using namespace std;int mapNode[55][55]; //图节点数组，保存墙信息bool collected[55][55]; //每个节点是否被访问int roomNum; //房间数量int roomNowArea; //当前搜索的房间的面积void dfs(int x,int y) &#123; if(collected[x][y])&#123; //如果该节点已被访问就返回上一层 return; &#125; collected[x][y] = true; //访问它 roomNowArea++; //找到一个未被访问的节点将当前房间面积加一 /* 因为1，2，4，8的二进制表达分别为：0001、0010、0100、1000 所以可以运用位运算看它的那一位上是不是1， 如果不是则说明没有墙，可以向这个方向继续搜索。 */ if((mapNode[x][y] &amp; 2) == 0) dfs(x-1,y); //如果没有北墙就搜索左边 if((mapNode[x][y] &amp; 8) == 0) dfs(x+1,y); //南墙 if((mapNode[x][y] &amp; 1) == 0) dfs(x,y-1); //西墙 if((mapNode[x][y] &amp; 4) == 0) dfs(x,y+1); //东墙&#125;int main()&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; for( int i = 0; i &lt; x; i++)&#123; for( int j = 0; j &lt; y; j++)&#123; cin &gt;&gt; mapNode[i][j]; collected[i][j] = false; &#125; &#125; //以上为输入阶段 int maxRoomArea = 0; //最大房间面积 roomNum = 0; //房间数量初始化 for( int i = 0; i &lt; x; i++)&#123; for( int j = 0; j &lt; y; j++)&#123; if(!collected[i][j])&#123; //找到没有被访问的节点 roomNum++; //找到一个新的就说明有一个新的房间 roomNowArea = 0; //重置当前房间的面积 dfs(i,j); //从该节点开始搜索该房间 if(roomNowArea &gt; maxRoomArea) maxRoomArea = roomNowArea; //保存最大房间面积 &#125; &#125; &#125; cout &lt;&lt; roomNum &lt;&lt; endl //输出 &lt;&lt; maxRoomArea; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM</tag>
        <tag>题解</tag>
        <tag>百练</tag>
        <tag>DFS</tag>
        <tag>极大连通子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用bash命令]]></title>
    <url>%2F2018%2F01%2F13%2Fbash%2F</url>
    <content type="text"><![CDATA[关于文本的程序 命令 解释 cp 复制一个或多个文件 diff 显示两个文件的不同之处 file 显示与文件内容相关的信息 grep 在文件中查找某个字符串 head 显示文件开头部分的内容 lpq 显示在打印队列中的作业 lpr 将文件放入打印队列中 lprm 从打印队列中删除某个作业 mv 将文件重命名或移动到其他目录 sort 将文件按行排序 tail 显示文件末尾的内容 uniq 显示文件内容，忽略连续重复的行 文件压缩、解压缩、归档程序 命令 解释 bunzip2 将 bzip 压缩的文件恢复为原来大小和格式 bzcat 显示 bzip2 压缩过的文件 bzip2 压缩文件 compress 压缩文件（但效率没有 bzip2 或 gzip 高） gunzip 将 gzip 压缩的文件恢复为原来大小和格式 gzip 压缩文件 unzip 解压 zip 包，与WindowsPKZIP 兼容 zcat 显示 gzip 压缩过的文件 zip 创建zip包，与 Windows PKZIP 兼容 tar 将归档文件打包和解包 定位程序 命令 解释 locate/mlocate 在本地系统上搜索文件 whereis 显示实用程序、源代码或 man 页的完整路径名 which 显示可运行命令的完整路径名 显示系统和用户信息的程序 命令 解释 finger 显示用户的详细信息，包括全名 free 显示内存使用信息 hostname 显示本地系统名 uptime 显示系统负载和运行信息 w 显示登录本地系统的用户的详细信息 who 显示登录本地系统的用户的信息 用户通信程序 命令 解释 mesg 接受或拒绝 write 发送的消息 write 给登录的用户发送消息 其他程序 命令 解释 date 显示当前日期和时间 echo 复制自身参数并在屏幕上显示]]></content>
      <categories>
        <category>泛 - 计算机</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2956 Repeatless Numbers（枚举）]]></title>
    <url>%2F2018%2F01%2F13%2Fpoj-2956-repeatless-numbers%2F</url>
    <content type="text"><![CDATA[题目链接：http://poj.org/problem?id=2956 Repeatless NumbersTime Limit: 1000MS Memory Limit: 65536K DescriptionA repeatless number is a positive integer containing no repeated digits. For instance, the first 25 repeatless numbers are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, 27, … Given an integer _n_, your goal is to compute the _n_th repeatless number. InputThe input test file will contain multiple test cases, each consisting of a single line containing the integer _n_, where 1 ≤ _n_ ≤ 1000000. The end-of-file is marked by a test case with _n_ = 0 and should not be processed. OutputFor each input case, the program should print the _n_th repeatless number on a single line. Sample Input25100000 Sample Output2726057 题解题目大意每位的数字都不相同的数字为Repeatless Number，输入一个数n输出第n个这种数字的值。 解题分析可以考虑一个一个数字去尝试看它是不是Repeatless Numbers，遇到第n个就输出并跳出循环。然而这样会超时。我们考虑用DFS枚举数字的每位打表实现。 解题思路从小到大枚举每一位，前面可用0占位，先进行打表，读入每个n直接输出表中第n项。具体的实现见代码，有详细注释。 代码Ubuntu Pastebin : https://paste.ubuntu.com/26527896/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//POJ 2956 Repeatless Numbers（枚举）//2018-01-13#include &lt;iostream&gt;#define max 10000000 //打表的范围using namespace std;int a[max+10]; //第n个数字保存在a[n]中bool digitMap[10]; //10个数字是否可用int n = 0; //从0开始遍历void dfs(int nowNum,int digit,int flag) //参数表中 nowNum数字的值 nowNum枚举到第几位了，0是否可以占位使用&#123; //如果flag为1位0不能占位使用 0时反之 if(n &gt; max)&#123; //如果n大于最大值就不要继续打表了 跳出函数 return; &#125; if(digit == 8)&#123; //当位数等于8时找到一个8位（因为我们要打表到max，max为8位）的没有重复位的数 a[n++] = nowNum; //nowNum为第n个符合要求的数字 return; &#125; for( int i = 0; i &lt; 10; i++)&#123; //遍历0-9十个数字在当前位上的情况 if(i == 0 &amp;&amp; flag == 0)&#123; //如果该位为0且0可以继续站位使用 dfs(0,digit+1,0); &#125;else&#123; if(digitMap[i])&#123; //如果这数还没被用过 digitMap[i] = false; //标记它为用了 dfs(nowNum*10+i,digit+1,1); //递归解决后面的位 digitMap[i] = true; //把该数字标记为没用过 继续遍历 （回溯法） &#125; &#125; &#125;&#125;int main()&#123; for( int i = 0; i &lt; 10; i++)&#123; digitMap[i] = true; //将10个数字都标记为可用 &#125; dfs(0,0,0); //从0开始遍历 while(true)&#123; int m; cin &gt;&gt; m; if(m == 0)&#123; //如果输入数据为0 退出 break; &#125; cout &lt;&lt; a[m] &lt;&lt; endl; //输出表中的值 &#125; return 0;&#125; 一点思考我认为此题可用dp不用递归的解决，我准备之后尝试一下，之后也会在本篇文章中继续更新。 参考资料 http://blog.sina.com.cn/s/blog_738dc7850101mmd8.html http://blog.csdn.net/u011686226/article/details/14497975]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>DFS</tag>
        <tag>POJ</tag>
        <tag>枚举法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1 Two Sum]]></title>
    <url>%2F2018%2F01%2F13%2Fleetcode-1-two-sum%2F</url>
    <content type="text"><![CDATA[题目链接：https://leetcode.com/problems/two-sum/description/ Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 题解题目大意给出一个整数数组，和一个整数，数组中存在两个数的和等于那个给定的整数，以一个两单元数组的形式返回那两个数在数组中的下标。 解题分析此题很简单，只需要用二重循环枚举所有的和的情况就可以实现。 代码Ubuntu Pastebin : https://paste.ubuntu.com/26527959/123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;a(2); cout &lt;&lt; nums.size(); bool find = true; for( int i = 0; i &lt; nums.size()&amp;&amp;find; i++)&#123; for( int j = 0; j &lt; nums.size()&amp;&amp;find; j++)&#123; if(i == j)&#123; continue; &#125; if(nums[i]+nums[j] == target)&#123; a[0] = j; a[1] = i; find = false; &#125; &#125; &#125; return a; &#125;&#125;; 优化此题如果以简单枚举的方式实现我们很容易得出它的时间复杂度为O(n^2)。当然我们有更好的实现，可以把时间复杂度降到O(n)。把元素存到一个hash_map中，单重循环遍历（target-每个元素）是否在hash_map中存在，如果存在则返回它们的下标。hash_map.find()是时间复杂度为O(1)乘上数组的遍历时间复杂度为O(n)。这样优化可以把运行时间从319 ms降到6 ms。 优化后的代码Ubuntu Pastebin : https://paste.ubuntu.com/26527963/123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; result; for (int i = 0; i &lt; numbers.size(); i++) &#123; int numberToFind = target - numbers[i]; if (hash.find(numberToFind) != hash.end()) &#123; result.push_back(hash[numberToFind] ); result.push_back(i ); return result; &#125; hash[numbers[i]] = i; &#125; return result; &#125;&#125;; 参考资料： 《LEETCODE 50 COMMON INTERVIEW QUESTIONS》hash_map.find()介绍：http://www.cplusplus.com/reference/unordered_map/unordered_map/find/ hash_map与map的性能分析：http://blog.csdn.net/blues1021/article/details/45054159]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>优化</tag>
        <tag>LeetCode</tag>
        <tag>hash_map</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1753 Flip Game（DFS枚举）]]></title>
    <url>%2F2018%2F01%2F13%2Fpoj-1753-flip-game%2F</url>
    <content type="text"><![CDATA[题目链接http://poj.org/problem?id=1753 Flip GameTime Limit: 1000MS Memory Limit: 65536K DescriptionFlip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules: Choose any one of the 16 pieces. Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any). Consider the following position as an example: bwbw wwww bbwb bwwb Here “b” denotes pieces lying their black side up and “w” denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become: bwbw bwww wwwb wwwb The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal. InputThe input consists of 4 lines with 4 characters “w” or “b” each that denote game field position. OutputWrite to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it’s impossible to achieve the goal, then write the word “Impossible” (without quotes). Sample Inputbwwbbbwbbwwbbwww Sample Output4 题解题目大意有4*4的棋盘，每个棋子有黑白两种颜色，当把一个棋子的颜色反转(黑-&gt;白或者白-&gt;黑)时，其周围上下左右(如果存在的话)的棋子的颜色也被反转，问至少翻转几次棋子可以将棋盘上的棋子变为同一种颜色。 解题分析 一个棋子第二次被翻转会抵消第一次翻转一个棋子的效果，一个棋子多次翻转是无意义的，每个棋子只有翻转和不翻转两种情况。 棋子被翻转的先后顺序对结果无影响。 解题思路棋盘上一共有16个棋子，我们最多只能翻转16次棋子，我们可以考虑枚举翻转的次数，之后在给定翻转次数的情况下枚举被翻转的棋子。 此题从枚举思路与XUJCOJ 16级线上比赛（2017/03/05）4:老徐追妹纸v2 的思路基本一致，可以当做额外练习。题目链接：http://www.xujcoj.org/Home/Contest/problem/cid/63/match_id/4/ctype/0 代码Ubuntu Pastebin : https://paste.ubuntu.com/26527872/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//POJ 1753 Flip Game（DFS枚举）//2018-01-12#include &lt;iostream&gt;using namespace std;bool a[4][4]; //棋盘数组bool ok = false; //是否找到方案int step; //当前要枚举的翻转次数bool isComplete() //检查是否全为同色&#123; bool re = true; for( int i = 0; i &lt; 4 &amp;&amp; re; i++)&#123; for( int j = 0; j &lt; 4 &amp;&amp; re; j++)&#123; if(a[i][j] != a[0][0])&#123; re = false; &#125; &#125; &#125; return re;&#125;void filp(int x,int y) //翻转一个棋子&#123; a[x][y] = !a[x][y]; //翻转它本身 if(x &gt; 0)&#123; //左边的棋子如果存在则翻转它 a[x-1][y] = !a[x-1][y]; &#125; if(x &lt; 3)&#123; //右边 a[x+1][y] = !a[x+1][y]; &#125; if(y &gt; 0)&#123; //上边 a[x][y-1] = !a[x][y-1]; &#125; if(y &lt; 3)&#123; //下边 a[x][y+1] = !a[x][y+1]; &#125;&#125;void dfs(int x,int y,int nowStep)//当前枚举到的棋子的坐标 nowStep为已经翻转了多少棋子&#123; if(nowStep == step)&#123; //如果翻转棋子的次数达到当前要枚举的翻转次数 ok = isComplete(); //棋盘是否同色 return; &#125; if(y == 4 || ok)&#123; //如果棋盘被遍历完或者已找到方案就退出函数 return; &#125; //以下是一个用递归代替n层循环的思路 filp(x,y); //如果翻转当前棋子 if(x &lt; 3)&#123; //遍历其他棋子 从左到右从上到下 dfs(x+1,y,nowStep+1); &#125;else&#123; dfs(0,y+1,nowStep+1); &#125; filp(x,y); //如果不翻转当前棋子 再翻转一次当前棋子抵消上次翻转的效果继续枚举 if(x &lt; 3)&#123; dfs(x+1,y,nowStep); &#125;else&#123; dfs(0,y+1,nowStep); &#125;&#125;int main()&#123; for( int i = 0; i &lt; 4; i++)&#123; for( int j = 0; j &lt; 4; j++)&#123; char temp; cin &gt;&gt; temp; if(temp == 'b')&#123; a[i][j] = true; &#125;else &#123; a[i][j] = false; &#125; &#125; &#125; //以上为输入阶段 黑色在数组中为true白色为false int i; for( i = 0; i &lt;= 16; i++)&#123; step = i; dfs(0,0,0); //从左上角的棋子开始枚举 if(ok)&#123; //如果找到一种方案 break; &#125; &#125; if(i &lt;= 16)&#123; //如果i小于等于16说明找到一种方案 输出步数即可 cout &lt;&lt; i; &#125;else&#123; //如果没有找到输出"Impossible" cout &lt;&lt; "Impossible"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题解</tag>
        <tag>DFS</tag>
        <tag>POJ</tag>
        <tag>枚举法</tag>
      </tags>
  </entry>
</search>
