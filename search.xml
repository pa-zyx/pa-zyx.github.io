<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€Oracle Database æœŸæœ«è€ƒç¬”è®°]]></title>
    <url>%2F2019%2F12%2F12%2Foracle_endterm_notes%2F</url>
    <content type="text"><![CDATA[å¼‚å¸¸123456789BEGIN...EXCEPTION WHEN ZERO_DIVIDE THEN DBMS_OUTPUT.PUT_LINE(&apos;DIvision by zero&apos;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&apos;An exception occurred&apos;);END;/ OTHERS å¼‚å¸¸å¯å¤„ç†æ‰€æœ‰å¼‚å¸¸ï¼Œä½†å¿…é¡»åœ¨ EXCEPTION å—ä¸­æ‰€æœ‰ç‰¹å®šå¼‚å¸¸ä¹‹åã€‚é‡åˆ°å¼‚å¸¸åæ‰§è¡Œå®Œå¼‚å¸¸å¤„ç†ä»£ç åï¼Œç¨‹åºä¼šé€€å‡ºæ­¤ä»£ç å—ã€‚ è¿‡ç¨‹123456create or replace procedure helloasbegin dbms_output.put_line(&apos;Hello World!&apos;);end;/ 12345678910create or replace procedure hello(v_employee_id in employees.employee_id%type)as v_salary employees.salary%type;begin select salary into v_salary from employees where employee_id=v_employee_id; dbms_output.put_line(v_salary);end;/ å‚æ•°æ¨¡å¼ IN: å‚æ•°é»˜è®¤æ¨¡å¼ï¼Œè¿‡ç¨‹ä½“ä¸­ä¸èƒ½æ”¹å˜ IN å‚æ•°çš„å€¼ OUT: åªåœ¨è¿‡ç¨‹ä½“å†…éƒ¨èµ‹å€¼ï¼Œå¿½ç•¥ä¼ å…¥å€¼ï¼Œå¿…é¡»ä¸ºå˜é‡ IN OUT: åœ¨è¿‡ç¨‹ä½“å†…éƒ¨èµ‹å€¼ï¼Œä¿ç•™ä¼ å…¥å€¼ï¼Œå¯ä»¥ä¿®æ”¹ï¼Œå¿…é¡»ä¸ºå˜é‡ æ‰§è¡Œè¿‡ç¨‹1234567891011SQL&gt; exec procedure_nameSQL&gt; exec procedure_name(v_name)SQL&gt; exec procedure_name(:v_name) --å¤–éƒ¨å˜é‡begin...procedure_name;procedure_name(v_name);...end;/ å®šä¹‰å¤–éƒ¨å˜é‡12SQL&gt; variable v_name v_typeSQL&gt; print v_name åˆ é™¤è¿‡ç¨‹1DROP PROCEDURE procedure_name; å‡½æ•°12345678910create or replace function circle_area(p_radius number)return numberas v_pi number := 3.1416; v_area number;begin v_area := v_pi * power(p_radius,2); return v_area;end circle_area;/ åˆ é™¤å‡½æ•°1DROP FUNCTION function_name; è§¦å‘å™¨åœ¨ DML è¯­å¥ä¹‹å‰æˆ–ä¹‹åè¢«æ¿€æ´»ã€‚ è¯­å¥çº§è§¦å‘å™¨ï¼šå¯¹äºæ•´æ¡è¯­å¥åªæ‰§è¡Œä¸€æ¬¡è§¦å‘å™¨è¿‡ç¨‹ã€‚ è¡Œçº§è§¦å‘å™¨ï¼šå¯¹äºæ¯è¡Œçš„æ“ä½œå„æ‰§è¡Œä¸€æ¬¡è§¦å‘å™¨è¿‡ç¨‹ã€‚ 123456789101112CREATE [OR REPLACE] TRIGGER trigger_name&#123;BEFORE | AFTER | INSTEAD OF | FOR&#125; trigger_even-- ä¹‹å‰ã€ä¹‹åã€ä»£æ›¿ã€11gå¤åˆè§¦å‘å™¨ON table_name[FOR EACH ROW] -- è¡Œçº§è§¦å‘å™¨[&#123;FORWARD | REVERSE&#125; CROSSEDITION] -- 11g[&#123;FORWARD | REVERSE&#125; schema.other_trigger] -- 11g[&#123;ENABLE | DISABLE&#125;] -- 11g[WHEN tigger_condition]BEGIN trigger_bodyEND tigger_name; trigger_even UPDATE INSERT DELETE UPDATE OF col_name DELETE OR INSERT OR UPDATE OF col_name old &amp; new DML OLD NEW INSRET NULL insert value UPDATE value before update value after update DELETE value before delete NULL trigger_body å†…ä½¿ç”¨ old æˆ– new æ—¶ï¼Œéœ€åŠ  : ä½¿ç”¨å¤–éƒ¨å˜é‡ï¼Œ:oldã€ :newã€‚ ç¦ç”¨å’Œå¯ç”¨è§¦å‘å™¨12ALTER TRIGGER trigger_name DISABLE;ALTER TRIGGER trigger_name ENABLE; åˆ é™¤è§¦å‘å™¨1DROP TRIGGER trigger_name;]]></content>
      <categories>
        <category>è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>å¼‚å¸¸</tag>
        <tag>Oracle</tag>
        <tag>æ•°æ®åº“</tag>
        <tag>SQL</tag>
        <tag>PL/SQL</tag>
        <tag>è§¦å‘å™¨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€æ¦‚ç‡è®ºä¸æ•°ç†ç»Ÿè®¡â€”â€”æ•°å­—ç‰¹å¾]]></title>
    <url>%2F2019%2F12%2F08%2Fprobability_num_chara_notes%2F</url>
    <content type="text"><![CDATA[éšæœºå˜é‡çš„æ•°å­—ç‰¹å¾æœŸæœ›å®šä¹‰$$\begin{align}&amp; x \sim p_i \implies EX = \sum_i x_i P_i\\&amp; x \sim f(x) \implies EX = \int_{-\infty}^{+\infty} xf(x)\, \mathrm{d}x \\\\&amp; x \sim p_i , Y = g(x) \implies EY = \sum_i g(x_i) P_i \\&amp; x \sim f(x) , Y = g(x) \implies EY = \int_{-\infty}^{+\infty} g(x)f(x)\, \mathrm{d}x\\\end{align}$$ æ€§è´¨$$E \left(\sum_{i=1}^n a_i X_i\right) = \sum_{i=1}^n a_i E X_i \\Ec = c \; , \; E(EX) = EX \\E(aX+c) = aEX + c \; , \; E(X \pm Y) = EX \pm EY$$ è‹¥ $X,Y$ ç‹¬ç«‹$$EXY = EX \cdot EY$$ æ–¹å·®å®šä¹‰$$Dx = E\left[\left(X-EX\right)^2\right] = E(X^2) - (EX)^2 \\\Downarrow \\E(X^2) = (EX)^2 + DX \\\Downarrow \\E(X^2) \geq (EX)^2$$ æ€§è´¨$$Dc = 0 \; , \; D(aX + b) = a^2 DX \\D(X \pm Y) = DX + DY \pm 2Cov(X,Y) \\$$ $$\begin{cases}&amp; D(X \pm Y) = DX + DY \pm 2Cov(X,Y)\\&amp; D\left(\sum_{i=1}^n X_i\right) = \sum_{i=1}^n DX_i + 2\sum_{i=1}^n \sum_{j=1}^n cov(X_i,Y_i)\end{cases}$$ è‹¥ $X,Y$ ç‹¬ç«‹$$D(aX+bY) = a^2 DX + b^2 DY$$ åæ–¹å·®å®šä¹‰$$Cov(X,Y) = E\left[(X-EX)(Y-EY)\right] = E(XY) - EX \cdot EY$$ $$E(XY) =\begin{cases}&amp; \sum_i \sum_j x_i y_j P{X = x_i,Y = y_i} \;{(ç¦»æ•£)} \\&amp; \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xyf(x,y) \mathrm{d}x \mathrm{d}y \;{(è¿ç»­)}\end{cases}$$ ç›¸å…³ç³»æ•°$$\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{DX}\sqrt{DY}} \; , \; |\rho_{XY}| \leq 1$$ æ€§è´¨$$Cov(X,X) = DX \; , \; \rho_{XX} = 1 \\Cov(X,Y) = Cov(Y,X) \\Cov(X,c) = 0 \; , \; Cov(aX+b,Y) = aCov(X,Y)\\Cov(X_1 + X_2,Y) = Cov(X_1,Y) + Cov(X_2,Y)$$ è‹¥ $Y = aX+b$ï¼Œåˆ™$$\rho_{XY} =\begin{cases}1 &amp; \quad a &gt; 0\\-1 &amp; \quad a &lt; 0\end{cases}$$ å¸¸ç”¨åˆ†å¸ƒçš„æœŸæœ›å’Œæ–¹å·®åˆ—è¡¨ åˆ†å¸ƒ åˆ†å¸ƒåˆ— $p_k$ æˆ–æ¦‚ç‡å¯†åº¦ $f(x)$ $0 - 1$ åˆ†å¸ƒ $B(1,p)$ $P\{X=k\}=p^k(1-p)^{1-k},k=0,1$ äºŒé¡¹åˆ†å¸ƒ $B(n,p)$ $P\{X=k\} = C^k_n p^k(1-p)^{n-k},k=0,1,\dots,n$ æ³Šæ¾åˆ†å¸ƒ $P(\lambda)$ $P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda},k=0,1,\dots$ å‡ ä½•åˆ†å¸ƒ $G(p)$ $P\{X=k\} = (1-p)^{k-1}p,k=1,2,\cdots$ æ­£æ€åˆ†å¸ƒ $N(\mu,\sigma^2)$ $f(x) = \frac{1}{\sqrt{2\pi}\sigma}exp\left\{-\frac{(x-\mu)^2}{2\sigma^2}\right\} , -\infty &lt; x &lt; +\infty$ å‡åŒ€åˆ†å¸ƒ $U(a,b)$ $f(x) = \frac{1}{b-a},a &lt; x &lt; b$ æŒ‡æ•°åˆ†å¸ƒ $E(\lambda)$ $f(x) = \lambda e^{-\lambda x},x&gt;0$ åˆ†å¸ƒ æœŸæœ› æ–¹å·® $0 - 1$ åˆ†å¸ƒ $B(1,p)$ $p$ $p(1-p)$ äºŒé¡¹åˆ†å¸ƒ $B(n,p)$ $np$ $np(1-p)$ æ³Šæ¾åˆ†å¸ƒ $P(\lambda)$ $\lambda$ $\lambda$ å‡ ä½•åˆ†å¸ƒ $G(p)$ $\frac{1}{p}$ $\frac{1-p}{p^2}$ æ­£æ€åˆ†å¸ƒ $N(\mu,\sigma^2)$ $\mu$ $\sigma^2$ å‡åŒ€åˆ†å¸ƒ $U(a,b)$ $\frac{a+b}{2}$ $\frac{(b-a)^2}{12}$ æŒ‡æ•°åˆ†å¸ƒ $E(\lambda)$ $\frac{1}{\lambda}$ $\frac{1}{\lambda^2}$]]></content>
      <categories>
        <category>æ•°å­¦</category>
      </categories>
      <tags>
        <tag>æœŸæœ›</tag>
        <tag>æ–¹å·®</tag>
        <tag>åæ–¹å·®</tag>
        <tag>æ¦‚ç‡è®º</tag>
        <tag>æ•°å­—ç‰¹å¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŒæœèŠ±å¤•æ‹¾ã€0x04 é‡å¯]]></title>
    <url>%2F2019%2F12%2F07%2Fdiary_4%2F</url>
    <content type="text"><![CDATA[åœ¨ 19 å¹´çš„æœ€åä¸€ä¸ªæœˆï¼Œæˆ‘åˆæ‹¾èµ·äº†æˆ‘å³å°†è’åºŸçš„åšå®¢ã€‚ä¸Šä¸€ç¯‡éšç¬”ç«Ÿç„¶æ˜¯ä¸€å¹´å‰ï¼Œæ—¶é—´è¿‡å¾—å®åœ¨å¤ªå¿«ï¼Œèº«è¾¹çš„åŒå­¦ä¹Ÿéƒ½åœ¨æ„Ÿå¹æ—¶é—´é£é€ã€‚ æœ€è¿‘äººå·¥é™é›¨ï¼Œæ°”æ¸©æœ‰ç‚¹å‡‰ï¼Œå¾ˆéš¾é¡¶ã€‚ä¹Ÿè®¸æ˜¯æ°”æ¸©çš„ç¼˜æ•…æˆ‘é¥­é‡å¤§å¢ï¼Œä¼™é£Ÿè´¹éƒ½ä¸å¤ªå¤Ÿäº†ã€‚ä¹Ÿæ€ªåƒå¾—å¤ªé¥±çƒ­é‡è¿‡å‰©ï¼Œèµ¶ä¸Šåä¸º251ï¼Œæˆ‘çœŸæ­£æˆä¸ºäº†åä¸ºé»‘ç²‰ï¼Œå–åŠ›çš„åšäº†ä¸¤å¤©é»‘å…¬å…³ã€‚ æˆ‘æƒ³è®°å½•ä¸€ä¸‹æˆ‘çš„æ€è€ƒè¿‡ç¨‹å’Œä»åä¸ºçš„é—®é¢˜ä¸­æˆ‘å¸å–çš„æ•™è®­ã€‚ æˆ‘å‘ç°åœ¨æˆ‘æ€è€ƒè¿‡ç¨‹ä¸­ï¼Œæˆ‘æ€»ä¼šåˆ›é€ å¦ä¸€ä¸ªè´¨é—®æˆ‘çš„æˆ‘ï¼Œå®ƒçš„è´¨é—®æ€»ä¼šä»¥ä¸¤ä¸ªé—®é¢˜å¼€å§‹ï¼šä¸€æ˜¯ï¼Œæˆ‘ä¸€å®šæ˜¯å¯¹çš„å—ï¼ŸäºŒæ˜¯ï¼Œå¯¹æ–¹ä¸€å®šæ˜¯é”™çš„å—ï¼Ÿè¿™æ ·çš„è´¨é—®çš„ç­”æ¡ˆå¿…å°†æ˜¯ä¸¤ä¸ªå¦å®šçš„ç»“æœã€‚å¯¹äºæ¯ä¸ªé—®é¢˜ï¼ŒåŸºæœ¬éƒ½æœ‰å¾ˆå¤šè‡ªå·±å¯¹è‡ªå·±çš„è´¨é—®ï¼Œæƒ³ç€æƒ³ç€å°±ç´¯äº†ï¼Œæ€è€ƒçš„è¿‡ç¨‹åˆè¿‡é•¿ï¼Œä¸€æ®µæ–‡å­—å¾ˆéš¾è¡¨è¾¾ï¼Œè€Œä¸”è§‚ç‚¹è¶‹äºä¸­ç«‹æ²¡ä»€ä¹ˆåŠ²ï¼Œè¿™å°±å¯¼è‡´æˆ‘å¾ˆé•¿ä¸€æ®µæ—¶é—´å¾ˆå°‘åœ¨ç¤¾äº¤åª’ä½“å‘å£°ã€‚æˆ‘ä¸çŸ¥é“è¿™æ˜¯å¥½æ˜¯åï¼Œæˆ‘åªçŸ¥é“ä»å‰æˆ‘ä¸æ˜¯è¿™æ ·ï¼Œåæ­£ä¸è¯´æœ‰ä¸è¯´çš„å¥½å¤„ï¼Œå°±æ˜¯ä¸å¤ªä¼šæ¿€åŠ¨ï¼Œäººåœ¨è¡¨è¾¾è‡ªå·±è§‚ç‚¹æ—¶éƒ½æ˜¯æ¿€åŠ¨çš„ã€‚ ä»¥ä¸‹åŒ…å«æˆ‘å¯¹åä¸ºçš„é—®é¢˜çš„æ€è€ƒå’Œç†è§£ï¼Œä½œä¸ºé»é»‘ç²‰ï¼Œè¨€è®ºå¯èƒ½å¼•èµ·åä¸ºæ”¯æŒè€…çš„ç”Ÿç†ååº”ï¼Œå¿«è·‘ï¼ è¯´èµ·åä¸ºï¼Œæ—©å¹´æˆ‘ä¹°è¿‡ä¸€äº›å®ƒçš„é…ä»¶ï¼Œä¸­è§„ä¸­çŸ©ï¼Œå®¶é‡Œäººé€æ¸è½¬å‘è‹¹æœï¼Œåä¸ºçš„äº§å“æˆ‘ç¡®å®äº†è§£ç”šå°‘ã€‚è¿‘å‡ å¹´åä¸ºå¥½åƒèµ·æ¥äº†ï¼Œæ”¯æŒè€…è¶Šæ¥è¶Šå¤šã€‚å®˜æ–¹åª’ä½“ä¹Ÿå¤šæ¬¡ä¸ºåä¸ºå‘å£°ï¼Œæ–°é—»ä¸­ä¹Ÿèƒ½æ„Ÿå—åˆ°åä¸ºå’Œç¥–å›½å¯†åˆ‡çš„è”ç³»ã€‚è¿™ç§è”ç³»å¥½åƒä¸åŒäºå°ç±³ç­‰å…¶ä»–æ°‘è¥ä¼ä¸šï¼Œæœ‰ç§åƒå›½å®¶ç”µç½‘é‚£æ ·çš„é¾™å¤´å›½ä¼çš„å‘³é“ï¼Œç”šè‡³æ›´å¤¸å¼ ã€‚ï¼ˆåä¸ºå’Œç¥–å›½æ‰¯ä¸Šå…³ç³»ï¼Œæˆ‘ä¸ªäººè®¤ä¸ºä¸»è¦åŸå› è¿˜æ˜¯åœ¨ä½™æŸæˆ–è€…æ•´ä¸ªä¼ä¸šå®£ä¼ è¿‡ç¨‹ä¸­ï¼Œå¤šæ¬¡å‘è¡¨åä¸ºè¢«è¿«å®³çš„è¨€è®ºï¼Œå¼•èµ·æ”¯æŒè€…å¯¹æ•Œæ–¹çš„æ”»åŠ¿ï¼Œåœ¨ä¹¦æœ¬ä¸Šçš„æ•…äº‹ä¸­äººä»¬å¤šæ•°æƒ…å†µåªä¸ºå›½å®¶æ°‘æ—è€Œæˆ˜ï¼Œæˆ‘è®¤ä¸ºè¿™å…¶å®ä¹Ÿç®—æ˜¯ä¸€ç§æš—ç¤ºã€‚ï¼‰ è¿™ä¸¤å¹´ä¹Ÿå¬è¯´è¿‡ä¸å°‘å…³äºåä¸ºçš„é»‘æ–™ï¼Œè‡ªå·±ä¸ç”¨ä¹Ÿä¸å¤ªå…³å¿ƒï¼Œè€Œä¸”æˆ‘æ€»æ„Ÿè§‰å®ƒçš„æ”¯æŒè€…å¤ªå¤šï¼Œæˆ‘æƒ³è¯´ä¸¤å¥æ—¶ï¼Œå°±æƒ³åˆ°ç¬¬äºŒæ¡è´¨é—®ï¼Œé‚£ä¹ˆå¤šæ”¯æŒè€…éƒ½æ˜¯é”™çš„å—ï¼Ÿä¹Ÿæ— æ³•ä¿è¯è‡ªå·±çš„æ­£ç¡®æ€§ï¼Œåªèƒ½æ†‹ç€ï¼ˆå…¶å®æˆ‘å¿ƒé‡Œæ€»æœ‰ä¸€å¥è¯åœ¨å›æƒ³ï¼Œåœ¨æŒ‘æˆ˜é‚£ä¸ªè´¨é—®ï¼Œé‚£å°±æ˜¯â€œè¿™ä¸ªä¸–ç•Œä¸Šç™¾åˆ†ä¹‹å…«åçš„äººéƒ½æ˜¯ç¬¨è›‹ã€‚â€ï¼Œæˆ‘è§‰å¾—è¿™å¥è¯æŒºå¯¹çš„ï¼Œæ¯æ¬¡æˆ‘åœ¨ä¸€ä¸ªé¢†åŸŸä½“ä¼šåˆ°ç¬¨è›‹æ•°é‡åºå¤§ä¹‹åæˆ‘å°±å¿«æˆäº†ï¼‰ã€‚ åœ¨æ†‹äº†å¾ˆå¤šè„è¯åï¼Œ251 è¢«æ›å…‰ï¼Œæˆ‘ç…å‡†æœºä¼šä¸€é€šæ“ä½œï¼Œåœ¨ç¤¾äº¤åª’ä½“å‘äº†ä¸€äº›é»‘åä¸ºçš„è¨€è®ºï¼ˆé»‘å…¶å®ä¹Ÿå°±æ˜¯æŠŠåä¸ºåšçš„äº‹æƒ…è®²ä¸€éï¼‰ï¼Œè¿˜è·Ÿèº«è¾¹åŒå­¦è®²äº†è®²æ•…äº‹ï¼ŒæœŸé—´ä¹Ÿéª‚è„è¯ï¼ŒæŠŠç–‘ä¼¼èŠ±ç²‰åŒå­¦çš„å¾®åšæ‹‰é»‘äº†ã€‚è¶Šæ¥è¶Šæ¿€åŠ¨ï¼Œä¹Ÿè®¸æ˜¯å‹æŠ‘äº†å¾ˆä¹…ã€‚èµ·åˆæˆ‘æ¿€åŠ¨çš„åŸå› æ˜¯åä¸ºçš„æ¶å¿ƒçš„äº‹ï¼Œåæ¥æ…¢æ…¢å°±è½¬å‘å¯¹ç¬¨è›‹çš„æ°”æ„¤ï¼Œæ€ä¹ˆè¿˜ä¼šæœ‰å¾ˆå¤šç¬¨è›‹æ´—åä¸ºï¼Ÿæˆ‘å¼€å§‹è¿›è¡Œä½çƒˆåº¦çš„äººèº«æ”»å‡»ï¼Œè´¨ç–‘å®ƒä»¬è„‘å­çš„å¯ç”¨æ€§ã€‚é‚£å¯çœŸæ˜¯è¿‡ç˜¾å“Ÿï¼Œå®Œå…¨ä¸ç”¨æ€è€ƒï¼Œæ— è„‘é»‘ï¼Œç›´æ¥æ€¼ï¼Œå‘æ³„äº†ä¸€é€šã€‚ä½†å¾ˆå¿«æˆ‘å†³å®šç¦æ­¢è‡ªå·±åœ¨ç¤¾äº¤åª’ä½“å†å‘ä¹±ä¸ƒå…«ç³Ÿå…³äºåä¸ºçš„ä¸œè¥¿ï¼Œæˆ‘éœ€è¦å†·é™ã€‚ å†·é™åï¼Œæ¥ä¸‹æ¥æ˜¯æˆ˜æœ¯æ€»ç»“ï¼š åä¸ºä¸ºä»€ä¹ˆæŠ¥æ¡ˆæ—¶å¤šæ¬¡å˜æ›´æçš„ç½ªåï¼Ÿ å¦‚æœæ²¡æœ‰ææ¸…æ¥šå°±æŒ‡æ§å‘˜å·¥æœ‰è´Ÿè´£ä»»å—ï¼Ÿ åä¸ºæ˜¯å¦å­˜åœ¨éª—è¡¥è¡Œä¸ºï¼Ÿä¸ºä»€ä¹ˆä¸å…¬å¸ƒææ•²è¯ˆå‹’ç´¢åä¸ºçš„èµ„æ–™ï¼Ÿï¼ˆå¦‚æœåä¸ºæ˜¯æ¸…ç™½çš„ï¼‰ åä¸ºä¸æ˜¯ä¸€æ¬¡ä¸¤æ¬¡äº†ï¼Œ60å¤©çš„å¦ä¸€å‘˜å·¥ï¼Œç›´æ¥ä»æ³°å›½é£è¿”ï¼Œæœ€ç»ˆæ£€å¯Ÿé™¢ä¸èµ·è¯‰ã€‚ åä¸ºä¸¾æŠ¥åª’ä½“æ›å…‰å…¶äº§å“è´¨é‡é—®é¢˜ä¸ºè°£è¨€ï¼Œé¾™å²—åˆ†å±€è·¨çœå…µåˆ†å…­è·¯æŠ“æ•ç›¸å…³äººå‘˜ã€‚ è¯´åˆ°åº•æˆ‘è´¨é—®çš„æ˜¯åä¸ºæ˜¯å¦æ»¥ç”¨å…¬æƒåŠ›ã€‚ æˆ‘ä¸ºä»€ä¹ˆè¦å–åŠ›çš„é»‘åä¸ºï¼Ÿå¦‚æœè¿™ä»¶äº‹æ˜¯å…¶ä»–ä¼ä¸šåšçš„ï¼Œæˆ‘ç»ä¸ä¼šè¿™æ ·æ¿€åŠ¨ï¼Œç”šè‡³ä¼šé€‰æ‹©åŸè°…ã€‚åŸå› æ˜¯æˆ‘è®¤ä¸ºåä¸ºæ˜¯ä¸ªä¸¤é¢ä¼ä¸šï¼Œè¡¨é¢æ ‘ç«‹æ°‘æ—ä¼ä¸šçš„å½¢è±¡ï¼Œåˆ©ç”¨å¤§å®¶çš„å¯¹ç¥–å›½çš„æ„Ÿæƒ…å‘å±•ä¼ä¸šã€‚å®åˆ™æ˜¯ä¸ªâ€å°äººâ€œï¼Œä¸å»ç»´æŠ¤å›½å®¶çš„æ³•åˆ¶ï¼Œä»»ä½•äº‹ä»¶ä»ä¸é“æ­‰ï¼Œåˆ©ç”¨æ³•å¾‹é€ƒé¿ä¹‰åŠ¡ã€‚å®åœ¨çœ‹ä¸æƒ¯â€œå°äººâ€å¾—å¿—ã€‚ æˆ‘æƒ³è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæœ‰é‚£ä¹ˆå¤šäººçªç„¶å‡ºæ¥æŠµåˆ¶åä¸ºçš„åŸå› ï¼Œåä¸ºåŸ¹å…»ä¸äººæ°‘çš„æ„Ÿæƒ…åˆ°å¤´æ¥è·Ÿäººæ°‘è®²æ³•å¾‹ã€‚è¿™å°±å¥½åƒä½ å…„å¼ŸèƒŒåè¯´ä½ åè¯è¯‹æ¯ä½ å»è®¨å¥½åˆ«äººï¼Œä½ è·Ÿä»–è®²æƒ…è°Šï¼Œä»–è¯´è€å­æ²¡è¿æ³•ã€‚è¿™è¿œæ¯”é™Œç”Ÿäººå·ä½ ä¸€å—é’±ï¼Œæ›´è®©äººç”Ÿæ°”ï¼Œå› ä¸ºåè€…ä½ ç›´æ¥æŠ¥è­¦å°±å¯ä»¥äº†ï¼Œå‰è€…ä½ ä¹Ÿåªèƒ½æ°”ç€ã€‚æ³¨æ„ï¼æˆ‘æ²¡è·Ÿåä¸ºæœ‰ä»€ä¹ˆç‹—å±æ„Ÿæƒ…ï¼Œæˆ‘åªæ˜¯å•çº¯çš„è®¨åŒåä¸ºæƒ…æ³•ä¸¤æ‰‹æŠ“çš„æ¶å¿ƒè¡Œä¸ºï¼Œæ‹¿åˆ°äº†æ‰€æœ‰åˆ©ç›Šï¼Œå´ä¸å±¥è¡Œä¹‰åŠ¡ã€‚å¦‚æœè‡ªå°æ°‘æ—ä¼ä¸šå°±åº”è¯¥æ‰¿æ‹…è´£ä»»å»ç»´æŠ¤æ³•åˆ¶ï¼Œ996è¿æ³•åŠ³åŠ¨æ³•å¯ä»¥åœä¸€ä¸‹ã€‚å¦‚æœä¸æƒ³åšæ°‘æ—ä¼ä¸šï¼Œåªæƒ³å¥½å¥½èµšé’±ï¼Œé‚£è¯·ä¸è¦å†è®©å…¬ä¸»å†™ç…½æƒ…æ–‡ç« åšå¾—äººæ°‘çš„åŒæƒ…ã€‚ å¤§ä¸‰äº†ï¼Œæ¥å­¦æ ¡ä¸¤å¹´å¤šäº†ï¼Œè§è¿‡è‡ªç§è‡ªåˆ©ä¸¤é¢çš„åŒå­¦ï¼Œä¹Ÿè§è¿‡åˆ©ç”¨ä»–äººè¾¾åˆ°è‡ªå·±ç›®çš„çš„åŒå­¦ã€‚æˆ‘ä¸äº†è§£è‡ªå·±å£ç¢‘å¦‚ä½•ï¼Œä½†æˆ‘çŸ¥é“ä»–ä»¬å¾—æ„çš„èƒŒåæ˜¯è¢«äººå”¾å¼ƒï¼ˆè‡³å°‘æ˜¯è¢«æˆ‘å”¾å¼ƒï¼‰ã€‚åšå¥½è‡ªå·±ï¼Œé ä¹±ä¸ƒå…«ç³Ÿæ‰‹æ®µå¾—åˆ°çš„ä¸œè¥¿è‚¯å®šæ˜¯è¦è¿˜çš„ã€‚ æœ€åï¼Œåšå®¢æ­£å¼å¼€å§‹å‘¨æ›´ï¼Œæ¯å‘¨å†™ç‚¹å„¿ï¼ŒæŒç»­è¾“å‡ºã€‚]]></content>
      <categories>
        <category>æ³› - è®°</category>
      </categories>
      <tags>
        <tag>è®°</tag>
        <tag>251</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŒæœèŠ±å¤•æ‹¾ã€å†™åœ¨19å¹´11æœˆ10æ—¥]]></title>
    <url>%2F2019%2F11%2F10%2Fend%2F</url>
    <content type="text"><![CDATA[æ¥ä¸‹æ¥ä½ ä»¬çœ‹åˆ°çš„æ„Ÿè¨€æ˜¯æˆ‘å†™è¿‡é«˜åº¦æœ€é«˜çš„æ„Ÿè¨€ï¼Œå› ä¸ºè¿™é‡Œçš„æ¯ä¸ªå­—éƒ½æ˜¯åœ¨å—æ˜Œé£å¾€å¦é—¨çš„ä¸€ä¸‡ä¸€åƒç±³é«˜ç©ºä¸Šä¿¯ç°ç€ç¥–å›½çš„å¤§å¥½æ²³å±±å†™ä¸‹çš„ã€‚æˆ‘è®°å¾—åœ¨ä¸€å¹´å¤šä»¥å‰çœèµ›å‡†å¤‡ç»„é˜Ÿæ—¶ï¼Œæˆ‘å°±è·Ÿé˜Ÿå‹è¯´æˆ‘æƒ³æ‹¿åˆ°äºšæ´²åŒºåŸŸèµ›çš„é“¶å¥–ã€‚å…¶å®å½“æ—¶æˆ‘å¿ƒé‡Œæƒ³çš„æ˜¯æ‹¿ä¸ªé“œå¥–å°±å¥½ï¼Œè¯´é“¶å¥–åªæ˜¯æƒ³è®©å¤§å®¶æŠŠç›®æ ‡å®šçš„é«˜ä¸€äº›ã€‚å› ä¸ºé‚£æ—¶å­¦é•¿ä»¬æœ€å¥½æˆç»©ä»…æ˜¯çœèµ›çš„é“œå¥–ï¼Œå„ç§æ¯”èµ›çš„è§„åˆ™å’ŒæŠ¥åå­¦æ ¡éƒ½æ²¡äººäº†è§£ã€‚å¹¸è¿çš„æ˜¯æˆ‘ä»¬åœ¨å½“å¹´å°±æ‹¿åˆ°äº†çœèµ›çš„é“œå¥–ï¼Œä¹Ÿæ˜¯å­¦æ ¡ç¬¬ä¸€æ”¯å¤§ä¸€å°±æ‹¿åˆ°çœèµ›é“œå¥–çš„é˜Ÿä¼ã€‚æ­£å› çœèµ›çš„æˆç»©å¸¦æ¥çš„è¿·ä¹‹è‡ªä¿¡ï¼Œæˆ‘åœ¨æš‘å‡æ‰¾åˆ°äº†ICPCçš„æ•™ç»ƒç¾¤ï¼Œé¡ºåˆ©çš„æŠ¥åäº†åŒ—äº¬ç«™å’Œé’å²›ç«™çš„ç½‘ç»œèµ›ã€‚é˜´é”™é˜³å·®çš„ä»¥å«åº•çš„æˆç»©æ‰“è¿›äº†é’å²›ç°åœºèµ›ï¼Œä¸å‡ºæ„å¤–çš„åœ¨ç°åœºèµ›å«åº•ï¼Œæ‹¿åˆ°äº†ç”Ÿæ¶¯ç¬¬ä¸€å—é“ç‰Œï¼Œä¸è¿‡ä¹Ÿè§è¯†äº†æ¸…åŒ—çš„å¤§ä½¬ä»¬ï¼Œè™½ç„¶é‚£åœºæ˜¯å—å¤§â˜•ï¸ğŸ”æ§çš„æ¯ï¼Œä»Šå¤©è¿™åœºè¿˜æ˜¯å®ƒä»¬æ§æ¯ï¼Œä¸å¾—ä¸è¯´å†å²æ€»æ˜¯æƒŠäººçš„ç›¸ä¼¼ã€‚æ‰“é“çš„ç»å†åœ¨å½“æ—¶å¯¹è‡ªå·±æ²¡æœ‰å¤ªå¤§æ‰“å‡»ï¼Œå› ä¸ºè‡ªå·±è¿˜å¹´è½»æ‰å¤§äºŒï¼Œæƒ³ç€æ˜å¹´ä¸€å®šå¯ä»¥æ‹¿åˆ°ç‰Œå­ã€‚é‚£æ¬¡æ‰“é“å›æ¥åï¼Œä¸€ä¸ªé˜Ÿå‹ä¹Ÿé€€å‡ºäº†ï¼Œå»å®éªŒå®¤åšé¡¹ç›®äº†ã€‚è¯´åˆ°è¿™é‡Œï¼Œè¿™ä¸¤å¹´çœ‹ç€åŒå­¦ä»¬éƒ½åœ¨è¿›æ­¥å„ç§æ¯”èµ›æ‹¿å¥–æ§æ¯å„ç§å¥–å­¦é‡‘åœ¨å®éªŒå®¤æˆ–è€…å„ç§é¡¹ç›®æ··çš„é£ç”Ÿæ°´èµ·ï¼Œè¿‡ç¨‹ä¸­æˆ‘æ²¡æœ‰ç¾¡æ…•ä»€ä¹ˆï¼Œä¹Ÿæ²¡æƒ³è¿‡å»åšé¡¹ç›®æˆ–è€…å»å®éªŒå®¤ï¼Œå› ä¸ºæˆ‘å°±æƒ³æ‹¿åˆ°é‚£å—åŒºåŸŸèµ›çš„é“œç‰Œã€‚å¤§äºŒä¸‹å­¦æœŸï¼Œå‚åŠ äº†CCPCçš„é‚€è¯·èµ›å’ŒICPCçš„é‚€è¯·èµ›éƒ½æ‹¿åˆ°äº†é“œå¥–ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡æ‹¿åˆ°å…¨å›½æ¯”èµ›çš„å¥–é¡¹ã€‚æœ€ä»¤äººå¼€å¿ƒçš„æ˜¯åœ¨çœèµ›ä¹Ÿæ‹¿åˆ°äº†é“¶å¥–ï¼Œæ‰“ç ´äº†å­¦æ ¡å¤šå¹´é“œå¥–çš„è®°å½•ã€‚æš‘å‡å¦å¤§çš„å‹å†›è¿˜é‚€è¯·æˆ‘ä»¬å’Œé›†å¤§ä¸€èµ·è¿‡å»è®­ç»ƒï¼Œåªåœ¨å®¶å¾…äº†åŠä¸ªæœˆå°±å›åˆ°å¦é—¨åˆ°å¦å¤§é›†è®­ï¼Œè¿™äº›ç»å†éƒ½è®©æˆ‘æ„Ÿè§‰ç¦»é‚£å—ç‰Œå­è¿‘äº†å¾ˆå¤šï¼Œä¸‹åŠå¹´æ‹¿å¥–åº”è¯¥æ˜¯å…«ä¹ä¸ç¦»åäº†ã€‚é—æ†¾çš„æ˜¯ä¸‹åŠå¹´æˆ‘ä»¬èµ„æºæ‹‰æ»¡ï¼Œæ‰“äº†å››åœºæ¯”èµ›å“ˆå°”æ»¨å¦é—¨å—äº¬å—æ˜Œï¼Œåªæœ‰å¦é—¨æ‹¿åˆ°äº†é“œå¥–ã€‚å—äº¬å—æ˜Œéƒ½æ˜¯åªå·®ä¸€ç‚¹ç‚¹ã€‚ä¸Šä¸ªæœˆæˆ‘çœ‹ç€å—äº¬éš”å£é˜Ÿçš„é“œç‰Œï¼Œæˆ‘åªæœ‰ä¸€ç§æ„Ÿè§‰ï¼Œæˆ‘ä¸æœï¼Œæˆ‘æ„Ÿè§‰æˆ‘é…å¾—ä¸Šé‚£å—ç‰Œå­ã€‚ä½†æœ€ç»ˆæˆ‘è¿˜æ˜¯æ²¡èƒ½æ‹¿åˆ°å®ƒã€‚æš‘å‡å¦å¤§é›†è®­å›æ¥åï¼Œæˆ‘å°±å†³å®šæ‰“å®Œä»Šå¹´çš„æ¯”èµ›å°±é€€å½¹äº†ã€‚å…¶å®è¿™æ˜¯æˆ‘æ—©æœ‰çš„æ‰“ç®—ï¼Œæ„Ÿè§‰è‡ªå·±å·²ç»æ²¡æœ‰å½“åˆçš„æ¿€æƒ…äº†ï¼Œæš‘å‡è¿‡ååŸºæœ¬å°±å†æ²¡åˆ·è¿‡ä»€ä¹ˆé¢˜ã€‚å’Œä¸´æ²‚å¤§å­¦çš„å‹å†›èŠå¤©æ—¶ï¼Œå‘ç°å¤§å®¶éƒ½ä¸€æ ·ï¼Œåœ¨æ¯”èµ›å‰éƒ½å¾ˆæµ®èºï¼Œæ‚£å¾—æ‚£å¤±æ— å¿ƒåˆ·é¢˜ï¼Œè®¡åˆ’ç€é€€å½¹åè¦åšçš„äº‹æƒ…ã€‚å¹¸è¿çš„æ˜¯è¿™ä¸¤å¹´ä¹Ÿå–å¾—äº†ä¸€äº›æˆç»©ï¼Œå¦‚æœè¯´ICPCï¼ˆIUPCï¼‰è¿˜ç®—ä¸ªä½“é¢çš„æ¯”èµ›ï¼Œæˆ‘ä¹Ÿç®—å‚èµ›é€‰æ‰‹ä¸­çš„è€å¹´äººè·Ÿå¤§å®¶è¿‡äº†ä¸¤æ‹›ï¼Œæ¿€æµå‹‡é€€ã€‚ä¹Ÿç®—æ˜¯ç»™è‡ªå·±ç•™äº†ç‚¹é¢œé¢ã€‚åœ¨æœ€åè·Ÿè¿™äº›æ¯”èµ›è¯´å†è§å‰ï¼Œæˆ‘æƒ³æ­£å¼å‡ºä¸€æ¬¡é¢˜ï¼ŒåŠä¸€æ¬¡æ¯”èµ›ã€‚ç»™åŒå­¦ä»¬ä¸€ä¸ªäº¤ä»£ï¼Œç»™å¤§å®¶è´¡çŒ®ä¸€äº›é¢˜ç›®ï¼Œçºªå¿µæˆ‘é€å»çš„é’æ˜¥ã€‚è¿™åœºæ¯”èµ›ä¹Ÿè®¸ä¼šåœ¨ä¸‹ä¸ªæœˆè·Ÿå¤§å®¶è§é¢ï¼Œå¸Œæœ›åŒå­¦ä»¬èƒ½å¤Ÿå–œæ¬¢ã€‚æˆ‘è¦å¼€å§‹è€ƒç ”å¤ä¹ äº†ï¼Œæ¢ä¸ªæ–¹å‘ç»§ç»­å‰è¿›ã€‚å¸Œæœ›èƒ½å¤Ÿä¸ºè®¡ç®—æœºç§‘å­¦è´¡çŒ®å‡ºè‡ªå·±çš„æ™ºæ…§ã€‚ç»§ç»­åŠªåŠ›ï¼Œä¸ºäº†å¿ƒä¸­çš„æ¢¦æƒ³ï¼]]></content>
      <categories>
        <category>æ³› - è®°</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
        <tag>å¿ƒå¾—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€Oracle Database æœŸä¸­è€ƒç¬”è®°]]></title>
    <url>%2F2019%2F11%2F06%2Foracle_midterm_notes%2F</url>
    <content type="text"><![CDATA[DDLå»ºè¡¨1234567891011121314CREATE TABLE staff ( PRIMARY KEY (staff_num), staff_num INTEGER DEFAULT 1 NOT NULL, first_name VARCHAR2(100) NOT NULL, leader_num INTEGER NOT NULL, CONSTRAINT staff_first_name_uq UNIQUE (first_name), CONSTRAINT staff_leader_num_ck CHECK(leader_num &gt;= 1 AND leader_num &lt; 100), CONSTRAINT staff_leader_fk FOREIGN KEY(first_name) REFERENCES staff2(first_name)); åªå¤åˆ¶è¡¨ç»“æ„1CREATE TABLE staff_temp like staff; å¤åˆ¶è¡¨ç»“æ„åŠæ•°æ®1CREATE TABLE staff_temp as select * from staff; åˆ è¡¨1DROP TABLE staff; ä¿®æ”¹è¡¨æ·»åŠ åˆ—12ALTER TABLE staffADD new_column_name INTEGER; åˆ é™¤åˆ—12ALTER TABLE staffDROP COLUMN drop_column_name; ä¿®æ”¹åˆ—12ALTER TABLE staffMODIFY modify_column_name INTEGER; æ·»åŠ çº¦æŸ1234567891011121314151617181920-- æ·»åŠ  CHECK çº¦æŸALTER TABLE staffADD CONSTRAINT staff_first_name_ck CHECK (first_name in (&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));-- æ·»åŠ  UNIQUE çº¦æŸALTER TABLE staffADD CONSTRAINT staff_first_name_uq UNIQUE (first_name);-- æ·»åŠ  FOREIGN KEY çº¦æŸALTER TABLE staffADD CONSTRAINT staff_leader_fk FOREIGN KEY(first_name) REFERENCES staff2(first_name); -- æ·»åŠ  NOT NULL çº¦æŸ (ä½¿ç”¨ MODIFY !!!)ALTER TABLE staffMODIFY first_name CONSTRAINT staff_first_name_nn NOT NULL;ALTER TABLE staffMODIFY first_name NOT NULL; åˆ é™¤ã€ç¦ç”¨ã€å¯ç”¨çº¦æŸ1234567891011-- åˆ é™¤ALTER TABLE staffDROP CONSTRAINT staff_first_name_nn;-- ç¦ç”¨ALTER TABLE staffDISABLE CONSTRAINT staff_first_name_nn;-- å¯ç”¨ALTER TABLE staffENABLE CONSTRAINT staff_first_name_nn; æ¸…ç©ºè¡¨DELETE 12DELETE staff;COMMIT; TRUNCATE 1TRUNCATE TABLE staff; TRUNCATE DELETE æ¸…ç©ºè¡¨æ ¼ T F è¯­å¥ç±»å‹ DDL DML è‡ªåŠ¨æäº¤ T F å¯å›æ»š F T é‡Šæ”¾å‚¨å­˜ç©ºé—´ T F æ¨èä½¿ç”¨ T F æ³¨é‡Š12345COMMENT ON TABLE table_name is &apos;è¡¨æ³¨é‡Š&apos;;COMMENT ON TABLE staff is &apos;å‘˜å·¥è¡¨&apos;;COMMENT ON COLUMN column_name is &apos;åˆ—æ³¨é‡Š&apos;;COMMENT ON COLUMN staff_num is &apos;å‘˜å·¥å·&apos;; é‡å‘½åè¡¨1RENAME staff TO staff2; DMLæŸ¥è¯¢åŸºæœ¬é¡ºåº1234567SELECT avg(group_column) FROMtable_a INNER JOIN table_bUSING(join_column)WHERE join_column &gt; 1GROUP BY group_columnHAVING avg(group_column) &gt; 10ORDER BY oreder_column DESC; WITH123456789101112131415161718WITH t AS ( SELECT equipment_name,damage*speed*(1+durability/100) val FROM equipments WHERE durability IS NOT NULL AND attack_id IS NOT null UNION ALL SELECT equipment_name,durability*dr_ratio*2 FROM equipments WHERE durability IS NOT null AND attack_id IS NULL)SELECT equipment_name,valFROM tWHERE val &gt; ( SELECT AVG(val) FROM t)ORDER BY val DESC; IN TABLE1234567SELECT npc_name,attack_type,npc_hpFROM npcs inner join attack_types USING(attack_id)WHERE (attack_id,npc_hp) in ( SELECT attack_id,max(npc_hp) FROM npcs GROUP BY attack_id); è¿æ¥1234567891011-- å†…è¿æ¥FROM products INNER JOIN product_typesUSING (product_type_id);-- å¤–è¿æ¥FROM products (LEFT | RIGHT | FULL) OUTER JOIN product_typesUSING (product_type_id);-- è‡ªè¿æ¥FROM employees w INNER JOIN employees mON w.manager_id = m.employee_id; æ‚é¡¹12345where equipment_name like &apos;%é“_&apos;group by cid,cnamenvl(gname,&apos;æ— &apos;) å‡½æ•°æ’å…¥æ•°æ®12INSERT INTO staff VALUES(1,&apos;fn&apos;,10);INSERT INTO staff(staff_num,first_name,leader_num) VALUES(1,&apos;fn&apos;,10); åˆ é™¤æ•°æ®12DELETE FROM staffWHERE staff_num = 1; ä¿®æ”¹æ•°æ®12UPDATE staff SET staff_num = 3, first_name = &apos;xxx&apos;WHERE staff_num = 1; PL/SQL1234567891011121314151617181920212223set serveroutput ondeclarecursor c_countries IS select cname,cid from countries;v_cid countries.cid%type;v_city_cnt integer;v_gener_cnt integer;begin for v_c IN c_countries LOOP v_cid := v_c.cid; select count(*) into v_city_cnt from cities where cid = v_cid; select count(*) into v_gener_cnt from generals where cid = v_cid and cityid is not null; IF gener_cnt &gt; 2 THEN DBMS_OUTPUT.PUT_LINE(v_c.cname ||&apos;æœ‰&apos;||v_city_cnt||&apos;åº§åŸå¸‚ï¼Œ&apos;||v_gener_cnt||&apos;åç°å½¹æ­¦å°†&apos;); END IF; END LOOP;end;/]]></content>
      <categories>
        <category>è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>æ•°æ®åº“</tag>
        <tag>SQL</tag>
        <tag>PL/SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache2 æœåŠ¡å™¨é…ç½® HTTPS]]></title>
    <url>%2F2019%2F08%2F18%2Fssl%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°ç”±äºå¤šæ¬¡é…ç½® SSL è¯ä¹¦ï¼Œæ¯æ¬¡é—´éš”æ—¶é—´è¾ƒé•¿ï¼Œæ¯æ¬¡éƒ½å¿˜è®°æ€ä¹ˆæã€‚ã€‚ã€‚ç‰¹åœ°æ€»ç»“ä¸€ä¸‹ï¼Œå»¶ç¼“é˜¿å…¹æµ·é»˜ã€‚ è¿™ä»½æ•™ç¨‹åªé’ˆå¯¹ Apache2 æœåŠ¡å™¨ï¼Œä¸”å·²å†™å¥½é…ç½®æ–‡ä»¶çš„é€‰æ‰‹ã€‚ å¤§æ¦‚åˆ†ä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š ç”³è¯·è¯ä¹¦ éªŒè¯åŸŸåæ‰€æœ‰æƒ ä¸‹è½½è¯ä¹¦è½¬æ¢æ ¼å¼ å°†è¯ä¹¦ä¼ å…¥æœåŠ¡å™¨ ä¿®æ”¹é…ç½®æ–‡ä»¶ è½½å…¥é…ç½®æ–‡ä»¶ é‡å¯ Apache ç”³è¯·è¯ä¹¦æ¨è FreeSSLï¼Œå…¶ä¸­æœ‰ä¸¤æ¬¾å…è´¹è¯ä¹¦ï¼šTrustAsia çš„ä¸€å¹´å•åŸŸåè¯ä¹¦ã€Letâ€™s Encryptçš„ 90 å¤©é€šé…ç¬¦è¯ä¹¦ã€‚ å¦‚æœå­åŸŸåè¾ƒå°‘æ¨èé€‰æ‹©å‰è€…ï¼Œæˆ‘ç”¨çš„å­åŸŸåæ¯”è¾ƒå¤šé€‰æ‹©åè€…ï¼Œæ–‡ä»¶è¾ƒå°‘ä½† 90 å¤©è¦é…ç½®ä¸€æ¬¡ã€‚ éªŒè¯åŸŸåæ‰€æœ‰æƒæ ¹æ® FreeSSL ç½‘ç«™çš„æç¤ºï¼Œåœ¨è§£æåŸŸåçš„ç½‘ç«™æŒ‰è¦æ±‚æ·»åŠ  TXT è®°å½•å³å¯ã€‚ ä¸‹è½½è¯ä¹¦è½¬æ¢æ ¼å¼ä¸‹è½½åˆ°è¯ä¹¦åä¼šå‘ç°æ˜¯ä¸‰ä¸ªæ–‡ä»¶ï¼Œè€Œ Apache2 åªéœ€è¦ä¸¤ä¸ªæ–‡ä»¶ï¼Œæœ€ç»ˆéœ€è¦ä¸€ä¸ª .key å’Œä¸€ä¸ª .pemçš„æ–‡ä»¶ã€‚ ä½ å°†ä¸‹è½½åˆ°å¦‚ä¸‹ä¸‰ä¸ªæ–‡ä»¶ï¼š .keyæ–‡ä»¶ï¼Œè¯ä¹¦ç§é’¥ CA_xxx.crtï¼ŒCA ä¸­é—´è¯ä¹¦ åŸŸå.crtï¼ŒæœåŠ¡å™¨è¯ä¹¦ å…¶ä¸­ .key æ–‡ä»¶å°±æ˜¯æœ€ç»ˆéœ€è¦çš„ .key æ–‡ä»¶ï¼Œè€Œ .pem æ–‡ä»¶éœ€è¦è‡ªå·±åˆ›å»ºå†å°† åŸŸå.crt å’Œ CA_xxx.crt æŒ‰é¡ºåºç²˜è´´è¿›å»ã€‚ å°†è¯ä¹¦ä¼ å…¥æœåŠ¡å™¨ä½¿ç”¨ scp å°†è¯ä¹¦ä¸Šä¼ è‡³æœåŠ¡å™¨ï¼Œå½“ç„¶è¿™éœ€è¦é…ç½®å¥½ sshã€‚ å‘½ä»¤æ ¼å¼å’Œç¤ºä¾‹å¦‚ä¸‹ï¼š12scp file_source file_targetscp ./pazyx_xyz.pem git@pazyx.xyz:~/ æˆ‘ä¸€èˆ¬æ˜¯å°†æ–‡ä»¶ä¼ å…¥ home ç›®å½•åå† sshç™»å½•åˆ°æœåŠ¡å™¨å°†æ–‡ä»¶ä» home ç›®å½•æ”¾åˆ° /etc/apache2/ssl/ ç›®å½•ä¸‹ï¼Œä»¥å…æƒé™å—é™ã€‚ ä¿®æ”¹é…ç½®æ–‡ä»¶é…ç½®æ–‡ä»¶ä¸º /etc/apache2/site-available/default-ssl.confå¦‚ä½•é…ç½®ç•¥ï¼Œå› ä¸ºæˆ‘ä¹Ÿå¿˜äº†ï¼Œéšä¾¿æ”¹ä¸€æ”¹å°±æ˜¯äº†ã€‚ è½½å…¥é…ç½®æ–‡ä»¶1a2ensite default-ssl é‡å¯ Apache1sudo service apache2 restart å‚è€ƒèµ„æ–™ Apacheé…ç½®ssl å…è´¹è¯ä¹¦ä¸‹è½½çš„ä¸¤ä¸ªæ–‡ä»¶çš„è¯´æ˜]]></content>
      <categories>
        <category>ç¬”è®°</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>HTTPS</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œé¢˜è§£ã€kuangbin æœ€å°ç”Ÿæˆæ ‘]]></title>
    <url>%2F2019%2F04%2F29%2Fkuangbin_MST%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿° POJ-1251 Jungle Roads (æ°´é¢˜ï¼Œ%c) POJ-1287 Networking (æ°´) POJ-2031 Building a Space Station (%fæµ®ç‚¹æ•°å°´å°¬ç²¾åº¦ï¼Œä¸¤çƒé—´è·ç¦») POJ-2421 Constructing Roads (ä¸€äº›è¾¹å·²å»ºå¥½ï¼Œç®€å•å¤„ç†ä¸€ä¸‹) ZOJ-1586 QS Network (å¤„ç†ä¸€ä¸‹è¾¹æƒ) HDU-1233 è¿˜æ˜¯ç•…é€šå·¥ç¨‹ (æ°´) HDU-1875 ç•…é€šå·¥ç¨‹å†ç»­ (æµ®ç‚¹æ•°ï¼Œæ¡ä»¶è¿è¾¹) HDU-1301 Jungle Roads (é‡å¤ -&gt; POJ-1251) POJ-2349 Arctic Network (ç¬¬ K å¤§è¾¹) POJ-1751 Highways (æ±‚æœ€å°ç”Ÿæˆæ ‘çš„è¾¹ï¼ŒåŠ  0 æƒè¾¹) UVA-10147 Highways (å¤šç»„çš„ POJ-1751) + POJ-1258 Agri-Net (æ°´) POJ-3026 Borg Maze (BFS + Kruskalï¼Œç”¨æœ€çŸ­è·¯å»ºå›¾ï¼Œåƒåœ¾è¾“å…¥) POJ-1789 Truck History (Primï¼ŒKruskal è¶…æ—¶) POJ-1679 The Unique MST (æ¬¡å°ç”Ÿæˆæ ‘) ä»£ç æœ€åé™„ç®€å•é¢˜è§£ æ¨¡æ¿Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * Kruskal ç®—æ³•æ±‚ MST */#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125; Prim12345678910111213141516171819202122232425262728293031323334/* * Prim æ±‚ MST * è€—è´¹çŸ©é˜µ cost[][]ï¼Œæ ‡å·ä» 0 å¼€å§‹ï¼Œ0âˆ¼n-1 * è¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œè¿”å› -1 è¡¨ç¤ºåŸå›¾ä¸è¿é€š */#include &lt;string.h&gt;const int INF = 0x3f3f3f3f;const int MAXN = 110;bool vis[MAXN];int lowc[MAXN];//ç‚¹æ˜¯ 0 n-1int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); vis[0] = true; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; //åŸå›¾ä¸è¿é€š ans += minc; vis[p] = true; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; &#125; return ans;&#125; SecondMST (Prim)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* * æ¬¡å°ç”Ÿæˆæ ‘ * æ±‚æœ€å°ç”Ÿæˆæ ‘æ—¶ï¼Œç”¨æ•°ç»„ Max[i][j] æ¥è¡¨ç¤º MST ä¸­ i åˆ° j æœ€å¤§è¾¹æƒ * æ±‚å®Œåï¼Œç›´æ¥æšä¸¾æ‰€æœ‰ä¸åœ¨ MST ä¸­çš„è¾¹ï¼Œæ›¿æ¢æ‰æœ€å¤§è¾¹æƒçš„è¾¹ï¼Œæ›´æ–°ç­”æ¡ˆ * ç‚¹çš„ç¼–å·ä» 0 å¼€å§‹ */#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 110;const int INF = 0x3f3f3f3f;bool vis[MAXN];int lowc[MAXN];int pre[MAXN];int Max[MAXN][MAXN];// Max[i][j] è¡¨ç¤ºåœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ä» i åˆ° j çš„è·¯å¾„ä¸­çš„æœ€å¤§è¾¹æƒbool used[MAXN][MAXN];int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); memset(Max, 0, sizeof(Max)); memset(used, false, sizeof(used)); vis[0] = true; pre[0] = -1; for (int i = 1; i &lt; n; i++) &#123; lowc[i] = cost[0][i]; pre[i] = 0; &#125; lowc[0] = 0; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; ans += minc; vis[p] = true; used[p][pre[p]] = used[pre[p]][p] = true; for (int j = 0; j &lt; n; j++) &#123; if (vis[j] &amp;&amp; j != p) Max[j][p] = Max[p][j] = max(Max[j][pre[p]], lowc[p]); if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) &#123; lowc[j] = cost[p][j]; pre[j] = p; &#125; &#125; &#125; return ans;&#125;int smst(int cost[][MAXN], int n, int ans) &#123; int Min = INF; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) if (cost[i][j] != INF &amp;&amp; !used[i][j]) &#123; Min = min(Min, ans + cost[i][j] - Max[i][j]); &#125; if (Min == INF) return -1; //ä¸å­˜åœ¨ return Min;&#125; ä»£ç POJ-1251 Jungle Roads1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// POJ-1251 Jungle Roads// https://vjudge.net/problem/POJ-1251#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; for (int i = 0; i &lt; n - 1; i++) &#123; char x; int m; scanf(" %c%d", &amp;x, &amp;m); for (int j = 0; j &lt; m; j++) &#123; char y; int w; scanf(" %c%d", &amp;y, &amp;w); addedge(x - 'A', y - 'A', w); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// è£¸é¢˜ï¼Œscanf %c è¯»å…¥å°´å°¬// scanf(" %c%d", &amp;x, &amp;m); POJ-1287 Networking1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// POJ-1287 Networking// https://vjudge.net/problem/POJ-1287#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int main() &#123; int n, m; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// è£¸é¢˜ POJ-2031 Building a Space Station12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// POJ-2031 Building a Space Station// https://vjudge.net/problem/POJ-2031#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;double len(double x, double y, double z, double xx, double yy, double zz) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y) + (zz - z) * (zz - z));&#125;double cirlen(double x, double y, double z, double r, double xx, double yy, double zz, double rr) &#123; double ll = len(x, y, z, xx, yy, zz); if (ll - r - rr &lt; 1e-5) &#123; return 0; &#125; else &#123; return ll - r - rr; &#125;&#125;double xp[MAXN];double yp[MAXN];double zp[MAXN];double rp[MAXN];int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;xp[i], &amp;yp[i], &amp;zp[i], &amp;rp[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; addedge(i, j, cirlen(xp[i], yp[i], zp[i], rp[i], xp[j], yp[j], zp[j], rp[j])); &#125; &#125; double ans = Kruskal(n); printf("%.3f\n", ans); &#125; return 0;&#125;// æµ®ç‚¹æ•°çš„æœ€å°ç”Ÿæˆæ ‘ï¼Œçƒä¹‹é—´çš„è·ç¦»ï¼Œè·ç¦»å°äºé›¶ï¼Œå°±å»ºä¸€æ¡æƒä¸º 0 çš„è¾¹// POJå°´å°¬ç²¾åº¦ %f POJ-2421 Constructing Roads12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// POJ-2421 Constructing Roads// https://vjudge.net/problem/POJ-2421#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int mapx[MAXN][MAXN];int main() &#123; int N; scanf("%d", &amp;N); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; scanf("%d", &amp;mapx[i][j]); &#125; &#125; int Q; scanf("%d", &amp;Q); for (int i = 0; i &lt; Q; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); mapx[a][b] = 0; mapx[b][a] = 0; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = i + 1; j &lt;= N; j++) &#123; if (i == j) continue; addedge(i, j, min(mapx[i][j], mapx[j][i])); &#125; &#125; int ans = Kruskal(N); printf("%d\n", ans);&#125;// æœ‰ä¸€äº›è·¯å·²å»ºå¥½ï¼ŒæŠŠè¾¹æƒæ”¹ä¸º 0 å°±å¥½äº† ZOJ-1586 QS Network1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ZOJ-1586 QS Network// https://vjudge.net/problem/ZOJ-1586#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 1100; //æœ€å¤§ç‚¹æ•°const int MAXM = 2000000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨int codec[MAXN]; // *&amp;*struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; tol = 0; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;codec[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int w; scanf("%d", &amp;w); if (i &lt; j) addedge(i, j, w + codec[i] + codec[j]); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// åŠ è¾¹æ—¶ï¼ŒåŠ ä¸€ä¸‹é€‚é…å™¨çš„ä»·æ ¼ HDU-1233 è¿˜æ˜¯ç•…é€šå·¥ç¨‹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// HDU-1233 è¿˜æ˜¯ç•…é€šå·¥ç¨‹// https://vjudge.net/problem/HDU-1233#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; int m = n * (n - 1) / 2; for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); addedge(a, b, w); &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// è£¸é¢˜ HDU-1875 ç•…é€šå·¥ç¨‹å†ç»­12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// HDU-1875 ç•…é€šå·¥ç¨‹å†ç»­// https://vjudge.net/problem/HDU-1875#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 310; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); if (n == 0) break; tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); if (xly &gt;= 10 &amp;&amp; xly &lt;= 1000) addedge(i, j, xly * 100); &#125; &#125; double ans = Kruskal(n); if (ans &gt; 0) &#123; printf("%.1f\n", ans); &#125; else &#123; printf("oh!\n"); &#125; &#125; return 0;&#125;// æµ®ç‚¹æ•°ï¼Œæ¡ä»¶è¿è¾¹ HDU-1301 Jungle Roads123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// HDU-1301 Jungle Roads// https://vjudge.net/problem/HDU-1301#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; tol = 0; for (int i = 0; i &lt; n - 1; i++) &#123; char x; int m; scanf(" %c%d", &amp;x, &amp;m); for (int j = 0; j &lt; m; j++) &#123; char y; int w; scanf(" %c%d", &amp;y, &amp;w); addedge(x - 'A', y - 'A', w); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// ç«Ÿç„¶æœ‰é‡å¤çš„é¢˜ï¼Œä¸€æ¨¡ä¸€æ · -&gt; POJ-1251// è£¸é¢˜ï¼Œscanf %c è¯»å…¥å°´å°¬// scanf(" %c%d", &amp;x, &amp;m); POJ-2349 Arctic Network123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// POJ-2349 Arctic Network// https://vjudge.net/problem/POJ-2349#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 510; //æœ€å¤§ç‚¹æ•°const int MAXM = 250000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨vector&lt;double&gt; vd;struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans = max(ans, w); vd.push_back(w); // ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; vd.clear(); int n, s; scanf("%d%d", &amp;s, &amp;n); if (n == 0) break; tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); addedge(i, j, xly); &#125; &#125; double ans = Kruskal(n); ans = vd[vd.size() - s]; printf("%.2f\n", ans); &#125; return 0;&#125;// æœ€å°ç”Ÿæˆæ ‘çš„ç¬¬ K å¤§è¾¹ POJ-1751 Highways123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// POJ-1751 Highways// https://vjudge.net/problem/POJ-1751#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1000; //æœ€å¤§ç‚¹æ•°const int MAXM = 1000000; //æœ€å¤§è¾¹æ•°vector&lt;int&gt; vx;vector&lt;int&gt; vy;int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; if (w &gt; 1e-5) &#123; vx.push_back(u); vy.push_back(v); &#125; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int n; scanf("%d", &amp;n); tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); addedge(i, j, xly * 100); &#125; &#125; int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); addedge(a, b, 0); &#125; double ans = Kruskal(n); for (int i = 0; i &lt; vx.size(); i++) &#123; printf("%d %d\n", vx[i], vy[i]); &#125; return 0;&#125;// æ±‚æœ€å°ç”Ÿæˆæ ‘çš„è¾¹ï¼ŒåŠ  0 æƒè¾¹ UVA-10147 Highways123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// UVA-10147 Highways// https://vjudge.net/problem/UVA-10147#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1000; //æœ€å¤§ç‚¹æ•°const int MAXM = 1000000; //æœ€å¤§è¾¹æ•°vector&lt;int&gt; vx;vector&lt;int&gt; vy;int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v; double w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, double w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;//æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;//ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1double Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° double ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; double w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; if (w &gt; 0) &#123; vx.push_back(u); vy.push_back(v); &#125; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;double len(double x, double y, double xx, double yy) &#123; return sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y));&#125;double xp[MAXN];double yp[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; vx.clear(); vy.clear(); int n; scanf("%d", &amp;n); tol = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf", &amp;xp[i], &amp;yp[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; double xly = len(xp[i], yp[i], xp[j], yp[j]); addedge(i, j, xly * 100); &#125; &#125; int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); addedge(a, b, 0); &#125; double ans = Kruskal(n); for (int i = 0; i &lt; vx.size(); i++) &#123; printf("%d %d\n", vx[i], vy[i]); &#125; if (vx.size() == 0) printf("No new highways need\n"); if (T != 0) printf("\n"); &#125; return 0;&#125;// æ±‚æœ€å°ç”Ÿæˆæ ‘çš„è¾¹ï¼ŒåŠ  0 æƒè¾¹ POJ-1258 Agri-Net12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// POJ-1258 Agri-Net// https://vjudge.net/problem/POJ-1258#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 110; //æœ€å¤§ç‚¹æ•°const int MAXM = 10000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; tol = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int w; scanf("%d", &amp;w); addedge(i, j, w); &#125; &#125; int ans = Kruskal(n); printf("%d\n", ans); &#125; return 0;&#125;// è£¸é¢˜ POJ-3026 Borg Maze123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// POJ-3026 Borg Maze// https://vjudge.net/problem/POJ-3026#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 1100; //æœ€å¤§ç‚¹æ•°const int MAXM = 1000000; //æœ€å¤§è¾¹æ•°int F[MAXN]; //å¹¶æŸ¥é›†ä½¿ç”¨struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125; //æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å°åˆ°å¤§æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125; //ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; F[t1] = t2; cnt++; &#125; if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š else return ans;&#125;int mapx[MAXN][MAXN];int dirx[10] = &#123;0, 1, 0, -1&#125;;int diry[10] = &#123;1, 0, -1, 0&#125;;int n, m;void bfs(int x, int y) &#123; bool vis[MAXN][MAXN]; memset(vis, false, sizeof(vis)); queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; Q; Q.push(make_pair(make_pair(x, y), 0)); vis[x][y] = true; while (!Q.empty()) &#123; int xt = Q.front().first.first; int yt = Q.front().first.second; int times = Q.front().second; Q.pop(); if (mapx[x][y] != mapx[xt][yt] &amp;&amp; mapx[xt][yt] != 0) &#123; addedge(mapx[x][y], mapx[xt][yt], times); &#125; for (int i = 0; i &lt; 4; i++) &#123; int tx = xt + dirx[i]; int ty = yt + diry[i]; if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &lt; m &amp;&amp; !vis[tx][ty]) &#123; if (mapx[tx][ty] != -1) &#123; Q.push(make_pair(make_pair(tx, ty), times + 1)); vis[tx][ty] = true; &#125; &#125; &#125; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); char str[100]; while (T--) &#123; tol = 0; memset(mapx, -1, sizeof(mapx)); int cnt = 0; scanf("%d%d", &amp;n, &amp;m); gets(str); for (int i = 0; i &lt; m; i++) &#123; gets(str); for (int j = 0; j &lt; n; j++) &#123; if (str[j] == 'A' || str[j] == 'S') &#123; mapx[i][j] = ++cnt; &#125; else if (str[j] == ' ') &#123; mapx[i][j] = 0; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (mapx[i][j] &gt; 0) &#123; bfs(i, j); &#125; &#125; &#125; int ans = Kruskal(cnt); printf("%d\n", ans); &#125; return 0;&#125;// BFS + Kruskal// ç”¨æ— æƒå›¾æœ€çŸ­è·¯æƒå€¼åŠ è¾¹// ä¸€å¼€å§‹ MAXN å’Œ MAXM å¼€å°äº†ï¼Œwa...wa...wa... POJ-1789 Truck History12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// POJ-1789 Truck History// https://vjudge.net/problem/POJ-1789#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 2010; //æœ€å¤§ç‚¹æ•°const int INF = 0x3f3f3f3f;bool vis[MAXN];int lowc[MAXN];int cost[MAXN][MAXN];//ç‚¹æ˜¯ 0 n-1int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); vis[0] = true; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; //åŸå›¾ä¸è¿é€š ans += minc; vis[p] = true; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; &#125; return ans;&#125;char str[MAXN][10];int len(int a, int b) &#123; int ans = 0; for (int i = 0; i &lt; 7; i++) &#123; if (str[a][i] != str[b][i]) &#123; ans++; &#125; &#125; return ans;&#125;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", str[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == j) continue; cost[i][j] = len(i, j); &#125; &#125; int ans = Prim(cost, n); printf("The highest possible quality is 1/%d.\n", ans); &#125; return 0;&#125;// Kruskal è¶…æ—¶ï¼Œç”¨ Prim ! POJ-1679 The Unique MST123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// POJ-1679 The Unique MST// https://vjudge.net/problem/POJ-1679#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 110;const int INF = 0x3f3f3f3f;bool vis[MAXN];int lowc[MAXN];int pre[MAXN];int Max[MAXN][MAXN];// Max[i][j] è¡¨ç¤ºåœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ä» i åˆ° j çš„è·¯å¾„ä¸­çš„æœ€å¤§è¾¹æƒbool used[MAXN][MAXN];int Prim(int cost[][MAXN], int n) &#123; int ans = 0; memset(vis, false, sizeof(vis)); memset(Max, 0, sizeof(Max)); memset(used, false, sizeof(used)); vis[0] = true; pre[0] = -1; for (int i = 1; i &lt; n; i++) &#123; lowc[i] = cost[0][i]; pre[i] = 0; &#125; lowc[0] = 0; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; ans += minc; vis[p] = true; used[p][pre[p]] = used[pre[p]][p] = true; for (int j = 0; j &lt; n; j++) &#123; if (vis[j] &amp;&amp; j != p) Max[j][p] = Max[p][j] = max(Max[j][pre[p]], lowc[p]); if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) &#123; lowc[j] = cost[p][j]; pre[j] = p; &#125; &#125; &#125; return ans;&#125;int smst(int cost[][MAXN],int n,int ans)&#123; int Min=INF; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++) if(cost[i][j]!=INF &amp;&amp; !used[i][j]) &#123; Min=min(Min,ans+cost[i][j]-Max[i][j]); &#125; if(Min==INF)return -1;//ä¸å­˜åœ¨ return Min;&#125;int costx[MAXN][MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; memset(costx, 0x3f, sizeof(costx)); int n, m; scanf("%d%d", &amp;n, &amp;m); int sum = 0; for (int i = 0; i &lt; n; i++) costx[i][i] = 0; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); a--; b--; costx[a][b] = c; costx[b][a] = c; &#125; int ans = Prim(costx, n); int ansMST = smst(costx, n,ans); if (ans == ansMST) &#123; printf("Not Unique!\n"); &#125; else &#123; printf("%d\n", ans); &#125; &#125; return 0;&#125;// æ¬¡å°ç”Ÿæˆæ ‘ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆæœ€å°ç”Ÿæˆæ ‘è®¡æ•°ä¸è¡Œ// kuangbin é¢˜è§£ï¼šhttps://www.cnblogs.com/kuangbin/p/3147329.html]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DFS</tag>
        <tag>Dijkstra</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œé¢˜è§£ã€kuangbin æœ€çŸ­è·¯]]></title>
    <url>%2F2019%2F04%2F29%2Fkuangbin_short_path%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿° POJ-2387 Til the Cows Come Homeï¼ˆæ°´ï¼‰ POJ-2253 Froggerï¼ˆæµ®ç‚¹æ•°ï¼Œå°´å°¬ç²¾åº¦ï¼‰ POJ-1797 Heavy Transportationï¼ˆæ±‚æ‰€æœ‰è·¯å¾„ä¸­æœ€å¤§è¾¹æƒçš„æœ€å°å€¼ï¼‰ POJ-3268 Silver Cow Partyï¼ˆæ±‚å¾€è¿”æœ€çŸ­è·¯ï¼Œåå‘è¿è¾¹ï¼‰ POJ-1860 Currency Exchangeï¼ˆæ¢æ±‡é—®é¢˜ï¼Œæœ€é•¿è·¯åˆ¤æ–­æ­£ç¯ï¼‰ POJ-3259 Wormholesï¼ˆåˆ¤æ–­è´Ÿå€¼åœˆï¼‰ POJ-1502 MPI Maelstromï¼ˆæ‰€æœ‰ç‚¹æœ€çŸ­è·¯ä¸­çš„æœ€é•¿è·¯ï¼‰ POJ-3660 Cow Contestï¼ˆä¼ é€’é—­åŒ… floyd æˆ– DFSï¼‰ POJ-2240 Arbitrageï¼ˆåˆ¤æ–­æ­£ç¯ï¼‰ POJ-1511 Invitation Cardsï¼ˆæ±‚å¾€è¿”æœ€çŸ­è·¯ï¼Œåå‘è¿è¾¹ï¼‰ POJ-1847 Tramï¼ˆæ°´ï¼‰ POJ-1062 æ˜‚è´µçš„è˜ç¤¼* POJ-3159 Candiesï¼ˆä¼ªå·®åˆ†çº¦æŸç³»ç»Ÿï¼ˆè£¸æœ€çŸ­è·¯ï¼‰+ è¾“å…¥è¾“å‡ºæŒ‚ï¼‰ POJ-2502 Subwayï¼ˆå»ºå›¾éº»çƒ¦ï¼‰ POJ-3169 Layoutï¼ˆå·®åˆ†çº¦æŸç³»ç»Ÿï¼Œè¾“å‡ºå·®å€¼ï¼‰ LightOJ-1074 Extended Trafficï¼ˆåˆ¤æ–­æ‰€æœ‰è´Ÿç¯ï¼‰ HDU-4725 The Shortest Path in Nya Graphï¼ˆå»ºå›¾æŠ€å·§ï¼‰ HDU-3416 Marriage Match IVï¼ˆæœ€çŸ­è·¯ + æœ€å¤§æµ æ‰¾å‡ºæœ€çŸ­è·¯ç»è¿‡çš„è¾¹ï¼‰ ä»£ç æœ€åé™„ç®€å•é¢˜è§£ æ¨¡æ¿Dijkstra_simple123456789101112131415161718192021222324252627282930313233343536373839/* * å•æºæœ€çŸ­è·¯å¾„ï¼ŒDijkstra ç®—æ³•ï¼Œé‚»æ¥çŸ©é˜µå½¢å¼ï¼Œå¤æ‚åº¦ä¸ºO(n^2) * æ±‚å‡ºæº beg åˆ°æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œä¼ å…¥å›¾çš„é¡¶ç‚¹æ•°ï¼Œå’Œé‚»æ¥çŸ©é˜µ cost[][] * è¿”å›å„ç‚¹çš„æœ€çŸ­è·¯å¾„ lowcost[], è·¯å¾„ pre[].pre[i] è®°å½• beg åˆ° i * è·¯å¾„ä¸Šçš„çˆ¶ç»“ç‚¹ï¼Œpre[beg]=-1 * å¯æ›´æ”¹è·¯å¾„æƒç±»å‹ï¼Œä½†æ˜¯æƒå€¼å¿…é¡»ä¸ºéè´Ÿ */const int MAXN = 1010;#define typec intconst typec INF = 0x3f3f3f3f;bool vis[MAXN];int pre[MAXN];void Dijkstra(typec cost[][MAXN], typec lowcost[], int n, int beg) &#123; for (int i = 0; i &lt; n; i++) &#123; lowcost[i] = INF; vis[i] = false; pre[i] = -1; &#125; lowcost[beg] = 0; for (int j = 0; j &lt; n; j++) &#123; int k = -1; int Min = INF; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; lowcost[i] &lt; Min) &#123; Min = lowcost[i]; k = i; &#125; &#125; if (k == -1) break; vis[k] = true; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; lowcost[k] + cost[k][i] &lt; lowcost[i]) &#123; lowcost[i] = lowcost[k] + cost[k][i]; pre[i] = k; &#125; &#125; &#125;&#125; Dijkstra_set12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ– Dijkstra ç®—æ³• * å¤æ‚åº¦ O(ElogE) * æ³¨æ„å¯¹ * vector&lt;Edge&gt;E[MAXN] è¿›è¡Œåˆå§‹åŒ–ååŠ è¾¹ */#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125; Bellman_Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * å•æºæœ€çŸ­è·¯ bellman_ford ç®—æ³•ï¼Œå¤æ‚åº¦ O(VE) * å¯ä»¥å¤„ç†è´Ÿè¾¹æƒå›¾ã€‚ * å¯ä»¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ã€‚è¿”å› true, å½“ä¸”ä»…å½“å›¾ä¸­ä¸åŒ…å«ä»æºç‚¹å¯è¾¾çš„è´Ÿæƒå›è·¯ * vector&lt;Edge&gt;E; å…ˆ E.clear() åˆå§‹åŒ–ï¼Œç„¶ååŠ å…¥æ‰€æœ‰è¾¹ * ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹ (ä» 0 å¼€å§‹ç®€å•ä¿®æ”¹å°±å¯ä»¥äº†) */#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 550;int dist[MAXN];struct Edge &#123; int u, v; int cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E;//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹bool bellman_ford(int start, int n) &#123; for (int i = 1; i &lt;= n; i++) dist[i] = INF; dist[start] = 0; //æœ€å¤šåš n-1 æ¬¡ for (int i = 1; i &lt; n; i++) &#123; bool flag = false; for (int j = 0; j &lt; E.size(); j++) &#123; int u = E[j].u; int v = E[j].v; int cost = E[j].cost; if (dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; flag = true; &#125; if (!flag) return true; &#125; &#125; for (int j = 0; j &lt; E.size(); j++) &#123; if (dist[E[j].v] &gt; dist[E[j].u] + E[j].cost) &#123; return false; &#125; &#125; return true;&#125; SPFA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * å•æºæœ€çŸ­è·¯ SPFA * æ—¶é—´å¤æ‚åº¦ 0(kE) * è¿™ä¸ªæ˜¯é˜Ÿåˆ—å®ç°ï¼Œæœ‰æ—¶å€™æ”¹æˆæ ˆå®ç°ä¼šæ›´åŠ å¿«ï¼Œå¾ˆå®¹æ˜“ä¿®æ”¹ * è¿™ä¸ªå¤æ‚åº¦æ˜¯ä¸å®šçš„ */#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return true;&#125; Floyd12345678910111213#include &lt;algorithm&gt;using namespace std;const int MAXN = 105;int dist[MAXN][MAXN];void floyd(int n) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dist[i][j] = min(dist[i][j], dist[i][k] + dist[j][k]); &#125; &#125; &#125;&#125; è¾“å…¥è¾“å‡ºæŒ‚123456789101112131415161718192021#include &lt;cstdio&gt;int Scan() &#123; //è¾“å…¥å¤–æŒ‚ int res = 0, flag = 0; char ch; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125;void Out(int a) &#123; //è¾“å‡ºå¤–æŒ‚ if (a &lt; 0) &#123; putchar('-'); a = -a; &#125; if (a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125; ä»£ç POJ-2387 Til the Cows Come Home123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// POJ-2387 Til the Cows Come Home// https://vjudge.net/problem/POJ-2387#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int T, N; while (~scanf("%d%d", &amp;T, &amp;N)) &#123; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; for (int i = 0; i &lt; T; i++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; Dijkstra(N, 1); printf("%d\n", dist[N]); &#125;&#125;// è£¸çš„ dji_setï¼Œå‘ï¼šå¤šç»„è¾“å…¥ï¼ POJ-2253 Frogger12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// POJ-2253 Frogger// https://vjudge.net/problem/POJ-2253#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v; double c; qnode(int _v = 0, double _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v; double cost; Edge(int _v = 0, double _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];double dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; double cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; max(dist[u], cost)) &#123; dist[v] = max(dist[u], cost); que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, double w) &#123; E[u].push_back(Edge(v, w)); &#125;double tone_x[MAXN], tone_y[MAXN];double len(int a, int b) &#123; return sqrt((tone_x[a] - tone_x[b]) * (tone_x[a] - tone_x[b]) + (tone_y[a] - tone_y[b]) * (tone_y[a] - tone_y[b]));&#125;int main() &#123; int N; int CNT = 1; while (~scanf("%d", &amp;N)) &#123; if (N == 0) break; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; for (int i = 1; i &lt;= N; i++) &#123; scanf("%lf%lf", &amp;tone_x[i], &amp;tone_y[i]); &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; if (i == j) continue; addedge(i, j, len(i, j)); &#125; &#125; Dijkstra(N, 1); printf("Scenario #%d\n", CNT++); printf("Frog Distance = %.3lf\n\n", dist[2]); &#125;&#125;// æœ€çŸ­è·¯å˜å½¢ï¼Œå¤§å‘ï¼šPOJé€‰æ‹©C++æ‰èƒ½è¿‡ï¼Ÿï¼Ÿï¼Ÿ POJ-1797 Heavy Transportationdij_set1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// POJ-1797 Heavy Transportation// https://vjudge.net/problem/POJ-1797#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 10000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &lt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = 0; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = INF; que.push(qnode(start, dist[start])); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &lt; min(dist[u], cost)) &#123; dist[v] = min(dist[u], cost); que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int T, CNT = 1; scanf("%d", &amp;T); while (CNT &lt;= T) &#123; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); addedge(a, b, w); addedge(b, a, w); &#125; Dijkstra(n, 1); printf("Scenario #%d:\n%d\n\n", CNT++, dist[n]); &#125; return 0;&#125;//æ±‚ 1 - n ä¸­æ‰€æœ‰è·¯å¾„ä¸­æœ€å¤§è¾¹æƒçš„æœ€å°å€¼ dij_simple123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// POJ-1797 Heavy Transportation// https://vjudge.net/problem/POJ-1797#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;#define typec intconst typec INF = 0x3f3f3f3f;int xcost[MAXN][MAXN];int dist[MAXN];bool vis[MAXN];void Dijkstra(typec cost[][MAXN], typec lowcost[], int n, int beg) &#123; for (int i = 0; i &lt; n; i++) &#123; lowcost[i] = 0; vis[i] = false; &#125; lowcost[beg] = INF; for (int j = 0; j &lt; n; j++) &#123; int k = -1; int Min = 0; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; lowcost[i] &gt; Min) &#123; Min = lowcost[i]; k = i; &#125; &#125; if (k == -1) break; vis[k] = true; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; min(lowcost[k], cost[k][i]) &gt; lowcost[i]) &#123; lowcost[i] = min(lowcost[k], cost[k][i]); &#125; &#125; &#125;&#125;int main() &#123; int T, CNT = 1; scanf("%d", &amp;T); while (CNT &lt;= T) &#123; memset(xcost, 0, sizeof(xcost)); memset(dist, 0, sizeof(dist)); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); a--; b--; xcost[a][b] = xcost[b][a] = max(w, xcost[a][b]); &#125; Dijkstra(xcost, dist, n, 0); printf("Scenario #%d:\n%d\n\n", CNT++, dist[n - 1]); &#125; return 0;&#125;//æ±‚ 1 - n ä¸­æ‰€æœ‰è·¯å¾„ä¸­æœ€å¤§è¾¹æƒçš„æœ€å°å€¼ Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// POJ-1797 Heavy Transportation// https://vjudge.net/problem/POJ-1797#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 2005; //æœ€å¤§ç‚¹æ•°const int MAXM = 2000005; //æœ€å¤§è¾¹æ•°int F[MAXN];struct Edge &#123; int u, v, w;&#125; edge[MAXM]; //å­˜å‚¨è¾¹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬èµ·ç‚¹/ç»ˆç‚¹/æƒå€¼int tol; //è¾¹æ•°ï¼ŒåŠ è¾¹å‰èµ‹å€¼ä¸º 0void addedge(int u, int v, int w) &#123; edge[tol].u = u; edge[tol].v = v; edge[tol++].w = w;&#125;// æ’åºå‡½æ•°ï¼Œè®²è¾¹æŒ‰ç…§æƒå€¼ä»å¤§åˆ°å°æ’åºbool cmp(Edge a, Edge b) &#123; return a.w &gt; b.w; &#125;int find(int x) &#123; if (F[x] == -1) return x; else return F[x] = find(F[x]);&#125;int xans;// ä¼ å…¥ç‚¹æ•°ï¼Œè¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æƒå€¼ï¼Œå¦‚æœä¸è¿é€šè¿”å› -1int Kruskal(int n) &#123; memset(F, -1, sizeof(F)); sort(edge, edge + tol, cmp); int cnt = 0; //è®¡ç®—åŠ å…¥çš„è¾¹æ•° int ans = 0; for (int i = 0; i &lt; tol; i++) &#123; int u = edge[i].u; int v = edge[i].v; int w = edge[i].w; int t1 = find(u); int t2 = find(v); if (t1 != t2) &#123; ans += w; xans = min(xans, w); F[t1] = t2; cnt++; &#125; //---------------------------------------------------------------- int x1 = find(1); int xn = find(n); if (x1 == xn) break; //---------------------------------------------------------------- // 1-nè¿æ¥åå°±ä¸éœ€è´ªå¿ƒ if (cnt == n - 1) break; &#125; if (cnt &lt; n - 1) return -1; //ä¸è¿é€š return ans;&#125;int main() &#123; int T, CNT = 1; scanf("%d", &amp;T); while (CNT &lt;= T) &#123; tol = 0; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf("%d%d%d", &amp;a, &amp;b, &amp;w); addedge(a, b, w); // addedge(b, a, w); &#125; xans = 0x3f3f3f3f; Kruskal(n); printf("Scenario #%d:\n%d\n\n", CNT++, xans); &#125; return 0;&#125;//æ±‚ 1 - n ä¸­æ‰€æœ‰è·¯å¾„ä¸­æœ€å¤§è¾¹æƒçš„æœ€å°å€¼ POJ-3268 Silver Cow Party123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// POJ-3268 Silver Cow Party// https://vjudge.net/problem/POJ-3268#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 10000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int u, v, cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];vector&lt;Edge&gt; Etmp;bool vis[MAXN];int dist[MAXN];int tdist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(u, v, w)); &#125;int main() &#123; int n, m, x; scanf("%d%d%d", &amp;n, &amp;m, &amp;x); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); Etmp.push_back(Edge(a, b, c)); &#125; Dijkstra(n, x); for (int i = 1; i &lt;= n; i++) &#123; tdist[i] = dist[i]; E[i].clear(); &#125; for (int i = 0; i &lt; m; i++) &#123; addedge(Etmp[i].v, Etmp[i].u, Etmp[i].cost); &#125; int ans = 0; Dijkstra(n, x); for (int i = 1; i &lt;= n; i++) &#123; tdist[i] += dist[i]; ans = max(ans, tdist[i]); &#125; printf("%d\n", ans); return 0;&#125;// ä» x å‘æ‰€æœ‰ç‚¹è·‘ä¸€æ¬¡ dijï¼Œå°†è¾¹åå‘å†æ¥ä¸€æ¬¡ï¼Œæ±‚å¾€è¿”è·ç¦» POJ-1860 Currency Exchange1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// POJ-1860 Currency Exchange// https://vjudge.net/problem/POJ-1860#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int N, M, S;double V;const int MAXN = 1010;const int INF = 10000;struct Edge &#123; int v; double cost; double c; Edge(int _v = 0, double _cost = 0, double _c = 0) : v(_v), cost(_cost), c(_c) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, double w, double c) &#123; E[u].push_back(Edge(v, w, c));&#125;bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°double dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = 0; vis[start] = true; dist[start] = V; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &lt; (dist[u] - E[u][i].c) * E[u][i].cost) &#123; dist[v] = (dist[u] - E[u][i].c) * E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return true; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return false;&#125;int main() &#123; scanf("%d%d%d%lf", &amp;N, &amp;M, &amp;S, &amp;V); for (int i = 0; i &lt; M; i++) &#123; int a, b; double rab, cab, rba, cba; scanf("%d%d%lf%lf%lf%lf", &amp;a, &amp;b, &amp;rab, &amp;cab, &amp;rba, &amp;cba); addedge(a, b, rab, cab); addedge(b, a, rba, cba); &#125; if (SPFA(S, N)) &#123; printf("YES"); &#125; else &#123; printf("NO"); &#125; printf("\n"); return 0;&#125;// æ¢æ±‡é—®é¢˜ï¼Œæœ€é•¿è·¯åˆ¤æ–­æ­£ç¯ POJ-3259 Wormholes12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// POJ-3159 Candies// https://vjudge.net/problem/POJ-3159#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int Scan() &#123; //è¾“å…¥å¤–æŒ‚ int res = 0, flag = 0; char ch; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125;void Out(int a) &#123; //è¾“å‡ºå¤–æŒ‚ if (a &lt; 0) &#123; putchar('-'); a = -a; &#125; if (a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125;const int INF = 0x3f3f3f3f;const int MAXN = 30005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int n, m; n = Scan(); m = Scan(); // scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; a = Scan(); b = Scan(); c = Scan(); // scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; Dijkstra(n, 1); Out(dist[n]); // printf("%d\n", dist[n]);&#125;// ä¼ªè£…çš„å·®åˆ†çº¦æŸç³»ç»Ÿï¼ˆè£¸çš„æœ€çŸ­è·¯ï¼‰ï¼Œè¾“å…¥è¾“å‡ºTLEï¼Œä¸Šè¾“å…¥è¾“å‡ºæŒ‚ POJ-1502 MPI Maelstrom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// POJ-1502 MPI Maelstrom// https://vjudge.net/problem/POJ-1502#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;// #include &lt;sstream&gt;// #include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int n; scanf("%d", &amp;n); char str[100]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; // string s; // cin &gt;&gt; s; // if (s[0] == 'x') continue; // stringstream ss; // ss &lt;&lt; s; // ss &gt;&gt; tmp; scanf("%s", str); if (str[0] == 'x') continue; int tmp = atoi(str); addedge(i, j, tmp); addedge(j, i, tmp); &#125; &#125; Dijkstra(n, 1); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ans = max(ans, dist[i]); &#125; printf("%d\n", ans); return 0;&#125;// ä» 1 å‡ºå‘æœ€çŸ­è·¯ä¸­çš„æœ€é•¿è·¯ POJ-3660 Cow ContestFloyd12345678910111213141516171819202122232425262728293031323334353637383940414243444546// POJ-3660 Cow Contest// https://vjudge.net/problem/POJ-3660#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int MAXN = 105;int dist[MAXN][MAXN];void floyd(int n) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dist[i][j] = (dist[i][j] || (dist[i][k] &amp;&amp; dist[k][j])); &#125; &#125; &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); memset(dist, 0, sizeof(dist)); for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); dist[a][b] = 1; &#125; floyd(n); int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; for (int j = 1; j &lt;= n; j++) &#123; if (dist[i][j] || dist[j][i]) cnt++; &#125; if (cnt &gt;= n - 1) &#123; ans++; &#125; &#125; printf("%d\n", ans); return 0;&#125;// ä¼ é€’é—­åŒ… DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// POJ-3660 Cow Contest// https://vjudge.net/problem/POJ-3660#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 105;int n, m;vector&lt;int&gt; ed[MAXN];int vis[MAXN][MAXN]; // vis[i][j]è¡¨ç¤ºi-&gt;jå¯è¾¾void dfs(int s) //æ™®é€šçš„dfsç®—æ³•&#123; int num = n; stack&lt;int&gt; st; st.push(s); vis[s][s] = 1; while (!st.empty()) &#123; int now = st.top(); st.pop(); int len = ed[now].size(); for (int i = 0; i &lt; len; ++i) &#123; if (vis[s][ed[now][i]] == 0) &#123; st.push(ed[now][i]); vis[s][ed[now][i]] = 1; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); ed[a].push_back(b); // vis[a][b] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; dfs(i); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; int cnt = 0; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) continue; if (vis[i][j] || vis[j][i]) cnt++; &#125; if (cnt &gt;= n - 1) &#123; ans++; &#125; &#125; printf("%d\n", ans); return 0;&#125;// ä¼ é€’é—­åŒ… POJ-2240 Arbitrage123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// POJ-2240 Arbitrage// https://vjudge.net/problem/POJ-2240#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; double cost; Edge(int _v = 0, double _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, double w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°double dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) dist[i] = 0; vis[start] = true; dist[start] = 100; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &lt; dist[u] * E[u][i].cost) &#123; dist[v] = dist[u] * E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int Case = 1; while (true) &#123; int n; cin &gt;&gt; n; if (n == 0) break; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; map&lt;string, int&gt; name; for (int i = 1; i &lt;= n; i++) &#123; string str; cin &gt;&gt; str; name[str] = i; &#125; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; string a, b; double x; cin &gt;&gt; a &gt;&gt; x &gt;&gt; b; addedge(name[a], name[b], x); &#125; cout &lt;&lt; "Case " &lt;&lt; Case++ &lt;&lt; ": "; if (!SPFA(1, n)) &#123; cout &lt;&lt; "Yes"; &#125; else &#123; cout &lt;&lt; "No"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;// SPFA åˆ¤æ–­æ­£ç¯ POJ-1511 Invitation Cards12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// POJ-1511 Invitation Cards// https://vjudge.net/problem/POJ-1511#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int u, v, cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];vector&lt;Edge&gt; Etmp;bool vis[MAXN];int dist[MAXN];int tdist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(u, v, w)); &#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); Etmp.clear(); for (int i = 1; i &lt;= n; i++) &#123; E[i].clear(); &#125; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); Etmp.push_back(Edge(a, b, c)); &#125; Dijkstra(n, 1); long long int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; sum += dist[i]; E[i].clear(); &#125; for (int i = 0; i &lt; m; i++) &#123; addedge(Etmp[i].v, Etmp[i].u, Etmp[i].cost); &#125; Dijkstra(n, 1); for (int i = 1; i &lt;= n; i++) &#123; sum += dist[i]; &#125; printf("%lld\n", sum); &#125; return 0;&#125;// æ±‚ 1 åˆ°æ‰€æœ‰ç‚¹å†è¿”å›çš„æœ€çŸ­è·¯å¾„é•¿åº¦æ±‚å’Œï¼Œsuméœ€è¦ long long// ä¸ POJ-3268 Silver Cow Party ç±»ä¼¼ï¼Œå°†è¾¹åå‘å†æ±‚ä¸€æ¬¡å³å¯ POJ-1847 Tram12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// POJ-1847 Tram// https://vjudge.net/problem/POJ-1847#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int N, A, B; scanf("%d%d%d", &amp;N, &amp;A, &amp;B); for (int i = 1; i &lt;= N; i++) &#123; int ct, a; scanf("%d%d", &amp;ct, &amp;a); addedge(i, a, 0); for (int j = 1; j &lt; ct; j++) &#123; scanf("%d", &amp;a); addedge(i, a, 1); &#125; &#125; SPFA(A, N); if (dist[B] != INF) &#123; printf("%d\n", dist[B]); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125;// è£¸æœ€çŸ­è·¯ï¼ŒSPFAï¼ŒDij éƒ½å¯ä»¥ POJ-1062 æ˜‚è´µçš„è˜ç¤¼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// POJ-1062 æ˜‚è´µçš„è˜ç¤¼// https://vjudge.net/problem/POJ-1062#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int M, N;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;long long degree[MAXN];bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°long long dist[MAXN];bool SPFA(int start, int n, int a, int b) &#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (degree[v] &lt; a || degree[v] &gt; b) &#123; continue; &#125; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; scanf("%d%d", &amp;M, &amp;N); for (int i = 0; i &lt;= N; i++) &#123; E[i].clear(); &#125; long long mind = 100000, maxd = 0; for (int i = 1; i &lt;= N; i++) &#123; int w, X; scanf("%d%lld%d", &amp;w, &amp;degree[i], &amp;X); mind = min(mind, degree[i]); maxd = max(maxd, degree[i]); addedge(0, i, w); for (int j = 0; j &lt; X; j++) &#123; int T, V; scanf("%d%d", &amp;T, &amp;V); addedge(T, i, V); &#125; &#125; long long ans = E[0][0].cost; for (int i = degree[1] - M; i &lt;= degree[1]; i++) &#123; SPFA(0, N, i, i + M); ans = min(ans, dist[1]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; POJ-3159 Candies12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// POJ-3159 Candies// https://vjudge.net/problem/POJ-3159#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int Scan() &#123; //è¾“å…¥å¤–æŒ‚ int res = 0, flag = 0; char ch; if ((ch = getchar()) == '-') flag = 1; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125;void Out(int a) &#123; //è¾“å‡ºå¤–æŒ‚ if (a &lt; 0) &#123; putchar('-'); a = -a; &#125; if (a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125;const int INF = 0x3f3f3f3f;const int MAXN = 30005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int main() &#123; int n, m; n = Scan(); m = Scan(); // scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; a = Scan(); b = Scan(); c = Scan(); // scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; Dijkstra(n, 1); Out(dist[n]); // printf("%d\n", dist[n]);&#125;// ä¼ªè£…çš„å·®åˆ†çº¦æŸç³»ç»Ÿï¼ˆè£¸çš„æœ€çŸ­è·¯ï¼‰ï¼Œè¾“å…¥è¾“å‡ºTLEï¼Œä¸Šè¾“å…¥è¾“å‡ºæŒ‚ POJ-2502 Subway123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// POJ-2502 Subway// https://vjudge.net/problem/POJ-2502#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qnode &#123; int v; double c; qnode(int _v = 0, double _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v; double cost; Edge(int _v = 0, double _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];double dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, double w) &#123; E[u].push_back(Edge(v, w)); &#125;double xx[300];double yy[300];double len(int a, int b) &#123; return sqrt((xx[a] - xx[b]) * (xx[a] - xx[b]) + (yy[a] - yy[b]) * (yy[a] - yy[b]));&#125;int main() &#123; int cnt = 1; scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt]); cnt++; scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt]); cnt++; while (~scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt])) &#123; vector&lt;int&gt; subway; subway.push_back(cnt); cnt++; while (xx[cnt - 1] != -1 &amp;&amp; yy[cnt - 1] != -1) &#123; scanf("%lf%lf", &amp;xx[cnt], &amp;yy[cnt]); subway.push_back(cnt); cnt++; &#125; cnt--; for (int i = 0; i &lt; subway.size() - 2; i++) &#123; addedge(subway[i], subway[i + 1], len(subway[i], subway[i + 1]) / 40 * 60); addedge(subway[i + 1], subway[i], len(subway[i], subway[i + 1]) / 40 * 60); &#125; &#125; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; if (i == j) continue; addedge(i, j, len(i, j) / 10 * 60); &#125; &#125; Dijkstra(cnt, 1); printf("%d\n", int(dist[2] / 1000 + 0.5));&#125;// æ°´é¢˜ï¼Œè¿è¾¹éº»çƒ¦ä¸€ç‚¹ï¼Œè¾“å…¥ä¹Ÿéº»çƒ¦// åœ°é“åªèƒ½ä¸€ç«™ä¸€ç«™çš„èµ°// ç»“æœè¦è¾“å‡ºæ•´æ•°ï¼Œç«Ÿç„¶è¦å››èˆäº”å…¥ï¼ï¼ï¼ POJ-3169 Layout12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// POJ-3169 Layout// https://vjudge.net/problem/POJ-3169#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return true;&#125;int main() &#123; int N, ML, MD; scanf("%d%d%d", &amp;N, &amp;ML, &amp;MD); for (int i = 0; i &lt; ML; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); &#125; for (int i = 0; i &lt; MD; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(b, a, -c); &#125; if (SPFA(1, N)) &#123; if (dist[N] == INF) &#123; printf("-2"); &#125; else &#123; printf("%d", dist[N]); &#125; &#125; else &#123; printf("-1"); &#125; printf("\n");&#125;// å·®åˆ†çº¦æŸç³»ç»Ÿ// A - B &lt;= D -&gt; add(Aï¼ŒBï¼ŒD)// A - B &gt;= D -&gt; åŒä¹˜ - 1å¾— B - A &lt;= -D -&gt; add(Bï¼ŒAï¼Œ-D) LightOJ-1074 Extended Traffic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// LightOJ-1074 Extended Traffic// https://vjudge.net/problem/LightOJ-1074#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge &#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;bool vis[MAXN]; //åœ¨é˜Ÿåˆ—æ ‡å¿—int cnt[MAXN]; //æ¯ä¸ªç‚¹çš„å…¥é˜Ÿåˆ—æ¬¡æ•°int dist[MAXN];bool SPFA(int start, int n) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; if (++cnt[v] &gt; n) &#123; dist[v] = -INF; &#125; else &#123; que.push(v); &#125; // cnt[i] ä¸ºå…¥é˜Ÿåˆ—æ¬¡æ•°ï¼Œç”¨æ¥åˆ¤å®šæ˜¯å¦å­˜åœ¨è´Ÿç¯å›è·¯ &#125; &#125; &#125; &#125; return true;&#125;int arr[MAXN];int main() &#123; int T; scanf("%d", &amp;T); for (int Case = 1; Case &lt;= T; Case++) &#123; for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; printf("Case %d:\n", Case); int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int m; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); addedge(a, b, (arr[b] - arr[a]) * (arr[b] - arr[a]) * (arr[b] - arr[a])); &#125; bool flag = SPFA(1, n); int q; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; int x, ans; scanf("%d", &amp;x); if (dist[x] == INF || dist[x] &lt; 3) &#123; printf("?\n"); &#125; else &#123; printf("%d\n", dist[x]); &#125; &#125; &#125;&#125;// SPFA åˆ¤æ–­**æ‰€æœ‰è´Ÿç¯** HDU-4725 The Shortest Path in Nya Graph1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// HDU-4725 The Shortest Path in Nya Graph// https://vjudge.net/problem/HDU-4725#include &lt;string.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 300005;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int v, cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(v, w)); &#125;int arr[MAXN];int flag[MAXN];int main() &#123; int T; scanf("%d", &amp;T); for (int Case = 1; Case &lt;= T; Case++) &#123; int N, M, C; scanf("%d%d%d", &amp;N, &amp;M, &amp;C); memset(flag, 0, sizeof(flag)); for (int i = 1; i &lt;= N * 3; i++) &#123; E[i].clear(); &#125; for (int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;arr[i]); flag[arr[i]]++; addedge(i, arr[i] + N + 1 + 1, 0); addedge(i, arr[i] + N + 1 - 1, 0); addedge(arr[i] + N + 1, i, C); &#125; for (int i = 0; i &lt; M; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addedge(a, b, c); addedge(b, a, c); &#125; Dijkstra(N * 3, 1); printf("Case #%d: ", Case); if (dist[N] == INF) &#123; printf("%d\n", -1); &#125; else &#123; printf("%d\n", dist[N]); &#125; &#125;&#125;// å»ºå›¾å›°éš¾ä¸€äº›çš„æœ€çŸ­è·¯é—®é¢˜ï¼Œå¦‚æœå®Œå…¨æŒ‰é¢˜æ„å»ºå›¾ä¼šè¶…æ—¶// å°†å±‚æŠ½è±¡æˆè™šç‚¹ï¼Œç‚¹åˆ°ç›¸é‚»å±‚çš„è™šç‚¹è¿ä¸€æ¡ 0// è¾¹æƒçš„è™šè¾¹ï¼Œè™šç‚¹åˆ°å½“å‰å±‚çš„ç‚¹è¿ä¸€æ¡ C è¾¹æƒçš„è¾¹ HDU-3416 Marriage Match IV123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179// HDU-3416 Marriage Match IV// https://vjudge.net/problem/HDU-3416#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 2000;struct qnode &#123; int v, c; qnode(int _v = 0, int _c = 0) : v(_v), c(_c)&#123;&#125;; bool operator&lt;(const qnode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge &#123; int u, v, cost; Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];vector&lt;Edge&gt; Ex;bool vis[MAXN];int dist[MAXN];//ç‚¹çš„ç¼–å·ä» 1 å¼€å§‹void Dijkstra(int n, int start) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) dist[i] = INF; priority_queue&lt;qnode&gt; que; while (!que.empty()) que.pop(); dist[start] = 0; que.push(qnode(start, 0)); qnode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[tmp.v][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qnode(v, dist[v])); &#125; &#125; &#125;&#125;void addedge(int u, int v, int w) &#123; E[u].push_back(Edge(u, v, w)); &#125;const int MAXM = 1200010;struct Edgef &#123; int to, next, cap, flow;&#125; edge[MAXM];int tol;int head[MAXN];void init() &#123; tol = 2; memset(head, -1, sizeof(head));&#125;void addedge(int u, int v, int w, int rw) &#123; edge[tol].to = v; edge[tol].cap = w; edge[tol].flow = 0; edge[tol].next = head[u]; head[u] = tol++; edge[tol].to = u; edge[tol].cap = rw; edge[tol].flow = 0; edge[tol].next = head[v]; head[v] = tol++;&#125;int Q[MAXN];int dep[MAXN], cur[MAXN], sta[MAXN];bool bfs(int s, int t, int n) &#123; int front = 0, tail = 0; memset(dep, -1, sizeof(dep[0]) * (n + 1)); dep[s] = 0; Q[tail++] = s; while (front &lt; tail) &#123; int u = Q[front++]; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] == -1) &#123; dep[v] = dep[u] + 1; if (v == t) return true; Q[tail++] = v; &#125; &#125; &#125; return false;&#125;int dinic(int s, int t, int n) &#123; int maxflow = 0; while (bfs(s, t, n)) &#123; for (int i = 0; i &lt; n; i++) &#123; cur[i] = head[i]; &#125; int u = s, tail = 0; while (cur[s] != -1) &#123; if (u == t) &#123; int tp = INF; for (int i = tail - 1; i &gt;= 0; i--) &#123; tp = min(tp, edge[sta[i]].cap - edge[sta[i]].flow); &#125; maxflow += tp; for (int i = tail - 1; i &gt;= 0; i--) &#123; edge[sta[i]].flow += tp; edge[sta[i] ^ 1].flow -= tp; if (edge[sta[i]].cap - edge[sta[i]].flow == 0) tail = i; &#125; u = edge[sta[tail] ^ 1].to; &#125; else if (cur[u] != -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 == dep[edge[cur[u]].to]) &#123; sta[tail++] = cur[u]; u = edge[cur[u]].to; &#125; else &#123; while (u != s &amp;&amp; cur[u] == -1) &#123; u = edge[sta[--tail] ^ 1].to; &#125; cur[u] = edge[cur[u]].next; &#125; &#125; &#125; return maxflow;&#125;int distA[MAXN];int distB[MAXN];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; init(); Ex.clear(); for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); Ex.push_back(Edge(a, b, c)); addedge(a, b, c); &#125; int A, B; scanf("%d%d", &amp;A, &amp;B); Dijkstra(n, A); memcpy(distA, dist, sizeof(dist)); for (int i = 0; i &lt; MAXN; i++) &#123; E[i].clear(); &#125; for (int i = 0; i &lt; Ex.size(); i++) &#123; addedge(Ex[i].v, Ex[i].u, Ex[i].cost); &#125; Dijkstra(n, B); memcpy(distB, dist, sizeof(dist)); for (int i = 0; i &lt; Ex.size(); i++) &#123; if (distA[Ex[i].u] + distB[Ex[i].v] + Ex[i].cost == distA[B]) &#123; addedge(Ex[i].u, Ex[i].v, 1, 0); &#125; &#125; int ans = dinic(A, B, n); printf("%d\n", ans); &#125;&#125;// æ±‚æœ€çŸ­è·¯çš„æ¡æ•°ï¼ˆæ— å…¬å…±è¾¹ï¼‰// æ‰¾å‡ºæœ€çŸ­è·¯ç»è¿‡çš„è¾¹ï¼Œè·‘æœ€å¤§æµ]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>DFS</tag>
        <tag>Dijkstra</tag>
        <tag>SPFA</tag>
        <tag>Kruskal</tag>
        <tag>Floyd</tag>
        <tag>æœ€çŸ­è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€çŸ­è·¯ç®—æ³•2â€”â€”SPFA]]></title>
    <url>%2F2019%2F02%2F02%2Fspfa%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°åœ¨æœ€çŸ­è·¯ç®—æ³•1â€”â€”Dijkstraä¸­ï¼Œæˆ‘ä»‹ç»äº† Dijkstra ç®—æ³•ï¼Œå…¶ä¸­ç»™å‡ºäº†ä¸€ç§å¥‡æ€ªçš„ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ï¼Œä¼˜åŒ–åçš„ä»£ç å…¶å®æœ‰ç‚¹ä¸åƒ Dijkstra ç®—æ³•ï¼Œè€Œæ›´åƒä»Šå¤©è¦ä»‹ç»çš„ SPFAï¼ˆShortest Path Faster Algorithmï¼‰ ç®—æ³•ã€‚SPFA ç®—æ³•ä¹Ÿæ˜¯ä¸€ç§å•æºæœ€çŸ­è·¯ç®—æ³•ï¼Œå®é™…ä¸Šæ˜¯ Bellman-Ford ç®—æ³•çš„é˜Ÿåˆ—ä¼˜åŒ–ï¼Œå®ƒæœ€å¤§çš„ç‰¹ç‚¹æ˜¯å®ƒå¯å¤„ç†æœ‰è´Ÿæƒè¾¹çš„å›¾ï¼Œå¹¶å¯ä»¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨è´Ÿå€¼åœˆã€‚ æ€æƒ³SPFA ç®—æ³•é‡‡ç”¨åŠ¨æ€é€¼è¿›æ³•ï¼Œä½¿ç”¨é˜Ÿåˆ—ä¿å­˜å¾…ä¼˜åŒ–çš„é¡¶ç‚¹ï¼Œä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ç‚¹å¯¹å…¶é‚»æ¥ç‚¹è¿›è¡Œä¼˜åŒ–ï¼Œè‹¥æœ‰è°ƒæ•´åˆ™å°†å…¶å…¥é˜Ÿç­‰å¾…è°ƒæ•´ã€‚åå¤å–å‡ºé˜Ÿé¦–æ›´æ–°æœ€çŸ­è·¯ï¼Œç›´è‡³é˜Ÿåˆ—ä¸ºç©ºã€‚ å®ç°12345678910111213141516171819202122232425262728293031323334const int MAX_N = 100;struct edge &#123; int next, weight;&#125;;vector&lt;edge&gt;G[MAX_N]; bool inq[MAX_N];int dist[MAX_N];void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; inq[s] = true; queue&lt;int&gt; que; que.push(s); while (!que.empty()) &#123; int u = que.front(); que.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &lt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; que.push(v); inq[v] = true; &#125; &#125; &#125; &#125;&#125; G é‚»æ¥è¡¨ inq æ ‡ç¤ºé¡¶ç‚¹æ˜¯å¦å·²å…¥é˜Ÿ dist ä¿å­˜èµ·å§‹ç‚¹åˆ°å„ä¸ªç‚¹çš„è·ç¦» que ä¿å­˜ç­‰å¾…ä¼˜åŒ–çš„é¡¶ç‚¹ åº”ç”¨è´Ÿå€¼åœˆåˆ¤æ–­åœ¨ SPFA ç®—æ³•ä¸­å¢åŠ  cnt æ•°ç»„è®°å½•é¡¶ç‚¹å…¥é˜Ÿæ¬¡æ•°ï¼Œå¦‚æœå…¥é˜Ÿæ¬¡æ•°å¤§äºé¡¶ç‚¹æ€»æ•° n è¯´æ˜å­˜åœ¨è´Ÿå€¼åœˆã€‚ è¡¥å……åéƒ¨åˆ†ä»£ç ï¼š 1234567891011121314151617181920212223queue&lt;int&gt; que;que.push(s);cnt[s]++; // **while (!que.empty()) &#123; int u = que.front(); que.pop(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &lt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; que.push(v); cnt[v]++; // ** inq[v] = true; if(cnt[v] &gt; n)&#123; // ** cout &lt;&lt; "å­˜åœ¨è´Ÿå€¼åœˆ" &lt;&lt; endl; return; &#125; &#125; &#125; &#125;&#125; æœ€é•¿è·¯æ–¹æ³• 1å°†è¾¹æƒå–ç›¸åæ•°ï¼Œè·‘å®Œç®—æ³•åï¼Œdist æ•°ç»„çš„å€¼ä¸ºè·ç¦»çš„ç›¸åæ•°ã€‚ æ–¹æ³• 2 å°†æ›´æ–°æ“ä½œæ”¹ä¸ºçš„æ¡ä»¶ dist[u] + G[u][i].weight &gt; dist[v] åˆå§‹åŒ– dist æ•°ç»„æ—¶ç»™äºˆæå°å€¼å¦‚ 0xbf 1234memset(dist, 0xbf, sizeof(dist));...if (dist[u] + G[u][i].weight &gt; dist[v])... å·®åˆ†çº¦æŸç³»ç»Ÿå¦‚æœä¸€ä¸ªä¸ç­‰å¼ç»„ç”± $nâ€‹$ ä¸ªå˜é‡å’Œ $mâ€‹$ ä¸ªçº¦æŸæ¡ä»¶ç»„æˆï¼Œä¸”æ¯ä¸ªçº¦æŸæ¡ä»¶éƒ½æ˜¯å½¢å¦‚ $x_j - x_i \leq k, 1 \leq i,j \leq nâ€‹$ çš„ä¸ç­‰å¼ï¼Œåˆ™ç§°å…¶ä¸ºå·®åˆ†çº¦æŸç³»ç»Ÿã€‚ $x_j - x_i \leq k$ å¯¹åº”äºæœ€çŸ­è·¯ç½‘ç»œä¸­çš„ä¸‰è§’ä¸ç­‰å¼ $dist_v - dist_u \leq w_{&lt;u,v&gt;}$ï¼Œå³ $dist_v + w_{&lt;u,v&gt;} \leq dist_u$ã€‚ç”¨æœ€çŸ­è·¯ç®—æ³•å¾—åˆ°ç­”æ¡ˆ $dist_i$ï¼Œä¹Ÿå°±æ±‚å‡ºäº†ä¸ç­‰å¼ç»„çš„ä¸€ä¸ªè§£ã€‚ å¢åŠ ä¸€ä¸ªè¶…çº§æº $s$ ï¼Œ$s$ è¿æ¥å…¶ä½™æ¯ä¸ªé¡¶ç‚¹ï¼Œè¾¹æƒå‡ä¸º $0$ã€‚æ‰§è¡Œ SPFA ç®—æ³•ï¼Œå¦‚æœæœªå‡ºç°è´Ÿå€¼åœˆ dist æ•°ç»„å³æ»¡è¶³æ¡ä»¶çš„ä¸€ç»„è§£ï¼Œåä¹‹ä¸ç­‰å¼ç»„æ— è§£ã€‚ ç”±äºå·®åˆ†çº¦æŸç³»ç»Ÿå¯èƒ½å‡ºç°è´Ÿæƒè¾¹å’Œè´Ÿå€¼åœˆï¼Œæ‰€ä»¥åŸºæœ¬åªèƒ½ç”¨ SPFA ç®—æ³•è§£å†³ã€‚ $x_j - x_i \leq kâ€‹$ æ±‚æœ€çŸ­è·¯å˜å½¢ä¸º $x_i +k \geq x_jâ€‹$ ä» $iâ€‹$ åˆ° $jâ€‹$ è¿ä¸€æ¡æƒå€¼ä¸º $kâ€‹$ çš„è¾¹ æ±‚æœ€çŸ­è·¯å˜å½¢ä¸º $x_j - k \leq x_i$ ä» $j$ åˆ° $i$ è¿ä¸€æ¡æƒå€¼ä¸º $-k$ çš„è¾¹ ä¼˜åŒ–SPFA ç®—æ³•æœ‰ä¸¤ç§ä¼˜åŒ–æ–¹å¼ SLFï¼šSmall Label First ç­–ç•¥ LLLï¼šLarge Label Last ç­–ç•¥ SLF å¯ä½¿é€Ÿåº¦æå‡ $15\sim20\%$ï¼›SLF + LLL å¯æé«˜çº¦ $50\%$ SLFè®¾è¦å…¥é˜Ÿçš„é¡¶ç‚¹ä¸º $j$ ï¼Œé˜Ÿé¦–å…ƒç´ ä¸º $i$ ï¼Œè‹¥ $dist[j] &lt; dist[i]$ ï¼Œåˆ™å°† $j$ ä»é˜Ÿé¦–å…¥é˜Ÿï¼Œåä¹‹ä»é˜Ÿå°¾å…¥é˜Ÿã€‚ å®ç°ä¸Šéœ€è¦åœ¨é˜Ÿé¦–æ’å…¥å…ƒç´ ï¼Œéœ€è¦å°†å®¹å™¨ä» queue æ”¹ä¸º deque åŒç«¯é˜Ÿåˆ—ã€‚ ä»£ç 1234567891011121314151617181920212223242526272829void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; inq[s] = true; deque&lt;int&gt; que; que.push_back(s); while (!que.empty()) &#123; int u = que.front(); que.pop_front(); inq[u] = false; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &gt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; if(dist[i] &lt; dist[que.front()])&#123; que.push_front(v); &#125;else&#123; que.push_back(v); &#125; inq[v] = true; &#125; &#125; &#125; &#125;&#125; LLLè®¾é˜Ÿé¦–å…ƒç´ ä¸º $i$ ï¼Œé˜Ÿåˆ—ä¸­æ‰€æœ‰æœ€çŸ­è·ç¦»å€¼çš„å¹³å‡å€¼ä¸º $x$ ï¼Œè‹¥ $d[i] &gt; x$ åˆ™å°†å…¶æ’å…¥åˆ°é˜Ÿå°¾ï¼ŒæŸ¥æ‰¾ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°æ‰¾åˆ°æŸä¸€é¡¶ç‚¹ $i$ ä½¿å¾— $d[i] &lt; x$ ï¼Œåˆ™å°† $i$ å‡ºé˜Ÿè¿›è¡Œæ¾å¼›æ“ä½œã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); int sum = 0,cnt = 1; // ** dist[s] = 0; inq[s] = true; deque&lt;int&gt; que; que.push_back(s); while (!que.empty()) &#123; int u = que.front(); que.pop_front(); inq[u] = false; if(dist[u] * cnt &gt; sum)&#123; que.push_back(u); continue; &#125; sum -= dist[u]; // ** cnt--; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &gt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; que.push_back(v); inq[v] = true; sum += dist[v]; // ** cnt++; &#125; &#125; &#125; &#125;&#125; SLF + LLLç»¼åˆ SLF ç­–ç•¥å’Œ LLL ç­–ç•¥ 1234567891011121314151617181920212223242526272829303132333435363738void spfa(int s) &#123; memset(inq, false, sizeof(inq)); memset(dist, 0x3f, sizeof(dist)); int sum = 0,cnt = 1; dist[s] = 0; inq[s] = true; deque&lt;int&gt; que; que.push_back(s); while (!que.empty()) &#123; int u = que.front(); que.pop_front(); inq[u] = false; if(dist[u] * cnt &gt; sum)&#123; // LLL que.push_back(u); continue; &#125; sum -= dist[u]; cnt--; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].next; if (dist[u] + G[u][i].weight &gt; dist[v]) &#123; dist[v] = dist[u] + G[u][i].weight; if (!inq[v]) &#123; // SLF if(dist[i] &lt; dist[que.front()])&#123; que.push_front(v); &#125;else&#123; que.push_back(v); &#125; inq[v] = true; sum += dist[v]; cnt++; &#125; &#125; &#125; &#125;&#125; å¤æ‚åº¦åˆ†æè®¾ $V$ ä»£è¡¨ç»“ç‚¹çš„ä¸ªæ•°ï¼Œ$E$ ä»£è¡¨è¾¹çš„ä¸ªæ•°ã€‚ ç©ºé—´å¤æ‚åº¦é™¤å»é‚»æ¥è¡¨çš„ç©ºé—´å ç”¨ï¼ŒSPFA ç®—æ³•é¢å¤–ç©ºé—´å¼€é”€æ˜¾ç„¶ä¸º $O(V)$ æ—¶é—´å¤æ‚åº¦å¦‚æœé¡¶ç‚¹çš„å¹³å‡å…¥é˜Ÿæ¬¡æ•°ä¸º $k$ ï¼Œåˆ™ SPFA ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(kE)$ï¼Œå¯¹äºè¾ƒä¸ºéšæœºçš„ç¨€ç–å›¾ï¼Œæ ¹æ®ç»éªŒ $k$ ä¸€èˆ¬ä¸è¶…è¿‡ $4$ ã€‚ SPFA çš„æœ¬è´¨æ˜¯ Bellman-Ford ç®—æ³•çš„é˜Ÿåˆ—ä¼˜åŒ–ï¼Œæœ¬è´¨ä¸Šæ²¡æœ‰æ”¹å˜ Bellman-Ford ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼Œå¯¹äºç¨ å¯†å›¾æ¥è¯´ï¼ŒSPFA æœ€åä»æ˜¯ $O(VE)$ çš„æ—¶é—´å¤æ‚åº¦ï¼Œè¿œå·®äº Dijkstra ç®—æ³•çš„ $O( (V + E) \log V )$ å¤æ‚åº¦ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ACM</tag>
        <tag>ä¼˜å…ˆé˜Ÿåˆ—</tag>
        <tag>SPFA</tag>
        <tag>Bellman-Ford</tag>
        <tag>æœ€çŸ­è·¯å¾„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œä¹¦æ‘˜ã€ã€Šæ·±åº¦æ¢ç´¢ C++ å¯¹è±¡æ¨¡å‹ã€‹ï¼ˆä¸‰ï¼‰]]></title>
    <url>%2F2018%2F12%2F21%2Finside_cpp_obj_model_3%2F</url>
    <content type="text"><![CDATA[Data è¯­æ„å­¦ (The Semantics of Data)1234class X &#123;&#125;;class Y : public virtual X&#123;&#125;;class Z : public virtual X&#123;&#125;;class A : public Y, public Z&#123;&#125;; Y å’Œ Z çš„å¤§å°ä¸æœºå™¨ï¼ˆå­—é•¿ï¼‰æœ‰å…³ï¼Œä¹Ÿå’Œç¼–è¯‘å™¨æœ‰å…³ï¼Œå…·ä½“å—ä»¥ä¸‹ä¸‰ä¸ªå› ç´ çš„å½±å“ï¼š è¯­è¨€æœ¬èº«æ‰€é€ æˆçš„é¢å¤–è´Ÿæ‹…ï¼ˆoverheaï¼‰ ç¼–è¯‘å™¨å¯¹äºç‰¹æ®Šæƒ…å†µæ‰€æä¾›çš„ä¼˜åŒ–å¤„ç† Alignment çš„é™åˆ¶ class A çš„å¤§å°ç”±ä¸‹åˆ—å‡ ç‚¹å†³å®šï¼š è¢«å¤§å®¶å…±äº«çš„å”¯ä¸€ä¸€ä¸ª class X å®ä¾‹ï¼Œå¤§å°ä¸º 1 byteã€‚ Base class Y å’Œ Base class Y çš„å¤§å°ï¼Œå‡å»â€œå›  virtual base class X è€Œé…ç½®â€ çš„å¤§å°ï¼Œç»“æœå¼ 4 bytesã€‚ class A è‡ªå·±çš„å¤§å°ï¼š0 byteã€‚ class A çš„ alignment æ•°é‡ï¼ˆå¦‚æœæœ‰çš„åŒ–ï¼‰ã€‚ç»“æœä¸º 12 bytes â€ç‰¹åˆ«å¯¹ empty virual base class åšäº†å¤„ç†â€œ çš„ç¼–è¯‘å™¨ï¼Œclass X å®ä¾‹çš„é‚£ 1 byte å°†è¢«æ‹¿æ‰ï¼Œclass A çš„å¤§å°å°†æ˜¯ 8 bytesã€‚ ç»§æ‰¿å¾—åˆ°çš„æ•°æ®çš„å­˜æ”¾é¡ºåºï¼ŒC++æ ‡å‡†æ²¡æœ‰å¼ºåˆ¶å®šä¹‰å…¶é—´çš„æ’åˆ—é¡ºåºã€‚ Data Member çš„ç»‘å®š (The Binding of a Data Member)123456789101112extern int x;class Point3d&#123;public: ... // å¯¹äºå‡½æ•°æœ¬ä½“çš„åˆ†æå°†å»¶è¿Ÿï¼Œç›´è‡³ class å£°æ˜çš„å³å¤§æ‹¬å·å‡ºç°æ‰å¼€å§‹ã€‚ float X() const &#123; return x; &#125;private: float x; ...&#125;;// åˆ†æåœ¨è¿™é‡Œè¿›è¡Œ member function çš„ argument list ä¼šåœ¨ç¬¬ä¸€æ¬¡é­é‡æ—¶è¢«é€‚å½“åœ°å†³è®®å®Œæˆã€‚extern å’Œ nested type names ä¹‹é—´çš„éç›´è§‰ç»‘å®šæ“ä½œè¿˜æ˜¯ä¼šå‘ç”Ÿã€‚1234567891011typedef int length;class Point3d&#123;public: void mumble( length val ) &#123; _val = val; &#125; // length ä¸º int length mumble() &#123; return _val; &#125;private: typedef float length; length _val;&#125;; é‡‡ç”¨é˜²å¾¡æ€§ç¨‹åºé£æ ¼æ”¹è¿›å123456789101112typedef int length;class Point3d&#123;private: typedef float length;public: void mumble( length val ) &#123; _val = val; &#125; // length ä¸º float length mumble() &#123; return _val; &#125;private: length _val;&#125;; è¯·æ€»æ˜¯æŠŠ â€œnested type å£°æ˜â€ æ”¾åœ¨ class çš„èµ·å§‹å¤„ã€‚ Data Member çš„å¸ƒå±€ (Data Member Layout)C++ Standard è¦æ±‚ï¼Œåœ¨åŒä¸€ä¸ª access sectionï¼ˆä¹Ÿå°±æ˜¯ privateã€‚publicï¼Œprotected ç­‰åŒºæ®µï¼‰ä¸­ï¼Œmembers çš„æ’åˆ—åªéœ€ç¬¦åˆâ€œè¾ƒæ™šå‡ºç°çš„ members åœ¨ class object ä¸­æœ‰è¾ƒé«˜çš„åœ°å€â€è¿™ä¸€æ¡ä»¶å³å¯ã€‚ åˆ¤æ–­å“ªä¸ª section å…ˆå‡ºç°çš„ template functionï¼š12345678910template &lt; class class_type, class data_type1, class data_type2 &gt;const char* access_order( data_type1 class_type::*mem1, data_type2 class_type::*mem2 )&#123; assert (mem1 != mem2); return mem1 &lt; mem2 ? "member 1 occurs first" : "member 1 occurs first";&#125; è°ƒç”¨ï¼šaccess_order( &amp;Point3d::z, &amp;Point3d::y ); Data Member çš„å­˜å–12Point origin;Point *pt = &amp;origin; 12origin.x = 0.0;pt-&gt;x = 0.0; é€šè¿‡ origin å­˜å–ï¼Œå’Œé€šè¿‡ pt å­˜å–çš„å·®å¼‚å°†åœ¨æœ¬èŠ‚å¾—å‡ºç­”æ¡ˆã€‚ Static Data Memberæ¯ä¸ª static member çš„å­˜å–è®¸å¯ï¼Œä»¥åŠä¸ class çš„å…³è”ï¼Œå¹¶ä¸ä¼šæ‹›è‡´ä»»ä½•ç©ºé—´ä¸Šæˆ–æ‰§è¡Œæ—¶é—´ä¸Šçš„é¢å¤–è´Ÿæ‹…ï¼Œä¸è®ºæ˜¯åœ¨ä¸ªåˆ«çš„ class objects è¿˜æ˜¯åœ¨ static data member æœ¬èº«ã€‚ Nonstatic Data MemberNonstatic Data Member ç›´æ¥å­˜æ”¾åœ¨æ¯ä¸€ä¸ª class object ä¹‹ä¸­ã€‚é™¤éç»ç”±æ˜¾å¼çš„ï¼ˆexplicitï¼‰æˆ–éšå¼çš„ï¼ˆimplicitï¼‰class objectï¼Œå¦åˆ™æ²¡æœ‰åŠæ³•ç›´æ¥å­˜å–å®ƒä»¬ã€‚ 123456Point 3dPoint 3d::translate( const Point3d &amp;pt)&#123; x += pt.x; y += pt.y; z += pt.z;&#125; è¡¨é¢ä¸Šæ‰€çœ‹åˆ°çš„å¯¹äº x,y,z çš„ç›´æ¥å­˜å–ï¼Œäº‹å®ä¸Šæ˜¯ç»ç”±ä¸€ä¸ªâ€œimplicit class objectâ€ï¼ˆç”± this æŒ‡é’ˆè¡¨è¾¾ï¼‰å®Œæˆçš„ã€‚äº‹å®ä¸Šè¿™ä¸ªå‡½æ•°çš„å‚æ•°æ˜¯ï¼š123456Point 3dPoint 3d::translate( Point3d *const this, const Point3d &amp;pt)&#123; this-&gt;x += pt.x; this-&gt;y += pt.y; this-&gt;z += pt.z;&#125; æ¬²å¯¹ä¸€ä¸ª nonstatic data member è¿›è¡Œå­˜å–æ“ä½œï¼Œç¼–è¯‘å™¨éœ€è¦æŠŠ class object çš„èµ·å§‹åœ°å€åŠ ä¸Š data member çš„åç§»ä½ç½®ï¼ˆoffsetï¼‰ã€‚origin._y = 0.0; ä¼šè½¬åŒ–ä¸º &amp;origin + (&amp;Point3d::_y - 1);ã€‚è¯·æ³¨æ„å…¶ä¸­çš„ -1æ“ä½œã€‚æŒ‡å‘ data member çš„æŒ‡é’ˆï¼Œå…¶ offset å€¼æ€»æ˜¯è¢«åŠ ä¸Š 1ï¼Œè¿™æ ·å¯ä»¥ä½¿ç¼–è¯‘ç³»ç»ŸåŒºåˆ†å‡ºâ€œä¸€ä¸ªæŒ‡å‘ data member çš„æŒ‡é’ˆï¼Œç”¨ä»¥æŒ‡å‡º class çš„ç¬¬ä¸€ä¸ª memberâ€ å’Œ â€œä¸€ä¸ªæŒ‡å‘ data members çš„æŒ‡é’ˆï¼Œæ²¡æœ‰æŒ‡å‡ºä»»ä½• memberâ€ ä¸¤ç§æƒ…å†µã€‚ æ¯ä¸€ä¸ª nonstatic data member çš„åç§»ä½ç½®ï¼ˆoffsetï¼‰åœ¨ç¼–è¯‘æ—¶æœŸå³å¯è·çŸ¥ï¼Œç”šè‡³å¦‚æœ member å±äºä¸€ä¸ª base class subobjectï¼ˆæ´¾ç”Ÿè‡ªå•ä¸€æˆ–å¤šé‡ç»§æ‰¿ä¸²é“¾ï¼‰ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚å­˜å–ä¸€ä¸ª nonstatic data member ï¼Œå…¶æ•ˆç‡å’Œå­˜å–ä¸€ä¸ª C struct member æˆ– ä¸€ä¸ª nonderived class çš„ member æ˜¯ä¸€æ ·çš„ã€‚ Nonstatic Data Member åœ¨è™šæ‹Ÿç»§æ‰¿ä¸­è™šæ‹Ÿç»§æ‰¿å°†ä¸ºâ€œç»ç”± base class subobject å­˜å– class memberâ€œ å¯¼å…¥ä¸€å±‚æ–°çš„é—´æ¥æ€§ï¼š12Point3d *pt3d;pt3d-&gt;_x = 0.0; å…¶æ‰§è¡Œæ•ˆç‡åœ¨ _x æ˜¯ä¸€ä¸ª struct memberã€ä¸€ä¸ª class memberã€å•ä¸€ç»§æ‰¿ã€å¤šé‡ç»§æ‰¿çš„æƒ…å†µä¸‹éƒ½å®Œå…¨ç›¸åŒã€‚ä½†å¦‚æœ _x æ˜¯ä¸€ä¸ª virtual base class çš„ member ï¼Œå­˜å–é€Ÿåº¦ä¼šç¨æ…¢ä¸€ç‚¹ã€‚ origin._y = 0.0; ä¼šè½¬åŒ–ä¸º &amp;origin + (&amp;Point3d::_y - 1);å½“ Point3d æ˜¯ä¸€ä¸ª derived classï¼Œè€Œå…¶ç»§æ‰¿ç»“æ„ä¸­æœ‰ä¸€ä¸ª virtual base classï¼Œå¹¶ä¸”è¢«å­˜å–çš„ memberï¼ˆå¦‚æœ¬ä¾‹çš„ x ï¼‰æ˜¯ä¸€ä¸ªä»è¯¥ virtual base class ç»§æ‰¿è€Œæ¥çš„ member æ—¶ï¼Œå°±ä¼šæœ‰é‡å¤§çš„å·®å¼‚ã€‚è¿™æ—¶å€™æˆ‘ä»¬ä¸èƒ½è¯´ pt å¿…ç„¶æŒ‡å‘å“ªä¸€ç§ class typeï¼ˆå› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå°±ä¸çŸ¥é“ç¼–è¯‘æ—¶æœŸè¿™ä¸ª member çœŸæ­£çš„ offset ä½ç½®ï¼‰ï¼Œæ‰€ä»¥è¿™ä¸ªå­˜å–æ“ä½œå¿…é¡»å»¶è¿Ÿè‡³æ‰§è¡ŒæœŸï¼Œç»ç”±ä¸€ä¸ªé¢å¤–çš„é—´æ¥å¯¼å¼•ï¼Œæ‰èƒ½å¤Ÿè§£å†³ã€‚ä½†å¦‚æœä½¿ç”¨ origin ï¼Œå°±ä¸ä¼šæœ‰è¿™äº›é—®é¢˜ï¼Œmembers çš„ offset ä½ç½®åœ¨ç¼–è¯‘æ—¶æœŸå°±å›ºå®šäº†ã€‚ â€œç»§æ‰¿â€ ä¸ Data Memberderived class members å’Œ base class(es) members çš„æ’åˆ—é¡ºåºï¼Œåˆ™å¹¶æœªåœ¨ C++ Standard ä¸­å¼ºåˆ¶æŒ‡å®šï¼›ç†è®ºä¸Šç¼–è¯‘å™¨å¯ä»¥è‡ªç”±å®‰æ’ã€‚åœ¨å¤§å¤šæ•°ç¼–è¯‘å™¨ä¸Šå¤´ï¼Œbase class members æ€»æ˜¯å…ˆå‡ºç°ï¼Œä½†å±äº virtual base class çš„é™¤å¤–ï¼ˆä¸€èˆ¬è€Œè¨€ï¼Œä»»ä½•ä¸€æ¡é€šåˆ™ä¸€æ—¦ç¢°ä¸Š virtual base class å°±æ²¡è¾™äº†ï¼Œè¿™é‡Œäº¦ä¸ä¾‹å¤–ï¼‰ã€‚ åªè¦ç»§æ‰¿ä¸è¦å¤šæ€ (Inheritance without Polymorphism)ä¸€èˆ¬è€Œè¨€ï¼Œå…·ä½“ç»§æ‰¿ï¼ˆconcrete inheritanceï¼‰ç›¸å¯¹è™šæ‹Ÿç»§æ‰¿ï¼ˆvirtual inheritanceï¼‰å¹¶ä¸ä¼šå¢åŠ ç©ºé—´æˆ–å­˜å–æ—¶é—´ä¸Šçš„é¢å¤–è´Ÿæ‹…ã€‚ C++è¯­è¨€ä¿è¯â€œå‡ºç°åœ¨ derived class ä¸­çš„ base class subobject æœ‰å…¶å®Œæ•´åŸæ ·æ€§â€ã€‚å› ä¸ºè¦ä¿è¯ bitwise æ‹·è´çš„æ­£ç¡®æ€§ã€‚ 123456class Concrete&#123; int val; char c1; char c2; char c3;&#125;; val å ç”¨ 4 bytesï¼› c1ã€c2å’Œc3 å„å ç”¨ 1 bytesï¼› alignmentï¼ˆè°ƒæ•´åˆ° word è¾¹ç•Œï¼‰éœ€è¦ 1 byteã€‚ 12345678910class Concrete1 &#123; int val; char c1;&#125;;class Concrete2 : public Concrete1 &#123; char c2;&#125;;class Concrete3 : public Concrete2 &#123; char c3;&#125;; Concrete1 å ç”¨ 8 bytesï¼ŒåŒ…æ‹¬å¡«è¡¥ç”¨çš„ 3 bytesã€‚ Concrete2 å ç”¨ 12 bytesï¼Œå¡«è¡¥ 3 bytesã€‚ Concrete3 å ç”¨ 16 bytesï¼Œå¡«è¡¥ 3 bytesã€‚ åŠ ä¸Šå¤šæ€ (Adding Polymorphism)Polymorphism å¸¦æ¥ç©ºé—´å’Œå­˜å–æ—¶é—´ä¸Šçš„é¢å¤–è´Ÿæ‹… å¯¼å…¥ä¸€ä¸ª virtual tableï¼Œç”¨æ¥å­˜å–å®ƒæ‰€å£°æ˜çš„æ¯ä¸€ä¸ª virtual functions çš„åœ°å€ã€‚è¿™ä¸ª table çš„å…ƒç´ ä¸ªæ•°ä¸€èˆ¬è€Œè¨€æ˜¯è¢«å£°æ˜çš„ virtual functions çš„ä¸ªæ•°ï¼Œå†åŠ ä¸Šä¸€ä¸ªæˆ–ä¸¤ä¸ª slotsï¼ˆç”¨ä»¥æ”¯æŒ runtime tyoe identifitionï¼‰ã€‚ åœ¨æ¯ä¸€ä¸ª class object ä¸­å¯¼å…¥ä¸€ä¸ª vptrï¼Œæä¾›æ‰§è¡Œå™¨çš„é“¾æ¥ï¼Œä½¿æ¯ä¸€ä¸ª object èƒ½å¤Ÿæ‰¾åˆ°ç›¸åº”çš„ virtual tableã€‚ åŠ å¼º constructorï¼Œä½¿å®ƒèƒ½å¤Ÿä¸º vptr è®¾å®šåˆå€¼ï¼Œè®©å®ƒæŒ‡å‘ class æ‰€å¯¹åº”çš„ virtual tableã€‚è¿™å¯èƒ½æ„å‘³ç€åœ¨ derived class å’Œæ¯ä¸€ä¸ª base class çš„ constructor ä¸­ï¼Œé‡æ–°è®¾å®š vptr çš„å€¼ã€‚å…¶æƒ…å†µè§†ç¼–è¯‘å™¨ä¼˜åŒ–çš„ç§¯ææ€§è€Œå®šã€‚ åŠ å¼º destructorï¼Œä½¿å®ƒèƒ½å¤ŸæŠ¹æ¶ˆâ€œæŒ‡å‘ class ä¹‹ç›¸å…³ virtual tableâ€ çš„ vptrã€‚vptr å¾ˆå¯èƒ½å·²ç»åœ¨ derived class destructor ä¸­è¢«è®¾å®šä¸º derived class çš„ virtual table çš„åœ°å€ã€‚destructor çš„è°ƒç”¨çš„é¡ºåºä¸Šåå‘çš„ï¼šä» derived class åˆ° base classï¼Œä¸€ä¸ªç§¯æçš„ä¼˜åŒ–ç¼–è¯‘å™¨å¯ä»¥å‹æŠ‘é‚£äº›å¤§é‡çš„åˆ¶å®šæ“ä½œã€‚ vptr æ”¾åœ¨å‰ç«¯ï¼Œä»£ä»·æ˜¯ä¸§å¤±äº† C è¯­è¨€å…¼å®¹æ€§ã€‚ å¤šé‡ç»§æ‰¿ (Multiple Inheritance)â€¦â€¦ è™šæ‹Ÿç»§æ‰¿ (Virtual Inheritance)è™šæ‹Ÿç»§æ‰¿çš„ä¸¤ä¸ªé—®é¢˜ æ¯ä¸€ä¸ªå¯¹è±¡å¿…é¡»é’ˆå¯¹å…¶æ¯ä¸€ä¸ª virtual base class èƒŒè´Ÿä¸€ä¸ªé¢å¤–çš„æŒ‡é’ˆï¼Œç„¶è€Œç†æƒ³ä¸Šæˆ‘ä»¬å¸Œæœ› class object æœ‰å›ºå®šè´Ÿæ‹…ï¼Œä¸å› ä¸ºå…¶ virtual base classes çš„ä¸ªæ•°è€Œæœ‰æ‰€å˜åŒ–ã€‚ ç”±äºè™šæ‹Ÿç»§æ‰¿ä¸²é“¾çš„åŠ é•¿ï¼Œå¯¼è‡´é—´æ¥å­˜å–å±‚æ¬¡çš„å¢åŠ ã€‚æˆ‘ä»¬å¸Œæœ›æœ‰å›ºå®šçš„å­˜å–æ—¶é—´ï¼Œä¸å› ä¸ºè™šæ‹Ÿæ´¾ç”Ÿçš„æ·±åº¦è€Œæ”¹å˜ã€‚ ç¬¬ä¸€ä¸ªé—®é¢˜ä¸¤ç§è§£å†³åŠæ³•ï¼š Microsoft ç¼–è¯‘å™¨å¼•å…¥çš„ virtual base class tableã€‚ åœ¨ virtual function table ä¸­æ”¾ç½® virtual base class çš„ offsetï¼ˆä¸æ˜¯åœ°å€ï¼‰ï¼Œåœ¨ Sun ç¼–è¯‘å™¨ä¸­ï¼Œvirtual function table å¯ç»ç”±æ­£å€¼æˆ–è´Ÿå€¼æ¥ç´¢å¼•ï¼Œå¦‚æœæ˜¯æ­£å€¼ç´¢å¼•åˆ° virtual function ï¼Œå¦‚æœæ˜¯è´Ÿå€¼ç´¢å¼•åˆ° virtual base class offsetã€‚ ç¬¬äºŒä¸ªé—®é¢˜ï¼Œå®ƒä»¬ç»ç”±æ‹·è´æ“ä½œå–å¾—æ‰€æœ‰çš„ nested virtual base class æŒ‡é’ˆï¼Œæ”¾åˆ°çš„ derived class object ä¹‹ä¸­ã€‚ å¯¹è±¡æˆå‘˜çš„æ•ˆç‡ (Object Member Efficiency)èšåˆï¼ˆaggregtionï¼‰å°è£…ï¼ˆencapsulationï¼‰ç»§æ‰¿ï¼ˆinheritanceï¼‰ ä¸æ–­åŠ å¼ºæŠ½è±¡åŒ–ç¨‹åº¦åï¼Œæ•°æ®çš„å­˜å–æ•ˆç‡ ä¼˜åŒ– æœªä¼˜åŒ– ä¸ªåˆ«çš„å±€éƒ¨å˜é‡ 0.80 1.42 å±€éƒ¨æ•°ç»„ CC 0.80 2.55 NCC 0.80 1.42 struct ä¹‹ä¸­æœ‰ public æˆå‘˜ 0.80 1.42 class ä¹‹ä¸­æœ‰ inline Get å‡½æ•° CC 0.80 2.56 NCC 0.80 3.10 class ä¹‹ä¸­æœ‰ inline Get &amp; Set å‡½æ•° CC 0.80 1.74 NCC 0.80 2.87 å¦‚æœæŠŠä¼˜åŒ–å¼€å…³æ‰“å¼€ï¼Œâ€œå°è£…â€å°±ä¸ä¼šå¸¦æ¥æ‰§è¡Œå™¨çš„æ•ˆç‡æˆæœ¬ï¼Œä½¿ç”¨ inline å­˜å–å‡½æ•°äº¦ç„¶ã€‚ ä¸ºä»€ä¹ˆåœ¨ CC ä¹‹ä¸‹å­˜å–æ•°ç»„ï¼Œå‡ ä¹æ¯” NCC æ…¢ä¸¤å€ï¼Ÿ12345678// CC assembler output# 13 pB[ x ] = pA[ x ] - pB[ x ]; add $25, $sp, 20 1.s $f4, 0($25) addu $24, $sp, 8 1.s $f6, 8($24) sub.s $f8, $f4, $f6 s.s $f8, 0($24) 123456// NCC assembler output# 13 pB[ x ] = pA[ x ] - pB[ x ]; 1.s $f4, 20($25) 1.s $f6, 16($24) sub.s $f8, $f4, $f6 s.s $f8, 0($24) 1.s åŠ è½½ä¸€ä¸ªå•ç²¾åº¦æµ®ç‚¹æ•° s.s å­˜å‚¨ä¸€ä¸ªå•ç²¾åº¦æµ®ç‚¹æ•° sub.s å°†ä¸¤ä¸ªå•ç²¾åº¦æµ®ç‚¹æ•°ç›¸å‡ åœ¨ç»§æ‰¿æ¨¡å‹ä¹‹ä¸‹çš„æ•°æ®å­˜å– ä¼˜åŒ– æœªä¼˜åŒ– å•ä¸€ç»§æ‰¿ ç›´æ¥å­˜å– 0.80 1.42 ä½¿ç”¨ inline å‡½æ•° CC 0.80 2.55 NCC 0.80 3.10 è™šæ‹Ÿç»§æ‰¿ï¼ˆå•å±‚ï¼‰ ç›´æ¥å­˜å– 1.60 1.94 ä½¿ç”¨ inline å‡½æ•° CC 1.60 2.75 NCC 1.60 3.30 è™šæ‹Ÿç»§æ‰¿ï¼ˆåŒå±‚ï¼‰ ç›´æ¥å­˜å– CC 2.25 2.74 NCC 3.04 3.68 ä½¿ç”¨ inline å‡½æ•° CC 2.25 3.22 NCC 2.50 3.81 æŒ‡å‘ Data Member çš„æŒ‡é’ˆ (Pointer to Data Members)1234567class Point3d&#123;public: virtual ~Point3d(); static Point3d origin; float x, y, z;&#125;;&amp;Point3d::z // å¾—åˆ° z åœ¨ class object ä¸­çš„ offset è¾“å‡º offset123printf("%p\n",&amp;Point3d::x);printf("%p\n",&amp;Point3d::y);printf("%p\n",&amp;Point3d::z); æ—©æœŸä¸€äº›ç¼–è¯‘å™¨ &amp;Point3d::z è¿™ä¸ªæ“ä½œçš„å€¼ä¸º z çš„ offset + 1ã€‚123float Point3d::*p1 = 0;float Point3d::*p2 = &amp;Point3d:x;// Point3d::* çš„æ„æ€æ˜¯ "æŒ‡å‘ Point3d data member" çš„æŒ‡é’ˆç±»å‹ 1234if(p1 == p2) &#123; cout &lt;&lt; " p1 &amp; p2 contain the same value -- "; cout &lt;&lt; " they must address the same member!" &lt;&lt; endl;&#125; å¯¹ offset åŠ  1ï¼Œæ–¹ä¾¿åŒºåˆ† NULL å’Œç¬¬ä¸€ä¸ª data memberã€‚ 1234567891011121314151617struct Base1&#123; int val1; &#125;;struct Base2&#123; int val2; &#125;;struct Derived : Base1, Base2&#123;&#125;;void func1( int Derived::*dmp, Derived *pd)&#123; pd-&gt;*dmp;&#125;void func2( Derived *pd)&#123; // bmp ä¸º 1 int Base2::*bmp = &amp;Base2::val2; // bmp == 1 // ä½†åœ¨ Derived ä¸­ï¼Œ val2 == 5 func1(bmp,pd);&#125; 12// ç»ç”±ç¼–è¯‘å™¨å†…éƒ¨è½¬æ¢func1( bmp + sizeof( Base1 ), pd ); ä¸€èˆ¬è€Œè¨€ï¼Œæˆ‘ä»¬ä¸èƒ½å¤Ÿä¿è¯ bmp ä¸æ˜¯ 0ï¼Œå› æ­¤å¿…é¡»æ³¨æ„è¿™ä¸€ç‚¹ï¼š1func1( bmp ? bmp + sizeof( Base1 ) : 0, pd ); æˆ‘çš„æµ‹è¯•ç¨‹åºï¼š1234567891011121314151617181920212223242526272829struct Base1&#123; int val1; &#125;;struct Base2&#123; int val2; &#125;;struct Derived : Base1, Base2&#123;&#125;;int func1( int Derived::*dmp, Derived *pd)&#123; printf("%p\n",dmp); return pd-&gt;*dmp;&#125;int func2( Derived *pd)&#123; int Base2::*bmp = &amp;Base2::val2; printf("%p\n",bmp); return func1(bmp,pd);&#125;int main()&#123; Derived xx; xx.val1 = 11; xx.val2 = 22; cout &lt;&lt; func2(&amp;xx) &lt;&lt; endl; return 0;&#125; â€œæŒ‡å‘ Data Member çš„æŒ‡é’ˆâ€ çš„æ•ˆç‡é—®é¢˜å­˜å– Nonstatic Data Member ä¼˜åŒ– æœªä¼˜åŒ– ç›´æ¥å­˜å– 0.80 1.42 æŒ‡é’ˆæŒ‡å‘å·²ç»‘å®šçš„ Member 0.80 3.04 æŒ‡é’ˆæŒ‡å‘ Data Member CC 0.80 5.34 NCC 4.04 5.34 â€œæŒ‡å‘ Data Member çš„æŒ‡é’ˆâ€å­˜å–æ–¹å¼ ä¼˜åŒ– æœªä¼˜åŒ– æ²¡æœ‰ç»§æ‰¿ 0.80 5.34 å•ä¸€ç»§æ‰¿ï¼ˆä¸‰å±‚ï¼‰ 0.80 5.34 è™šæ‹Ÿç»§æ‰¿ï¼ˆå•å±‚ï¼‰ 1.60 5.44 è™šæ‹Ÿç»§æ‰¿ï¼ˆåŒå±‚ï¼‰ 2.14 5.51 åœ¨ä¸¤ä¸ªç¼–è¯‘å™¨ä¸­ï¼Œæ¯æ¬¡å­˜å– Point::xï¼Œåƒè¿™æ ·ï¼š pB.*bx ä¼šè¢«è½¬æ¢ä¸ºï¼š1&amp;pB-&gt;__vbcPoint + ( bx - 1 ) è€Œä¸æ˜¯è½¬æ¢ä¸ºæœ€ç›´æ¥çš„ï¼š1&amp;pB + ( bx - 1 ) é¢å¤–çš„é—´æ¥æ€§ä¼šé™ä½â€œæŠŠæ‰€æœ‰çš„å¤„ç†éƒ½æ¬ç§»åˆ°å¯„å­˜å™¨ä¸­æ‰§è¡Œâ€çš„ä¼˜åŒ–èƒ½åŠ›ã€‚]]></content>
      <categories>
        <category>æ³› - ä¹¦æ‘˜</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€ã€ŠEffective C++ã€‹ è¯»ä¹¦ç¬”è®°ï¼ˆä¸‰ï¼‰]]></title>
    <url>%2F2018%2F12%2F19%2Feffective-cpp03%2F</url>
    <content type="text"><![CDATA[æ³¨æ„ï¼è¿™åªæ˜¯æˆ‘çš„è¯»ä¹¦ç¬”è®°ï¼Œå¸®åŠ©æˆ‘è®°å½•ã€‚å…¶ä¸­å¯èƒ½æœ‰ä¸€äº›ä¸ä¸¥è°¨çš„è§£é‡Šæˆ–æ²¡æœ‰åšå¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå¤§å®¶å­¦ä¹ è¿˜æ˜¯å»ºè®®ç›´æ¥çœ‹ä¹¦ï¼ˆè™½ç„¶ä¹¦ä¸­ä¹Ÿæœ‰ä¸ä¸¥è°¨çš„è§£é‡Šï¼‰ã€‚ èµ„æºç®¡ç†æ¡æ¬¾ 13ï¼šä»¥å¯¹è±¡ç®¡ç†èµ„æº123456void f()&#123; Investment* pInv = creteInvestment(); // è°ƒç”¨ factory å‡½æ•° ... delete pInv; // é‡Šæ”¾ pInv æ‰€æŒ‡å¯¹è±¡&#125; ... å¯èƒ½å­˜åœ¨è¿‡æ—©çš„ return è¯­å¥ï¼Œæˆ–æŠ›å‡ºæŸäº›å¼‚å¸¸ï¼Œdelete è¯­å¥å°†ä¸ä¼šè¢«æ‰§è¡Œã€‚ç±»ä¼¼çš„ goto è¯­å¥æˆ–å¾ªç¯ä¸­çš„ continue å’Œ breakã€‚ ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œåˆ©ç”¨æ ˆä¸­å¯¹è±¡çš„ææ„å‡½æ•°è‡ªåŠ¨å¯¹å…¶ deleteã€‚ 123456void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); ...&#125; è·å¾—èµ„æºåç«‹åˆ»æ”¾è¿›ç®¡ç†å¯¹è±¡ï¼ˆmanaging objectï¼‰ ç®¡ç†å¯¹è±¡ï¼ˆmanaging objectï¼‰è¿ç”¨ææ„å‡½æ•°ç¡®ä¿èµ„æºè¢«é‡Šæ”¾ å¸¸ä½¿ç”¨çš„ RAII classes ï¼štr1::shared_ptr å’Œ auto_ptr ã€‚ æ¡æ¬¾ 14ï¼šåœ¨èµ„æºç®¡ç†ç±»ä¸­å°å¿ƒ copying è¡Œä¸º12345678910111213class Lock&#123;public: explicit Lock(Mutex* pm) : mutexPtr(pm) &#123; lock(muterPtr); &#125; ~Lock() &#123; unlock(mutexPtr); &#125;private: Mutex *mutexPtr;&#125; 1234Mutex m;Lock ml1(&amp;m);Lock ml2(ml1); RAII classes åº”è¢«ç¦æ­¢å¤åˆ¶æˆ–é‡‡ç”¨â€œå¼•ç”¨è®¡æ•°æ³•ï¼ˆreference-countï¼‰â€ã€‚ ç¦æ­¢å¤åˆ¶1234class Lock: private Uncopyable&#123; ...&#125; â€œå¼•ç”¨è®¡æ•°æ³•â€ï¼ˆreference-countï¼‰123456789class Lock&#123;public: explicit Lock(Mutex* pm) : mutexPtr(pm, unlock) &#123; lock(muterPtr.get()); &#125;private: std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;&#125; è¿›è¡Œâ€œæ·±åº¦æ‹·è´â€ï¼Œå¤åˆ¶åº•éƒ¨èµ„æº è½¬ç§»åº•éƒ¨èµ„æºçš„æ‹¥æœ‰æƒï¼Œå¦‚ï¼šauto_ptr Coping å‡½æ•°åŒ…æ‹¬ copy æ„é€ å‡½æ•°å’Œ copy assignmentæ“ä½œç¬¦ã€‚ æ¡æ¬¾ 15ï¼šåœ¨èµ„æºç®¡ç†ç±»ä¸­æä¾›å¯¹åŸå§‹èµ„æºçš„è®¿é—®æ¯ä¸ª RAII class åº”è¯¥æä¾›ä¸€ä¸ª â€œå–å¾—å…¶æ‰€ç®¡ç†ä¹‹èµ„æºâ€ çš„æ–¹æ³•ã€‚å¯¹åŸå§‹èµ„æºçš„è®¿é—®å¯èƒ½ç»ç”±æ˜¾å¼è½¬æ¢æˆ–éšå¼è½¬æ¢ã€‚æ˜¾å¼è½¬æ¢æ¯”è¾ƒå®‰å…¨ï¼Œä½†éšå¼è½¬æ¢å¯¹å®¢æˆ·æ¯”è¾ƒæ–¹ä¾¿ã€‚ æ¡æ¬¾ 16ï¼šæˆå¯¹ä½¿ç”¨ new å’Œ delete æ—¶è¦é‡‡å–ç›¸åŒå½¢å¼ä½¿ç”¨ new è¦ä¸¥æ ¼æ­é… deleteï¼Œå¦‚ä½¿ç”¨ delete[] ä¸ºæœªå®šä¹‰çš„è¡Œä¸ºï¼Œå¯èƒ½å¤šæ¬¡è°ƒç”¨ææ„å‡½æ•°ã€‚ä½¿ç”¨ new[] è¦ä¸¥æ ¼æ­é… delete[]ã€‚è°¨æ…å¯¹æ•°ç»„ç±»å‹ typedef ã€‚ æ¡æ¬¾ 17ï¼šä»¥ç‹¬ç«‹è¯­å¥å°† newed å¯¹è±¡ç½®å…¥æ™ºèƒ½æŒ‡é’ˆ12int priority();void processWidget(std::tr1::shared_ptr&lt;Widget&gt;, priority()); 12345processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());// è¿›å…¥å‡½æ•°å‰åšäº†ä»¥ä¸‹ä¸‰ä»¶äº‹// æ‰§è¡Œ "new Widget"// è°ƒç”¨ tr1::shared_ptr æ„é€ å‡½æ•°// è°ƒç”¨ priority() ç¼–è¯‘å™¨å¯¹è¿™ä¸‰ä»¶äº‹çš„å®Œæˆæ¬¡åºä¸Šå¼¹æ€§å¾ˆå¤§ã€‚å¦‚åœ¨ priority() æŠ›å‡ºäº†å¼‚å¸¸ï¼Œnew Widget è¿”å›çš„æŒ‡é’ˆå°†å¯èƒ½é—å¤±ï¼Œå› ä¸ºå®ƒå°šæœªè¢«ç½®å…¥ std::tr1::shared_ptr å†…ã€‚ é¿å…è¿™ç±»é—®é¢˜åªéœ€åˆ†ç¦»è¯­å¥ï¼Œæ§åˆ¶æ‰§è¡Œé¡ºåºã€‚12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority);]]></content>
      <categories>
        <category>æ³› - ç¬”è®°</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>è¯»ä¹¦</tag>
        <tag>ç¬”è®°</tag>
        <tag>Effective C++</tag>
        <tag>æ™ºèƒ½æŒ‡é’ˆ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œä¹¦æ‘˜ã€ã€Šè‡ªæ§åŠ›ã€‹]]></title>
    <url>%2F2018%2F12%2F12%2Fbooks-1%2F</url>
    <content type="text"><![CDATA[æˆ‘è¦åšï¼Œæˆ‘ä¸è¦ï¼Œæˆ‘æƒ³è¦ï¼šä»€ä¹ˆæ˜¯æ„å¿—åŠ›ï¼Ÿä¸ºä»€ä¹ˆæ„å¿—åŠ›è‡³å…³é‡è¦ï¼Ÿ ç ”ç©¶è¡¨æ˜ï¼Œè‡ªè¯©æ„å¿—åšå®šçš„äººåè€Œæœ€å®¹æ˜“åœ¨è¯±æƒ‘é¢å‰å¤±æ§ã€‚æ¯”å¦‚ï¼Œè‡ªä¿¡èƒ½æŠµåˆ¶è¯±æƒ‘çš„æˆ’çƒŸè€…æœ€å®¹æ˜“åœ¨4ä¸ªæœˆåæ•…æ€å¤èŒï¼Œè¿‡äºä¹è§‚çš„èŠ‚é£Ÿè€…æœ€ä¸å®¹æ˜“å‡è‚¥æˆåŠŸã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºä»–ä»¬æ— æ³•é¢„æµ‹è‡ªå·±åœ¨ä½•æ—¶ä½•åœ°ã€ä¼šç”±äºä½•ç§åŸå› å¤±æ§ã€‚ æ¯ä¸ªäººéƒ½åœ¨ä»¥æŸç§æ–¹å¼æŠµåˆ¶è¯±æƒ‘ã€ç™–å¥½ã€å¹²æ‰°å’Œæ‹–å»¶ã€‚è¿™ä¸æ˜¯ä¸ªä½“çš„å¼±ç‚¹æˆ–ä¸ªäººçš„ä¸è¶³ï¼Œè€Œæ˜¯æ™®éçš„ç»éªŒï¼Œæ˜¯äººæ‰€å…±æœ‰çš„çŠ¶æ€ã€‚ â€œè¯´ä¸â€å±äºæ„å¿—åŠ›çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸”æ˜¯ä¸å¯æˆ–ç¼ºçš„ä¸€éƒ¨åˆ†ã€‚ ç‰¢è®°è‡ªå·±çœŸæ­£æƒ³è¦çš„æ˜¯ä»€ä¹ˆ å‰é¢çš®è´¨å¹¶ä¸æ˜¯æŒ¤æˆä¸€å›¢çš„ç°è´¨ï¼Œè€Œæ˜¯åˆ†æˆäº†ä¸‰ä¸ªåŒºåŸŸï¼Œåˆ†ç®¡â€œæˆ‘è¦åšâ€â€œæˆ‘ä¸è¦â€å’Œâ€œæˆ‘æƒ³è¦â€ä¸‰ç§åŠ›é‡ã€‚ å¦‚æœæ²¡æœ‰äº†æ¬²æœ›ï¼Œäººä»¬å°±ä¼šå˜å¾—æ²®ä¸§ï¼›å¦‚æœæ²¡æœ‰äº†ææƒ§ï¼Œäººä»¬å°±æ²¡æ³•ä¿æŠ¤è‡ªå·±ã€è¿œç¦»ä¼¤å®³ã€‚ åœ¨æ„å¿—åŠ›æŒ‘æˆ˜ä¸­è·èƒœçš„å…³é”®ï¼Œåœ¨äºå­¦ä¼šåˆ©ç”¨åŸå§‹æœ¬èƒ½ï¼Œè€Œä¸æ˜¯åæŠ—è¿™äº›æœ¬èƒ½ã€‚ æ³¨æ„åŠ›åˆ†æ•£çš„äººæ›´å®¹æ˜“å‘è¯±æƒ‘å±ˆæœã€‚ å¦‚æœä½ æƒ³æœ‰æ›´å¼ºçš„è‡ªæ§åŠ›ï¼Œå°±å¾—æœ‰æ›´å¤šçš„è‡ªæˆ‘æ„è¯†ã€‚ åªè¦å¥¹èƒ½æ„è¯†åˆ°è‡ªå·±åœ¨åšä»€ä¹ˆï¼Œå°±æœ‰å¯èƒ½åœä¸‹æ¥ã€‚ è§‚å¯Ÿè‡ªå·±ç©¶ç«Ÿæ˜¯æ€æ ·å±ˆæœäºå†²åŠ¨çš„ã€‚ ç¥ç»å­¦å®¶å‘ç°ï¼Œå¦‚æœä½ ç»å¸¸è®©å¤§è„‘å†¥æƒ³ï¼Œå®ƒä¸ä»…ä¼šå˜å¾—æ“…é•¿å†¥æƒ³ï¼Œè¿˜ä¼šæå‡ä½ çš„è‡ªæ§åŠ›ï¼Œæå‡ä½ é›†ä¸­æ³¨æ„åŠ›ã€ç®¡ç†å‹åŠ›ã€å…‹åˆ¶å†²åŠ¨å’Œè®¤è¯†è‡ªæˆ‘çš„èƒ½åŠ›ã€‚ä¸€æ®µæ—¶é—´ä¹‹åï¼Œä½ çš„å¤§è„‘å°±ä¼šå˜æˆè°ƒè¯•è‰¯å¥½çš„æ„å¿—åŠ›æœºå™¨ã€‚ ä¸ä»…è¦å…³æ³¨è‡ªå·±èƒ½å¦å°†æ³¨æ„åŠ›é›†ä¸­åˆ°å‘¼å¸ä¸Šï¼Œè¿˜è¦æ³¨æ„è§‚å¯Ÿï¼Œè¿™ç§è®­ç»ƒåœ¨å…¶ä»–æ—¶å€™æ˜¯å¦å½±å“äº†ä½ çš„é€‰æ‹©ã€‚ åœ¨å†¥æƒ³è®­ç»ƒé‡Œåšçš„äº‹æ­£æ˜¯ä»–åœ¨ç”Ÿæ´»ä¸­ä¹Ÿè¦é¢å¯¹çš„â€”â€”æŠŠè‡ªå·±çš„æ³¨æ„åŠ›æ”¶å›ï¼Œä¸“æ³¨äºæœ€åˆçš„ç›®æ ‡ã€‚ï¼ˆåœ¨å†¥æƒ³è®­ç»ƒä¸­ï¼Œç›®æ ‡å°±æ˜¯ä¸“æ³¨å‘¼å¸ã€‚ï¼‰ æ„å¿—åŠ›çš„æœ¬èƒ½ï¼šäººç”Ÿæ¥å°±èƒ½æŠµåˆ¶å¥¶é…ªè›‹ç³•çš„è¯±æƒ‘ è‡ªæ§åŠ›ä¸ä»…å’Œå¿ƒç†æœ‰å…³ï¼Œæ›´å’Œç”Ÿç†æœ‰å…³ã€‚åªæœ‰åœ¨å¤§è„‘å’Œèº«ä½“åŒæ—¶ä½œç”¨çš„ç¬é—´ï¼Œä½ æ‰æœ‰åŠ›é‡å…‹æœå†²åŠ¨ã€‚ åº”æ¿€ååº”æ˜¯ä¸€ç§ç®¡ç†èƒ½é‡çš„æœ¬èƒ½ï¼Œè¿™ç§æœ¬èƒ½å†³å®šäº†ä½ å°†å¦‚ä½•åˆ©ç”¨æœ‰é™çš„ä½“åŠ›å’Œè„‘åŠ›ã€‚ æˆ‘ä»¬æ€»è§‰å¾—è¯±æƒ‘å’Œéº»çƒ¦æ¥è‡ªå¤–éƒ¨ä¸–ç•Œï¼Œæ¯”å¦‚å±é™©çš„ç”œç”œåœˆã€ç½ªæ¶çš„é¦™çƒŸã€å……æ»¡è¯±æƒ‘çš„ç½‘ç»œã€‚ä½†è‡ªæ§åŠ›å‘Šè¯‰æˆ‘ä»¬ï¼Œé—®é¢˜å‡ºåœ¨æˆ‘ä»¬è‡ªå·±èº«ä¸Šï¼Œæ˜¯æˆ‘ä»¬çš„æ€æƒ³ã€æ¬²æœ›ã€æƒ…ç»ªå’Œå†²åŠ¨å‡ºäº†é—®é¢˜ã€‚ â€œä¸‰æ€è€Œåè¡Œâ€ååº”å’Œåº”æ¿€ååº”æœ‰ä¸€å¤„å…³é”®çš„åŒºåˆ«ï¼šå‰è€…çš„èµ·å› æ˜¯ä½ æ„è¯†åˆ°äº†å†…åœ¨çš„å†²çªï¼Œè€Œä¸æ˜¯å¤–åœ¨çš„å¨èƒã€‚ æœ€æœ‰æ•ˆçš„åšæ³•å°±æ˜¯å…ˆè®©è‡ªå·±æ”¾æ…¢é€Ÿåº¦ï¼Œè€Œä¸æ˜¯ç»™è‡ªå·±åŠ é€Ÿï¼ˆæ¯”å¦‚åº”æ¿€ååº”ï¼‰ã€‚â€œä¸‰æ€è€Œåè¡Œâ€ååº”å°±æ˜¯è®©ä½ æ…¢ä¸‹æ¥ã€‚å½“ä½ æ„è¯†åˆ°å†…åœ¨å†²çªçš„æ—¶å€™ï¼Œå¤§è„‘å’Œèº«ä½“ä¼šåšå‡ºååº”ï¼Œå¸®åŠ©ä½ æ”¾æ…¢é€Ÿåº¦ã€æŠ‘åˆ¶å†²åŠ¨ã€‚ å½“äººä»¬æ„Ÿåˆ°å‹åŠ›æ—¶ï¼Œäº¤æ„Ÿç¥ç»ç³»ç»Ÿä¼šæ§åˆ¶èº«ä½“ã€‚è¿™ç§ç”Ÿç†å­¦ç°è±¡è®©ä½ èƒ½å¤Ÿæˆ˜æ–—æˆ–è€…é€ƒè·‘ã€‚å¿ƒç‡å‡é«˜ï¼Œå¿ƒç‡å˜å¼‚åº¦å°±ä¼šé™ä½ã€‚æ­¤æ—¶ï¼Œç”±äºä¼´éšåº”æ¿€ååº”äº§ç”Ÿçš„ç„¦è™‘æˆ–æ„¤æ€’ï¼Œå¿ƒç‡ä¼šè¢«è¿«ä¿æŒåœ¨è¾ƒé«˜çš„æ°´å¹³ä¸Šã€‚ç›¸åï¼Œå½“äººä»¬æˆåŠŸè‡ªæ§çš„æ—¶å€™ï¼Œå‰¯äº¤æ„Ÿç¥ç»ç³»ç»Ÿä¼šå‘æŒ¥ä¸»è¦ä½œç”¨ï¼Œç¼“è§£å‹åŠ›ï¼Œæ§åˆ¶å†²åŠ¨è¡Œä¸ºã€‚å¿ƒç‡é™ä½ï¼Œå¿ƒç‡å˜å¼‚åº¦ä¾¿ä¼šå‡é«˜ã€‚æ­¤æ—¶ï¼Œäººä»¬èƒ½æ›´å¥½åœ°é›†ä¸­æ³¨æ„åŠ›å¹¶ä¿æŒå¹³é™ã€‚ å¿ƒç‡å˜å¼‚åº¦è¾ƒé«˜çš„äººèƒ½æ›´å¥½åœ°é›†ä¸­æ³¨æ„åŠ›ã€é¿å…åŠæ—¶è¡Œä¹çš„æƒ³æ³•ã€æ›´å¥½åœ°åº”å¯¹å‹åŠ›ã€‚ æœ‰å¾ˆå¤šå› ç´ ä¼šå½±å“åˆ°æ„å¿—åŠ›å‚¨å¤‡ï¼Œæ¯”å¦‚ä½ åƒä»€ä¹ˆï¼ˆä»¥æ¤ç‰©ä¸ºåŸææ–™çš„ã€æœªç»åŠ å·¥çš„é£Ÿç‰©æœ‰åŠ©äºæé«˜å¿ƒç‡å˜å¼‚åº¦ï¼Œåƒåœ¾é£Ÿå“åˆ™ä¼šé™ä½å¿ƒç‡å˜å¼‚åº¦ï¼‰æˆ–æ˜¯ä½åœ¨å“ªé‡Œï¼ˆç³Ÿç³•çš„ç©ºæ°”è´¨é‡ä¼šé™ä½å¿ƒç‡å˜å¼‚åº¦ï¼‰ã€‚ä»»ä½•ç»™ä½ çš„èº«å¿ƒå¸¦æ¥å‹åŠ›çš„ä¸œè¥¿éƒ½ä¼šå½±å“è‡ªæ§åŠ›çš„ç”Ÿç†åŸºç¡€ï¼Œç”šè‡³ä¼šæ‘§æ¯ä½ çš„æ„å¿—åŠ›ã€‚ç„¦è™‘ã€æ„¤æ€’ã€æŠ‘éƒå’Œå­¤ç‹¬éƒ½ä¸è¾ƒä½çš„å¿ƒç‡å˜å¼‚åº¦å’Œè¾ƒå·®çš„è‡ªæ§åŠ›æœ‰å…³ã€‚æ…¢æ€§ç–¼ç—›å’Œæ…¢æ€§ç–¾ç—…åˆ™ä¼šæ¶ˆè€—èº«ä½“å’Œå¤§è„‘çš„æ„å¿—åŠ›å‚¨å¤‡ã€‚ å°†å‘¼å¸é¢‘ç‡é™ä½åˆ°æ¯åˆ†é’Ÿ4-6æ¬¡ï¼Œä¹Ÿå°±æ˜¯æ¯æ¬¡å‘¼å¸ç”¨10-15ç§’æ—¶é—´ï¼Œæ¯”å¹³å¸¸å‘¼å¸è¦æ…¢ä¸€äº›ã€‚åªè¦ä½ æœ‰è¶³å¤Ÿçš„è€å¿ƒï¼ŒåŠ ä¸Šå¿…è¦çš„ç»ƒä¹ ï¼Œè¿™ä¸€ç‚¹ä¸éš¾åŠåˆ°ã€‚æ”¾æ…¢å‘¼å¸èƒ½æ¿€æ´»å‰é¢çš®è´¨ã€æé«˜å¿ƒç‡å˜å¼‚åº¦ï¼Œæœ‰åŠ©äºä½ çš„èº«å¿ƒä»å‹åŠ›çŠ¶æ€è°ƒæ•´åˆ°è‡ªæ§åŠ›çŠ¶æ€ã€‚è¿™æ ·è®­ç»ƒå‡ åˆ†é’Ÿä¹‹åï¼Œä½ å°±ä¼šæ„Ÿåˆ°å¹³é™ã€æœ‰æ§åˆ¶æ„Ÿï¼Œèƒ½å¤Ÿå…‹åˆ¶æ¬²æœ›ã€è¿æ¥æŒ‘æˆ˜ã€‚ æ»¥ç”¨è¯ç‰©æˆ–æ‚£æœ‰åˆ›ä¼¤ååº”æ¿€éšœç¢ç—‡çš„æˆå¹´äººï¼Œæ¯å¤©è¿›è¡Œ20åˆ†é’Ÿæ”¾æ…¢å‘¼å¸çš„ç»ƒä¹ ï¼Œå°±èƒ½æé«˜å¿ƒç‡å˜å¼‚åº¦ï¼Œé™ä½æ¬²æœ›å’ŒæŠ‘éƒç¨‹åº¦ã€‚ é”»ç‚¼èƒ½æé«˜å¿ƒç‡å˜å¼‚åº¦çš„åŸºå‡†çº¿ï¼Œä»è€Œæ”¹å–„è‡ªæ§åŠ›çš„ç”Ÿç†åŸºç¡€ã€‚ æ”¹å–„å¿ƒæƒ…ã€ç¼“è§£å‹åŠ›çš„æœ€æœ‰æ•ˆçš„é”»ç‚¼æ˜¯æ¯æ¬¡5åˆ†é’Ÿï¼Œè€Œä¸æ˜¯æ¯æ¬¡å‡ å°æ—¶ã€‚ ä»»ä½•èƒ½è®©ä½ ç¦»å¼€æ¤…å­çš„æ´»åŠ¨ï¼Œéƒ½èƒ½æé«˜ä½ çš„æ„å¿—åŠ›å‚¨å¤‡ã€‚ å¦‚æœä½ è§‰å¾—é”»ç‚¼å¤ªç´¯äº†ï¼Œæˆ–æ˜¯æ²¡æœ‰æ—¶é—´é”»ç‚¼ï¼Œé‚£ä¹ˆä¸å¦¨å°†é”»ç‚¼å½“åšæ¢å¤ä½“èƒ½å’Œæ„å¿—åŠ›çš„æ–¹æ³•ã€‚ é•¿æœŸç¡çœ ä¸è¶³è®©ä½ æ›´å®¹æ˜“æ„Ÿåˆ°å‹åŠ›ã€èŒç”Ÿæ¬²æœ›ã€å—åˆ°è¯±æƒ‘ã€‚ä½ è¿˜ä¼šå¾ˆéš¾æ§åˆ¶æƒ…ç»ªã€é›†ä¸­æ³¨æ„åŠ›ï¼Œæˆ–æ˜¯æ— åŠ›åº”ä»˜â€œæˆ‘æƒ³è¦â€çš„æ„å¿—åŠ›æŒ‘æˆ˜ã€‚ å¦‚æœç¡çœ ä¸è¶³çš„äººè¡¥ä¸Šä¸€ä¸ªå¥½è§‰ï¼Œä»–çš„å‰é¢çš®è´¨å°±ä¼šæ¢å¤å¦‚åˆã€‚å®é™…ä¸Šï¼Œä»–çš„å¤§è„‘å’Œä¼‘æ¯è‰¯å¥½çš„äººçš„å¤§è„‘ä¼šå®Œå…¨ä¸€æ ·ã€‚ å¦‚æœä½ æ˜çŸ¥é“è‡ªå·±èƒ½è·å¾—æ›´å¤šçš„ç¡çœ ï¼Œå´æ²¡æ³•æ—©ç‚¹å…¥ç¡ï¼Œé‚£å°±ä¸è¦æƒ³ç¡è§‰è¿™ä»¶äº‹ï¼Œæƒ³ä¸€æƒ³ä½ åˆ°åº•å¯¹ä»€ä¹ˆè¯´äº†â€œæˆ‘æƒ³è¦â€ã€‚è¿™ä¸ªæ„å¿—åŠ›æ³•åˆ™åŒæ ·é€‚ç”¨äºä½ æƒ³é€ƒé¿æˆ–æ‹–å»¶çš„äº‹â€”â€”å½“ä½ ä¸çŸ¥é“è‡ªå·±æƒ³åšä»€ä¹ˆçš„æ—¶å€™ï¼Œä½ æˆ–è®¸éœ€è¦çŸ¥é“è‡ªå·±ä¸æƒ³åšä»€ä¹ˆã€‚ è‡ªæ§éœ€è¦å¤§é‡èƒ½é‡ï¼Œå¾ˆå¤šç§‘å­¦å®¶éƒ½è®¤ä¸ºï¼Œé•¿æ—¶é—´çš„è‡ªæ§å°±åƒæ…¢æ€§å‹åŠ›ä¸€æ ·ï¼Œä¼šå‰Šå¼±å…ç–«ç³»ç»Ÿçš„åŠŸèƒ½ï¼Œå¢å¤§æ‚£ç—…çš„æ¦‚ç‡ã€‚ æ­£å¦‚é€‚åº¦çš„å‹åŠ›æ˜¯æœ‰æ„ä¹‰çš„å¥åº·ç”Ÿæ´»ä¸å¯ç¼ºå°‘çš„ä¸€éƒ¨åˆ†ï¼Œé€‚å½“çš„è‡ªæ§ä¹Ÿæ˜¯å¿…éœ€çš„ã€‚ä½†æ˜¯æ­£å¦‚æ…¢æ€§å‹åŠ›ä¼šå½±å“å¥åº·ä¸€æ ·ï¼Œè¯•å›¾æ§åˆ¶æ‰€æœ‰çš„æ€æƒ³ã€æƒ…ç»ªå’Œè¡Œä¸ºä¹Ÿæ˜¯ä¸€å‰‚æ¯’è¯ï¼Œä¼šç»™ä½ å¸¦å»è¿‡é‡çš„ç”Ÿç†è´Ÿæ‹…ã€‚ ä¸ºäº†èƒ½å¤Ÿä¿æŒå¥åº·ã€ç»´æŒå¹¸ç¦ç”Ÿæ´»ï¼Œä½ éœ€è¦æ”¾å¼ƒå¯¹æ„å¿—åŠ›çš„å®Œç¾æ§åˆ¶ã€‚ ä»å‹åŠ›å’Œè‡ªæ§åŠ›ä¸­æ¢å¤çš„æœ€ä½³é€”å¾„å°±æ˜¯æ”¾æ¾ã€‚æ”¾æ¾ï¼Œå³ä¾¿åªæ”¾æ¾å‡ åˆ†é’Ÿï¼Œéƒ½èƒ½æ¿€æ´»å‰¯äº¤æ„Ÿç¥ç»ç³»ç»Ÿï¼Œèˆ’ç¼“äº¤æ„Ÿç¥ç»ç³»ç»Ÿï¼Œä»è€Œæé«˜å¿ƒç‡å˜å¼‚åº¦ã€‚å®ƒè¿˜èƒ½æŠŠèº«ä½“è°ƒæ•´åˆ°ä¿®å¤å’Œè‡ªæ„ˆçŠ¶æ€ã€æé«˜å…ç–«åŠŸèƒ½ã€é™ä½å‹åŠ›è·å°”è’™åˆ†æ³Œã€‚ èƒ½æé«˜æ„å¿—åŠ›çš„â€œæ”¾æ¾â€æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„èº«å¿ƒä¼‘æ•´ã€‚å“ˆä½›åŒ»å­¦é™¢å¿ƒè„ç—…ä¸“å®¶èµ«ä¼¯ç‰¹Â·æœ¬æ£®ï¼ˆHerbert Bensonï¼‰ç§°ä¹‹ä¸ºâ€œç”Ÿç†å­¦æ”¾æ¾ååº”â€ã€‚ä½ çš„å¿ƒç‡å’Œå‘¼å¸é€Ÿåº¦ä¼šæ”¾ç¼“ï¼Œè¡€å‹ä¼šé™ä½ï¼Œè‚Œè‚‰ä¼šæ”¾æ¾ã€‚ä½ çš„å¤§è„‘ä¸ä¼šå»è§„åˆ’æœªæ¥ï¼Œä¹Ÿä¸ä¼šå»åˆ†æè¿‡å»ã€‚æƒ³è¦æ¿€å‘è¿™ç§æ”¾æ¾ååº”ï¼Œä½ éœ€è¦èººä¸‹æ¥ï¼Œç”¨æ•å¤´å«ç€è†ç›–ï¼Œè…¿ç¨ç¨æŠ¬èµ·ï¼ˆæˆ–è€…ï¼Œä½ å¯ä»¥é€‰æ‹©ä»»ä½•ä¸€ä¸ªä½ è§‰å¾—èˆ’æœçš„å§¿åŠ¿ï¼‰ã€‚é—­ä¸Šçœ¼ç›ï¼Œåšå‡ æ¬¡æ·±å‘¼å¸ï¼Œæ„Ÿè§‰ä½ çš„è…¹éƒ¨æœ‰èµ·ä¼ã€‚å¦‚æœä½ è§‰å¾—èº«ä½“æŸå¤„å¾ˆç´§å¼ ï¼Œä½ å¯ä»¥æœ‰æ„è¯†åœ°æŒ¤å‹æˆ–æ”¶ç¼©è‚Œè‚‰ï¼Œç„¶åå°±ä¸è¦å†å»ç®¡å®ƒäº†ã€‚æ¯”å¦‚ï¼Œå¦‚æœä½ å‘ç°æ‰‹æŒå’Œæ‰‹æŒ‡å¾ˆç´§å¼ ï¼Œé‚£ä¹ˆå°±æ”¥ä¸€ä¸‹æ‹³å¤´ï¼Œç„¶åå¼ å¼€æ‰‹æŒã€‚å¦‚æœä½ å‘ç°å‰é¢å’Œä¸‹å·´å¾ˆç´§å¼ ï¼Œé‚£ä¹ˆå°±æŒ¤æŒ¤çœ¼ã€çš±çš±çœ‰ï¼Œç„¶åå¼ å¤§å˜´å·´ï¼Œæ”¾æ¾æ•´ä¸ªé¢éƒ¨ã€‚ä¿æŒè¿™ç§çŠ¶æ€5-10åˆ†é’Ÿï¼Œè¯•ç€äº«å—è¿™ç§é™¤äº†å‘¼å¸ä»€ä¹ˆéƒ½ä¸ç”¨æƒ³çš„çŠ¶æ€ã€‚å¦‚æœä½ æ‹…å¿ƒä¼šç¡ç€ï¼Œé‚£å°±å…ˆè®¾å®šå¥½é—¹é’Ÿã€‚ æ„å¿—åŠ›æ˜¯ä¸€ç§ä¸æ–­è¿›åŒ–çš„èƒ½åŠ›ï¼Œæ˜¯æ¯ä¸ªäººéƒ½æœ‰çš„æœ¬èƒ½ã€‚å®ƒè¯¦ç»†åœ°è®°å½•äº†èº«ä½“å’Œå¤§è„‘çš„çŠ¶æ€ã€‚ æ„å¿—åŠ›ä¼šå—åˆ°å¤šæ–¹é¢çš„å½±å“ï¼Œæ¯”å¦‚ç¡çœ ä¸è¶³ã€é¥®é£Ÿä¸è‰¯ã€ä¹…åä¸åŠ¨å’Œå„ç§æ¶ˆè€—èƒ½é‡çš„äº‹æƒ…ï¼Œæˆ–æ˜¯èº«å¿ƒé•¿æœŸå¤„äºå‹åŠ›çŠ¶æ€ä¹‹ä¸‹ã€‚ ä»é•¿è¿œçš„è§’åº¦çœ‹ï¼Œæ²¡æœ‰ä»€ä¹ˆæ¯”å‹åŠ›æ›´æ¶ˆè€—æ„å¿—åŠ›äº†ã€‚å‹åŠ›å’Œè‡ªæ§çš„ç”Ÿç†å­¦åŸºç¡€æ˜¯äº’ç›¸æ’æ–¥çš„ã€‚ å‹åŠ›è®©ä½ å…³æ³¨å³æ—¶çš„ã€çŸ­æœŸçš„ç›®æ ‡å’Œç»“æœï¼Œè‡ªæ§åŠ›åˆ™éœ€è¦ä½ çš„å¤§è„‘æœ‰æ›´å¹¿é˜”çš„è§†é‡ã€‚ å­¦ä¼šå¦‚ä½•æ›´å¥½åœ°ç®¡ç†å‹åŠ›ï¼Œæ˜¯æé«˜æ„å¿—åŠ›çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚ å„¿ç«¥å¤šåŠ¨ç—‡çš„æ¦‚ç‡æ€¥å‰§æ”€å‡å¾ˆå¯èƒ½å’Œè¿™ç§ç¡çœ ä¹ æƒ¯æœ‰å…³ï¼Œå› ä¸ºå„¿ç«¥å¾€å¾€å—æˆäººç¡çœ ä¹ æƒ¯çš„å½±å“ï¼Œè€Œä¸”å„¿ç«¥éœ€è¦æ›´å¤šçš„ç¡çœ ã€‚ æˆ‘ä»¬çš„åä¹ æƒ¯ï¼ˆæ¯”å¦‚è¿‡åº¦é¥®é£Ÿå’Œç¡çœ ä¸è¶³ï¼‰ä¸ä»…åæ˜ äº†æˆ‘ä»¬ç¼ºä¹è‡ªæ§åŠ›ï¼Œè¿˜æ¶ˆè€—äº†æˆ‘ä»¬çš„ä½“åŠ›ï¼Œå¸¦æ¥äº†æ›´å¤šçš„å‹åŠ›ï¼Œå·èµ°äº†æˆ‘ä»¬çš„è‡ªæ§åŠ›ã€‚ å½“æˆ‘ä»¬é¢å¯¹çš„æ„å¿—åŠ›æŒ‘æˆ˜è¿‡äºå¼ºå¤§æ—¶ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“ç»™è‡ªå·±ä¸‹è¿™æ ·çš„ç»“è®ºâ€”â€”æˆ‘æ˜¯ä¸ªè½¯å¼±ã€æ‡’æƒ°ã€æ¯«æ— æ„å¿—åŠ›çš„åºŸç‰©ã€‚ä½†é€šå¸¸çš„æƒ…å½¢æ˜¯ï¼Œæˆ‘ä»¬çš„å¤§è„‘å’Œèº«ä½“å¹¶æœªå¤„äºè‡ªæ§çŠ¶æ€ã€‚å½“æˆ‘ä»¬å¤„åœ¨æ…¢æ€§å‹åŠ›ä¸­æ—¶ï¼Œè¿æ¥æ„å¿—åŠ›æŒ‘æˆ˜çš„æ˜¯æœ€å†²åŠ¨çš„è‡ªå·±ã€‚æƒ³è¦èµ¢å¾—æ„å¿—åŠ›æŒ‘æˆ˜ï¼Œæˆ‘ä»¬éœ€è¦è°ƒæ•´åˆ°æ­£ç¡®çš„èº«å¿ƒçŠ¶æ€ï¼Œç”¨èƒ½é‡å»è‡ªæ§ï¼Œè€Œä¸æ˜¯è‡ªå«ã€‚è¿™å°±æ„å‘³ç€ï¼Œæˆ‘ä»¬éœ€è¦ä»å‹åŠ›ä¸­æ¢å¤è¿‡æ¥ï¼Œä¿è¯æœ‰èƒ½é‡åšæœ€å¥½çš„è‡ªå·±ã€‚ æ„å¿—åŠ›æ˜¯ç§ç”Ÿç†æœ¬èƒ½ï¼Œå®ƒå’Œå‹åŠ›ä¸€æ ·ï¼Œé€šè¿‡ä¸æ–­è¿›åŒ–æ¥ä¿æŠ¤æˆ‘ä»¬ä¸å—è‡ªèº«ä¼¤å®³ã€‚ ç´¯åˆ°æ— åŠ›æŠµæŠ—ï¼šä¸ºä»€ä¹ˆè‡ªæ§åŠ›å’Œè‚Œè‚‰ä¸€æ ·æœ‰æé™ï¼Ÿ ä¼¼ä¹æˆ‘ä»¬åªæœ‰ä¸€å®šé‡çš„æ„å¿—åŠ›ï¼Œä¸€æ—¦ä½ å°†å®ƒæ¶ˆè€—æ®†å°½ï¼Œä½ åœ¨è¯±æƒ‘é¢å‰å°±ä¼šæ¯«æ— é˜²å¤‡åŠ›ï¼Œè‡³å°‘ä¼šå¤„äºä¸‹é£ã€‚ äººä»¬æ—©æ™¨çš„æ„å¿—åŠ›æœ€å¼ºï¼Œç„¶åæ„å¿—åŠ›éšç€æ—¶é—´çš„æ¨ç§»é€æ¸å‡å¼±ã€‚ æ—¶é—´è¿‡é•¿ï¼Œæ³¨æ„åŠ›è®­ç»ƒå°±ä¸ä»…ä¼šåˆ†æ•£æ³¨æ„åŠ›ï¼Œè¿˜ä¼šè€—å°½èº«ä½“çš„èƒ½é‡ã€‚æ§åˆ¶æƒ…ç»ªä¸ä»…ä¼šå¯¼è‡´æƒ…ç»ªå¤±æ§ï¼Œè¿˜ä¼šä¿ƒä½¿äººä»¬è´­ä¹°ä»–ä»¬æœ¬ä¸éœ€è¦çš„ä¸œè¥¿ã€‚æŠµæŠ—ç”œé£Ÿçš„è¯±æƒ‘ä¸ä»…ä¼šè®©äººæ›´æƒ³åƒå·§å…‹åŠ›ï¼Œè¿˜ä¼šå¯¼è‡´æ‹–å»¶ç—‡ã€‚ èµ„æºä¸è¶³æ—¶ï¼Œå¤§è„‘ä¼šé€‰æ‹©æ»¡è¶³å½“ä¸‹çš„éœ€æ±‚ï¼›èµ„æºå……è¶³æ—¶ï¼Œå¤§è„‘åˆ™ä¼šè½¬å‘é€‰æ‹©é•¿æœŸçš„æŠ•èµ„ã€‚ æ›´å¥½çš„æ–¹æ³•æ˜¯ä¿è¯ä½ çš„èº«ä½“æœ‰è¶³å¤Ÿçš„é£Ÿç‰©ä¾›åº”ï¼Œè¿™æ ·èƒ½ç»™ä½ æ›´æŒä¹…çš„èƒ½é‡ã€‚å¤§å¤šæ•°å¿ƒç†å­¦å®¶å’Œè¥å…»å­¦å®¶æ¨èä½è¡€ç³–é¥®é£Ÿï¼Œå› ä¸ºå®ƒèƒ½è®©ä½ çš„è¡€ç³–ç¨³å®šã€‚ä½è¡€ç³–é£Ÿå“åŒ…æ‹¬ç˜¦è‚‰è›‹ç™½ã€åšæœå’Œè±†ç±»ã€ç²—çº¤ç»´è°·ç±»å’Œéº¦ç‰‡ã€å¤§å¤šæ•°çš„æ°´æœå’Œè”¬èœã€‚ è¿™äº›ç ”ç©¶ä¸­è®­ç»ƒçš„â€œè‚Œè‚‰â€ä¸æ˜¯ä¸ºäº†è®©ä½ åœ¨è§„å®šæœŸé™å‰å®Œæˆä»»åŠ¡ã€ç”¨å·¦æ‰‹å¼€é—¨æˆ–ä¸è¯´è„è¯ï¼Œè€Œæ˜¯è®©ä½ å…»æˆä¹ æƒ¯ã€å…³æ³¨è‡ªå·±æ­£åœ¨åšçš„äº‹æƒ…ã€é€‰æ‹©æ›´éš¾çš„è€Œä¸æ˜¯æœ€ç®€å•çš„äº‹ã€‚é€šè¿‡æ¯ä¸€æ¬¡æ„å¿—åŠ›ç»ƒä¹ ï¼Œå¤§è„‘å¼€å§‹ä¹ æƒ¯äºä¸‰æ€è€Œåè¡Œã€‚ æˆ‘ä»¬æ€»æ˜¯åœ¨æ„å¿—åŠ›çœŸæ­£è€—å°½ä¹‹å‰å°±æ„Ÿåˆ°æ— æ³•åšæŒäº†ã€‚ä»æŸç§ç¨‹åº¦ä¸Šè¯´ï¼Œæˆ‘ä»¬åº”è¯¥æ„Ÿè°¢å¤§è„‘å¸®åŠ©æˆ‘ä»¬ä¿å­˜èƒ½é‡ã€‚æ­£å¦‚å¤§è„‘æ‹…å¿ƒä½“èƒ½æ¯ç«­æ—¶ä¼šå‘Šè¯‰è‚Œè‚‰æ”¾æ…¢é€Ÿåº¦ä¸€æ ·ï¼Œå¤§è„‘ä¹Ÿä¼šå¯¹å¤§é‡æ¶ˆè€—å‰é¢çš®è´¨ä¸­èƒ½é‡çš„æ´»åŠ¨å–Šâ€œåœâ€ã€‚è¿™å¹¶ä¸æ„å‘³ç€æˆ‘ä»¬ç”¨å…‰äº†æ„å¿—åŠ›ï¼Œæˆ‘ä»¬åªæ˜¯éœ€è¦ç§¯æ”’ä½¿ç”¨æ„å¿—åŠ›çš„åŠ¨åŠ›ç½¢äº†ã€‚ çŸ¥é“æˆ‘ä»¬çš„æ„å¿—åŠ›æ¯”æƒ³è±¡ä¸­å¤šå¾—å¤šï¼Œè¿™ç¡®å®æ˜¯ä»¶ä»¤äººå¼€å¿ƒçš„äº‹ã€‚æˆ–è®¸æˆ‘ä»¬ä¹Ÿå¯ä»¥åƒè¿åŠ¨å‘˜ä¸€æ ·ï¼ŒæŒºè¿‡æ„å¿—åŠ›æ¶ˆè€—æ®†å°½çš„æ„Ÿè§‰ï¼Œå†²è¿‡æ„å¿—åŠ›æŒ‘æˆ˜çš„ç»ˆç‚¹ã€‚ å®¹å¿ç½ªæ¶ï¼šä¸ºä½•å–„è¡Œä¹‹åä¼šæœ‰æ¶è¡Œï¼Ÿ å¿ƒç†å­¦å®¶ä¸€ç›´è®¤ä¸ºï¼Œå½“ä½ è¡¨è¾¾ä¸€ç§æ€åº¦æ—¶ï¼Œä½ æ›´å¯èƒ½æŒ‰è¿™ç§å‡†åˆ™è¡Œäº‹ã€‚æ¯•ç«Ÿï¼Œè°æ„¿æ„åšä¼ªå›å­ï¼Ÿä½†æ™®æ—æ–¯é¡¿çš„å¿ƒç†å­¦å®¶æ­ç¤ºäº†ä¸€ä¸ªä¾‹å¤–ï¼Œè¿™å’Œæˆ‘ä»¬å¯¹è¡¨é‡Œå¦‚ä¸€çš„æ¸´æœ›èƒŒé“è€Œé©°ã€‚å½“è¯´åˆ°å­°æ˜¯å­°éæ—¶ï¼Œæˆ‘ä»¬éƒ½èƒ½æ¯«ä¸è´¹åŠ›åœ°ä½œå‡ºç¬¦åˆé“å¾·æ ‡å‡†çš„é€‰æ‹©ã€‚æˆ‘ä»¬åªæƒ³è®©è‡ªå·±æ„Ÿè§‰è‰¯å¥½ï¼Œè€Œè¿™å°±ä¸ºè‡ªå·±çš„èƒ¡ä½œéä¸ºå¼€äº†ç»¿ç¯ã€‚ æ˜ç¡®é©³æ–¥æ€§åˆ«æ­§è§†å’Œç§æ—æ­§è§†è¨€è®ºçš„å­¦ç”Ÿï¼Œè§‰å¾—è‡ªå·±å·²ç»è·å¾—äº†é“å¾·è®¸å¯è¯ã€‚ä»–ä»¬å·²ç»å‘è‡ªå·±è¯æ˜äº†ï¼Œä»–ä»¬æ²¡æœ‰æ€§åˆ«æ­§è§†æˆ–ç§æ—æ­§è§†ã€‚è¿™å°±è®©ä»–ä»¬åœ¨å¿ƒç†å­¦å®¶æ‰€è°“çš„â€œé“å¾·è®¸å¯â€ï¼ˆmoral licensingï¼‰é¢å‰ä¸å ªä¸€å‡»ã€‚å½“ä½ åšå–„äº‹çš„æ—¶å€™ï¼Œä½ ä¼šæ„Ÿè§‰è‰¯å¥½ã€‚è¿™å°±æ„å‘³ç€ï¼Œä½ æ›´å¯èƒ½ç›¸ä¿¡è‡ªå·±çš„å†²åŠ¨ã€‚è€Œå†²åŠ¨å¸¸å¸¸ä¼šå…è®¸ä½ åšåäº‹ã€‚ â€œé“å¾·è®¸å¯â€ä¸ä»…ä¼šæ‰¹å‡†æˆ‘ä»¬åšåäº‹ï¼Œä¹Ÿä¼šè®©æˆ‘ä»¬é”™å¤±åšå–„äº‹çš„æœºä¼šã€‚ å¦‚æœä½ å»é”»ç‚¼äº†å°±è¯´è‡ªå·±å¾ˆâ€œå¥½â€ï¼Œæ²¡å»é”»ç‚¼å°±è¯´è‡ªå·±å¾ˆâ€œåâ€ï¼Œé‚£ä¹ˆä½ å¾ˆå¯èƒ½å› ä¸ºä»Šå¤©å»é”»ç‚¼äº†ï¼Œæ˜å¤©å°±ä¸å»äº†ã€‚å¦‚æœä½ å»å¤„ç†äº†ä¸€ä¸ªé‡è¦é¡¹ç›®å°±è¯´è‡ªå·±å¾ˆâ€œå¥½â€ï¼Œæ‹–å»¶ç€ä¸å»å¤„ç†å°±è¯´è‡ªå·±å¾ˆâ€œåâ€ï¼Œé‚£ä¹ˆä½ å¾ˆå¯èƒ½å› ä¸ºæ—©ä¸Šå–å¾—äº†è¿›æ­¥ï¼Œä¸‹åˆå°±å˜æ‡’æ•£äº†ã€‚ç®€å•è¯´æ¥ï¼Œåªè¦æˆ‘ä»¬çš„æ€æƒ³ä¸­å­˜åœ¨æ­£åä¸¤æ–¹ï¼Œå¥½çš„è¡Œä¸ºå°±æ€»æ˜¯å…è®¸æˆ‘ä»¬åšä¸€ç‚¹åäº‹ã€‚ ä»»ä½•è®©ä½ å¯¹è‡ªå·±çš„ç¾å¾·æ„Ÿåˆ°æ»¡æ„çš„äº‹ï¼Œå³ä¾¿åªæ˜¯æƒ³æƒ³ä½ åšè¿‡çš„å–„äº‹ï¼Œéƒ½ä¼šå…è®¸æˆ‘ä»¬å†²åŠ¨è¡Œäº‹ã€‚ â€œé“å¾·è®¸å¯â€æœ€ç³Ÿç³•çš„éƒ¨åˆ†å¹¶ä¸æ˜¯å®ƒå¯ç–‘çš„é€»è¾‘ï¼Œè€Œæ˜¯å®ƒä¼šè¯±ä½¿æˆ‘ä»¬åšå‡ºèƒŒç¦»è‡ªå·±æœ€å¤§åˆ©ç›Šçš„äº‹ã€‚ ä¸è¦æŠŠæ”¯æŒç›®æ ‡å®ç°çš„è¡Œä¸ºè¯¯è®¤ä¸ºæ˜¯ç›®æ ‡æœ¬èº«ã€‚ä¸æ˜¯è¯´ä½ åšäº†ä¸€ä»¶å’Œä½ ç›®æ ‡ä¸€è‡´çš„äº‹æƒ…ï¼Œä½ å°±ä¸ä¼šå†é¢ä¸´å±é™©äº†ã€‚æ³¨æ„è§‚å¯Ÿä¸€ä¸‹ï¼Œä½ æ˜¯å¦å› ä¸ºè®¤ä¸ºæŸäº›ç§¯æçš„è¡Œä¸ºå€¼å¾—ç§°èµï¼Œå°±å¿˜äº†è‡ªå·±å®é™…çš„ç›®æ ‡æ˜¯ä»€ä¹ˆã€‚ å¤§éƒ¨åˆ†äººè®¤ä¸ºï¼Œå–å¾—è¿›æ­¥ä¼šåˆºæ¿€æˆ‘ä»¬è·å¾—æ›´å¤§çš„æˆåŠŸã€‚ä½†å¿ƒç†å­¦å®¶çŸ¥é“ï¼Œæˆ‘ä»¬æ€»æ˜¯æŠŠè¿›æ­¥å½“åšæ”¾æ¾çš„å€Ÿå£ã€‚ èŠåŠ å“¥å¤§å­¦å•†å­¦é™¢ç ”ç©¶ç”Ÿé™¢çš„æ•™æˆé˜¿è€¶è±ç‰¹Â·è´¹ä»€å·´èµ«ï¼ˆAyelet Fishbachï¼‰å’Œè€¶é²å¤§å­¦ç®¡ç†å­¦æ•™æˆæ‹‰ç»´Â·å¤šå°”ï¼ˆRavi Dharï¼‰å·²ç»è¯æ˜äº†ï¼Œåœ¨å®ŒæˆæŸä¸ªç›®æ ‡è¿‡ç¨‹ä¸­å–å¾—çš„è¿›æ­¥ï¼Œä¼šåˆºæ¿€äººä»¬åšå‡ºå¦¨ç¢å®Œæˆç›®æ ‡çš„è¡Œä¸º åº”è¯¥æƒ³ç€â€œæˆ‘åšè¿™ä»¶äº‹æ˜¯å› ä¸ºæˆ‘æƒ³è¦â€¦â€¦â€ æœ‰æ—¶å€™ï¼Œå¤§è„‘ä¼šå¯¹èƒ½å®Œæˆç›®æ ‡çš„å¯èƒ½æ€§æ„Ÿåˆ°å…´å¥‹ï¼Œå®ƒé”™æŠŠå¯èƒ½æ€§å½“æˆçœŸæ­£å®Œæˆäº†ç›®æ ‡ã€‚ å¯¹æœªæ¥çš„ä¹è§‚ä¸»ä¹‰ç²¾ç¥ï¼Œä¸ä»…ä¼šå½±å“æˆ‘ä»¬è‡ªå·±çš„å†³å®šï¼Œè¿˜ä¼šå½±å“æˆ‘ä»¬ç©¶ç«Ÿä¼šä¸ä¼šæŒ‰è‡ªå·±æ‰€è¯´çš„å»åšã€‚å¿ƒç†å­¦å®¶å·²ç»è¯æ˜äº†ï¼Œæˆ‘ä»¬é”™è¯¯åœ°è®¤ä¸ºè‡ªå·±æ˜å¤©ä¼šæ¯”ä»Šå¤©æœ‰æ›´å¤šçš„ç©ºé—²æ—¶é—´ã€‚ äººä»¬æ˜¯ä¸ºç†æƒ³ä¸–ç•Œä½œå‡ºé¢„ä¼°ï¼Œå´åœ¨ç°å®ä¸–ç•Œç”Ÿæ´»äº†ä¸¤å‘¨ã€‚ å½“ä½ æƒ³æ”¹å˜æŸç§è¡Œä¸ºçš„æ—¶å€™ï¼Œè¯•ç€å‡å°‘è¡Œä¸ºçš„å˜åŒ–æ€§ï¼Œè€Œä¸æ˜¯å‡å°‘é‚£ç§è¡Œä¸ºã€‚ ä½ æ˜çŸ¥é“åº”è¯¥åšä¸€ä»¶äº‹æƒ…å´æ‹–å»¶ä¸åšæ—¶ï¼Œä¸è¦é—®è‡ªå·±â€œæˆ‘æ˜¯æƒ³ä»Šå¤©åšè¿˜æ˜¯æ˜å¤©åšï¼Ÿâ€ï¼Œè€Œè¦é—®è‡ªå·±â€œæˆ‘æ˜¯ä¸æ˜¯æƒ³æ‰¿æ‹…æ°¸è¿œæ‹–å»¶ä¸‹å»çš„æ¶æœï¼Ÿâ€ ç ”ç©¶è¡¨æ˜ï¼Œé€‰æ‹©å¥åº·ä¸»é£Ÿçš„äººï¼Œé€šå¸¸ä¼šåœ¨é¥®æ–™ã€é…èœå’Œç”œç‚¹ä¸Šçºµå®¹è‡ªå·±ã€‚ æ‰˜å„¿æ‰€ä¼šè®©æ™šæ¥å­©å­çš„çˆ¶æ¯äº¤ç½šæ¬¾ï¼Œä½†è¿™ç§åˆ¶åº¦å®é™…ä¸Šå¢åŠ äº†æ™šæ¥å­©å­çš„æ¦‚ç‡ã€‚å®¶é•¿å¯ä»¥è´­ä¹°æ™šæ¥å­©å­çš„æƒåˆ©ï¼Œä»¥æ­¤æ¥æ¶ˆé™¤è‡ªå·±çš„ç½ªæ¶æ„Ÿã€‚ ä»æœ¬è´¨ä¸Šçœ‹ï¼Œé“å¾·è®¸å¯å°±æ˜¯ä¸€ç§èº«ä»½å±æœºã€‚æˆ‘ä»¬ä¹‹æ‰€ä»¥ä¼šå¥–åŠ±è‡ªå·±çš„è‰¯å¥½è¡Œä¸ºï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å†…å¿ƒæ·±å¤„è®¤ä¸ºï¼ŒçœŸæ­£çš„è‡ªå·±æƒ³åšåäº‹ã€‚ä»è¿™ç‚¹æ¥çœ‹ï¼Œæ¯æ¬¡è‡ªæ§éƒ½æ˜¯ä¸€ç§æƒ©ç½šï¼Œåªæœ‰æ”¾çºµè‡ªæˆ‘æ‰æ˜¯å¥–åŠ±ã€‚ä½†æˆ‘ä»¬ä¸ºä»€ä¹ˆä¸€å®šè¦è¿™æ ·çœ‹å¾…è‡ªå·±å‘¢ï¼Ÿæƒ³è¦èµ°å‡ºâ€œé“å¾·è®¸å¯â€çš„é™·é˜±ï¼Œæˆ‘ä»¬å°±è¦çŸ¥é“ï¼Œé‚£ä¸ªæƒ³å˜å¥½çš„è‡ªå·±æ‰æ˜¯çœŸæ­£çš„è‡ªå·±ï¼Œæƒ³æŒ‰æ ¸å¿ƒä»·å€¼è§‚ç”Ÿæ´»çš„è‡ªå·±ã€‚ åœ¨è¿½æ±‚è‡ªæ§çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¸åº”è¯¥æŠŠæ‰€æœ‰çš„æ„å¿—åŠ›æŒ‘æˆ˜éƒ½æ”¾åœ¨é“å¾·æ ‡å‡†çš„æ¡†æ¶ä¸­ã€‚æˆ‘ä»¬æ€»æ˜¯è½»æ˜“åœ°è®¤ä¸ºï¼Œè‡ªå·±åšè¿‡çš„å–„è¡Œï¼Œæˆ–æ˜¯ä»…ä»…è€ƒè™‘è¦å»åšçš„å–„è¡Œï¼Œç»™äº†æˆ‘ä»¬é“å¾·ä¸Šçš„è®¸å¯ã€‚å¦‚æœåªæŒ‰ç…§â€œæ­£ç¡®â€å’Œâ€œé”™è¯¯â€æ¥åˆ¤æ–­åšè¿‡çš„äº‹ï¼Œè€Œä¸æ˜¯ç‰¢è®°æˆ‘ä»¬çœŸæ­£æƒ³è¦çš„ä¸œè¥¿ï¼Œå°±ä¼šå¸¦æ¥ä¸ç›®æ ‡ç›¸æŠµè§¦çš„å†²åŠ¨ï¼Œå¹¶å…è®¸æˆ‘ä»¬åšå‡ºå¦¨ç¢è‡ªå·±çš„è¡Œä¸ºã€‚æƒ³è¦åšåˆ°å§‹ç»ˆå¦‚ä¸€ï¼Œæˆ‘ä»¬å°±éœ€è¦è®¤åŒç›®æ ‡æœ¬èº«ï¼Œè€Œä¸æ˜¯æˆ‘ä»¬åšå–„äº‹æ—¶çš„å…‰ç¯ã€‚ æ˜å¤©å’Œä»Šå¤©æ¯«æ— åŒºåˆ«ã€‚å½“ä½ æƒ³æ”¹å˜è¡Œä¸ºçš„æ—¶å€™ï¼Œè¯•ç€å‡å°‘è¡Œä¸ºçš„å˜åŒ–æ€§ï¼Œè€Œä¸æ˜¯å‡å°‘æŸç§è¡Œä¸ºã€‚ å–æ¶ˆè®¸å¯ï¼Œç‰¢è®°ç†ç”±ã€‚ä¸‹ä¸€å›ï¼Œå½“ä½ å‘ç°è‡ªå·±åœ¨ç”¨æ›¾ç»çš„å–„è¡Œä¸ºæ”¾çºµè¾©æŠ¤çš„æ—¶å€™ï¼Œåœä¸‹æ¥æƒ³ä¸€æƒ³ä½ åšâ€œå¥½â€äº‹çš„åŸå› ï¼Œè€Œä¸æ˜¯ä½ åº”ä¸åº”è¯¥å¾—åˆ°å¥–åŠ±ã€‚ å¤§è„‘çš„å¼¥å¤©å¤§è°ï¼šä¸ºä»€ä¹ˆæˆ‘ä»¬è¯¯æŠŠæ¸´æœ›å½“å¹¸ç¦ å¤šå·´èƒºä¼šå‘Šè¯‰å¤§è„‘å…¶ä»–çš„éƒ¨åˆ†å®ƒä»¬éœ€è¦æ³¨æ„ä»€ä¹ˆï¼Œæ€æ ·æ‰èƒ½è®©è´ªå©ªçš„æˆ‘ä»¬å¾—æ‰‹ã€‚å¤§é‡çš„å¤šå·´èƒºå¹¶ä¸èƒ½äº§ç”Ÿå¿«ä¹çš„æ„Ÿè§‰ï¼Œé‚£ç§æ„Ÿè§‰æ›´åƒæ˜¯ä¸€ç§æ¿€åŠ±ã€‚æˆ‘ä»¬ä¼šè§‰å¾—è­¦é†’ã€æ¸…é†’ã€ç€è¿·ã€‚æˆ‘ä»¬å‘ç°äº†å¦‚ä½•æ‰èƒ½å¾—åˆ°å¿«ä¹ï¼Œè€Œä¸”æ„¿æ„ä¸ºäº†è·å¾—è¿™ç§æ„Ÿè§‰ä»˜å‡ºåŠªåŠ›ã€‚ è¿™äº›è®¾å¤‡å°±è¿™æ ·ä¿˜è·äº†æˆ‘ä»¬ï¼Œè®©æˆ‘ä»¬ä¸æ–­è¦æ±‚æ›´å¤šã€‚åœ¨æˆ‘ä»¬æ‰€å¤„çš„æ—¶ä»£é‡Œï¼Œå¥–åŠ±çš„æ‰¿è¯ºå¯ä»¥ç”¨æˆ‘ä»¬ä¸Šç½‘æ—¶çš„è¡Œä¸ºæ¥æ‰“æ¯”æ–¹â€”â€”æˆ‘ä»¬æœç´¢ï¼Œå†æœç´¢ï¼Œæœç´¢æ›´å¤šçš„ã€‚æˆ‘ä»¬ç‚¹å‡»é¼ æ ‡ï¼Œå°±åƒç¬¼å­é‡Œçš„å°ç™½é¼ æƒ³å†æ„Ÿå—ä¸€æ¬¡ç”µå‡»ä¸€æ ·ã€‚æˆ‘ä»¬è¿½å¯»ç€éš¾ä»¥æ‰æ‘¸çš„å¥–åŠ±ï¼Œç›´åˆ°æœ€ç»ˆè§‰å¾—æ»¡æ„ã€‚ æ‰‹æœºã€äº’è”ç½‘å’Œå…¶ä»–ç¤¾äº¤åª’ä½“å¯èƒ½æ˜¯æ— æ„ä¸­æ¿€æ´»äº†æˆ‘ä»¬çš„å¥–åŠ±ç³»ç»Ÿï¼Œä½†ç”µè„‘å’Œç”µå­æ¸¸æˆçš„è®¾è®¡è€…æ˜¯æœ‰æ„è¯†åœ°æ§åˆ¶äº†äººä»¬çš„å¥–åŠ±ç³»ç»Ÿï¼Œè®©ç©å®¶ä¸Šé’©ã€‚â€œå‡çº§â€å’Œâ€œè·èƒœâ€éšæ—¶å¯èƒ½å‡ºç°ï¼Œæ¸¸æˆå°±è¿™æ ·æ¿€å‘äº†äººä»¬çš„å…´è¶£ã€‚è¿™ä¹Ÿæ˜¯äººä»¬å¾ˆéš¾æˆ’æ‰æ¸¸æˆçš„åŸå› ã€‚ 2005å¹´ï¼Œ28å²çš„éŸ©å›½é”…ç‚‰ä¿®ç†å·¥ææ‰¿ç”Ÿåœ¨è¿ç»­50ä¸ªå°æ—¶å¥‹æˆ˜â€œæ˜Ÿé™…äº‰éœ¸â€ä¹‹åæ­»äºå¿ƒè¡€ç®¡è¡°ç«­ã€‚ä»–ä¸åƒä¸ç¡ï¼Œåªæƒ³ç»§ç»­ç©æ¸¸æˆã€‚å¬åˆ°è¿™ä»¶äº‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¾ˆéš¾ä¸è”æƒ³åˆ°å¥¥å°”å…¹å’Œç±³å°”çº³å®éªŒä¸­åŠ›ç«­è€Œäº¡çš„å°ç™½é¼ ã€‚ å¤šå·´èƒºåœ¨æˆ‘ä»¬ä¸Šç˜¾æ—¶ä¼šå‘æŒ¥æŸäº›ä½œç”¨ã€‚æœ€ä»¤æˆ‘ä»¬åƒæƒŠçš„æ˜¯å®ƒåœ¨å¸•é‡‘æ£®æ‚£è€…æ²»ç–—è¿‡ç¨‹ä¸­å‘æŒ¥çš„ä½œç”¨ã€‚å¸•é‡‘æ£®ç—‡æ˜¯ä¸€ç§å¸¸è§çš„ç¥ç»é€€åŒ–æ€§ç–¾ç—…ï¼Œç—…å› æ˜¯è„‘ç»†èƒä¸­ç¼ºå°‘å¤šå·´èƒºã€‚å¤šå·´èƒºåœ¨åˆºæ¿€è¡Œä¸ºä¸­èµ·çš„ä½œç”¨ä¸»è¦è¡¨ç°åœ¨ï¼šå‡ç¼“æˆ–å‡å°‘è¿åŠ¨ã€æŠ‘éƒä»¥åŠé—´æ­‡æ€§ç´§å¼ ç—‡ã€‚æ ‡å‡†çš„å¸•é‡‘æ£®æ²»ç–—æ–¹å¼æ˜¯åŒæ—¶æœç”¨ä¸¤ç§è¯ç‰©ï¼šå·¦æ—‹å¤šå·´å’Œå¤šå·´èƒºå—ä½“æ¿€åŠ¨å‰‚ã€‚å‰è€…å¯ä»¥å¸®åŠ©å¤§è„‘äº§ç”Ÿå¤šå·´èƒºï¼Œåè€…èƒ½åˆºæ¿€å¤§è„‘ä¸­çš„å¤šå·´èƒºè…ºä½“ï¼Œæ¨¡ä»¿å¤šå·´èƒºçš„è¡Œä¸ºã€‚å½“ç—…äººåˆšå¼€å§‹æ¥å—è¯ç‰©æ²»ç–—æ—¶ï¼Œå¤§è„‘ä¸­å¤šå·´èƒºçš„å«é‡ä¼šæ¯”å¾€å¸¸å¤šã€‚è¿™å°±å‡è½»äº†å¸•é‡‘æ£®çš„ä¸»è¦ç—‡çŠ¶ï¼Œä½†åŒæ—¶å¸¦æ¥äº†éš¾ä»¥é¢„æ–™çš„æ–°é—®é¢˜ã€‚ å½“å¤šå·´èƒºç»™æˆ‘ä»¬çš„å¤§è„‘å®‰æ’å¯»æ‰¾å¥–åŠ±çš„ä»»åŠ¡æ—¶ï¼Œæˆ‘ä»¬å°±å±•ç°äº†è‡ªå·±æœ€æ•¢äºå†’é™©ã€æœ€å†²åŠ¨ã€æœ€å¤±æ§çš„ä¸€é¢ã€‚ æ›´é‡è¦çš„æ˜¯ï¼Œå¦‚æœå¥–åŠ±è¿Ÿè¿Ÿæ²¡æœ‰åˆ°æ¥çš„è¯ï¼Œå¥–åŠ±çš„æ‰¿è¯ºï¼ˆå’Œä¸€æƒ³åˆ°è¦åœä¸‹æ¥å°±ä¸æ–­å¢é•¿çš„ç„¦è™‘ï¼‰è¶³ä»¥è®©æˆ‘ä»¬ä¸€ç›´ä¸Šç˜¾ã€‚å¦‚æœä½ æ˜¯å®éªŒå®¤é‡Œçš„å°ç™½é¼ ï¼Œä½ å°±ä¼šä¸€æ¬¡æ¬¡åœ°å»æŒ‰æ æ†ï¼Œç›´åˆ°åŠ›ç«­è€Œäº¡æˆ–è¢«é¥¿æ­»ã€‚å¦‚æœä½ æ˜¯äººç±»ï¼Œä½ å°±ä¼šæç©ºé’±åŒ…ã€å¡«æ»¡è‚šå­â€”â€”è¿™è¿˜æ˜¯å¥½çš„ã€‚å¦‚æœä¸¥é‡çš„è¯ï¼Œä½ ä¼šå‘ç°è‡ªå·±æ‚£ä¸Šäº†å¼ºè¿«ç—‡ã€‚ å½“å¥–åŠ±çš„æ‰¿è¯ºé‡Šæ”¾å¤šå·´èƒºçš„æ—¶å€™ï¼Œä½ æ›´å®¹æ˜“å—åˆ°å…¶ä»–å½¢å¼çš„è¯±æƒ‘ã€‚ å¤§é‡åˆ†æ³Œçš„å¤šå·´èƒºä¼šæ”¾å¤§â€œåŠæ—¶è¡Œä¹â€çš„å¿«æ„Ÿï¼Œè®©ä½ ä¸å†å…³å¿ƒé•¿æœŸçš„åæœã€‚ å¦‚æœä½ å’¬äº†ä¸€å£åº—é‡Œæ–°æ¨å‡ºçš„è‚‰æ¡‚å·ï¼Œä½ å°±ä¼šå‘ç°è‡ªå·±åˆå¾€è´­ç‰©è½¦é‡Œå¤šæ”¾äº†å‡ ä»¶ä¸œè¥¿ã€‚å³ä¾¿ä½ æŠµæŒ¡ä½äº†æ ·å“çš„è¯±æƒ‘ï¼Œä½ ä¹Ÿä¼šå› ä¸ºå¤§è„‘é‡Šæ”¾äº†æ›´å¤šçš„å¤šå·´èƒºè€Œå»å¯»æ‰¾ä¸€äº›ä¸œè¥¿ï¼Œä»¥æ»¡è¶³ä½ å¥–åŠ±çš„æ‰¿è¯ºã€‚ å¤§è„‘çš„å¥–åŠ±ç³»ç»Ÿå¯¹æ–°é²œæ„Ÿå’Œå¤šæ ·æ€§ä¹Ÿä¼šæœ‰ååº”ã€‚ä½ çš„å¤šå·´èƒºç¥ç»å…ƒä¼šå¯¹ç†Ÿæ‚‰çš„å¥–åŠ±ååº”è¾ƒå°‘ è™½ç„¶æˆ‘ä»¬æ‰€å¤„çš„ä¸–ç•Œæ€»è®©æˆ‘ä»¬äº§ç”Ÿæ¬²æœ›ï¼Œä½†æˆ‘ä»¬åªè¦ç”¨å¿ƒè§‚å¯Ÿï¼Œå°±èƒ½çœ‹é€ä¸€äº›ä¸œè¥¿ã€‚çŸ¥é“é‚£æ˜¯æ€ä¹ˆä¸€å›äº‹å¹¶ä¸èƒ½å®Œå…¨æ¶ˆé™¤ä½ çš„æ¬²æœ›ï¼Œä½†å®ƒèƒ½è®©ä½ è‡³å°‘æœ‰æœºä¼šæŠ—äº‰ä¸€ä¸‹ï¼Œé”»ç‚¼ä¸€ä¸‹â€œæˆ‘ä¸è¦â€åŠ›é‡ã€‚ æˆ‘ä»¬çš„å¥–åŠ±ç³»ç»Ÿé¢å¯¹å¯èƒ½è·å¾—çš„å¤§å¥–ä¼šæ›´åŠ å…´å¥‹ã€‚å®ƒä¼šä¿ƒä½¿æˆ‘ä»¬å»åšä»»ä½•å¯èƒ½è·å¥–çš„äº‹ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆäººä»¬å®æ„¿ä¹°ä¹é€å½©ç¥¨ï¼Œä¹Ÿä¸æ„¿æ„æŠŠé’±å­˜åˆ°é“¶è¡Œé‡Œ æˆ‘çš„å­¦ç”Ÿé€šè¿‡ä½¿ç”¨éŸ³ä¹ã€æ—¶å°šæ‚å¿—å’Œç”µè§†ï¼Œè®©è‡ªå·±åœ¨åšé€šå¸¸ä¼šæ¨è¿Ÿçš„ä»»åŠ¡æ—¶ï¼Œäº§ç”Ÿæ›´å¤šå¤šå·´èƒºï¼Œå¸®åŠ©ä»–ä»¬æ‰¾åˆ°äº†è§£å†³åŠæ³•ï¼Œæ¯”å¦‚å¸¦ä¸Šå¯æ€•çš„æ–‡ä¹¦å·¥ä½œèµ°è¿›è‡ªå·±å–œæ¬¢çš„å’–å•¡å…ï¼Œè¾¹å–çƒ­å·§å…‹åŠ›è¾¹å®Œæˆå·¥ä½œï¼Œæˆ–æ˜¯æå¯Œåˆ›æ„åœ°ä¹°ä¸€å †åˆ®åˆ®ä¹å½©ç¥¨ï¼ŒæŠŠå®ƒä»¬æ”¾åœ¨ä½ æƒ³æ‹–å»¶çš„é¡¹ç›®å‘¨å›´ã€‚è¿˜æœ‰ä¸€äº›äººæƒ³è±¡è‡ªå·±åŠªåŠ›å·¥ä½œåå–å¾—çš„æœ€ä½³ç»“æœï¼Œè®©æœªæ¥çš„å¥–åŠ±æ˜¾å¾—æ›´åŠ çœŸå®ã€‚å¦‚æœæœ‰ä»€ä¹ˆäº‹è®©ä½ è§‰å¾—å¾ˆä¸æ„‰å¿«ï¼Œæ‰€ä»¥ä½ æ€»æ˜¯æ‹–å»¶ç€ä¸å»åšï¼Œä½ èƒ½ä¸èƒ½æŠŠå®ƒå’Œèƒ½è®©å¤šå·´èƒºç¥ç»å…ƒç‡ƒçƒ§çš„äº‹è”ç³»åœ¨ä¸€èµ·ï¼Œä»è€Œä¿ƒä½¿è‡ªå·±å»åšå‘¢ï¼Ÿ å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿåœä¸‹æ¥è§‚å¯Ÿä¸€ä¸‹ï¼Œè‡ªå·±åœ¨æœ‰æ‰€æ¸´æœ›çš„æ—¶å€™ï¼Œå¤§è„‘å’Œèº«ä½“ä¸­ç©¶ç«Ÿå‘ç”Ÿäº†ä»€ä¹ˆäº‹æƒ…ï¼Œæˆ‘ä»¬å°±ä¼šå‘ç°ï¼Œå¥–åŠ±çš„æ‰¿è¯ºå¸¦ç»™æˆ‘ä»¬çš„å‹åŠ›å’Œå¿«ä¹å‡ ä¹ä¸åˆ†ä¸Šä¸‹ã€‚æ¸´æœ›å¹¶ä¸æ˜¯æ€»èƒ½è®©æˆ‘ä»¬æ„Ÿè§‰è‰¯å¥½ã€‚æœ‰æ—¶å€™ï¼Œå®ƒä¼šè®©æˆ‘ä»¬è§‰å¾—è‡ªå·±å •è½äº†ã€‚è¿™æ˜¯å› ä¸ºï¼Œå¤šå·´èƒºçš„é¦–è¦åŠŸèƒ½æ˜¯è®©æˆ‘ä»¬è¿½æ±‚å¿«ä¹ï¼Œè€Œä¸æ˜¯è®©æˆ‘ä»¬å¿«ä¹ã€‚å®ƒå¹¶ä¸ä»‹æ„ç»™æˆ‘ä»¬æ¥ç‚¹å‹åŠ›ï¼Œå³ä¾¿è¿™ä¼šè®©æˆ‘ä»¬åœ¨è¿½æ±‚å¿«ä¹çš„æ—¶å€™è§‰å¾—ä¸å¿«ä¹ã€‚ å¤§éƒ¨åˆ†äººä¼šæ›´å…³æ³¨å¯¹å¿«ä¹çš„æ‰¿è¯ºï¼Œè€Œä¸å…³æ³¨å¤šå·´èƒºåˆºæ¿€æ¬²æœ›æ—¶æ„Ÿè§‰åˆ°çš„ä¸å¿«ä¹ã€‚ æˆ‘ä»¬è¯¯æŠŠæ¸´æœ›çš„æ„Ÿè§‰å½“åšäº†å¿«ä¹çš„ä¿è¯ã€‚ æˆ‘ä»¬è¯¯ä»¥ä¸ºçš„å¿«ä¹æºæ³‰ï¼Œå…¶å®æ­£æ˜¯ç—›è‹¦çš„æ ¹æºã€‚ å½“æˆ‘ä»¬çš„å¥–åŠ±ç³»ç»Ÿå¹³é™ä¸‹æ¥æ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸ä¼šæ„Ÿåˆ°æ»¡è¶³ï¼Œè€Œæ›´å¯èƒ½è¡¨ç°å¾—å†·æ¼ ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå¾ˆå¤šå¸•é‡‘æ£®ç—…äººä¼šè§‰å¾—æŠ‘éƒï¼Œè€Œä¸æ˜¯å®‰å®ï¼Œå› ä¸ºä»–ä»¬çš„å¤§è„‘æ— æ³•äº§ç”Ÿè¶³å¤Ÿçš„å¤šå·´èƒºã€‚ æˆ‘ä»¬éœ€è¦å¥–åŠ±çš„æ‰¿è¯ºï¼Œè®©æˆ‘ä»¬ä¿æŒå¯¹ç”Ÿæ´»çš„å…´è¶£ï¼Œå¹¶ç»§ç»­ç”Ÿæ´»ä¸‹å»ã€‚å¦‚æœæˆ‘ä»¬å¹¸è¿çš„è¯ï¼Œå¥–åŠ±ç³»ç»Ÿä¼šç»§ç»­è¿™æ ·ä¸ºæˆ‘ä»¬æœåŠ¡ä¸‹å»ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¸Œæœ›å®ƒä¸è¦å’Œæˆ‘ä»¬ä½œå¯¹ã€‚æˆ‘ä»¬æ‰€å¤„çš„ä¸–ç•Œå……æ»¡äº†ç§‘å­¦æŠ€æœ¯ã€å¹¿å‘Šå’Œå„ç§å„æ ·çš„æœºä¼šï¼Œæˆ‘ä»¬æ€»æ˜¯äº§ç”Ÿæ¬²æœ›ï¼Œå´å¾ˆå°‘å¾—åˆ°æ»¡è¶³ã€‚å¦‚æœæˆ‘ä»¬æƒ³æ‹¥æœ‰è‡ªæ§åŠ›ï¼Œå°±éœ€è¦åŒºåˆ†è®©æˆ‘ä»¬çš„ç”Ÿæ´»æœ‰æ„ä¹‰çš„çœŸå®å¥–åŠ±ï¼Œå’Œè®©æˆ‘ä»¬åˆ†æ•£ç²¾åŠ›ã€ä¸Šç˜¾çš„è™šå‡å¥–åŠ±ã€‚å­¦ä¼šåŒºåˆ†è¿™ä¸¤ç§å¥–åŠ±ï¼Œä¹Ÿè®¸æ˜¯æˆ‘ä»¬èƒ½åšåˆ°çš„æœ€å¥½çš„äº‹äº†ã€‚ æ¬²æœ›æ²¡æœ‰ç»å¯¹çš„å¥½åä¹‹åˆ†ï¼Œé‡è¦çš„æ˜¯æ¬²æœ›å°†æˆ‘ä»¬å¼•å‘å“ªä¸ªæ–¹å‘ï¼Œä»¥åŠæˆ‘ä»¬æ˜¯å¦è¶³å¤Ÿæ˜æ™ºï¼ŒçŸ¥é“ä»€ä¹ˆæ—¶å€™è¯¥å¬ä»æ¬²æœ›çš„å£°éŸ³ã€‚ â€œé‚£åˆå¦‚ä½•â€ï¼šæƒ…ç»ªä½è½ä¸ºä½•ä¼šä½¿äººå±ˆæœäºè¯±æƒ‘ï¼Ÿ åœ¨ç ”ç©¶å‹åŠ›ã€ç„¦è™‘ã€ç½ªæ¶æ„Ÿå¯¹è‡ªæ§åŠ›çš„å½±å“æ—¶ï¼Œæˆ‘ä»¬å‘ç°ï¼Œæƒ…ç»ªä½è½ä¼šä½¿äººå±ˆæœï¼Œè€Œä¸”ç»å¸¸æ˜¯ä»¥ä»¤äººåƒæƒŠçš„æ–¹å¼å±ˆæœã€‚ä»¤äººææƒ§çš„å¸çƒŸè­¦ç¤ºä¼šè®©çƒŸæ°‘æ›´æ¸´æœ›é¦™çƒŸï¼Œç»æµå±æœºä¼šè®©äººæ›´æƒ³è´­ç‰©ï¼Œæ™šé—´æ–°é—»ä¼šè®©äººåƒå¾—æ›´å¤šã€‚ å½“ä½ æ„Ÿåˆ°å‹åŠ›æ—¶ï¼Œä½ çš„å¤§è„‘å°±ä¼šæŒ‡å¼•ç€ä½ ï¼Œè®©ä½ å»åšå®ƒè®¤ä¸ºèƒ½å¸¦ç»™ä½ å¿«ä¹çš„äº‹æƒ…ã€‚ ç¥ç»ç§‘å­¦å®¶è¯æ˜äº†ï¼Œå‹åŠ›åŒ…æ‹¬æ„¤æ€’ã€æ‚²ä¼¤ã€è‡ªæˆ‘æ€€ç–‘ã€ç„¦è™‘ç­‰æ¶ˆææƒ…ç»ªï¼Œä¼šä½¿ä½ çš„å¤§è„‘è¿›å…¥å¯»æ‰¾å¥–åŠ±çš„çŠ¶æ€ã€‚åªè¦ä½ çš„å¤§è„‘å’Œå¥–åŠ±çš„æ‰¿è¯ºè”ç³»èµ·æ¥ï¼Œä½ å°±ä¼šæ¸´æœ›å¾—åˆ°é‚£ä¸ªâ€œå¥–åŠ±â€ã€‚ å¥–åŠ±çš„æ‰¿è¯ºå’Œç¼“è§£å‹åŠ›çš„æ‰¿è¯ºä¼šå¯¼è‡´å„ç§å„æ ·ä¸åˆé€»è¾‘çš„è¡Œä¸ºã€‚æ¯”å¦‚ï¼Œä¸€é¡¹ç»æµå­¦ç ”ç©¶å‘ç°ï¼Œé‚£äº›å¯¹è‡ªå·±çš„ç»æµçŠ¶å†µè¡¨ç¤ºæ‹…å¿§çš„å¥³æ€§ï¼Œä¼šé€šè¿‡è´­ç‰©æ¥æ’è§£å†…å¿ƒçš„ç„¦è™‘å’Œå‹æŠ‘ã€‚ æœ‰æ•ˆå’Œæ— æ•ˆçš„ç­–ç•¥æœ€ä¸»è¦çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼ŸçœŸæ­£èƒ½ç¼“è§£å‹åŠ›çš„ä¸æ˜¯é‡Šæ”¾å¤šå·´èƒºæˆ–ä¾èµ–å¥–åŠ±çš„æ‰¿è¯ºï¼Œè€Œæ˜¯å¢åŠ å¤§è„‘ä¸­æ”¹å–„æƒ…ç»ªçš„åŒ–å­¦ç‰©è´¨ï¼Œå¦‚è¡€æ¸…ç´ ã€Î³-æ°¨åŸºä¸é…¸å’Œè®©äººæ„Ÿè§‰è‰¯å¥½çš„å‚¬äº§ç´ ã€‚è¿™äº›ç‰©è´¨è¿˜ä¼šè®©å¤§è„‘ä¸å†å¯¹å‹åŠ›äº§ç”Ÿååº”ï¼Œå‡å°‘èº«ä½“é‡Œçš„å‹åŠ›è·å°”è’™ï¼Œäº§ç”Ÿæœ‰æ²»æ„ˆæ•ˆæœçš„æ”¾æ¾ååº”ã€‚ æ ¹æ®â€œææƒ§ç®¡ç†â€ç†è®ºï¼Œå½“äººç±»æƒ³åˆ°è‡ªå·±çš„æ­»äº¡æ—¶ï¼Œå¾ˆè‡ªç„¶ä¼šè§‰å¾—å®³æ€•ã€‚æˆ‘ä»¬å¯ä»¥æš‚æ—¶é¿å¼€å±é™©ï¼Œä½†ç»ˆç©¶é€ƒä¸è¿‡å®¿å‘½ã€‚æ¯å½“æˆ‘ä»¬æƒ³èµ·è‡ªå·±ä¸å¯èƒ½æ°¸ç”Ÿæ—¶ï¼ˆæ¯”å¦‚ï¼Œçœ‹æ™šé—´æ–°é—»çš„æ—¶å€™ï¼Œæ¯29ç§’æˆ‘ä»¬å°±ä¼šæœ‰ä¸€æ¬¡è¿™æ ·çš„æƒ³æ³•ï¼‰ï¼Œå¤§è„‘å°±ä¼šäº§ç”Ÿææƒ§çš„ååº”ã€‚æˆ‘ä»¬å¹¶éæ€»èƒ½æ„è¯†åˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºç„¦è™‘å¯èƒ½è¿˜æ²¡æœ‰æµ®å‡ºæ°´é¢ï¼Œè¿˜æ²¡æœ‰äº§ç”Ÿå¼ºçƒˆçš„ä¸é€‚æ„Ÿï¼Œæˆ–è€…æˆ‘ä»¬å¹¶ä¸çŸ¥é“è¿™æ˜¯ä¸ºä»€ä¹ˆã€‚å³ä½¿æˆ‘ä»¬æ„è¯†ä¸åˆ°è¿™ç§ææƒ§ï¼Œå®ƒè¿˜æ˜¯ä¼šè®©æˆ‘ä»¬ç«‹å³ä½œå‡ºå›åº”ï¼Œå¯¹æŠ—è‡ªå·±çš„æ— åŠ›æ„Ÿã€‚æˆ‘ä»¬ä¼šå»å¯»æ‰¾ä¿æŠ¤ä¼ï¼Œå¯»æ‰¾ä»»ä½•èƒ½è®©è‡ªå·±è§‰å¾—å®‰å…¨ã€æœ‰åŠ›é‡ã€å¾—åˆ°å®‰æ…°çš„ä¸œè¥¿ ç ”ç©¶å‘ç°ï¼Œå½“æˆ‘ä»¬æ„è¯†åˆ°è‡ªå·±ä¸ä¼šæ°¸ç”Ÿæ—¶ï¼Œæˆ‘ä»¬ä¼šæ›´å®¹æ˜“å±ˆæœäºå„ç§è¯±æƒ‘ï¼Œå°±åƒæ˜¯åœ¨å¥–åŠ±å’Œå‡å‹çš„æ‰¿è¯ºé‡Œå¯»æ‰¾å¸Œæœ›å’Œå®‰å…¨æ„Ÿä¸€æ ·ã€‚ ä¸€é¡¹è°ƒæŸ¥å‘ç°ï¼Œæ–°é—»ä¸­çš„æ­»äº¡æŠ¥é“ä¼šè®©è§‚ä¼—å¯¹è±ªåè½¿è½¦ã€åŠ³åŠ›å£«æ‰‹è¡¨ç­‰å½°æ˜¾èº«ä»½åœ°ä½çš„ä¸œè¥¿äº§ç”Ÿæ›´ç§¯æçš„å›åº”ã€‚è¿™å¹¶ä¸æ˜¯è¯´ï¼Œæˆ‘ä»¬è®¤ä¸ºä¸€å—åŠ³åŠ›å£«æ‰‹è¡¨å°±èƒ½è®©è‡ªå·±ä¸è¢«å¯¼å¼¹æ‰“ä¸­ï¼Œè€Œæ˜¯è¿™äº›å•†å“æå‡äº†æˆ‘ä»¬çš„è‡ªæˆ‘å½¢è±¡ï¼Œè®©æˆ‘ä»¬æ„Ÿåˆ°å……æ»¡åŠ›é‡ã€‚å¯¹å¾ˆå¤šäººæ¥è¯´ï¼Œè´­ç‰©æ˜¯è®©è‡ªå·±æ›´ä¹è§‚ã€æ›´æœ‰æŒæ§æ„Ÿçš„å¿«é€Ÿé€”å¾„ã€‚è¿™å°±æ˜¯ç¾å›½äººä¸ºä»€ä¹ˆåœ¨â€œ9Â·11â€äº‹ä»¶åå¦‚æ­¤æ„¿æ„æ¥å—å°å¸ƒä»€æ€»ç»Ÿçš„æè®®ï¼šâ€œæˆ‘å’Œæˆ‘å¤«äººé¼“åŠ±ç¾å›½äººè´­ç‰©ã€‚â€ â€œææƒ§ç®¡ç†â€çš„æ–¹æ³•èƒ½è®©æˆ‘ä»¬ä¸å»æƒ³é‚£ä¸ªä¸å¯é¿å…çš„æ­»äº¡ã€‚ä½†å½“æˆ‘ä»¬åœ¨è¯±æƒ‘ä¸­å¯»æ‰¾æ…°è—‰çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ˜¯åœ¨ä¸è‡ªè§‰åœ°åŠ é€Ÿè¿ˆå‘åŸå¢“çš„è„šæ­¥ã€‚ æœ‰æ—¶å€™ï¼Œâ€œææƒ§ç®¡ç†â€å¸¦æ¥çš„ä¸æ˜¯è¯±æƒ‘ï¼Œè€Œæ˜¯æ‹–å»¶ã€‚æˆ‘ä»¬æœ€æƒ³æ‹–å»¶çš„å¾ˆå¤šäº‹æƒ…ï¼Œéƒ½å’Œæ­»äº¡æœ‰æˆ–å¤šæˆ–å°‘çš„å…³è”ï¼Œæ¯”å¦‚é¢„çº¦çœ‹åŒ»ç”Ÿï¼ŒæŒ‰å¤„æ–¹å¼€è¯ï¼ŒéµåŒ»å˜±æœè¯ï¼Œä¿ç®¡æ³•å¾‹æ–‡ä»¶å’Œå†™é—å˜±ï¼Œå­˜é’±å…»è€ï¼Œç”šè‡³æ˜¯æ‰”æ‰è‡ªå·±ç»ä¸ä¼šç”¨åˆ°çš„ä¸œè¥¿å’Œä¸åˆèº«çš„è¡£æœã€‚ è¿œç¦»é‚£äº›ä¼šè®©ä½ äº§ç”Ÿææƒ§çš„ç”µè§†æ–°é—»ã€è®¿è°ˆèŠ‚ç›®ã€æ‚å¿—æˆ–ç½‘é¡µã€‚ æ¯«æ— æ„å¤–ï¼Œå¤´å¤©æ™šä¸Šå–äº†å¤ªå¤šé…’çš„äººç¬¬äºŒå¤©æ—©ä¸Šä¼šæ„Ÿåˆ°ç—›è‹¦ï¼Œä¼šè§‰å¾—å¤´ç–¼ã€æ¶å¿ƒã€ç–²å€¦ã€‚ä½†ä»–ä»¬çš„ç—›è‹¦ä¸ä»…ä»…æºäºå®¿é†‰ã€‚å¾ˆå¤šäººè¿˜æ„Ÿåˆ°ç½ªæ¶å’Œç¾æ„§ã€‚è¿™æ‰æ˜¯çœŸæ­£è®©äººæ„Ÿåˆ°å›°æ‰°çš„ã€‚å½“è¢«è¯•è€…å› ä¸ºå‰ä¸€æ™šé¥®é…’è¿‡é‡è€Œæƒ…ç»ªä½è½æ—¶ï¼Œä»–ä»¬æ›´å¯èƒ½åœ¨å½“å¤©æ™šä¸Šæˆ–ä»¥åå–æ›´å¤šçš„é…’ã€‚ç½ªæ¶æ„Ÿé©±ä½¿ä»–ä»¬å†åº¦é¥®é…’ã€‚ å±ˆæœä¼šè®©ä½ å¯¹è‡ªå·±å¤±æœ›ï¼Œä¼šè®©ä½ æƒ³åšä¸€äº›æ”¹å–„å¿ƒæƒ…çš„äº‹ã€‚é‚£ä¹ˆï¼Œæœ€å»‰ä»·ã€æœ€å¿«æ·çš„æ”¹å–„å¿ƒæƒ…çš„æ–¹æ³•æ˜¯ä»€ä¹ˆï¼Ÿå¾€å¾€æ˜¯åšå¯¼è‡´ä½ æƒ…ç»ªä½è½çš„äº‹ã€‚ å…³é”®æ˜¯ï¼Œå¯¼è‡´æ›´å¤šå •è½çš„è¡Œä¸ºå¹¶ä¸æ˜¯ç¬¬ä¸€æ¬¡çš„æ”¾å¼ƒï¼Œè€Œæ˜¯ç¬¬ä¸€æ¬¡æ”¾å¼ƒåäº§ç”Ÿçš„ç¾è€»æ„Ÿã€ç½ªæ¶æ„Ÿã€å¤±æ§æ„Ÿå’Œç»æœ›æ„Ÿã€‚ä¸€æ—¦ä½ é™·å…¥äº†è¿™æ ·çš„å¾ªç¯ï¼Œä¼¼ä¹é™¤äº†ç»§ç»­åšä¸‹å»ï¼Œå°±æ²¡æœ‰åˆ«çš„å‡ºè·¯äº†ã€‚å½“ä½ ï¼ˆåˆä¸€æ¬¡ï¼‰è´£å¤‡è‡ªå·±ï¼ˆåˆä¸€æ¬¡ï¼‰å±ˆæœäºè¯±æƒ‘çš„æ—¶å€™ï¼Œå¾€å¾€ä¼šå¸¦æ¥æ›´å¤šæ„å¿—åŠ›çš„å¤±æ•ˆï¼Œé€ æˆæ›´å¤šçš„ç—›è‹¦ã€‚ä½†æ˜¯ï¼Œä½ å¯»æ±‚å®‰æ…°çš„ä¸œè¥¿å¹¶ä¸èƒ½ä¸­æ–­è¿™ä¸ªå¾ªç¯ï¼Œå®ƒåªä¼šç»™ä½ å¸¦æ¥æ›´æ·±åˆ‡çš„ç½ªæ¶æ„Ÿã€‚ æˆ‘ä»¬å¯èƒ½ä¼šæƒ³ï¼Œç½ªæ¶æ„Ÿä¼šä¿ƒä½¿æˆ‘ä»¬æ”¹æ­£é”™è¯¯ï¼Œä½†å…¶å®è¿™æ­£æ˜¯â€œæƒ…ç»ªä½è½è®©æˆ‘ä»¬å±ˆæœäºè¯±æƒ‘â€çš„å¦ä¸€ä¸ªè¡¨ç°æ–¹å¼ã€‚ ä¼—å¤šç ”ç©¶æ˜¾ç¤ºï¼Œè‡ªæˆ‘æ‰¹è¯„ä¼šé™ä½ç§¯ææ€§å’Œè‡ªæ§åŠ›ï¼Œè€Œä¸”ä¹Ÿæ˜¯æœ€å®¹æ˜“å¯¼è‡´æŠ‘éƒçš„å› ç´ ã€‚å®ƒä¸ä»…è€—å°½äº†â€œæˆ‘è¦åšâ€çš„åŠ›é‡ï¼Œè¿˜è€—å°½äº†â€œæˆ‘æƒ³è¦â€çš„åŠ›é‡ã€‚ç›¸åï¼Œè‡ªæˆ‘åŒæƒ…åˆ™ä¼šæå‡ç§¯ææ€§å’Œè‡ªæ§åŠ›ï¼Œæ¯”å¦‚ï¼Œåœ¨å‹åŠ›å’ŒæŒ«æŠ˜é¢å‰æ”¯æŒè‡ªå·±ã€å¯¹è‡ªå·±å¥½ä¸€äº›ã€‚ å‡ºäººæ„æ–™çš„æ˜¯ï¼Œå¢å¼ºè´£ä»»æ„Ÿçš„ä¸æ˜¯ç½ªæ¶æ„Ÿï¼Œè€Œæ˜¯è‡ªæˆ‘è°…è§£ã€‚ç ”ç©¶äººå‘˜å‘ç°ï¼Œåœ¨ä¸ªäººæŒ«æŠ˜é¢å‰ï¼ŒæŒè‡ªæˆ‘åŒæƒ…æ€åº¦çš„äººæ¯”æŒè‡ªæˆ‘æ‰¹è¯„çš„æ€åº¦çš„äººæ›´æ„¿æ„æ‰¿æ‹…è´£ä»»ã€‚ä»–ä»¬ä¹Ÿæ›´æ„¿æ„æ¥å—åˆ«äººçš„åé¦ˆå’Œå»ºè®®ï¼Œæ›´å¯èƒ½ä»è¿™ç§ç»å†ä¸­å­¦åˆ°ä¸œè¥¿ã€‚ è‡ªæˆ‘è°…è§£èƒ½å¸®åŠ©äººä»¬ä»é”™è¯¯ä¸­æ¢å¤è¿‡æ¥ï¼Œå› ä¸ºå®ƒèƒ½æ¶ˆé™¤äººä»¬æƒ³åˆ°å¤±è´¥æ—¶çš„ç¾æ„§å’Œç—›è‹¦ã€‚ å¦‚æœä½ è§‰å¾—é‡åˆ°æŒ«æŠ˜æ„å‘³ç€ä½ å°†ä¸€äº‹æ— æˆã€åªä¼šæŠŠäº‹æƒ…æç³Ÿï¼Œé‚£ä¹ˆåæ€è¿™ä¸ªæŒ«æŠ˜åªä¼šè®©ä½ åœ¨ç—›è‹¦ä¸­æ›´è®¨åŒè‡ªå·±ã€‚ä½ æœ€ç´§è¿«çš„ç›®æ ‡æ˜¯å®‰æŠšè¿™ç§æ„Ÿè§‰ï¼Œè€Œä¸æ˜¯å¸å–æ•™è®­ã€‚ ä½ åªæ˜¯ä¸ªå‡¡äººã€‚æ¯ä¸ªäººéƒ½ä¼šé‡åˆ°æ„å¿—åŠ›æŒ‘æˆ˜ï¼Œæ¯ä¸ªäººéƒ½æœ‰å¤±å»è‡ªæ§çš„æ—¶å€™ã€‚è¿™åªæ˜¯äººæ€§çš„ç»„æˆéƒ¨åˆ†ï¼ŒæŒ«æŠ˜å¹¶ä¸æ„å‘³ç€ä½ æœ¬èº«æœ‰é—®é¢˜ã€‚æƒ³ä¸€æƒ³è¿™äº›è¯´æ³•æ˜¯ä¸æ˜¯çœŸçš„ã€‚ä½ èƒ½æƒ³è±¡ä½ å°Šæ•¬ã€å…³å¿ƒçš„å…¶ä»–äººä¹Ÿç»å†è¿‡åŒæ ·çš„æŠ—äº‰å’ŒæŒ«æŠ˜å—ï¼Ÿè¿™ä¸ªè§†è§’ä¼šè®©è‡ªæˆ‘æ‰¹è¯„å’Œè‡ªæˆ‘æ€€ç–‘çš„å£°éŸ³å˜å¾—ä¸é‚£ä¹ˆå°–é”ã€‚ å‹åŠ›ä¼šå¼•èµ·æ¬²æœ›ï¼Œè®©æˆ‘ä»¬çš„å¤§è„‘æ›´å®¹æ˜“å—åˆ°è¯±æƒ‘ã€‚å¦‚æœæœ‰ä¸œè¥¿æé†’æˆ‘ä»¬ä¸èƒ½æ°¸ç”Ÿï¼Œå°±ä¼šè®©æˆ‘ä»¬ä»é£Ÿç‰©ã€è´­ç‰©æˆ–é¦™çƒŸä¸­å¯»æ‰¾æ…°è—‰ã€‚é‚£ä¹ˆç½ªæ¶æ„Ÿå’Œè‡ªæˆ‘æ‰¹è¯„å‘¢ï¼Ÿå®ƒä»¬ä¼šè®©ä½ ç«‹åˆ»æƒ³åˆ°â€œé‚£åˆå¦‚ä½•ï¼Œæˆ‘è¿˜ä¸å¦‚å†æ”¾çºµä¸€ä¸‹è‡ªå·±å‘¢â€ã€‚ å‘èª“æ”¹å˜ä¼šè®©æˆ‘ä»¬å……æ»¡å¸Œæœ›ã€‚æˆ‘ä»¬å–œæ¬¢æƒ³è±¡æ”¹å˜åçš„ç”Ÿæ´»ï¼Œå¹»æƒ³æ”¹å˜åçš„è‡ªå·±ã€‚ç ”ç©¶æ˜¾ç¤ºï¼ŒèŠ‚é£Ÿè®¡åˆ’ä¼šè®©äººæ„Ÿè§‰æ›´æœ‰åŠ›é‡ï¼Œè¿åŠ¨è®¡åˆ’ä¼šè®©äººè§‰å¾—è‡ªå·±æ›´é«˜å¤§ã€‚ï¼ˆå½“ç„¶ï¼Œè¿™äº›å¹»æƒ³ä¸ä¸€å®šä¼šå®ç°ã€‚ï¼‰ ä¸å¹¸çš„æ˜¯ï¼Œå°±åƒå¥–åŠ±çš„æ‰¿è¯ºå’Œç¼“è§£å‹åŠ›çš„æ‰¿è¯ºä¸€æ ·ï¼Œæ”¹å˜çš„æ‰¿è¯ºä¹Ÿå¾ˆå°‘èƒ½æœæˆ‘ä»¬å¸Œæœ›çš„æ–¹å‘å‘å±•ã€‚ä¸åˆ‡å®é™…çš„ä¹è§‚å¯èƒ½ç»™æˆ‘ä»¬ä¸€æ—¶çš„å¿«ä¹ï¼Œä½†æ¥ä¸‹æ¥æˆ‘ä»¬å°±ä¼šæ„Ÿåˆ°å¤±è½ã€‚ å½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡é¢å¯¹æŒ«æŠ˜æ—¶ï¼Œå¤±æœ›å°±ä¼šå–ä»£æœ€åˆå†³å®šæ”¹å˜æ—¶çš„è‰¯å¥½æ„Ÿè§‰ã€‚æ²¡èƒ½è¾¾åˆ°é¢„æœŸç›®æ ‡ä¼šå†åº¦å¼•å‘æ›¾ç»çš„ç½ªæ¶æ„Ÿã€æŠ‘éƒå’Œè‡ªæˆ‘æ€€ç–‘ï¼Œè€Œæ‰¿è¯ºæ”¹å˜çš„æƒ…ç»ªæ…°è—‰ä½œç”¨ä¹Ÿæ¶ˆå¤±äº†ã€‚è¿™æ—¶ï¼Œå¤§å¤šæ•°äººä¼šå½»åº•æ”¾å¼ƒåŠªåŠ›ã€‚åªæœ‰å½“æˆ‘ä»¬æ„Ÿè§‰å¤±æ§ï¼Œéœ€è¦å†æ¬¡æ‹¥æœ‰å¸Œæœ›çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰ä¼šå†æ¬¡å‘èª“ä½œå‡ºæ”¹å˜ã€‚äºæ˜¯ï¼Œè¿™ä¸ªå¾ªç¯åˆå¼€å§‹äº†ã€‚ æˆ‘ä»¬éœ€è¦ç›¸ä¿¡ï¼Œæ”¹å˜æ˜¯å¯èƒ½åšåˆ°çš„ã€‚å¦‚æœå¤±å»äº†å¸Œæœ›ï¼Œæˆ‘ä»¬å°±ä¼šå¬å¤©ç”±å‘½äº†ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¿…é¡»é¿å…å¸¸è§çš„æ„å¿—åŠ›é™·é˜±ï¼Œå³ç”¨â€œæ”¹å˜çš„æ‰¿è¯ºâ€è€Œä¸æ˜¯â€œæ”¹å˜â€æ¥æ”¹å–„æˆ‘ä»¬çš„å¿ƒæƒ…ã€‚å¦åˆ™ï¼Œè¿™ç§çœ‹ä¼¼æ„å¿—åŠ›çš„ä¸œè¥¿å°±ä¼šæŠŠæˆ‘ä»¬å˜æˆæŒ‰å‹æ æ†çš„å°ç™½é¼ ï¼Œè§‰å¾—è¿™ä¸ªä¸œè¥¿èƒ½è®©æˆ‘ä»¬è·å¾—å¥–åŠ±ã€‚ ä¹è§‚ç»™æˆ‘ä»¬åŠ¨åŠ›ï¼Œä½†å°‘è®¸çš„æ‚²è§‚èƒ½å¸®æˆ‘ä»¬èµ°å‘æˆåŠŸã€‚ç ”ç©¶å‘ç°ï¼Œå¦‚æœèƒ½é¢„æµ‹è‡ªå·±ä»€ä¹ˆæ—¶å€™ã€ä¼šå¦‚ä½•å—åˆ°è¯±æƒ‘å’Œè¿èƒŒæ‰¿è¯ºï¼Œä½ å°±æ›´æœ‰å¯èƒ½æ‹¥æœ‰åšå®šçš„å†³å¿ƒã€‚ ä¸ºäº†é¿å…å‹åŠ›å¯¼è‡´çš„æ„å¿—åŠ›å¤±æ•ˆï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°èƒ½è®©æˆ‘ä»¬çœŸæ­£å¿«ä¹çš„ä¸œè¥¿ï¼Œè€Œä¸æ˜¯è™šå‡çš„å¥–åŠ±æ‰¿è¯ºï¼Œä¹Ÿä¸æ˜¯ç©ºæ´çš„æ”¹å˜æ‰¿è¯ºã€‚æˆ‘ä»¬éœ€è¦å…è®¸è‡ªå·±å»åšçœŸæ­£è®©è‡ªå·±å¿«ä¹çš„äº‹ï¼Œè¿œç¦»é‚£äº›ä¸æˆ‘ä»¬ç”Ÿæ´»æ— å…³çš„å‹åŠ›æ ¹æºã€‚å½“æˆ‘ä»¬é­é‡æŒ«æŠ˜æ—¶ï¼ˆè¿™ç§æƒ…å†µæ˜¯éš¾ä»¥é¿å…çš„ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦åŸè°…æ›¾ç»çš„å¤±è´¥ï¼Œä¸è¦æŠŠå®ƒä»¬ä½œä¸ºå±ˆæœæˆ–æ”¾å¼ƒçš„å€Ÿå£ã€‚æƒ³è¦å¢å¼ºè‡ªæ§åŠ›ï¼Œè‡ªæˆ‘åŒæƒ…æ¯”è‡ªæˆ‘æ‰“å‡»æœ‰æ•ˆå¾—å¤šã€‚ å‡ºå”®æœªæ¥ï¼šåŠæ—¶äº«ä¹çš„ç»æµå­¦ å¦‚æœæˆ‘ä»¬å¤„åœ¨æœ€ä½³çŠ¶æ€ï¼Œäººç±»æ§åˆ¶å†²åŠ¨çš„èƒ½åŠ›è®©å…¶ä»–ç‰©ç§è‡ªæƒ­å½¢ç§½ã€‚ä½†é€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æƒ³è±¡åŠ›ä¸°å¯Œçš„å¤§è„‘ä¸ä¼šä½œå‡ºæœ€æœ‰æˆ˜ç•¥æ€§çš„å†³å®šï¼Œè€Œæ˜¯è®©æˆ‘ä»¬è¡¨ç°å¾—åƒæ˜¯å¤±å»äº†ç†æ€§ã€‚è¿™æ˜¯å› ä¸ºï¼Œå‰é¢çš®è´¨æœ€æ“…é•¿çš„ä¸æ˜¯è‡ªæ§ã€‚å®ƒä¼šä¸ºé”™è¯¯çš„å†³å®šå¯»æ‰¾å€Ÿå£ï¼Œå‘æˆ‘ä»¬æ‰¿è¯ºæ˜å¤©ä¼šæ›´å¥½ã€‚ä½ å¯ä»¥è‚¯å®šï¼Œé‚£äº›é»‘çŒ©çŒ©ä¸ä¼šå¯¹è‡ªå·±è¯´ï¼šâ€œæˆ‘ç°åœ¨è¦åƒ2é¢—è‘¡è„ï¼Œå› ä¸ºæˆ‘è¿˜æœ‰ä¸‹ä¸€æ¬¡å¯ä»¥ç­‰ç€åƒ6é¢—è‘¡è„ã€‚â€ä½†äººç±»æ€»æœ‰å„ç§å„æ ·çš„èŠ±æ‹›ï¼Œè®©è‡ªå·±ç›¸ä¿¡æŠµæŠ—è¯±æƒ‘æ˜¯æ˜å¤©çš„äº‹æƒ…ã€‚å› æ­¤ï¼Œæ‹¥æœ‰å·¨å¤§å‰é¢çš®è´¨çš„æˆ‘ä»¬ï¼Œä¼šä¸€å†å±ˆæœäºå³åˆ»çš„æ»¡è¶³æ„Ÿã€‚ ä¸ºäº†è¿…é€Ÿå¾—åˆ°ç¬é—´çš„å¿«æ„Ÿï¼Œä»–ä»¬å¿˜è®°äº†è‡ªå·±çœŸæ­£æƒ³è¦çš„ä¸œè¥¿ã€‚ ç»æµå­¦å®¶ç§°ä¹‹ä¸ºâ€œå»¶è¿ŸæŠ˜æ‰£â€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç­‰å¾…å¥–åŠ±çš„æ—¶é—´è¶Šé•¿ï¼Œå¥–åŠ±å¯¹ä½ æ¥è¯´ä»·å€¼è¶Šä½ã€‚å¾ˆå°çš„å»¶è¿Ÿå°±èƒ½å¤§å¹…é™ä½ä½ æ„ŸçŸ¥åˆ°çš„ä»·å€¼ã€‚ å½“è¯±æƒ‘çœŸå®å­˜åœ¨æ—¶ï¼Œæˆ‘ä»¬çš„å¤§è„‘å°±è¿›å…¥äº†â€œæœå¯»å¥–åŠ±â€æ¨¡å¼ï¼Œç¡®ä¿æˆ‘ä»¬ä¸ä¼šé”™è¿‡ä»»ä½•å¥–åŠ±ã€‚ å½“æˆ‘ä»¬å’Œè¯±æƒ‘æ­£é¢äº¤é”‹çš„æ—¶å€™ï¼Œæˆ‘ä»¬åªæ„¿æ„é€‰æ‹©çŸ­æœŸçš„ã€å³æ—¶çš„å¥–åŠ±ï¼Œè¿™ç§æ¬²æœ›æ˜¯æ— å¯æŠµæŒ¡çš„ã€‚è¿™å°±å¸¦æ¥äº†â€œæœ‰é™æ„å¿—åŠ›â€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ°æˆ‘ä»¬çœŸçš„éœ€è¦è‡ªæ§åŠ›ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸€ç›´æ‹¥æœ‰è‡ªæ§åŠ›ã€‚ æˆ‘ä»¬åœ¨æƒè¡¡â€œå³æ—¶å¥–åŠ±â€å’Œâ€œæœªæ¥å¥–åŠ±â€æ—¶ï¼Œå¤§è„‘å¤„ç†é€‰é¡¹çš„æ–¹å¼ç›¸å½“ä¸ä¸€æ ·ã€‚â€œå³æ—¶å¥–åŠ±â€ä¼šæ¿€æ´»æ›´å¤è€ã€æ›´åŸå§‹çš„å¥–åŠ±ç³»ç»Ÿï¼Œåˆºæ¿€ç›¸åº”çš„å¤šå·´èƒºäº§ç”Ÿæ¬²æœ›ã€‚â€œæœªæ¥å¥–åŠ±â€åˆ™ä¸å¤ªèƒ½æ¿€æ´»è¿™ä¸ªå¥–åŠ±ç³»ç»Ÿã€‚ å¯¹é‚£äº›æƒ³å»¶è¿Ÿå¿«æ„Ÿçš„äººæ¥è¯´ï¼Œè¿™æ˜¯ä¸ªå¥½æ¶ˆæ¯ã€‚åªè¦ä½ èƒ½åˆ›é€ ä¸€ç‚¹è·ç¦»ï¼Œå°±ä¼šè®©æ‹’ç»å˜å¾—å®¹æ˜“èµ·æ¥ã€‚ å½“ä»–å¯¹è‡ªå·±çš„æ¬²æœ›ç›´æˆªäº†å½“åœ°è¯´â€œä¸â€æ—¶ï¼Œé‚£å¥â€œå¥½ï¼Œä½†è¦ç­‰10åˆ†é’Ÿâ€å‡å°‘äº†ä¸€éƒ¨åˆ†çš„ææƒ§å’Œå‹åŠ›ï¼Œè®©ä»–ç­‰èµ·æ¥æ›´è½»æ¾ã€‚å‡ æ¬¡ä¹‹åï¼Œä»–å°±èƒ½è½¬ç§»æ³¨æ„åŠ›ï¼Œå¿˜æ‰å¸çƒŸçš„å†²åŠ¨äº†ã€‚ å½“ä½ è§‰å¾—è‡ªå·±æ— æ³•åšåˆ°â€œä¸ä¼šæœ‰ä¸‹ä¸€æ¬¡â€çš„æ—¶å€™ï¼Œä¸å¦¨ç”¨â€œ10åˆ†é’Ÿå»¶è¿Ÿæ³•åˆ™â€æ¥å¢å¼ºä½ çš„è‡ªæ§åŠ›ã€‚ 1231. å½“ä½ å—åˆ°è¯±æƒ‘è¦åšä¸é•¿æœŸåˆ©ç›Šç›¸æ‚–çš„äº‹æ—¶ï¼Œè¯·æƒ³è±¡ä¸€ä¸‹ï¼Œè¿™ä¸ªé€‰æ‹©å°±æ„å‘³ç€ï¼Œä½ ä¸ºäº†å³æ—¶çš„æ»¡è¶³æ„Ÿæ”¾å¼ƒäº†æ›´å¥½çš„é•¿æœŸå¥–åŠ±ã€‚2. æƒ³è±¡ä½ å·²ç»å¾—åˆ°äº†é•¿æœŸçš„å¥–åŠ±ã€‚æƒ³è±¡æœªæ¥çš„ä½ æ­£åœ¨äº«å—è‡ªæ§çš„æˆæœã€‚3. ç„¶åæ‰ªå¿ƒè‡ªé—®ï¼šä½ æ„¿æ„æ”¾å¼ƒå®ƒï¼Œæ¥æ¢å–æ­£åœ¨è¯±æƒ‘ä½ çš„çŸ­æš‚å¿«æ„Ÿå—ï¼Ÿ å¤§è„‘ä¼šæŠŠæœªæ¥çš„è‡ªå·±å½“æˆåˆ«äººï¼Œè¿™ç§ä¹ æƒ¯å¯¹è‡ªæ§åŠ›å½±å“æå¤§ã€‚ç ”ç©¶å‘ç°ï¼Œå½“ä½ æƒ³åˆ°æœªæ¥çš„è‡ªå·±æ—¶ï¼Œå¤§è„‘ä¸­è¶Šæ˜¯æƒ³ä¸åˆ°è‡ªå·±ï¼Œä½ å°±è¶Šå¯èƒ½å¯¹æœªæ¥çš„è‡ªå·±è¯´â€œå»ä½ çš„â€ï¼Œä¹Ÿå°±è¶Šå¯èƒ½å¯¹å³æ—¶çš„æ»¡è¶³æ„Ÿè¯´â€œå¥½â€ã€‚ å½“æˆ‘ä»¬æ€è€ƒæœªæ¥æ—¶ï¼Œæˆ‘ä»¬èƒ½é¢„æµ‹åˆ°æœªæ¥çš„è‡ªå·±å’Œæƒ³è±¡ä¸­æœ‰ä»€ä¹ˆä¸åŒã€‚æœªæ¥çš„å¥–åŠ±ä¼¼ä¹å¹¶ä¸é‚£ä¹ˆæœ‰è¯±æƒ‘åŠ›ï¼Œæ‰€ä»¥æˆ‘ä»¬é€‰æ‹©äº†å³æ—¶çš„æ»¡è¶³æ„Ÿã€‚æˆ‘ä»¬æ— æ³•é¢„æµ‹è‡ªå·±ä¼šæ€ä¹ˆå—åˆ°è¯±æƒ‘ã€æ€ä¹ˆè¢«åˆ†æ•£æ³¨æ„åŠ›ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•åšå®šè‡ªå·±çš„ç›®æ ‡ã€‚å¦‚æœæˆ‘ä»¬æƒ³ä½œå‡ºæ›´æ˜æ™ºçš„å†³å®šï¼Œå°±è¦æ›´å¥½åœ°ç†è§£å’Œæ”¯æŒæœªæ¥çš„è‡ªå·±ã€‚æˆ‘ä»¬è¿˜éœ€è¦è®°ä½ï¼Œä¸ºç°åœ¨çš„è¡Œä¸ºæ‰¿æ‹…åæœçš„ï¼Œçœ‹ä¼¼æ˜¯æœªæ¥çš„è‡ªå·±ï¼Œå®é™…ä¸Šè¿˜æ˜¯æˆ‘ä»¬è‡ªå·±ã€‚æœªæ¥çš„è‡ªå·±ä¼šå¯¹æˆ‘ä»¬ç°åœ¨çš„ä»˜å‡ºæ„Ÿæ¿€ä¸å°½ã€‚ ä¼ æŸ“ï¼šä¸ºä»€ä¹ˆæ„å¿—åŠ›ä¼šä¼ æŸ“ï¼Ÿ æ„å¿—åŠ›è–„å¼±å¯èƒ½ä¼šä¼ æŸ“ï¼Œä½†ä½ ä»ç„¶å¯ä»¥è·å¾—è‡ªæ§åŠ›ã€‚ æˆ‘ä»¬æœ‰æ¨¡ä»¿åˆ«äººè¡ŒåŠ¨çš„æœ¬èƒ½ï¼Œè¿™å°±æ„å‘³ç€ï¼Œå½“ä½ çœ‹åˆ°åˆ«äººå»æ‹¿é›¶é£Ÿã€é¥®æ–™æˆ–ä¿¡ç”¨å¡çš„æ—¶å€™ï¼Œä½ è‡ªå·±ä¹Ÿä¼šæ— æ„è¯†åœ°æ¨¡ä»¿ä»–ä»¬çš„è¡Œä¸ºã€‚åŒæ—¶ï¼Œä½ ä¹Ÿä¼šå¤±å»è‡ªå·±çš„æ„å¿—åŠ›ã€‚ å½“æˆ‘ä»¬æƒ³è±¡åˆ«äººæƒ³è¦ä»€ä¹ˆçš„æ—¶å€™ï¼Œä»–ä»¬çš„æ¬²æœ›å°±ä¼šå¼•å‘æˆ‘ä»¬çš„æ¬²æœ›ï¼Œä»–ä»¬çš„é£Ÿæ¬²ä¹Ÿä¼šå¼•å‘æˆ‘ä»¬çš„é£Ÿæ¬²ã€‚ æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬æ„ŸæŸ“çš„ä¸æ˜¯æŸç§å…·ä½“çš„ç›®æ ‡ï¼Œæ¯”å¦‚åƒé›¶é£Ÿã€èŠ±é’±ã€è¯±æƒ‘é™Œç”Ÿäººï¼Œè€Œæ˜¯å’Œæˆ‘ä»¬çš„å†²åŠ¨ä¸€è‡´çš„ã€æ›´æ™®éçš„ç›®æ ‡ã€‚ äººä»¬æ„ŸæŸ“çš„ç›®æ ‡æ˜¯åšè‡ªå·±æƒ³åšçš„äº‹ï¼Œè€Œä¸æ˜¯è‡ªå·±åº”è¯¥åšçš„äº‹ã€‚ ä¸ºä»€ä¹ˆåœ¨å…³ç³»å¯†åˆ‡çš„äººä¸­é—´ï¼Œè¡Œä¸ºä¼šä¼ æŸ“å¾—è¿™ä¹ˆä¸¥é‡å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ç”¨å…ç–«ç³»ç»Ÿä½œä¸ªç±»æ¯”ã€‚åªæœ‰å½“å…ç–«ç³»ç»Ÿå‘ç°é‚£äº›äººâ€œå’Œæˆ‘ä»¬ä¸åŒâ€æ—¶ï¼Œå®ƒæ‰ä¼šæ‹’ç»ä»–ä»¬çš„ç›®æ ‡å’Œè¡Œä¸ºã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬ä½“å†…çš„å…ç–«ç³»ç»Ÿä¸ä¼šæ”»å‡»è‡ªèº«çš„ç»†èƒã€‚åªè¦å®ƒèƒ½è¾¨åˆ«å‡ºé‚£æ˜¯è‡ªå·±çš„ä¸œè¥¿ï¼Œå®ƒå°±ä¸ä¼šä½œå‡ºä»»ä½•ååº”ã€‚ å½“æˆ‘ä»¬æƒ³åˆ°æˆ‘ä»¬å–œçˆ±ã€å°Šé‡çš„äººå’Œæ„Ÿè§‰ç›¸ä¼¼çš„äººæ—¶ï¼Œæˆ‘ä»¬çš„å¤§è„‘ä¼šåƒå¯¹å¾…è‡ªå·±ä¸€æ ·å¯¹å¾…ä»–ä»¬ï¼Œè€Œä¸ä¼šæŠŠä»–ä»¬è§†ä¸ºâ€œåˆ«äººâ€ã€‚ å½“ä»–ä»¬è®¤è¯†åˆ°è‡ªå·±çš„è¡Œä¸ºä¸ä¿¡ä»°ä¸ç¬¦æ—¶ï¼Œé¼“åŠ±ä»–ä»¬å»åˆ¶è®¢æ”¹å˜è¡Œä¸ºçš„è®¡åˆ’ã€‚ç›¸ä¿¡å¥½çš„åŸºç£å¾’åº”è¯¥å‡è‚¥å’Œé”»ç‚¼èº«ä½“ï¼Œè¿™æ˜¯å¼ºæœ‰åŠ›çš„â€œç¤¾ä¼šè®¤åŒâ€ï¼Œè¿œæ¯”æ£€æµ‹å‡ºé«˜èƒ†å›ºé†‡ååŒ»ç”Ÿçš„ä¸¥å‰è­¦å‘Šæ¥å¾—æœ‰æ•ˆã€‚ å¦‚æœæˆ‘ä»¬æƒ³è®©åˆ«äººæ›´æœ‰æ„å¿—åŠ›ï¼Œå°±è¦è®©ä»–ä»¬ç›¸ä¿¡è‡ªæ§æ˜¯ä¸ªç¤¾ä¼šè§„èŒƒã€‚ 2010å¹´ã€Šå†…ç§‘åŒ»å­¦æ¡£æ¡ˆã€‹ä¸­çš„ä¸€ä»½æŠ¥å‘ŠæŒ‡å‡ºï¼Œæœ‰37%çš„äººåœ¨è¢«ä¸´åºŠè¯Šæ–­ä¸ºè‚¥èƒ–åï¼Œä¸ä»…è®¤ä¸ºè‡ªå·±å¹¶ä¸èƒ–ï¼Œè¿˜ç›¸ä¿¡è‡ªå·±å˜èƒ–çš„é£é™©å¾ˆä½ã€‚ åœ¨è¯´åˆ°â€œç¤¾ä¼šè®¤åŒâ€çš„æ—¶å€™ï¼Œæˆ‘ä»¬è®¤ä¸ºåˆ«äººåšçš„äº‹æ¯”åˆ«äººå®é™…åšçš„æ›´é‡è¦ã€‚æ¯”å¦‚ï¼Œå¤§å­¦ç”Ÿå¯¹èº«è¾¹åŒå­¦æ™®éä½œå¼Šçš„æƒ…å†µä¼°è®¡è¿‡é«˜ã€‚è¦æƒ³çŸ¥é“ä¸€ä¸ªå­¦ç”Ÿæœ‰æ²¡æœ‰ä½œå¼Šï¼Œè¦çœ‹ä»–æ˜¯å¦ç›¸ä¿¡åˆ«äººä¹Ÿåœ¨ä½œå¼Šï¼Œè€Œä¸æ˜¯çœ‹ä½œå¼Šçš„æƒ©ç½šæ˜¯å¦ä¸¥å‰ï¼Œä¹Ÿä¸æ˜¯çœ‹ä»–æ˜¯å¦è®¤ä¸ºè‡ªå·±ä¼šè¢«æŠ“ã€‚å½“ä»–ä»¬ç›¸ä¿¡è‡ªå·±çš„åŒå­¦ä½œäº†å¼Šæ—¶ï¼ŒåŸæœ¬è¯šå®çš„ç­çº§ä¹Ÿä¼šå˜æˆæ‰€æœ‰å­¦ç”Ÿéƒ½åœ¨è€ƒè¯•ä¸­å‘çŸ­ä¿¡ã€ä¼ ç­”æ¡ˆçš„ç­çº§ã€‚ï¼ˆæ˜¯çš„ï¼Œæˆ‘æ›¾æŠ“åˆ°ä¸€ä¸ªå­¦ç”ŸæŠ„åˆ«äººç­”æ¡ˆã€‚ï¼‰ å¦‚æœæˆ‘ä»¬è®¤ä¸ºåˆ«äººè¿˜åœ¨åšæˆ‘ä»¬è¯•å›¾æ”¹æ‰çš„ä¸è‰¯è¡Œä¸ºï¼Œé‚£ä¹ˆâ€œç¤¾ä¼šè®¤åŒâ€å°±ä¼šå¦¨ç¢æˆ‘ä»¬ä½œå‡ºæ”¹å˜ã€‚ è‡ªè±ªå’Œç¾æ„§ä¾èµ–å¤§è„‘çš®å±‚çš„æƒ…ç»ªåŒºï¼Œè€Œä¸æ˜¯ç”¨æ¥ä½œé€»è¾‘åˆ†æçš„å‰é¢çš®å±‚ã€‚ç¤¾ä¼šæƒ…æ„Ÿå¯èƒ½è¿›ä¸€æ­¥å¸®åŠ©æˆ‘ä»¬ä½œå‡ºé€‰æ‹©ï¼Œè®©æˆ‘ä»¬åœ¨è‡ªå·±çš„ç¾¤ä½“é‡Œç«™ç¨³è„šè·Ÿã€‚ å®éªŒç ”ç©¶å‘ç°ï¼Œè¡¨ç°å‡ºå†…ç–šæ„Ÿä¼šå‡å°‘å¿ƒç‡çš„å˜åŒ–ï¼Œé™ä½æ„å¿—åŠ›çš„ç”Ÿç†å‚¨å¤‡ã€‚åä¹‹ï¼Œè‡ªè±ªæ„Ÿä¼šä¿æŒç”šè‡³å¢åŠ è¿™ç§å‚¨å¤‡ã€‚ ä¸ºäº†è®©è‡ªè±ªæ„Ÿå‘æŒ¥ä½œç”¨ï¼Œæˆ‘ä»¬å¿…é¡»è®¤ä¸ºåˆ«äººéƒ½åœ¨ç›‘è§†è‡ªå·±ï¼Œæˆ–æˆ‘ä»¬æœ‰æœºä¼šå‘åˆ«äººæŠ¥å‘Šè‡ªå·±çš„æˆåŠŸã€‚ è®©è‡ªå·±åšå®šå†³å¿ƒçš„æœ‰æ•ˆç­–ç•¥æ˜¯â€”â€”å…¬å¼€ä½ çš„æ„å¿—åŠ›æŒ‘æˆ˜ ç ”ç©¶æ˜¾ç¤ºï¼Œäººä¸€æ—¦è¢«è¸¢å‡ºç¾¤ä½“ï¼Œæ„å¿—åŠ›å°±ä¼šè€—ç«­ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå½“äººä»¬è¢«ç¤¾ä¼šæ‹’ç»æ—¶ï¼Œä»–ä»¬å°±å¾ˆéš¾æŠµåˆ¶æ–°é²œå‡ºç‚‰çš„æ›²å¥‡é¥¼å¹²ï¼Œé¢å¯¹å…·æœ‰æŒ‘æˆ˜æ€§çš„ä»»åŠ¡ä¼šå¾ˆå¿«æ”¾å¼ƒï¼Œåœ¨éœ€è¦ç²¾ç¥é›†ä¸­çš„å®éªŒé‡Œä¹Ÿæ›´å®¹æ˜“åˆ†å¿ƒã€‚ ç ”ç©¶ä¹Ÿæ˜¾ç¤ºï¼Œå°‘æ•°æ—ç¾¤è¶Šæ˜¯å—åˆ°æ­§è§†ï¼Œè‡ªæˆ‘æ§åˆ¶èƒ½åŠ›å°±è¶Šå·®ã€‚è¿™åªæ˜¯æé†’å°‘æ•°æ—ç¾¤ï¼Œæ­§è§†ä¼šè€—å°½ä»–ä»¬çš„æ„å¿—åŠ›ã€‚åªè¦æˆ‘ä»¬è§‰å¾—è¢«æ’æ–¥æˆ–è¢«å†’çŠ¯ï¼Œæˆ‘ä»¬å°±æœ‰å¯èƒ½å±ˆæœäºè‡ªå·±æœ€ç³Ÿç³•çš„å†²åŠ¨ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬çš„å¤§è„‘ä¼šæŠŠåˆ«äººçš„ç›®æ ‡ã€ä¿¡å¿µå’Œè¡Œä¸ºæ•´åˆåˆ°è‡ªå·±çš„å†³ç­–ä¸­ã€‚å½“æˆ‘ä»¬è·Ÿåˆ«äººåœ¨ä¸€èµ·æ—¶ï¼Œæˆ–è€…åªæ˜¯ç®€å•åœ°æƒ³åˆ°ä»–ä»¬æ—¶ï¼Œåœ¨æˆ‘ä»¬çš„è„‘æµ·é‡Œï¼Œåˆ«äººå°±ä¼šæˆä¸ºå¦ä¸€ä¸ªâ€œè‡ªæˆ‘â€ï¼Œå¹¶ä¸”å’Œâ€œè‡ªæˆ‘â€æ¯”èµ›è‡ªæ§ã€‚åä¹‹äº¦ç„¶ï¼šæˆ‘ä»¬çš„è¡Œä¸ºä¹Ÿå½±å“äº†å…¶ä»–æ— æ•°äººï¼Œæˆ‘ä»¬åšçš„æ¯ä¸ªé€‰æ‹©å¯¹åˆ«äººæ¥è¯´ä¹Ÿæ˜¯ä¸€ç§é¼“èˆæˆ–è¯±æƒ‘ã€‚ åˆ«è¯»è¿™ç« ï¼šâ€œæˆ‘ä¸è¦â€åŠ›é‡çš„å±€é™æ€§ æ²¡æ³•ä¸å»æƒ³ç™½ç†Šï¼Œè¿™æˆ–è®¸ä¸æ˜¯æœ€ç³Ÿç³•çš„æ„å¿—åŠ›å¤±æ•ˆçš„æ¡ˆä¾‹ã€‚ä½†æ­£å¦‚æˆ‘ä»¬æ‰€è§ï¼Œè¶Šæ˜¯ä¸è®©æˆ‘ä»¬æƒ³ä¸€ä»¶äº‹ï¼Œæˆ‘ä»¬å°±ä¼šè¶Šå»æƒ³å®ƒã€‚å¯¹ç„¦è™‘ã€æ²®ä¸§ã€èŠ‚é£Ÿã€ä¸Šç˜¾çš„æœ€æ–°è°ƒæŸ¥è¯å®ï¼ŒæŠŠâ€œæˆ‘ä¸è¦â€çš„åŠ›é‡ç”¨åœ¨æ¶‰åŠæ€æƒ³ã€æƒ…æ„Ÿçš„å†…å¿ƒä¸–ç•Œï¼Œå®ƒå°±ä¼šå¤±æ•ˆã€‚å½“æ·±å…¥å†…å¿ƒä¸–ç•Œæ—¶ï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼Œæˆ‘ä»¬éœ€è¦ç»™è‡ªæ§ä¸€ä¸ªå…¨æ–°çš„å®šä¹‰ï¼Œç»™æ”¾å¼ƒè‡ªæ§ç•™å‡ºä¸€ç‚¹ç©ºé—´æ¥ã€‚ å½“äººä»¬è¯•å›¾æ‘†è„±æŸç§æƒ³æ³•æ—¶ï¼Œå®ƒå´åƒå›é£é•–ä¸€æ ·â€œå—–â€åœ°é£å›æ¥äº†ã€‚ å‹æŠ‘äººçš„æœ¬èƒ½æ—¶ï¼Œå°±ä¼šäº§ç”Ÿè¿™ç§è®½åˆºæ€§åå¼¹æ•ˆåº”ã€‚ éŸ¦æ ¼çº³è®¤ä¸ºï¼Œè¿™å’Œå¤§è„‘å¦‚ä½•å¤„ç†â€œä¸è¦å»æƒ³â€è¿™ä¸ªæŒ‡ä»¤æœ‰å…³ã€‚å¤§è„‘æŠŠè¿™ä¸ªæŒ‡ä»¤åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œåˆ†åˆ«ç”±ä¸¤ä¸ªä¸åŒç³»ç»Ÿå»æ‰§è¡Œã€‚å¤§è„‘çš„ä¸€éƒ¨åˆ†è´Ÿè´£å°†äººçš„æ³¨æ„åŠ›ä»è¢«ç¦æ­¢çš„æƒ³æ³•é‚£é‡Œå¼•å¼€ï¼Œå°±åƒéŸ¦æ ¼çº³ç¬¬ä¸€ä¸ªå®éªŒä¸­é‚£ä½è®¾æ³•ä¸å»æƒ³ç™½ç†Šçš„å¥³å£«ä¸€æ ·ï¼Œâ€œæˆ‘è¯•ç€å»æƒ³ç™½ç†Šä»¥å¤–çš„å…¶ä»–æ‰€æœ‰ä¸œè¥¿â€¦â€¦å˜¿ï¼Œçœ‹çœ‹è¿™é¢æ£•è‰²çš„å¢™â€ã€‚éŸ¦æ ¼çº³å°†è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºâ€œæ“ä½œâ€ã€‚â€œæ“ä½œâ€ä¾é å¤§è„‘çš„è‡ªæ§ç³»ç»Ÿæ¥å®Œæˆã€‚å’Œæ‰€æœ‰éœ€è¦ä»˜å‡ºåŠªåŠ›çš„è‡ªæˆ‘æ§åˆ¶ä¸€æ ·ï¼Œè¿™éœ€è¦è€—è´¹å¤§é‡çš„ç²¾åŠ›å’Œèƒ½é‡ã€‚å¤§è„‘çš„å¦ä¸€éƒ¨åˆ†åˆ™è´Ÿè´£å¯»æ‰¾è¯æ®ï¼Œè¯æ˜ä½ æ²¡æœ‰å»æƒ³ã€å»æ„Ÿè§‰ã€å»åšä½ ä¸è¯¥å»æƒ³ã€å»æ„Ÿè§‰ã€å»åšçš„äº‹ï¼Œå°±åƒé‚£ä½å¹´è½»çš„å¥³å£«è§‚å¯Ÿåˆ°çš„ï¼šâ€œæˆ‘æƒ³å‘€æƒ³å‘€æƒ³â€¦â€¦æ¯å½“æˆ‘è¯•ç€ä¸å»æƒ³ç™½ç†Šçš„æ—¶å€™ï¼Œæˆ‘å…¶å®æ€»æ˜¯æƒ³ç€å®ƒã€‚â€éŸ¦æ ¼çº³å°†è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºâ€œç›‘æ§â€ã€‚â€œç›‘æ§â€å’Œâ€œæ“ä½œâ€ä¸åŒï¼Œå®ƒè‡ªåŠ¨è¿è¡Œï¼Œæ— é¡»è€—è´¹å¤§é‡ç²¾åŠ›ã€‚â€œç›‘æ§â€ä¸å¤§è„‘çš„è‡ªåŠ¨å±é™©æ£€æµ‹ç³»ç»Ÿçš„è”ç³»æ›´ç´§å¯†ã€‚è‡ªåŠ¨è‡ªæ§ï¼è¿™å¬èµ·æ¥å¯èƒ½å¾ˆæ£’ï¼Œä½†å¦‚æœä½ è®¤è¯†åˆ°äº†â€œæ“ä½œâ€ä¸â€œç›‘æ§â€çš„é…åˆæœ‰å¤šé‡è¦ï¼Œä½ å°±ä¸ä¼šè¿™ä¹ˆæƒ³äº†ã€‚æ— è®ºåŸºäºä»€ä¹ˆåŸå› ï¼Œåªè¦â€œæ“ä½œâ€å‡å¼±äº†ï¼Œâ€œç›‘æ§â€å°±ä¼šæˆä¸ºè‡ªæ§çš„å™©æ¢¦ã€‚ ç–²æƒ«çš„â€œæ“ä½œâ€å’Œç²¾åŠ›å……æ²›çš„â€œç›‘æ§â€é€ æˆäº†å¤§è„‘çš„ä¸å¹³è¡¡ï¼Œè¿™ä¼šå¸¦æ¥é—®é¢˜ã€‚å½“â€œç›‘æ§â€å¯»æ‰¾è¢«ç¦çš„å†…å®¹æ—¶ï¼Œå®ƒä¼šè®©äººä¸æ–­æƒ³èµ·è¦å¯»æ‰¾çš„ç›®æ ‡ã€‚ç¥ç»å­¦å®¶æŒ‡å‡ºï¼Œå¤§è„‘çš„æ½œæ„è¯†ä¸æ–­æƒ³åˆ°è¢«ç¦æ­¢çš„å†…å®¹ã€‚è¿™ä¹ˆåšçš„ç»“æœæ˜¯ï¼Œä½ ä¼šæƒ³åˆ°ã€æ„Ÿè§‰åˆ°æˆ–å»åšè‡ªå·±æ­£åœ¨åŠªåŠ›é¿å…çš„äº‹ã€‚ æ— è®ºä½ æƒ³æ‘†è„±å“ªç§ææƒ§æˆ–æ¬²æœ›ï¼Œå®ƒä»¬æœ€åéƒ½ä¼šå˜å¾—æ›´è®©äººä¿¡æœï¼Œæ›´å¼•äººæ³¨ç›®ã€‚ æ€ä¹ˆæ‰èƒ½æ‰¾åˆ°æ‘†è„±è¿™ç§å›°å¢ƒçš„æ–¹æ³•å‘¢ï¼ŸéŸ¦æ ¼çº³æå‡ºäº†ä¸€ç§å¯¹æŠ—è®½åˆºæ€§åå¼¹çš„æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•æœ¬èº«å°±å¾ˆæœ‰è®½åˆºæ„å‘³â€”â€”è¿™ä¸ªæ–¹æ³•å°±æ˜¯æ”¾å¼ƒè‡ªæ§ã€‚å½“äººä»¬ä¸å†è¯•å›¾æ§åˆ¶é‚£äº›ä¸å¸Œæœ›å‡ºç°çš„æƒ³æ³•å’Œæƒ…ç»ªæ—¶ï¼Œå®ƒä»¬ä¹Ÿå°±ä¸ä¼šå†æ¥çƒ¦ä½ äº†ã€‚ ç»“æœè¯æ˜ï¼Œè¿™ç§æ–¹æ³•å¯¹æ¶ˆé™¤è®¸å¤šä¸å¥½çš„å†…å¿ƒæ„Ÿå—éƒ½æœ‰ç”¨ï¼Œå®ƒçš„é€‚ç”¨èŒƒå›´å¤§å¾—ä»¤äººåƒæƒŠã€‚å»æƒ³è‡ªå·±æ‰€æƒ³ï¼Œè¿½éšè‡ªå·±çš„æ„Ÿè§‰ï¼ˆä½ ä¸å¿…ç›¸ä¿¡å®ƒæ˜¯çœŸçš„ï¼Œä¸è¦è§‰å¾—å¿…é¡»é‡‡å–è¡ŒåŠ¨ï¼‰ï¼Œè¿™æ˜¯æ²»ç–—ç„¦è™‘ã€æŠ‘éƒã€å—œé£Ÿå’Œå„ç§ä¸Šç˜¾ç—‡çŠ¶çš„æœ‰æ•ˆæ–¹æ³•ã€‚æˆ‘ä»¬é€šè¿‡è¿™äº›è¯æ®å¯ä»¥çœ‹åˆ°ï¼Œæ”¾å¼ƒæ§åˆ¶å†…å¿ƒæ„Ÿå—ï¼Œåè€Œèƒ½è®©æˆ‘ä»¬æ›´å¥½åœ°æ§åˆ¶å¤–åœ¨è¡Œä¸ºã€‚ å¦‚æœä¸å’Œç„¦è™‘å¯¹æŠ—ï¼Œç„¦è™‘å°±ä¼šè‡ªç„¶ç¦»å»ã€‚ å¿ äºä½ çš„æ„Ÿå—ï¼Œä½†åˆ«ç›¸ä¿¡ä½ æ‰€æœ‰çš„æƒ³æ³• ç›´é¢è‡ªèº«æ¬²æœ›ï¼Œä½†ä¸è¦ä»˜è¯¸è¡ŒåŠ¨ã€‚ å½“å†²åŠ¨å æ®ä½ çš„å¤´è„‘æ—¶ï¼ŒèŠ±è‡³å°‘ä¸€åˆ†é’Ÿå»æ„Ÿè§‰è‡ªå·±çš„èº«ä½“ã€‚ä½ çš„å†²åŠ¨æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿæ˜¯çƒ­çš„è¿˜æ˜¯å†·çš„ï¼Ÿèº«ä½“æœ‰æ²¡æœ‰æ„Ÿåˆ°ä¸èˆ’æœï¼Ÿå¿ƒç‡ã€å‘¼å¸æˆ–å†…è„æœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿä¿æŒè¿™ä¸ªçŠ¶æ€è‡³å°‘ä¸€åˆ†é’Ÿã€‚çœ‹çœ‹è¿™äº›æ„Ÿè§‰åœ¨å¼ºåº¦æˆ–ç‰¹æ€§ä¸Šæœ‰ä»€ä¹ˆå˜åŒ–ã€‚ é©¾é©­å†²åŠ¨ä¸åªé€‚ç”¨äºæˆ’é™¤ç™–å¥½ï¼Œè¿˜èƒ½å¸®åŠ©ä½ æŒæ§æœ‰å®³çš„å†²åŠ¨ã€‚ å¯¹å†…æ¥å—è‡ªæˆ‘ï¼Œå¯¹å¤–æ§åˆ¶è¡ŒåŠ¨ã€‚ æŠ‘åˆ¶æ¬²æœ›çš„åé¢ä¸æ˜¯è‡ªæˆ‘æ”¾çºµã€‚ ç»“è¯­ æˆ‘ä»¬å¤©ç”Ÿå°±æœ‰è‡ªæ§çš„èƒ½åŠ›ï¼Œå³ä¾¿æœ‰æ—¶æˆ‘ä»¬ä¸å¤ªä¼šè¿ç”¨è¿™ç§èƒ½åŠ›ã€‚å®ƒä»¬å¸®æˆ‘ä»¬æ‰¾åˆ°å¤±è´¥çš„åŸå› ï¼Œä¸ºæˆ‘ä»¬æŒ‡å‡ºå¯è¡Œçš„è§£å†³æ–¹æ³•ã€‚å®ƒä»¬ç”šè‡³å‘Šè¯‰æˆ‘ä»¬ï¼Œåšäººæ„å‘³ç€ä»€ä¹ˆã€‚ åœ¨æœªæ¥çš„äººç”Ÿé“è·¯ä¸Šï¼Œè¯·ä¿æŒç§‘å­¦å®¶çš„å¿ƒæ€ã€‚å°è¯•æ–°é²œäº‹ç‰©ï¼Œæ”¶é›†è‡ªå·±çš„æ•°æ®ï¼Œæ ¹æ®è¯æ®ä½œå‡ºåˆ¤æ–­ã€‚å¯¹å‡ºäººæ„æ–™çš„æƒ³æ³•ä¿æŒå¼€æ”¾çš„å¿ƒæ€ï¼Œä»å¤±è´¥å’ŒæˆåŠŸä¸­æ±²å–ç»éªŒæ•™è®­ã€‚åšæŒæœ‰æ•ˆçš„æ–¹æ³•ï¼Œå’Œä»–äººåˆ†äº«ä½ äº†è§£çš„çŸ¥è¯†ã€‚é¢å¯¹å¤æ‚çš„äººæ€§å’Œç°ä»£ç¤¾ä¼šçš„è¯±æƒ‘ï¼Œæˆ‘ä»¬æœ€å¥½èƒ½åšåˆ°è¿™å‡ ç‚¹ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬èƒ½ä¿æŒå¥½å¥‡å¿ƒå’Œè‡ªæˆ‘åŒæƒ…ï¼Œé‚£å¯¹ä»˜å®ƒä»¬å°±ç»°ç»°æœ‰ä½™äº†ã€‚]]></content>
      <categories>
        <category>æ³› - ä¹¦æ‘˜</category>
      </categories>
      <tags>
        <tag>è‡ªæ§åŠ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åƒè‰ - æ‰“é“]]></title>
    <url>%2F2018%2F11%2F06%2F2018_icpc_qingdao_regional%2F</url>
    <content type="text"><![CDATA[The 2018 ACM-ICPC Asia Qingdao Regional Contestè¯•é¢˜ | ç»ˆæ¦œ ä¸‰é¢˜æ®‹é…·æ‰“é“Problem C. Flippy Sequence Problem J. Books Problem M. Function and Function é“ç‰ŒåŒºçš„å‹è°Š ç‡ƒçƒ§æˆ‘çš„åˆ¤é¢˜æœº(BURN MY OJ) ğŸ¤ çŒ›åƒè‰(VnEpCxmR) ã€Šæ‰“é“å½’æ¥ã€‹ ç”±è‘—åæ³¢æ™®è‰ºæœ¯å®¶èµµç šæ½‡æ‹æ‘„çš„å¤§ç”µå½±ã€Šæ‰“é“å½’æ¥ã€‹å°†åœ¨è¿‘æ—¥ç™»é™† YouTubeï¼Œæ•¬è¯·æœŸå¾…ã€‚ â€œè¾“å…¥ç†æƒ³ç¨‹åºï¼Œè¾“å‡ºå¿«ä¹äººç”Ÿã€‚â€ è°¢è°¢å¤§å®¶ï¼]]></content>
      <categories>
        <category>æ³› - çºªå¿µ</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>çºªå¿µ</tag>
        <tag>ICPC</tag>
        <tag>é’å²›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŒæœèŠ±å¤•æ‹¾ã€0x03 äºŒé›¶ä¸€å…«å¹´åæœˆäºŒåä¹æ—¥å‡Œæ™¨äººæ°‘å–ä¸åˆ°å†°é•‡å¯ä¹]]></title>
    <url>%2F2018%2F10%2F29%2Fdiary_3%2F</url>
    <content type="text"><![CDATA[äºŒé›¶ä¸€å…«å¹´åæœˆæˆ‘å› ä¸ºåŠå¤œå‡ºå»ä¹°å¯ä¹å·²ç»åˆ·äº†å››æ¬¡æ™šå½’ï¼Œç„¶è€Œäº”æ¬¡å°±è¦è®°è¿‡â€¦ æˆ‘ä»¬æ²¡æœ‰åŠæ³•ï¼Œåªèƒ½ç—›è‹¦çš„å…¥ç¡â€¦]]></content>
      <categories>
        <category>æ³› - è®°</category>
      </categories>
      <tags>
        <tag>è®°</tag>
        <tag>å¯ä¹</tag>
        <tag>è‡ªç”±</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•è®­ç»ƒè¥è§£é¢˜æ€»ç»“ï¼ˆç¬¬äºŒå‘¨ï¼‰//ToDo]]></title>
    <url>%2F2018%2F08%2F12%2Falgor_club_code_2%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®å¤§æ„ &amp; ä»£ç å®ç°æ’åºç»™å‡ºnä¸ªæ•´æ•°ï¼Œå°†å®ƒä»¬ä»å°åˆ°å¤§æ’åºåè¾“å‡ºã€‚ å¯¹äºå‰30%çš„æ•°æ®ï¼Œn â‰¤ 100ï¼Œç»™å‡ºçš„nä¸ªæ•´æ•°çš„ç»å¯¹å€¼ä¸è¶…è¿‡10ï¼› å¯¹äºå‰60%çš„æ•°æ®ï¼Œn â‰¤ 5000ï¼Œç»™å‡ºçš„nä¸ªæ•´æ•°çš„ç»å¯¹å€¼ä¸è¶…è¿‡10^9ï¼› å¯¹äºå¦20%çš„æ•°æ®ï¼Œn â‰¤ 500000ï¼Œç»™å‡ºçš„nä¸ªæ•´æ•°çš„ç»å¯¹å€¼ä¸è¶…è¿‡10^5ï¼› å¯¹äº100%çš„æ•°æ®ï¼Œn â‰¤ 500000ï¼Œç»™å‡ºçš„nä¸ªæ•´æ•°çš„ç»å¯¹å€¼ä¸è¶…è¿‡10^9ã€‚ æ—¶é—´ï¼š2 secç©ºé—´ï¼š256 MB 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;//#include &lt;algorithm&gt;//#include &lt;vector&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); vector&lt;int&gt; a; for (int i = 0; i &lt; n; ++i) &#123; int x; scanf("%d", &amp;x); a.push_back(x); &#125; sort(a.begin(),a.end()); //a = getAnswer(n, a); for (int i = 0; i &lt; n; ++i) printf("%d%c", a[i], " \n"[i == n - 1]); return 0;&#125; åˆ†ç»„æœ‰nä¸ªæ­£æ•´æ•°æ’æˆä¸€æ’ï¼Œä½ è¦å°†è¿™äº›æ•°åˆ†æˆmä»½ï¼ˆåŒä¸€ä»½ä¸­çš„æ•°å­—éƒ½æ˜¯è¿ç»­çš„ï¼Œä¸èƒ½éš”å¼€ï¼‰ï¼ŒåŒæ—¶æ•°å­—ä¹‹å’Œæœ€å¤§çš„é‚£ä¸€ä»½çš„æ•°å­—ä¹‹å’Œå°½é‡å°ã€‚ å¯¹äº50%çš„æ•°æ®ï¼Œn â‰¤ 100ï¼Œç»™å‡ºçš„nä¸ªæ­£æ•´æ•°ä¸è¶…è¿‡10ï¼› å¯¹äº100%çš„æ•°æ®ï¼Œm â‰¤ n â‰¤ 300000ï¼Œç»™å‡ºçš„nä¸ªæ­£æ•´æ•°ä¸è¶…è¿‡1000000ã€‚ æ—¶é—´ï¼š4 secç©ºé—´ï¼š512 MB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */bool check( long long d, int n, int m, vector&lt;int&gt; &amp;a )&#123; long long sum = 0; int cnt = 1; for( int i = 0; i &lt; n; ++i) &#123; if( a[i] &gt; d ) return false; sum += a[i]; if( sum &gt; d ) &#123; cnt++; i--; sum = 0; &#125; &#125; if(cnt &gt; m)&#123; return false; &#125; return true;&#125;// å°†æ‰€ç»™æ•°ç»„åˆ†æˆè¿ç»­çš„mä»½ï¼Œä½¿å¾—æ•°å­—ä¹‹å’Œæœ€å¤§çš„é‚£ä¸€ä»½çš„æ•°å­—ä¹‹å’Œæœ€å°// nï¼šæ•°ç»„å¤§å°// mï¼šé¢˜ä¸­çš„m// aï¼šæ‰€ç»™æ•°ç»„ï¼Œå¤§å°ä¸ºn// è¿”å›å€¼ï¼šæœ€ä¼˜æ–¹æ¡ˆä¸­ï¼Œæ•°å­—ä¹‹å’Œæœ€å¤§çš„é‚£ä¸€ä»½çš„æ•°å­—ä¹‹å’Œlong long getAnswer(int n, int m, vector&lt;int&gt; a) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ long long l = 1, r = 0; for( int i = 0; i &lt; n; ++i) r += a[i]; while( l &lt;= r ) &#123; long long mid = (l + r) &gt;&gt; 1; if(check(mid, n, m, a)) r = mid - 1; else l = mid + 1; &#125; return r + 1;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; a; a.resize(n); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); printf("%lld\n", getAnswer(n, m, a)); return 0;&#125; å¤§è½¬ç›˜é‚“è€å¸ˆæœ‰ä¸€ä¸ªå¤§è½¬ç›˜ï¼Œè¢«å¹³åˆ†æˆäº† 2^n ä»½ã€‚é‚“è€å¸ˆè¿˜æœ‰ä¸€ä¸ªé•¿åº¦ä¸º 2^n çš„æ•°ç»„ aï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ 0 æˆ– 1ã€‚äºæ˜¯é‚“è€å¸ˆå°±å¯ä»¥é€‰æ‹©å¤§è½¬ç›˜ä¸Šçš„ä¸€ä¸ªä½ç½®ï¼Œå°† a[0] å¡«å…¥å…¶ä¸­ï¼Œç„¶åæŒ‰é¡ºæ—¶é’ˆé¡ºåºä¾æ¬¡å°† a[1],a[2],â€¦,a[2^n-1] å¡«å…¥ã€‚å¯¹äºå¤§è½¬ç›˜ä¸Šçš„ä¸€ä¸ªæŒ‡å®šä½ç½®ï¼Œé‚“è€å¸ˆå¯ä»¥ä»å®ƒå¼€å§‹ï¼Œå–å‡ºé¡ºæ—¶é’ˆæ–¹å‘çš„ n ä¸ªä½ç½®ï¼Œå¹¶å°†å®ƒä»¬æŒ‰åŸé¡ºåºæ‹¼æ¥èµ·æ¥ï¼Œå¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸º n çš„ 01 ä¸²ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ª n ä½äºŒè¿›åˆ¶æ•°ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ªäºŒè¿›åˆ¶æ•°ç§°ä½œä»è¿™ä¸ªä½ç½®å¼€å§‹çš„å¹¸è¿æ•°ã€‚æ˜¾ç„¶åœ°ï¼Œå¤§è½¬ç›˜ä¸Šå…±æœ‰ 2^n ä¸ªä½ç½®å¯ä»¥è·å¾—å¹¸è¿æ•°ï¼Œè€Œå·§åˆçš„æ˜¯ n ä½äºŒè¿›åˆ¶æ•°æ°å¥½ä¹Ÿæœ‰ 2^n ä¸ªï¼Œæ‰€ä»¥é‚“è€å¸ˆå¸Œæœ›è¿™äº›æ‰€æœ‰çš„å¹¸è¿æ•°åŒ…å«äº†æ‰€æœ‰çš„ n ä½äºŒè¿›åˆ¶æ•°ã€‚è¯·è¾“å‡ºä¸€ä¸ªæ•°ç»„ aï¼Œä½¿å…¶æ»¡è¶³é‚“è€å¸ˆçš„è¦æ±‚ã€‚ï¼ˆå¦‚æœæœ‰å¤šè§£ï¼Œè¾“å‡ºä»»ä¸€å³å¯ï¼‰ æœ¬é¢˜åŒ…å« 16 ä¸ªæµ‹è¯•ç‚¹ã€‚å¯¹äºç¬¬ i ä¸ªæµ‹è¯•ç‚¹ï¼ˆ1&lt;=i&lt;=16ï¼‰ï¼Œæ»¡è¶³ n=iã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//#include &lt;bits/stdc++.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */int allOne;vector&lt;bool&gt; vis[2];string ans;int twoPow(int x)&#123; return 1 &lt;&lt; x;&#125;void dfs(int u)&#123; for( int i = 0; i &lt; 2; ++i ) &#123; if(!vis[i][u])&#123; int v = ((u &lt;&lt; 1) | i) &amp; allOne; vis[i][u] = 1; dfs(v); ans.push_back('0' + i); &#125; &#125;&#125;// æœ¬å‡½æ•°æ±‚è§£å¤§è½¬ç›˜ä¸Šçš„æ•°ï¼Œä½ éœ€è¦æŠŠå¤§è½¬ç›˜ä¸Šçš„æ•°æŒ‰é¡ºæ—¶é’ˆé¡ºåºè¿”å›// nï¼šå¯¹åº”è½¬ç›˜å¤§å°ï¼Œæ„ä¹‰ä¸é¢˜ç›®æè¿°ä¸€è‡´ï¼Œå…·ä½“è§é¢˜ç›®æè¿°ã€‚// è¿”å›å€¼ï¼šå°†å¤§è½¬ç›˜ä¸Šçš„æ•°æŒ‰é¡ºæ—¶é’ˆé¡ºåºæ”¾åˆ°ä¸€ä¸ªstringä¸­å¹¶è¿”å›string getAnswer(int n) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ allOne = twoPow(n - 1) - 1; ans = ""; for( int i = 0; i &lt; 2; ++i ) vis[i].resize(twoPow(n - 1), 0); dfs(0); return ans;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); cout &lt;&lt; getAnswer(n) &lt;&lt; endl; return 0;&#125; è±¡æ£‹ä½ æœ‰è¶³å¤Ÿå¤šçš„è±¡æ£‹â€œè½¦â€ï¼Œåœ¨ä¸€ä¸ªnÃ—nçš„æ£‹ç›˜ä¸Šä½ èƒ½æ”¾å¤šå°‘ä¸ªâ€œè½¦â€å‘¢ï¼Ÿæ³¨æ„ï¼Œæ‰€ç»™æ£‹ç›˜ä¸Šæœ‰äº›ä½ç½®ä¸èƒ½æ”¾ä»»ä½•ä¸œè¥¿ã€‚åŒæ—¶ï¼ŒæŸä¸€è¡Œï¼ˆåˆ—ï¼‰æœ€å¤šåªèƒ½å­˜åœ¨ä¸€ä¸ªâ€œè½¦â€ã€‚ å¯¹äº30%çš„æ•°æ®ï¼Œn â‰¤ 5ï¼› å¯¹äº60%çš„æ•°æ®ï¼Œn â‰¤ 20ï¼› å¯¹äº100%çš„æ•°æ®ï¼Œn â‰¤ 500ã€‚ æ—¶é—´ï¼š2 secç©ºé—´ï¼š256 MB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;//#include &lt;string.h&gt;//#include &lt;vector&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */const int N = 505 * 2, M = N * N;struct E &#123; int next, to;&#125; e[M];int cnt, ihead[N], mc[N];bool vis[N];void add(int x, int y)&#123; ++cnt; e[cnt].next = ihead[x]; e[cnt].to = y; ihead[x] = cnt;&#125;bool dfs(int x)&#123; for( int i = ihead[x]; i; i = e[i].next )&#123; int y = e[i].to; if(!vis[y])&#123; vis[y] = true; if(mc[y] == 0 || dfs(mc[y]))&#123; //3 mc[x] = y; mc[y] = x; return true; &#125; &#125; &#125; return false;&#125;// æ±‚è§£æ£‹ç›˜ä¸Šæœ€å¤šèƒ½æ”¾å¤šå°‘ä¸ªâ€œè½¦â€// nï¼šæ£‹ç›˜çš„å¤§å°ä¸ºnÃ—nçš„// boardï¼šæ‰€ç»™æ£‹ç›˜ï¼Œå¯¹äºæŸä¸ªä½ç½®ä¸Šçš„æ•°ï¼šè‹¥å€¼ä¸º1è¡¨ç¤ºå¯ä»¥æ”¾â€œè½¦â€ï¼›è‹¥å€¼ä¸º0è¡¨ç¤ºä¸èƒ½æ”¾â€œè½¦â€// è¿”å›å€¼ï¼šèƒ½æ”¾â€œè½¦â€çš„æœ€å¤§ä¸ªæ•°int getAnswer(int n, vector&lt;vector&lt;int&gt; &gt; board) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ cnt = 0; for( int i = 1; i &lt;= n * 2; i++)&#123; ihead[i] = 0; mc[i] = 0; &#125; for( int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; //1 if(board[i-1][j-1] == 1) add(i,j+n); &#125; &#125; int ans = 0; for( int i = 1; i &lt;= n; i++)&#123; if(!mc[i])&#123; memset(vis,0,sizeof(bool) * (n * 2 + 1)); if(dfs(i))&#123; ans++; &#125; &#125; &#125; return ans;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;vector&lt;int&gt; &gt; e; for (int i = 0; i &lt; n; ++i) &#123; vector&lt;int&gt; t; for (int j = 0; j &lt; n; ++j) &#123; int x; scanf("%d", &amp;x); t.push_back(x); &#125; e.push_back(t); &#125; printf("%d\n", getAnswer(n, e)); return 0;&#125; åºåˆ—è®¡æ•°ç»™å®šä¸€ä¸ªnä¸ªæ•´æ•°çš„åºåˆ—ä»¥åŠä¸€ä¸ªéè´Ÿæ•´æ•°dï¼Œè¯·ä½ è¾“å‡ºè¿™ä¸ªåºåˆ—ä¸­æœ‰å¤šå°‘ä¸ªè¿ç»­å­åºåˆ—ï¼ˆé•¿åº¦å¤§äº1ï¼‰ï¼Œæ»¡è¶³è¯¥å­åºåˆ—çš„æœ€å¤§å€¼æœ€å°å€¼ä¹‹å·®ä¸å¤§äºdã€‚ å¯¹äº60%çš„æ•°æ®ï¼Œn â‰¤ 5000ï¼› å¯¹äº100%çš„æ•°æ®ï¼Œn â‰¤ 300000ã€‚ ä¿è¯æ‰€æœ‰æ•´æ•°çš„ç»å¯¹å€¼ä¸è¶…è¿‡10^9ï¼Œdä¸è¶…è¿‡2Ã—10^9ã€‚ æ—¶é—´ï¼š10 secç©ºé—´ï¼š512 MB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;//#include &lt;cmath&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */const int N = 300005;int n,d,max_value[N],min_value[N];vector&lt;int&gt; a;long long solve(int l, int r)&#123; if(l == r) return 0; int mid = (l + r) &gt;&gt; 1;//ä¸­ç‚¹ long long ans = solve(l,mid)+solve(mid+1,r);//åˆ†æ²»æ±‚å‡ºå·¦å³ä¸¤åŠçš„å€¼ for( int i = mid + 1; i &lt;= r; i++)&#123; min_value[i] = (i == mid + 1) ? a[i] : min(min_value[i - 1], a[i]); max_value[i] = (i == mid + 1) ? a[i] : max(max_value[i - 1], a[i]); &#125; int mn = 0, mx = 0, pos = r; for( int i = mid; i &gt;= l &amp;&amp; pos &gt; mid; i--)&#123; //3 mn = (i==mid)?a[i]:min(mn,a[i]); mx = (i==mid)?a[i]:max(mx,a[i]); for(; pos &gt; mid &amp;&amp; max(mx,max_value[pos]) - min(mn,min_value[pos]) &gt; d; pos--); ans += pos - mid;//æ›´æ–°ç­”æ¡ˆ &#125; return ans;&#125;// æ±‚å‡ºæœ‰å¤šå°‘ä¸ªaæ•°ç»„ä¸­çš„è¿ç»­å­åºåˆ—ï¼ˆé•¿åº¦å¤§äº1ï¼‰ï¼Œæ»¡è¶³è¯¥å­åºåˆ—çš„æœ€å¤§å€¼æœ€å°å€¼ä¹‹å·®ä¸å¤§äºd// nï¼šaæ•°ç»„çš„é•¿åº¦// dï¼šæ‰€ç»™d// aï¼šæ•°ç»„aï¼Œé•¿åº¦ä¸ºn// è¿”å›å€¼ï¼šæ»¡è¶³æ¡ä»¶çš„è¿ç»­å­åºåˆ—çš„ä¸ªæ•°long long getAnswer(int n, int d, vector&lt;int&gt; a) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ ::n = n; ::d = d; ::a = a; return solve(0,n-1);&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n, d; scanf("%d%d", &amp;n, &amp;d); vector&lt;int&gt; a; a.resize(n); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); printf("%lld\n", getAnswer(n, d, a)); return 0;&#125; æœ€å°äº¤æ¢ç»™å®šä¸€ä¸ª 1 åˆ° n çš„æ’åˆ—ï¼ˆå³ä¸€ä¸ªåºåˆ—ï¼Œå…¶ä¸­ [1,n] ä¹‹é—´çš„æ­£æ•´æ•°æ¯ä¸ªéƒ½å‡ºç°äº†æ°å¥½ 1 æ¬¡ï¼‰ã€‚ä½ å¯ä»¥èŠ± 1 å…ƒé’±äº¤æ¢ä¸¤ä¸ªç›¸é‚»çš„æ•°ã€‚ç°åœ¨ï¼Œä½ å¸Œæœ›æŠŠå®ƒä»¬å‡åºæ’åºã€‚æ±‚ä½ å®Œæˆè¿™ä¸ªç›®æ ‡æœ€å°‘éœ€è¦èŠ±è´¹å¤šå°‘å…ƒé’±ã€‚ å¯¹äº 20% çš„æ•°æ®ï¼Œä¿è¯ n&lt;=7ã€‚ å¯¹äº 60% çš„æ•°æ®ï¼Œä¿è¯ n&lt;=1,000ã€‚ å¯¹äº 100% çš„æ•°æ®ï¼Œä¿è¯ n&lt;=200,000ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// #include &lt;bits/stdc++.h&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */vector&lt;int&gt; seq, seqTemp;long long cnt;void mergeSort(int l, int r)&#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; mergeSort(l, mid); mergeSort(mid+1,r); int p = l, q = mid + 1; for( int i = l; i &lt;= r; i++)&#123; if(q &gt; r || p &lt;= mid &amp;&amp; seq[p] &lt;= seq[q]) seqTemp[i] = seq[p++]; else&#123; seqTemp[i] = seq[q++]; cnt += (mid - p + 1); &#125; &#125; for( int i = l; i &lt;= r; i++) seq[i] = seqTemp[i];&#125;// è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯è®¡ç®—ç­”æ¡ˆï¼ˆå³æœ€å°‘èŠ±è´¹çš„é‡‘é’±ï¼‰// nï¼šè¡¨ç¤ºåºåˆ—é•¿åº¦// aï¼šå­˜å‚¨æ•´ä¸ªåºåˆ— a// è¿”å›å€¼ï¼šæœ€å°‘èŠ±è´¹çš„é‡‘é’±ï¼ˆéœ€è¦æ³¨æ„ï¼Œè¿”å›å€¼çš„ç±»å‹ä¸º 64 ä½æœ‰ç¬¦å·æ•´æ•°ï¼‰long long getAnswer(int n, vector&lt;int&gt; a) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ seq = a; seqTemp.resize(n); cnt = 0; mergeSort(0, n - 1); return cnt;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n, tmp; vector&lt;int&gt; a; a.clear(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;tmp); a.push_back(tmp); &#125; long long ans = getAnswer(n, a); cout &lt;&lt; ans &lt;&lt; '\n'; return 0;&#125; æ¥¼å°”é‚¦å¾·ç»™å®šåŒ…å« n ä¸ªæ•°çš„åºåˆ— Aã€‚å†ç»™å‡º Q ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®åŒ…å«ä¸€ä¸ªæ•° xï¼Œè¯¢é—®çš„æ˜¯åºåˆ— A ä¸­ä¸å°äº x çš„æœ€å°æ•´æ•°æ˜¯å¤šå°‘ï¼ˆæ— è§£è¾“å‡º-1ï¼‰ã€‚ å¯¹äº 50% çš„æ•°æ®ï¼Œä¿è¯ n&lt;=2000ã€‚ å¯¹äº 100% çš„æ•°æ®ï¼Œä¿è¯ n&lt;=300,000ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;// #include &lt;cstdio&gt;// #include &lt;vector&gt;// #include &lt;algorithm&gt;// #include &lt;iostream&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */// æœ¬å‡½æ•°ä¼ å…¥æ•°ç»„ a åŠæ‰€æœ‰è¯¢é—®ï¼Œä½ éœ€è¦æ±‚è§£æ‰€æœ‰è¯¢é—®å¹¶ä¸€å¹¶è¿”å›// nï¼šåºåˆ— a çš„é•¿åº¦// aï¼šå­˜å‚¨äº†åºåˆ— a// Qï¼šè¯¢é—®ä¸ªæ•°// queryï¼šä¾æ¬¡å­˜å‚¨äº†æ‰€æœ‰è¯¢é—®çš„å‚æ•° x// è¿”å›å€¼ï¼šä¸€ä¸ª vector&lt;int&gt;ï¼Œä¾æ¬¡å­˜æ”¾å„è¯¢é—®çš„ç­”æ¡ˆvector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; a, int Q, vector&lt;int&gt; query) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ vector&lt;int&gt; ans; ans.clear(); sort(a.begin(), a.end()); for( int i = 0; i &lt; Q; i++)&#123; int key = query[i]; int l = -1,r = n,mid; while(l+1 &lt; r)&#123; mid = (l + r) &gt;&gt; 1; if(a[mid] &lt; key) l = mid; else r = mid; &#125; int pos = r; if(pos &gt;= n) ans.push_back(-1); else ans.push_back(a[pos]); &#125; return ans;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n, Q, tmp; vector&lt;int&gt; a, query; a.clear(); query.clear(); scanf("%d", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;tmp); a.push_back(tmp); &#125; scanf("%d", &amp;Q); for (int i = 0; i &lt; Q; ++i) &#123; scanf("%d", &amp;tmp); query.push_back(tmp); &#125; vector&lt;int&gt; ans = getAnswer(n, a, Q, query); for (int i = 0; i &lt; Q; ++i) printf("%d\n", ans[i]); return 0;&#125; æœ€çŸ­è·¯ç»™å®šä¸€å¼  n ä¸ªç‚¹çš„æ— å‘å¸¦æƒå›¾ï¼ŒèŠ‚ç‚¹çš„ç¼–å·ä» 1 è‡³ nï¼Œæ±‚ä» S åˆ° T çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚ æœ¬é¢˜å…±è®¾ç½® 12 ä¸ªæµ‹è¯•ç‚¹ã€‚ å¯¹äºå‰ 10 ä¸ªæµ‹è¯•ç‚¹ï¼Œä¿è¯ n&lt;=2500ï¼Œm&lt;=6200ï¼Œå¯¹äºæ¯æ¡è¾¹æœ‰ w&lt;=1000ã€‚è¿™éƒ¨åˆ†æ•°æ®æœ‰æ¢¯åº¦ã€‚ å¯¹äºæ‰€æœ‰çš„ 12 ä¸ªæµ‹è¯•ç‚¹ï¼Œä¿è¯ n&lt;=100,000ï¼Œm&lt;=250,000ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;//#include &lt;set&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */const int MAX_N = 100050;struct edge &#123; int next, weight; edge(int ne,int we):next(ne),weight(we)&#123;&#125;&#125;;typedef pair&lt;int ,int&gt; P;vector&lt;edge&gt;G[MAX_N]; //é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾int dist[MAX_N];//int path[MAX_N];bool collected[MAX_N]; //æ ‡è®°æ¯ä¸ªé¡¶ç‚¹æ˜¯å¦è¢«æ”¶å½•void Dijkstra(int start)&#123; memset(dist,0x3f,sizeof(dist)); memset(collected,0,sizeof(collected)); set&lt;P, less&lt;P&gt; &gt; min_heap; //ç”¨ set æ¥ä¼ªå®ç°ä¸€ä¸ªå°æ ¹å †ï¼Œå¹¶å…·æœ‰æ˜ å°„äºŒå‰å †çš„åŠŸèƒ½ã€‚ dist[start] = 0; min_heap.insert(make_pair(0, start)); collected[start] = true; while(min_heap.size())&#123; //å¦‚æœå †ä¸ºç©ºï¼Œè¯´æ˜æ‰€æœ‰ç‚¹éƒ½å·²è¢«æ”¶å½•ï¼Œç»“æŸè¯¥ç®—æ³• auto iter = min_heap.begin(); int v = iter-&gt;second; min_heap.erase(*iter); collected[v] = true; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(!collected[e.next] &amp;&amp; dist[e.next] &gt; dist[v] + e.weight) &#123; min_heap.erase(make_pair(dist[e.next], e.next)); dist[e.next] = dist[v] + e.weight; //path[e.next] = v; min_heap.insert(make_pair(dist[e.next], e.next)); &#125; &#125; &#125;&#125;// è¿™ä¸ªå‡½æ•°ç”¨äºè®¡ç®—ç­”æ¡ˆï¼ˆæœ€çŸ­è·¯ï¼‰// nï¼šèŠ‚ç‚¹æ•°ç›®// mï¼šåŒå‘è¾¹æ•°ç›®// U,V,Wï¼šåˆ†åˆ«å­˜æ”¾å„è¾¹çš„ä¸¤ç«¯ç‚¹ã€è¾¹æƒ// s,tï¼šåˆ†åˆ«è¡¨ç¤ºèµ·ç‚¹ã€é‡ç‚¹// è¿”å›å€¼ï¼šç­”æ¡ˆï¼ˆå³ä» s åˆ° t çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼‰int shortestPath(int n, int m, vector&lt;int&gt; U, vector&lt;int&gt; V, vector&lt;int&gt; W, int s, int t) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ for( int i = 0; i &lt; m; i++)&#123; G[U[i]].push_back(edge(V[i],W[i])); G[V[i]].push_back(edge(U[i],W[i])); &#125; Dijkstra(s); return dist[t];&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n, m, s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); vector&lt;int&gt; U, V, W; U.clear(); V.clear(); W.clear(); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); U.push_back(u); V.push_back(v); W.push_back(w); &#125; printf("%d\n", shortestPath(n, m, U, V, W, s, t)); return 0;&#125; æ”¶è·äºŒåˆ†æ€æƒ³æ¶‰åŠé¢˜ç›®ï¼š åˆ†ç»„ åºåˆ—è®¡æ•° æ¥¼å°”é‚¦å¾· Dijkstra çš„å±€é™ä¹‹å‰åªè®¤ä¸ºï¼ŒDijkstra ç®—æ³•ä¸å¯ä»¥å¤„ç†å¸¦æœ‰è´Ÿå€¼åœˆçš„å›¾ã€‚å®é™…ä¸Š Dijkstra åœ¨å¤„ç†æœ‰å¤å€¼è¾¹æƒçš„å›¾æ—¶å¾ˆå¯èƒ½ä¸æ­£ç¡®ã€‚ ä¾‹ï¼š12341 -&gt; 2 w = 11 -&gt; 3 w = 22 -&gt; 4 w = 13 -&gt; 2 w = -2 æ­£ç¡®ç­”æ¡ˆä¸º 1ï¼ŒDijkstra ç»™å‡ºçš„ç­”æ¡ˆä¸º 2 ã€‚ ä¸€äº›ç®—æ³• äºŒåˆ†å›¾æœ€å¤§åŒ¹é… æ±‚æ¬§æ‹‰å›è·¯ å½’å¹¶æ’åºæ±‚é€†åºå¯¹ ToDoæ’åºæ‰‹åŠ¨å®ç° å†’æ³¡æ’åº æ’å…¥æ’åº é€‰æ‹©æ’åº å¿«é€Ÿæ’åº æœ€å°äº¤æ¢ä½¿ç”¨æ ‘çŠ¶æ•°ç»„ä¼˜åŒ–æ±‚é€†åºå¯¹çš„æš´åŠ›ç®—æ³•ï¼Œè¾¾åˆ°ä¸å½’å¹¶æ’åºç›¸åŒçš„å¤æ‚åº¦ã€‚ æ€»ç»“æ¬§æ‹‰å›è·¯ç®—æ³• æ¬§æ‹‰å›è·¯ è®¡è’œå®¢ æ€»ç»“åŒˆç‰™åˆ©ç®—æ³• åŒˆç‰™åˆ©ç®—æ³• è®¡è’œå®¢ äºŒåˆ†å­¦ä¹ ä½¿ç”¨ std::lower_bound ï¼Œæ³¨æ„è¾¹ç•Œã€‚ å®ç° Bellman-Ford ç®—æ³•ä¼ªä»£ç 123456789åˆå§‹åŒ– mind æ•°ç»„mind[0] : 0for round 1 to n æšä¸¾æ‰€æœ‰è¾¹ (u,v,len) mind[v] : min(min[v],mind[u]+len) if æœ¬è½®ä¸­æ²¡æœ‰ç‚¹è¢«æ›´æ–° break; if round == n+1 æ— è§£]]></content>
      <categories>
        <category>æ³› - è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>Bellman-Ford</tag>
        <tag>ToDo</tag>
        <tag>äºŒåˆ†</tag>
        <tag>åŒˆç‰™åˆ©ç®—æ³•</tag>
        <tag>æ’åº</tag>
        <tag>å½’å¹¶æ’åº</tag>
        <tag>æ¬§æ‹‰å›è·¯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç®—æ³•è®­ç»ƒè¥è§£é¢˜æ€»ç»“ï¼ˆç¬¬ä¸€å‘¨ï¼‰//ToDo]]></title>
    <url>%2F2018%2F08%2F04%2Falgor_club_code_1%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®å¤§æ„ &amp; ä»£ç å®ç°æ ˆç®€å•çš„æ ˆå®ç°ï¼Œæˆ‘ä½¿ç”¨æ•°ç»„å®ç°ï¼Œå¯ä»¥ä½¿ç”¨ vector ä»£æ›¿æ•°ç»„ã€‚æ—¥å¸¸å¯ä»¥ç›´æ¥ä½¿ç”¨ STL åº“ä¸­çš„ stack ç±»ï¼Œä½†å…¶æ— æ³•è¿›è¡Œ â€œcall by rankâ€ çš„è®¿é—®ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;string&gt;//#include &lt;cstdio&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */int mtop = -1;string mstack[100005];// å‹å…¥æ ˆé¡¶// nameï¼šè¢«å‹å…¥çš„äººçš„å§“åvoid push(string name) &#123; mtop++; mstack[mtop] = name; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */&#125;// å¼¹å‡ºæ ˆé¡¶// è¿”å›å€¼ï¼šè¢«å¼¹å‡ºäººçš„å§“åstring pop() &#123; if(mtop &gt; -1)&#123; mtop--; &#125; return mstack[mtop+1]; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */&#125;// è¯¢é—®æ ˆä¸­æŸä¸ªä½ç½®ä¸Šçš„äººçš„å§“åï¼ˆæ ˆåº•ä½ç½®ä¸º1ï¼Œå‘æ ˆé¡¶æ–¹å‘çš„ä½ç½®ä¾æ¬¡é€’å¢ï¼‰// posï¼šè¯¢é—®çš„ä½ç½®// è¿”å›å€¼ï¼šposä½ç½®ä¸Šäººçš„å§“åstring query(int pos) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ return mstack[pos-1];&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); char name[20]; for (; n--; ) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%s", name); push(name); &#125; else if (op == 2) &#123; printf("%s\n", pop().c_str()); &#125; else &#123; int pos; scanf("%d", &amp;pos); printf("%s\n", query(pos).c_str()); &#125; &#125; return 0;&#125; é˜Ÿåˆ—ç®€å•çš„é˜Ÿåˆ—å®ç°ï¼Œè¿™ä¸ªé˜Ÿåˆ—é—®é¢˜å¾ˆå¤§ï¼Œå°±æ˜¯å…ƒç´ å‡ºé˜Ÿåçš„ç©ºé—´æ— æ³•å›æ”¶ï¼Œé€ æˆæ— æ³•æŒç»­ä½¿ç”¨ï¼Œå ç”¨ç©ºé—´å¤§çš„é—®é¢˜ã€‚é¢˜ç›®è¦æ±‚è¾ƒä½ã€‚åº”è¯¥ä½¿ç”¨é“¾è¡¨æˆ–å¾ªç¯æ•°ç»„å®ç°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;//#include &lt;iostream&gt;//#include &lt;string&gt;//#include &lt;cstdio&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */int q = 0;int h = 0;string mque[100005];// é˜Ÿå°¾å…¥é˜Ÿ// nameï¼šå…¥é˜Ÿäººçš„å§“åvoid enqueue(string name) &#123; mque[h] = name; h++; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */&#125;// é˜Ÿé¦–å‡ºé˜Ÿ// è¿”å›å€¼ï¼šé˜Ÿé¦–çš„å§“åstring dequeue() &#123; q++; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ return mque[q-1];&#125;// è¯¢é—®é˜Ÿåˆ—ä¸­æŸä¸ªä½ç½®ä¸Šçš„äººçš„å§“åï¼ˆé˜Ÿé¦–ä½ç½®ä¸º1ï¼Œå¾€åä½ç½®ä¾æ¬¡é€’å¢ï¼‰// posï¼šè¯¢é—®çš„ä½ç½®// è¿”å›å€¼ï¼šposä½ç½®ä¸Šäººçš„å§“åstring query(int pos) &#123; return mque[q+pos-1]; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); char name[20]; for (; n--; ) &#123; int op; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%s", name); enqueue(name); &#125; else if (op == 2) &#123; printf("%s\n", dequeue().c_str()); &#125; else &#123; int pos; scanf("%d", &amp;pos); printf("%s\n", query(pos).c_str()); &#125; &#125; return 0;&#125; äºŒå‰æ ‘å®ç°å¹¶ç»´æŠ¤äºŒå‰æœç´¢æ ‘ï¼Œå¹¶è¾“å‡ºå…¶å‰åºå’Œååºéå†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;//#include &lt;cstdio&gt;//#include &lt;iostream&gt;//#include &lt;vector&gt;//#include &lt;string.h&gt;using namespace std;const int N = 100005;struct node &#123; int val; node* l; node* r; node():val(0),l(nullptr),r(nullptr)&#123;&#125; &#125;;node* root = nullptr;void insert(int v, node*&amp; x)&#123; if(x == 0)&#123; x = new node(); //cout &lt;&lt; x &lt;&lt; endl; x-&gt;l = nullptr; x-&gt;r = nullptr; x-&gt;val = v; return; &#125; if (v &lt;= x-&gt;val) &#123; insert(v,x-&gt;l); &#125; else if (v &gt; x-&gt;val) &#123; insert(v,x-&gt;r); &#125; return;&#125;void dlr( node* x, vector&lt;int&gt; &amp;ans) &#123; if(x)&#123; ans.push_back(x-&gt;val); dlr(x-&gt;l,ans); dlr(x-&gt;r,ans); &#125;&#125;void lrd( node* x, vector&lt;int&gt; &amp;ans)&#123; if(x)&#123; lrd(x-&gt;l,ans); lrd(x-&gt;r,ans); ans.push_back(x-&gt;val); &#125;&#125;vector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; sequence) &#123; for( int i = 0; i &lt; int(sequence.size()); ++i) insert(sequence[i],root); vector&lt;int&gt; ans; dlr(root,ans); lrd(root,ans); return ans;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;int&gt; sequence; for (int i = 0; i &lt; n; ++i) &#123; int x; scanf("%d", &amp;x); sequence.push_back(x); &#125; vector&lt;int&gt; ans = getAnswer(n, sequence); //cout &lt;&lt; ans.size() &lt;&lt; endl; for (int i = 0; i &lt; n; ++i)&#123; printf("%d%c", ans[i], " \n"[i == n - 1]); &#125; for (int i = 0; i &lt; n; ++i)&#123; printf("%d%c", ans[n + i], " \n"[i == n - 1]); &#125; return 0;&#125; æ•°å­—ç›’å­Hash Map å®ç°ï¼Œç”±äºæˆ‘çš„é—®é¢˜ï¼Œæ²¡æœ‰å»å®ç°ï¼Œä½¿ç”¨äº†STLåº“ä¸­çš„ map ç±»ï¼Œå‘¨æœ«ä¼šè¡¥å…… Hash Map çš„å®ç°ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;//#include &lt;map&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================typedef long long ll;/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */// æ‰§è¡Œæ“ä½œæ—¶ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°// opï¼šå¯¹åº”è¯¥æ¬¡æ“ä½œçš„ opï¼ˆå…·ä½“è¯·è§é¢˜ç›®æè¿°ï¼‰// xï¼šå¯¹åº”è¯¥æ¬¡æ“ä½œçš„ xï¼ˆå…·ä½“è¯·è§é¢˜ç›®æè¿°ï¼‰// è¿”å›å€¼ï¼šå¦‚æœè¾“å‡ºä¸º"Succeeded"ï¼Œåˆ™è¿™ä¸ªå‡½æ•°è¿”å› 1ï¼Œå¦åˆ™è¿”å› 0map&lt;ll,bool&gt; Map;bool check(int op, ll x) &#123; if(op == 1)&#123; if(Map[x])&#123; return false; &#125;else&#123; Map[x] = true; return true; &#125; &#125;else&#123; if(Map[x])&#123; Map[x] = false; return true; &#125; return Map[x]; &#125; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int Q, op; ll x; scanf("%d", &amp;Q); while (Q--) &#123; scanf("%d%lld", &amp;op, &amp;x); puts(check(op, x) ? "Succeeded" : "Failed"); &#125; return 0;&#125; é‡ç¼–ç å“ˆå¤«æ›¼ç¼–ç é—®é¢˜ï¼Œåˆå¹¶æ£®æ—ã€‚ä¸ POJ 3253 Fence Repair ç›¸ä¼¼ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;//#include &lt;queue&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================typedef long long ll;/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */// è¿™æ˜¯æ±‚è§£æ•´ä¸ªé—®é¢˜çš„å‡½æ•°// wï¼šé¢˜ç›®æè¿°ä¸­çš„ wï¼ˆæ‰€æœ‰ï¼‰// nï¼šé¢˜ç›®æè¿°ä¸­çš„ n// è¿”å›å€¼ï¼šç­”æ¡ˆpriority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q; ll getAnswer(int n, vector&lt;ll&gt; w) &#123; for( int i = 0; i &lt; n; i++)&#123; //æŠŠnå—æœ¨æ¿çš„é•¿åº¦å…¥é˜Ÿ q.push(w[i]); &#125; ll sum = 0; while(q.size() &gt; 1)&#123; //å¦‚æœè¿˜æ²¡æœ‰åˆæˆä¸€å—æœ¨æ¿å°±ç»§ç»­åˆå¹¶ ll minOne,minTwo; minOne = q.top(); q.pop(); minTwo = q.top(); q.pop(); //ä»é˜Ÿå¤´æ‹¿å‡ºä¸¤ä¸ªæœ€çŸ­çš„æœ¨æ¿ sum += (minOne + minTwo); //åŠ ä¸Šè¿™æ¬¡åˆå¹¶çš„å¼€é”€ q.push(minOne+minTwo); //å°†åˆå¹¶åçš„æœ¨æ¿å…¥é˜Ÿ &#125; return sum;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;long long&gt; w; for (int i = 0; i &lt; n; ++i) &#123; long long x; scanf("%lld", &amp;x); w.push_back(x); &#125; printf("%lld\n", getAnswer(n, w)); return 0;&#125; æˆç»©æ’åºæ’åºå¹¶è¾“å‡ºé€†åºå¯¹æ•°ç›®ï¼Œä½¿ç”¨å†’æ³¡æ’åºåœ¨æ¯æ¬¡äº¤æ¢è®°æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */// è¿™æ˜¯è¿›è¡Œæ’åºçš„å‡½æ•°// nï¼šé¢˜ç›®æè¿°ä¸­çš„ n// Aï¼šå„åŒå­¦çš„ç®—æ³•è®­ç»ƒè¥æˆç»©// DSï¼šå„åŒå­¦çš„æ•°æ®ç»“æ„è®­ç»ƒè¥æˆç»©// è¿”å›å€¼ï¼šå°†è¦è¾“å‡ºçš„æ•°å­—ä¾æ¬¡åŠ å…¥åˆ°è¿”å›å€¼çš„æ•°ç»„ä¸­class student&#123;public: int id; int algorithm,dataStruct; int score; student()&#123;&#125; student(int i,int a,int d):id(i),algorithm(a),dataStruct(d),score(a+d)&#123;&#125;&#125;;bool operator &lt; (student a,student b)&#123; if(a.score &lt; b.score)&#123; return true; &#125;else if(a.score == b.score)&#123; if(a.algorithm &lt; b.algorithm)&#123; return true; &#125; &#125; return false;&#125;int BubbleSort(vector&lt;student&gt; &amp;a,int size)&#123; int cnt = 0; for( int i = size-1; i &gt;= 0; i--)&#123; bool flag = false; //è®°å½•åœ¨ä¸€è¶Ÿæ’åºä¸­æ˜¯å¦æœ‰äº¤æ¢ for( int j = 0; j &lt; i; j++)&#123; if(a[j] &lt; a[j+1])&#123; student temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; //swap(a[j],a[j+1]); flag = true; cnt++; &#125; &#125; if(!flag) break; &#125; return cnt;&#125;vector&lt;int&gt; getAnswer(int n, vector&lt;int&gt; A, vector&lt;int&gt; DS) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ vector&lt;int&gt; ans; vector&lt;student&gt; temp; for( int i = 0; i &lt; n; i++)&#123; temp.push_back(student(i+1,A[i],DS[i])); &#125; int cnt = BubbleSort(temp,n); for(int i = 0; i &lt; n; i++)&#123; ans.push_back(temp[i].id); ans.push_back(temp[i].score); ans.push_back(temp[i].algorithm); ans.push_back(temp[i].dataStruct); &#125; ans.push_back(cnt); return ans;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n; scanf("%d", &amp;n); vector&lt;int&gt; A, DS; for (int i = 0; i &lt; n; ++i) &#123; int a, ds; scanf("%d%d", &amp;a, &amp;ds); A.push_back(a); DS.push_back(ds); &#125; vector&lt;int&gt; ans = getAnswer(n, A, DS); int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; printf("%d %d %d %d\n", ans[cnt], ans[cnt + 1], ans[cnt + 2], ans[cnt + 3]); cnt += 4; &#125; printf("%d\n", ans[cnt]); return 0;&#125; ç­‰å¼æ¥æºï¼šNOI 2015 day1 T1 ç¨‹åºè‡ªåŠ¨åˆ†æç®€å•å¹¶æŸ¥é›†é¢˜ç›®ï¼Œä¸»æ„ä¸€ä¸‹æ£€æŸ¥åº”è¯¥ç•™åˆ°æœ€åæ£€æŸ¥å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;// ================= ä»£ç å®ç°å¼€å§‹ =================/* è¯·åœ¨è¿™é‡Œå®šä¹‰ä½ éœ€è¦çš„å…¨å±€å˜é‡ */// ç»™å®šnä¸ªå˜é‡ä»¥åŠmä¸ªçº¦æŸï¼Œåˆ¤å®šæ˜¯å¦èƒ½æ‰¾å‡ºä¸€ç§èµ‹å€¼æ–¹æ¡ˆæ»¡è¶³è¿™mä¸ªçº¦æŸæ¡ä»¶// nï¼šå¦‚é¢˜æ„// mï¼šå¦‚é¢˜æ„// Aï¼šå¤§å°ä¸ºmçš„æ•°ç»„ï¼Œè¡¨ç¤ºmæ¡çº¦æŸä¸­çš„a// Bï¼šå¤§å°ä¸ºmçš„æ•°ç»„ï¼Œè¡¨ç¤ºmæ¡çº¦æŸä¸­çš„b// Eï¼šå¤§å°ä¸ºmçš„æ•°ç»„ï¼Œè¡¨ç¤ºmæ¡çº¦æŸä¸­çš„e// è¿”å›å€¼ï¼šè‹¥èƒ½æ‰¾å‡ºä¸€ç§æ–¹æ¡ˆï¼Œè¿”å›"Yes"ï¼›å¦åˆ™è¿”å›"No"ï¼ˆä¸åŒ…æ‹¬å¼•å·ï¼‰ã€‚int pre[500005];void init()&#123; for( int i = 1; i &lt;= 500004; i++)&#123; pre[i] = i; &#125;&#125;int get(int x)&#123; if(pre[x] == x)&#123; //x èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹ return x; &#125; return pre[x] = get(pre[x]); //è¿”å›çˆ¶èŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶å¦å½“å‰èŠ‚ç‚¹çˆ¶èŠ‚ç‚¹ç›´æ¥ä¸ºæ ¹èŠ‚ç‚¹&#125;void merge(int x,int y)&#123; x = get(x); y = get(y); if(x != y)&#123; // ä¸ä½åŒä¸€ä¸ªé›†åˆ pre[y] = x; &#125;&#125;string getAnswer(int n, int m, vector&lt;int&gt; A, vector&lt;int&gt; B, vector&lt;int&gt; E) &#123; /* è¯·åœ¨è¿™é‡Œè®¾è®¡ä½ çš„ç®—æ³• */ init(); vector&lt;int&gt; zero; for( int i = 0; i &lt; m; i++)&#123; if(E[i])&#123; merge(A[i],B[i]); &#125;else&#123; zero.push_back(i); &#125; &#125; for( int i = 0; i &lt; zero.size(); i++)&#123; if(get(A[zero[i]]) == get(B[zero[i]]))&#123; return "No"; &#125; &#125; return "Yes";&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int T; for (scanf("%d", &amp;T); T--; ) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; A, B, E; for (int i = 0; i &lt; m; ++i) &#123; int a, b, e; scanf("%d%d%d", &amp;a, &amp;b, &amp;e); A.push_back(a); B.push_back(b); E.push_back(e); &#125; printf("%s\n", getAnswer(n, m, A, B, E).c_str()); &#125; return 0;&#125; é“è·¯å‡çº§æœ€å¤§ç”Ÿæˆæ ‘é—®é¢˜ï¼Œä¸æœ€å°ç”Ÿæˆæ ‘ä¸€æ ·ã€‚ä½¿ç”¨ Kruskal ç®—æ³•è§£å†³ï¼Œéœ€è¦ç®€å•å®ç°ä¸€ä¸‹å¹¶æŸ¥é›†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;//#include &lt;vector&gt;//#include &lt;iostream&gt;//#include &lt;cstdio&gt;//#include &lt;cstring&gt;//#include &lt;algorithm&gt;using namespace std;const int MAX_N = 200050;const int MAX_M = 400050;struct edge &#123; int u, v, w; bool operator &lt; (const edge &amp;a)const &#123; return w &gt; a.w; &#125;&#125; e[MAX_M];int fa[MAX_N], n, m;int get(int x)&#123; if(fa[x] == x)&#123; return fa[x]; &#125; return fa[x] = get(fa[x]);&#125;vector&lt;int&gt; getAnswer(int n, int m, vector&lt;int&gt; U, vector&lt;int&gt; V) &#123; vector&lt;int&gt; re; for( int i = 0; i &lt; m; ++i)&#123; e[i].u = U[i]; e[i].v = V[i]; e[i].w = i+1; &#125; sort(e,e+m); for( int i = 1; i &lt;= n; ++i)&#123; fa[i] = i; &#125; for( int i = 0; i &lt; m; ++i)&#123; int x = get(e[i].u), y = get(e[i].v); if(x != y)&#123; fa[x] = y; re.push_back(e[i].w); &#125; &#125; sort(re.begin(), re.end()); return re;&#125;// ================= ä»£ç å®ç°ç»“æŸ =================int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); vector&lt;int&gt; U, V; for (int i = 0; i &lt; m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); U.push_back(u); V.push_back(v); &#125; vector&lt;int&gt; ans = getAnswer(n, m, U, V); printf("%d\n", int(ans.size())); for (int i = 0; i &lt; int(ans.size()); ++i) printf("%d\n", ans[i]); return 0;&#125; æ”¶è·è¾“å…¥è¾“å‡ºæŒ‚è¾“å…¥è¾“å‡ºæŒ‚æ˜¯çœŸçš„å¿«ï¼ ç®€å•çš„æ•°å­—è¾“å…¥è¾“å‡ºæŒ‚ï¼Œå®Œæ•´çš„è§ -&gt; è¿™é‡Œ1234567891011121314151617#include &lt;cstdio&gt; int Scan() &#123; //è¾“å…¥å¤–æŒ‚ int res = 0, flag = 0; char ch; if((ch = getchar()) == '-') flag = 1; else if(ch &gt;= '0' &amp;&amp; ch &lt;= '9') res = ch - '0'; while((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') res = res * 10 + (ch - '0'); return flag ? -res : res;&#125; void Out(int a) &#123; //è¾“å‡ºå¤–æŒ‚ if(a &lt; 0) &#123; putchar('-'); a = -a; &#125; if(a &gt;= 10) Out(a / 10); putchar(a % 10 + '0');&#125; è¾“å…¥è¾“å‡ºåˆ†ç¦»åŠ©æ•™ç»™çš„è§£é¢˜æ¨¡æ¿çœŸèˆ’æœï¼Œå¯ä»¥ä¸ç”¨è€ƒè™‘è¾“å‡ºé—®é¢˜ï¼Œä¸“å¿ƒå®ç°ç®—æ³•ï½ï½ï½ä»£ç å¯è¯»æ€§ä¹Ÿæé«˜ä¸å°‘ï¼Œä½†ç«èµ›ä¸­æ‰“çš„æ—¶é—´ä¹Ÿè®¸ä¼šå¢åŠ ä¸€äº›ï¼Œå¤æ‚åº¦ä¹Ÿä¼šå¢åŠ ä¸€äº›ã€‚ å“ˆå¤«æ›¼ç¼–ç  &amp; POJ 3253å“ˆå¤«æ›¼ç¼–ç å°±æ˜¯è´ªå¿ƒï½åœ¨ã€ŠæŒ‘æˆ˜ç¨‹åºè®¾è®¡ç«èµ›(ç¬¬2ç‰ˆ) ã€‹ä¸­è®²è§£çš„ POJ 3253 ç°åœ¨ä¸€çœ‹çœŸæ˜¯é†é†çŒé¡¶ï½ï½ï½ å­¦åˆ°ä¸€äº›ç®—æ³•å®ç° äºŒå‰æ ‘ Kruskal ç®—æ³• å“ˆå¤«æ›¼ç¼–ç çš„ \(O(n)\) å®ç° é¢˜ç›®ä¸­æ•°æ®èŒƒå›´åˆ†ææŠ€å·§è®¡ç®—æœºæ¯ç§’è¿ç®— \(10^8\) \(n = 10^6\) -&gt; \(O(n)\) \(n = 5 \times 10^5\) -&gt; \(O(n log n)\) \(n = 10^4\) -&gt; \(O(n^2)\) ToDoHash Map çš„å®ç°â€¦ å“ˆå¤«æ›¼ç¼–ç çš„ \(O(n)\) å®ç°ä½¿ç”¨æ ˆå’Œé˜Ÿåˆ—ä¼˜åŒ– æˆç»©æ’åº ä¼˜åŒ–\(O(n^2)\) -&gt; \(O(n log n)\) æ’åº -&gt; å¿«æ’æ’åºã€å½’å¹¶æ’åºæ±‚é€†åºå¯¹ -&gt; å½’å¹¶æ’åºã€æ ‘çŠ¶æ•°ç»„è¾…åŠ©ç»Ÿè®¡ é‡ç¼–ç  -&gt;ã€NOI2015ã€‘è·é©¬å²è¯—ä¸åŒè¿›åˆ¶ä¸‹çš„å“ˆå¤«æ›¼ç¼–ç ã€‚ã€NOI2015ã€‘è·é©¬å²è¯— å‚è€ƒèµ„æ–™ è¾“å…¥è¾“å‡ºå¤–æŒ‚ è¾“å…¥è¾“å‡ºå¤–æŒ‚æ€»ç»“ äºŒå‰æ ‘çš„C++ç®€å•å®ç°]]></content>
      <categories>
        <category>æ³› - è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>é˜Ÿåˆ—</tag>
        <tag>å¹¶æŸ¥é›†</tag>
        <tag>æ ˆ</tag>
        <tag>äºŒå‰æ ‘</tag>
        <tag>å“ˆå¤«æ›¼ç¼–ç </tag>
        <tag>Kruskal</tag>
        <tag>Hash Map</tag>
        <tag>è¾“å…¥è¾“å‡ºæŒ‚</tag>
        <tag>ToDo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‚è´¨æ•°è¡¨3â€”â€”é«˜çº§ç­›æ³•]]></title>
    <url>%2F2018%2F07%2F26%2Fisprimes-3%2F</url>
    <content type="text"><![CDATA[å¢é‡å¼ç­›æ³•ä¹‹å‰çš„ç­›æ³•éƒ½éœ€è¦äº‹å…ˆæŒ‡å®šä¸€ä¸ªNï¼Œç„¶åæ±‚Nä»¥å†…çš„è´¨æ•°ï¼Œä½†æ²¡åŠæ³•æ±‚Nä»¥ä¸Šçš„è´¨æ•°ã€‚æˆ‘ä»¬æƒ³è¦ä¸€ç§ç®—æ³•ä¸ç”¨äº‹å…ˆæŒ‡å®šNä¸€ç›´æ±‚ä¸‹å»ï¼Œå¦‚è¯•é™¤æ³•å°±æ˜¯å¢é‡å¼è¿è¡Œçš„ã€‚ å¢é‡å¼ç®—æ³•å¯ä»¥åœ¨ç®€æ˜“æ¬§æ‹‰ç­›è¿›è¡Œæ”¹è¿›çš„ã€‚ç®€æ˜“æ¬§æ‹‰ç­›é™åˆ¶å®ƒä¸èƒ½å¢é‡å¼è¿è¡Œçš„é—®é¢˜æ˜¯åœ¨äºå®ƒçš„ç©ºé—´ã€‚æ¯”å¦‚å¢é‡å¼è¿è¡Œç­›é€‰åˆ° 11 æ—¶ä½ éœ€è¦åˆ’æ‰ 121 ï¼Œè¿™æ ·ä½ å°±éœ€è¦ç»´æŒ N^2 çš„ç©ºé—´ï¼Œè¿™æ ·å°±å¾ˆæˆé—®é¢˜ï¼Œæƒ³è±¡å¦‚æœ N åˆ°1äº¿æ—¶ï¼Œé‚£ç©ºé—´å°†æ˜¯ä¸å¯æ¥å—çš„ã€‚æˆ‘ä»¬å°†ä¸å†æšä¸¾på’Œfï¼Œè€Œæ˜¯ä¾æ¬¡æ£€æŸ¥æ¯ä¸ªæ•°ï¼Œæ£€æŸ¥åˆ°ä¸€ä¸ªæ•°æ—¶åˆ’å»ä¸‹ä¸€ä¸ªæ•°ï¼Œå¹¶å†ä¸‹ä¸€ä¸ªæ•°å¤„åšæ ‡è®°ã€‚æ¯”å¦‚æˆ‘ä»¬æ£€æŸ¥åˆ° 10 ï¼Œæˆ‘ä»¬é€šè¿‡æŸç§æ–¹å¼è®¡ç®—å‡ºå®ƒçš„ä¸‹ä¸€ä¸ªè¦è¢«åˆ’æ‰çš„æ•°ä¸º 15 ï¼Œæˆ‘ä»¬åˆ’æ‰ 15 å¹¶åœ¨ 15 å¤„åšæ ‡è®°ï¼Œä¿è¯æ£€æŸ¥åˆ° 15 æ—¶æˆ‘ä»¬å¯ä»¥è½»æ¾çš„ç®—å‡º 25 ã€‚ç”± Bertrandâ€™s postulate è¿™ä¸ªæ•°å­¦ç»“è®ºå¾—å‡ºç›¸é‚»ä¸¤ä¸ªè´¨æ•°ç›¸å·®ä¸ä¼šè¶…è¿‡ä¸¤å€ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€å°†æ•°ç»„ç»´æŒåœ¨å½“å‰æ£€æŸ¥çš„æ•°çš„ä¸¤å€å³å¯ã€‚è¿™æ ·ç©ºé—´å¤æ‚åº¦å°±å°†ä¸ºäº† O(N) ã€‚ è¿™ä¸ªæ ‡è®°éœ€è¦å¹²ä»€ä¹ˆï¼Œå®ƒéœ€è¦å¸®åŠ©æˆ‘ä»¬åœ¨æ‹¿åˆ°ä¸€ä¸ªæ•°æ—¶è¿…é€Ÿæ‰¾å‡ºå®ƒçš„på’Œfã€‚æˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„ä¿å­˜å½“å‰è¢«æ£€æŸ¥çš„æ•°çš„æœ€å°è´¨å› å­åœ¨è´¨æ•°è¡¨çš„ä½ç½®å³å¯ã€‚è¿™æ ·æ¯”å¦‚æˆ‘ä»¬åœ¨æ‹¿åˆ° 15 æ—¶ï¼Œæˆ‘ä»¬æ‰¾åˆ°å®ƒçš„æœ€å°è´¨å› å­pä¸º 3 ï¼Œ15/3 ç®—å‡º f ä¸º 5ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨ f ä¹˜ä¸‹ä¸€ä¸ªè´¨æ•°å»æ‰¾åˆ° 25 åˆ’æ‰å®ƒå¹¶ç»§ç»­ä¼ é€’æ ‡è®°äº†ã€‚æ ‡è®°ä»æ¯ä¸ªå¶æ•°å¤„ï¼ˆå› ä¸ºç¬¬ä¸€ä¸ªç´ æ•°ä¸º 2 ï¼‰äº§ç”Ÿçš„ï¼Œåˆ°åˆ—æœ«å°¾æ¶ˆå¤±ï¼ˆp æœ€å¤§å¢é•¿åˆ° f çš„æœ€å°è´¨å› å­ï¼‰ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/DtN2WPpppf/1234567891011121314151617181920212223242526int bengalloun(int N)&#123; int nPrimes = 0; flag[2] = true; for( int i = 2; i &lt;= N; i++)&#123; flag[i * 2 - 1] = true; //å‡è®¾å®ƒä¸ºè´¨æ•° flag[i * 2] = false; //å¶æ•°ä¸€å®šä¸ºåˆæ•° lpfindex[i * 2] = 0; //å»ºç«‹åˆ—é¦–æ ‡è®° if(flag[i])&#123; primes[nPrimes++] = i; //å¦‚æœè¿˜æ²¡è¢«ç­›æ‰åŠ å…¥è´¨æ•°è¡¨ &#125;else&#123; //å¦‚æœæ˜¯åˆæ•° int u = lpfindex[i]; int p = primes[u]; int f = i / p; //è®¡ç®—på’Œf if(f % p != 0)&#123; //å¦‚æœæ²¡æœ‰åˆ°åˆ—å°¾å°±ä¼ é€’æ ‡è®° int j = primes[u + 1] * f; flag[j] = false; lpfindex[j] = u + 1; &#125; &#125; &#125; return nPrimes;&#125; å¤æ‚åº¦åˆ†ææ—¶é—´å¤æ‚åº¦ä¸æ€æƒ³ä¸ç®€æ˜“æ¬§æ‹‰ç­›ç›¸åŒï¼Œä¾ç„¶ä¸ºO(N)ã€‚å› ä¸ºè¦ä¸ºå¢é‡å¼è¿è¡Œåšå‡†å¤‡å®é™…è¦æ¯”ç®€æ˜“æ¬§æ‹‰ç­›å¤šèŠ±ä¸€å€çš„æ—¶é—´ã€‚ ç©ºé—´å¤æ‚åº¦flagå’Œlpfindexæ•°ç»„éƒ½ä¸ºO(N)çš„å¤æ‚åº¦ã€‚æ€»ä½“ç©ºé—´å¤æ‚åº¦ä¸ºO(N)ã€‚ åˆ†æ®µå¼ç­›æ³•å¯¹äºç°ä»£è®¡ç®—æœºè¿ç®—é€Ÿåº¦è¶Šæ¥è¶Šå¿«ï¼Œæ—¶é—´å¤æ‚åº¦å¯èƒ½é—®é¢˜ä¸å¤§ï¼Œä½†ç©ºé—´å¤æ‚åº¦æ˜¯ä¸ªé—®é¢˜ã€‚åˆ†æ®µå¼ç­›æ³•å°±æ˜¯è¦è§£å†³è¿™ä¸ªé—®é¢˜ã€‚åˆ†æ®µå¼ç­›æ³•æ˜¯åœ¨åŸƒå¼ç­›æ³•çš„åŸºç¡€ä¸Šæ”¹è¿›çš„ï¼Œ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/HzTG6HrbV2/123456789101112131415161718192021222324252627int segmented_eratosthenes(int N)&#123; int sqrtN = (int) sqrt(N); int n = eratosthenes(sqrtN); int nPrimes = n;// ä½¿ç”¨åŸƒå¼ç­›æ³•æ±‚å‡ºå‰ âˆšN å†…çš„è´¨æ•°ã€‚ int L = sqrtN; // åˆ†æ®µæ±‚ï¼ŒL ä¸ºæ¯æ®µé•¿åº¦ï¼Œå– âˆšN for( int start = sqrtN + 1; start &lt;= N; start += L)&#123; if(start + L &gt; N) L = N - start + 1; memset(flag, true, L * sizeof(bool)); for( int u = 0; u &lt; n; u++)&#123; int p = primes[u]; if(p * p &gt;= start + L) break; // æšä¸¾æœ¬æ®µä¸Šé™ä»¥å†…çš„è´¨æ•° for( int i = (p - start % p) % p; i &lt; L; i += p)&#123; flag[i] = false; // åˆ’æ‰æœ¬æ®µä¸­èƒ½è¢« p æ•´é™¤çš„æ•° &#125; &#125; for( int i = 0; i &lt; L; i++)&#123; if(flag[i]) primes[nPrimes++] = start + i; // æ‰¾åˆ°æœ¬æ®µä¸­æ²¡æœ‰è¢«åˆ’æ‰çš„æ•°å¹¶å°†å…¶æ”¶é›†åˆ°è´¨æ•°è¡¨ä¸­ &#125; &#125; return nPrimes;&#125; L çš„å–æ³•ç©ºé—´\(\sqrt{N}\) ä»¥å†…è´¨æ•°è¡¨å ç”¨äº† \(O(\sqrt{N})\) çš„ç©ºé—´ã€‚flag æ•°ç»„å ç”¨ \(O(L)\) çš„ç©ºé—´ã€‚è‹¥ \(L &gt; \sqrt{N}\) ç©ºé—´å¤æ‚åº¦å°†æé«˜ã€‚ æ—¶é—´è‹¥ \(L &lt; \sqrt{N}\)ï¼Œå½“ p æ¥è¿‘ \(\sqrt{N}\) æ—¶ï¼Œåˆ é™¤ p çš„å€æ•°å°±å®¹æ˜“â€œæ‰‘ç©ºâ€ã€‚ æ‰€ä»¥ \(L = \sqrt{N}\) æ—¶åˆšå¥½ã€‚ å¤æ‚åº¦åˆ†ææ—¶é—´å¤æ‚åº¦æœ¬è´¨ä¸Šæ˜¯åŸƒå¼ç­›æ³•ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º \(O(NloglogN)\)ã€‚å†…å­˜å ç”¨å°ï¼Œé¿å…äº†ç¼“å­˜ä¸å‘½ä¸­ï¼Œå®é™…ä¸Šæ¯”åŸƒå¼ç­›æ³•è¦å¿«ã€‚ ç©ºé—´å¤æ‚åº¦\(O(\sqrt{N})\)]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>è´¨æ•°</tag>
        <tag>æ±‚è´¨æ•°è¡¨</tag>
        <tag>ä¼˜åŒ–</tag>
        <tag>å¢é‡å¼ç­›æ³•</tag>
        <tag>åˆ†æ®µå¼ç­›æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŒæœèŠ±å¤•æ‹¾ã€0x02 å¹»è§‰]]></title>
    <url>%2F2018%2F07%2F24%2Fdiary_2%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘æœ‰äº›å°å‡‰ï½ç”µè„‘ç³»ç»Ÿå‡ºäº†é—®é¢˜ï¼Œåšå®¢æ•°æ®æ²¡åšå¥½å¤‡ä»½å·®ç‚¹ä¸¢å¤±ï¼Œæ—©ä¸Šåˆšåˆšå¾—åˆ°æ¶ˆæ¯æˆ‘çš„å¤§å­¦è‹±è¯­äºŒæŒ‚äº†ï½55åˆ†å¾ˆæ˜¯éš¾è¿‡ï½å¥½åœ¨å…¶ä»–éƒ½è¿˜ä¸é”™ï¼Œå¥–å­¦é‡‘å†å»ä¸æˆ‘æ— ç¼˜ï½ å…¶å®æˆ‘åˆšä¸Šå¤§å­¦æ—¶è§‰å¾—æŒ‚ç§‘ä¹Ÿæ²¡ä»€ä¹ˆï¼Œå› ä¸ºæˆ‘ä»æ¥ä¸æ˜¯å¥½å­¦ç”Ÿï¼Œåç§‘ä¹Ÿåå‡ å¹´äº†ã€‚ä½†æˆ‘ä¸èƒ½å®¹å¿çš„æ˜¯è®©ä¸€å †åªä¼šè€ƒè¯•çš„äººæ‹¿äº†é’±ï¼Œæˆ‘è§‰å¾—è¿™å¯¹æˆ‘æ˜¯ä¸€ç§ä¾®è¾±ï¼Œæˆ‘ä¸‹å­¦æœŸå¿…å°†æ‹¿ä¸€æ¬¡ä¸€ç­‰å¥–å­¦é‡‘ï¼Œä¹‹åéšæ„ï½ æˆ‘è¦å­¦è‹±è¯­äº†ï¼Œæˆ‘è§‰å¾—è¿™å¯¹æˆ‘å¾ˆé‡è¦ï¼Œå¦‚æœè‹±è¯­æå®šé‚£åé¢çš„äº‹æƒ…çœŸæ˜¯æ— æ³•æƒ³è±¡ï½ äº‹å®ä¸Šæˆ‘é«˜ä¸‰å°±è¿™ä¹ˆæƒ³äº†ï¼Œç»“æœé«˜è€ƒè‹±è¯­è€ƒäº† 44 åˆ†ï¼Œå¾ˆé†‰ã€‚ã€‚ã€‚ é«˜ä¸­å•Šï¼Œæˆ‘ä¸å­¦è‹±è¯­æ˜¯æœ‰åŸå› çš„ï¼Œå› ä¸ºæˆ‘è§‰å¾—å…¶ä»–çš„è¿˜èƒ½æé«˜ï¼Œè€Œä¸”æ›´ä¸ºé«˜æ•ˆï½æˆ‘å¹²æ‰äº†æœ€éš¾çš„ç‰©ç†ï¼Œä¹‹åä¸€è·¯è¿˜ç®—é¡ºé£é¡ºæ°´ï¼Œæ²¡åƒä»€ä¹ˆè‹¦ä¹Ÿä¸Šäº†å­¦ã€‚é—æ†¾çš„æ˜¯ç°åœ¨ä¸–é“ä¸ä¸€æ ·äº†ï¼Œæˆ‘æ€¥éœ€è‹±è¯­ï¼Œæˆ‘éœ€è¦çœ‹è‹±æ–‡çš„æŠ€æœ¯ä¹¦ç±ï¼Œæˆ‘éœ€è¦çœ‹ACMé¢˜ï¼Œä½†è¿™äº›ä¸æ˜¯æœ€é‡è¦çš„ï¼Œæœ€é‡è¦çš„æ˜¯æˆ‘ç°åœ¨å­¦è‹±è¯­å¦‚æœæˆäº†ï¼Œæˆ‘å°†æ— æ‰€ä¸èƒ½ï½æ²¡æœ‰ä»€ä¹ˆæ¯”è¿™ä¸ªé‡è¦çš„äº†ï¼Œå¦‚æœæˆäº†æˆ‘ç›¸ä¿¡å¤§å­¦åé¢å‡ å¹´ä¸€å®šé¡ºé£é¡ºæ°´ã€‚ã€‚ã€‚ æˆ‘ç°åœ¨æœ‰å¾ˆå¤§çš„å¹»è§‰ï¼Œæˆ‘æ„Ÿè§‰æˆ‘åªéœ€è¦åŠå¹´ï¼Œæˆ‘çœ‹äº†ä¸€äº›çŸ¥ä¹ä¸Šçš„ç»éªŒé€šå¸¸æ—¶é—´è·¨åº¦éƒ½æŒºé•¿çš„ï¼Œé‚£äº›éƒ½æ˜¯ç¬¨è›‹æˆ‘åªéœ€è¦åŠå¹´ï¼ åé¢çš„äº‹æƒ…è¿˜å¤šå•Šï¼Œæ—¶é—´å¤ªå°‘ã€‚æ•°å­¦å»ºæ¨¡çš„å¥½ä¸œè¥¿éƒ½æ²¡æå®šï¼Œç‰¹åˆ«æ˜¯å†™è®ºæ–‡ç”¨çš„æ’ç‰ˆè¯­è¨€ï¼Œæš‘å‡è¿˜è¦å­¦ã€‚ACMè¿˜è¦åˆ·å¾ˆå¤šé¢˜ï¼Œæš‘å‡è¿˜è¦çœ‹é‚“è€å¸ˆçš„ç®—æ³•è¯¾ã€‚æˆ‘è¿˜è®¡åˆ’æ€»ç»“ä¸€ä¸‹C++çš„åŸºç¡€é—®é¢˜ï¼Œå¼€å­¦å½“åŠ©æ•™ä¸èƒ½è¯¯äººå­å¼Ÿå•Šã€‚å¼€å­¦è¿˜æœ‰æ•°å­¦å»ºæ¨¡ç«èµ›å’ŒACMçš„ç½‘ç»œèµ›ï½å†å‚åŠ ä¸€ä¸‹è“æ¡¥æ¯ã€‚å¤§äºŒçš„è¯¾ç¨‹è¿˜æ˜¯æœ‰äº›éš¾åº¦çš„ï¼ŒJavaè™½ç„¶æˆ‘ä¹‹å‰å­¦è¿‡ä½†è¿˜æ˜¯éœ€è¦å†™å¾ˆå¤šä»£ç å»ç†Ÿç»ƒï¼Œå­¦Javaå°±ä¼´éšç€è¿˜è¦çœ‹è®¾è®¡æ¨¡å¼ï¼Œæ±‡ç¼–è¯­è¨€è™½ç„¶è‡ªå·±ä¹Ÿå†™è¿‡ï¼Œä½†è¿˜æ˜¯å¥½éš¾å•Šã€‚ã€‚ã€‚è¿˜æœ‰é‚£ä¸ªé˜´å·®é˜³é”™é€‰ä¸Šçš„å•ç‰‡æœºï¼ŒçœŸæ˜¯æ— åŠ›åæ§½ï¼Œè¿˜æ˜¯è™½ç„¶ï¼Œè™½ç„¶æˆ‘æ˜¯å†™è¿‡å•ç‰‡æœºçš„ç¨‹åºï¼Œä½†è¿˜æ˜¯å¥½éš¾å•Šã€‚ã€‚ã€‚ æœ€åæ‰¯ä¸ªæ·¡ï¼Œæœ€è¿‘æˆ‘æƒ³æ‹ä¸ªå¤§ç”µå½±ï¼ŒçœŸçš„ï½å“ªå¤©æˆ‘é—²äº†å°±å»æ‹ï¼Œä¸Šä¼ åˆ°YouTubeä¸Šã€‚]]></content>
      <categories>
        <category>æ³› - è®°</category>
      </categories>
      <tags>
        <tag>è®°</tag>
        <tag>è‹±è¯­</tag>
        <tag>å¤§ç”µå½±</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œä¹¦æ‘˜ã€ã€Šæ·±åº¦æ¢ç´¢ C++ å¯¹è±¡æ¨¡å‹ã€‹ï¼ˆäºŒï¼‰]]></title>
    <url>%2F2018%2F07%2F23%2Finside_cpp_obj_model_2%2F</url>
    <content type="text"><![CDATA[æ„é€ å‡½æ•°è¯­ä¹‰å­¦è‹±æ–‡æœ¯è¯­è¡¨ è‹±æ–‡ ä¸­æ–‡ implicit æš—ä¸­çš„ã€éšå¼çš„ï¼ˆé€šå¸¸æ„æŒ‡å¹¶éåœ¨ç¨‹åºæºä»£ç ä¸­å‡ºç°çš„ï¼‰ explicit æ˜¾å¼çš„ï¼ˆé€šå¸¸æ„æŒ‡ç¨‹åºæºä»£ç ä¸­æ‰€å‡ºç°çš„ï¼‰ trivial æ²¡ç”¨çš„ nontrivial æœ‰ç”¨çš„ memberwise å¯¹æ¯ä¸ª member æ–½ä»¥â€¦â€¦ bitwise å¯¹æ¯ä¸ª bit æ–½ä»¥â€¦â€¦ semantics è¯­æ„ å…³äº C++ ï¼Œæœ€å¸¸å¬åˆ°çš„ä¸€ä¸ªæŠ±æ€¨å°±æ˜¯ï¼Œç¼–è¯‘å™¨èƒŒç€ç¨‹åºå‘˜åšäº†å¤ªå¤šäº‹æƒ…ã€‚ å…³é”®è¯ explicit ä¹‹æ‰€ä»¥è¢«å¯¼å…¥è¿™ä¸ªè¯­è¨€ï¼Œå°±æ˜¯ä¸ºäº†ç»™ç¨‹åºå‘˜æä¾›ä¸€ç§æ–¹æ³•ï¼Œä½¿ä»–ä»¬èƒ½å¤Ÿåˆ¶æ­¢ â€œå•ä¸€å‚æ•°çš„ constructorâ€œ è¢«å½“ä½œä¸€ä¸ª conversion è¿ç®—ç¬¦ã€‚ â€œSchwarz Errorâ€ -&gt; basic_ios å¦‚ä½•ç©¿ä¸Šå®ƒçš„ bool Conversion è¿ç®—ç¬¦çš„å¼•å…¥åº”è¯¥æ˜¯æ˜æ™ºçš„ï¼Œè€Œå…¶æµ‹è¯•åº”è¯¥æ˜¯ä¸¥é…·çš„ï¼Œå¹¶ä¸”ä¸­ç¨‹åºä¸€å‡ºç°ä¸å¯»å¸¸æ´»åŠ¨çš„ç¬¬ä¸€ä¸ªç—‡å€™æ—¶ï¼Œå°±å‘å‡ºç–‘é—®ã€‚ Default Constructor çš„æ„é€ æ“ä½œç¨‹åºçš„éœ€è¦ã€ç¼–è¯‘å™¨çš„éœ€è¦ã€‚ç¨‹åºå¦‚æœæœ‰éœ€è¦ï¼Œé‚£æ˜¯ç¨‹åºå‘˜çš„è´£ä»»ã€‚ 12345678910class Foo &#123; public: int val; Foo *pnext; &#125;;void foo_bar()&#123; Foo bar; if ( bar.val || bar.pnext ) // ... do something // ... &#125; C++ Standard [ISO-C++95] Section 12.1 :å¯¹äº class Xï¼Œå¦‚æœæ²¡ç”¨ä»»ä½• user-declared constructorï¼Œé‚£ä¹ˆä¼šæœ‰ä¸€ä¸ª default constructor è¢«éšå¼çš„ï¼ˆ implicitly ï¼‰å£°æ˜å‡ºæ¥â€¦â€¦ä¸€ä¸ªè¢«éšå¼å£°æ˜å‡ºæ¥çš„ default constructor å°†æ˜¯ä¸€ä¸ª trivial constructorâ€¦â€¦ â€œå¸¦æœ‰ Default Constructorâ€ çš„ Member Class Objectå¦‚æœä¸€ä¸ª class æ²¡æœ‰ä»»ä½• constructorï¼Œä½†å®ƒå†…å«ä¸€ä¸ª member objectï¼Œè€Œåè€…æœ‰ default constructorï¼Œé‚£ä¹ˆè¿™ä¸ª class çš„ implicit default constructor å°±æ˜¯ â€œnontrivialâ€ ï¼Œç¼–è¯‘å™¨éœ€è¦ä¸ºæ”¹ class åˆæˆå‡ºä¸€ä¸ª default constructorã€‚ä¸è¿‡è¿™ä¸ªåˆæˆæ“ä½œåªæœ‰ä¸­ constructor çœŸæ­£éœ€è¦è¢«è°ƒç”¨æ—¶æ‰ä¼šå‘ç”Ÿã€‚ ç¼–è¯‘å™¨å¦‚ä½•é¿å…åˆæˆå‡ºå¤šä¸ª default constructor ï¼ŸæŠŠåˆæˆçš„ default constructorã€copy constructorã€destructorã€assignment copy operator éƒ½ä»¥ inline çš„æ–¹å¼å®Œæˆã€‚å¦‚æœå‡½æ•°å¤ªå¤æ‚ï¼Œä¸é€‚åˆåšæˆ inlineï¼Œå°±ä¼šåˆæˆå‡ºä¸€ä¸ª explicit non-inline static å®ä¾‹ï¼ˆ4.5èŠ‚æœ‰è¯¦ç»†è¯´æ˜ï¼‰ ç¼–è¯‘å™¨ä¼šæ‰©å¼ å·²å­˜åœ¨çš„ constructorsï¼Œåœ¨å…¶ä¸­å®‰æ’ä¸€äº›ä»£ç ï¼Œä½¿å¾— user code è¢«æ‰§è¡Œä¹‹å‰ï¼Œå…ˆè°ƒç”¨å¿…è¦çš„ default constructorsã€‚ C++ è¯­è¨€è¦æ±‚ä»¥ â€œmember objects åœ¨ class ä¸­çš„å£°æ˜é¡ºåºâ€ æ¥è°ƒç”¨å„ä¸ª constructorsã€‚ â€œå¸¦æœ‰ Default Constructorâ€ çš„ Base Classå¦‚æœä¸€ä¸ªæ²¡æœ‰ä»»ä½• constructor çš„ class æ´¾ç”Ÿè‡ªä¸€ä¸ª â€œå¸¦æœ‰ Default Constructorâ€ çš„ base classï¼Œé‚£ä¹ˆè¿™ä¸ª derived class çš„ default constructor ä¼šè¢«è§†ä¸º nontrivialï¼Œå¹¶å› æ­¤éœ€è¦è¢«åˆæˆå‡ºæ¥ã€‚å®ƒå°†è°ƒç”¨ä¸Šä¸€å±‚ base classes çš„ default constructorï¼ˆæ ¹æ®å®ƒä»¬çš„å£°æ˜é¡ºåºï¼‰ã€‚å¯¹ä¸€ä¸ªåç»§æ´¾ç”Ÿçš„ class è€Œè¨€ï¼Œè¿™ä¸ªåˆæˆçš„ constructor å’Œä¸€ä¸ª â€œè¢«æ˜¾å¼æä¾›çš„ default constructorâ€ æ²¡æœ‰ä»€ä¹ˆå·®å¼‚ã€‚ â€œå¸¦æœ‰ Virtual Functionâ€ çš„ Classå½“ class å£°æ˜ï¼ˆæˆ–ç»§æ‰¿ï¼‰ä¸€ä¸ª virtual function ï¼Œéœ€è¦åˆæˆ nontrivial çš„ default constructorã€‚ â€œå¸¦æœ‰ Virtual Functionâ€ çš„ class çš„ default constructor ä¼šæœ‰ä¸¤ä¸ªæ‰©å¼ è¡ŒåŠ¨åœ¨ç¼–è¯‘æœŸé—´å‘ç”Ÿï¼š ä¸€ä¸ª virtual function tableï¼ˆåœ¨ cfront ä¸­è¢«ç§°ä¸º vtbl ï¼‰ä¼šè¢«ç¼–è¯‘å™¨äº§ç”Ÿå‡ºæ¥ï¼Œå†…æ”¾ class çš„ virtual functions åœ°å€ã€‚ åœ¨æ¯ä¸€ä¸ª class object ä¸­ï¼Œä¸€ä¸ªé¢å¤–çš„ pointer memberï¼ˆä¹Ÿå°±æ˜¯ vptr ï¼‰ä¼šè¢«ç¼–è¯‘å™¨åˆæˆå‡ºæ¥ï¼Œå†…å«ç›¸å…³ä¹‹ class vtbl çš„åœ°å€ã€‚ 1234// widget.flip() çš„è½¬å˜( *widget.vptr[1] )( &amp;widget )// * 1 è¡¨ç¤º filp() åœ¨ virtual table ä¸­çš„å›ºå®šç´¢å¼•// * &amp;widget ä»£è¡¨è¦äº¤ç»™â€œè¢«è°ƒç”¨çš„æŸä¸ª flip() å‡½æ•°å®ä¾‹â€çš„thisæŒ‡é’ˆ ç¼–è¯‘å™¨å¿…é¡»ä¸ºæ¯ä¸€ä¸ª â€œå¸¦æœ‰ Virtual Functionâ€ çš„ class çš„ object çš„ vptr è®¾å®šåˆå€¼ï¼Œæ”¾çºµé€‚å½“çš„ virual table åœ°å€ã€‚å¯¹äºè¿™ä¸ª class æ‰€å®šä¹‰çš„æ¯ä¸€ä¸ª constructorï¼Œç¼–è¯‘å™¨ä¼šå®‰æ’ä¸€äº›ä»£ç æ¥åšè¿™æ ·çš„äº‹æƒ…ã€‚ â€œå¸¦æœ‰ Virtual Base Classâ€ çš„ Classclass æ´¾ç”Ÿè‡ªä¸€ä¸ªç»§æ‰¿ä¸²é“¾ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªæˆ–æ›´å¤šçš„ virtual base classesï¼Œéœ€è¦åˆæˆ nontrivial çš„ default constructorã€‚ Virtual base class çš„å®ç°æ³•åœ¨ä¸åŒçš„ç¼–è¯‘å™¨ä¹‹é—´æœ‰æå¤§çš„å·®å¼‚ã€‚ç„¶è€Œï¼Œæ¯ä¸€ç§å®ç°æ³•çš„å…±åŒç‚¹åœ¨äºå¿…é¡»ä½¿ virtual base class åœ¨å…¶æ¯ä¸€ä¸ª derived class object ä¸­çš„ä½ç½®ï¼Œèƒ½å¤Ÿäºæ‰§è¡ŒæœŸå‡†å¤‡å¦¥å½“ã€‚ 12345678910111213class X &#123; public: int i; &#125;;class A : pubilc virual X &#123; public: int j; &#125;;class B : pubilc virual X &#123; public: double d; &#125;;class C : public A, public B &#123; public: int k &#125;;// æ— æ³•åœ¨ç¼–è¯‘æ—¶æœŸå†³å®šï¼ˆresolveï¼‰å‡º pa-&gt;X::i çš„ä½ç½®void foo( const A* pa) &#123; pa-&gt;i = 1024; &#125;int main()&#123; foo( new A ); foo( new C );&#125; ç›¸å½“äºä¸‹é¢çš„ä»£ç 12void foo( const A* pa) &#123; pa-&gt;__vbcX-&gt;i = 1024; &#125;// __vbcX è¡¨ç¤ºç¼–è¯‘å™¨äº§ç”Ÿçš„æŒ‡é’ˆï¼ŒæŒ‡å‘ virtual base class Xã€‚ æ€»ç»“æœ‰ 4 ç§æƒ…å†µï¼Œä¼šé€ æˆâ€œç¼–è¯‘å™¨å¿…é¡»ä¸ºæœªå£°æ˜ constructor çš„ classes åˆæˆä¸€ä¸ª default constructorâ€ã€‚ æ²¡æœ‰ä»»ä½• constructor çš„ class å†…å«ä¸€ä¸ªæœ‰ default constructor çš„ member object æ²¡æœ‰ä»»ä½• constructor çš„ class æ´¾ç”Ÿè‡ªä¸€ä¸ª â€œå¸¦æœ‰ Default Constructorâ€ çš„ base class å½“ class å£°æ˜ï¼ˆæˆ–ç»§æ‰¿ï¼‰ä¸€ä¸ª virtual function class æ´¾ç”Ÿè‡ªä¸€ä¸ªç»§æ‰¿ä¸²é“¾ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªæˆ–æ›´å¤šçš„ virtual base classes C++ Standard æŠŠé‚£äº›åˆæˆç‰©ç§°ä¸º implicit nontrivial default constructorsã€‚ C++ æ–°æ‰‹ä¸¤ä¸ªå¸¸è§è¯¯è§£ï¼š ä»»ä½• class å¦‚æœæ²¡æœ‰å®šä¹‰ default constructorï¼Œå°±ä¼šè¢«åˆæˆå‡ºä¸€ä¸ªæ¥ã€‚ ç¼–è¯‘å™¨åˆæˆå‡ºæ¥çš„ default constructor ä¼šæ˜¾å¼è®¾å®š â€œclass å†…æ¯ä¸€ä¸ª data member çš„é»˜è®¤å€¼â€ã€‚ Copy Constructor çš„æ„é€ æ“ä½œæœ‰ä¸‰ç§æƒ…å†µï¼Œä¼šä»¥ä¸€ä¸ª object çš„å†…å®¹ä½œä¸ºå¦ä¸€ä¸ª class object çš„åˆå€¼ã€‚class X { ... }; X xx = x ä½œä¸ºå‚æ•°äº¤ç»™æŸä¸ªå‡½æ•° foo( xx ); ä½œä¸ºå‡½æ•°è¿”å›å€¼ return xx; Default Memberwise InitializationDefault constructors å’Œ copy constructors åœ¨å¿…è¦çš„æ—¶å€™æ‰ç”±ç¼–è¯‘å™¨äº§ç”Ÿå‡ºæ¥ã€‚å¯¹äº copy constructors å¿…è¦çš„æ—¶å€™æ˜¯æŒ‡è¯¥ class ä¸å±•ç° bitwise copy semantics æ—¶ã€‚ C++ Standard æŠŠ copy constructors åŒºåˆ†ä¸º trivial å’Œ nontrivial ä¸¤ç§ã€‚åªæœ‰ nontrivial çš„å®ä¾‹è¢«åˆæˆäºç¨‹åºä¹‹ä¸­ã€‚ Bitwise Copy Semanticsï¼ˆä½é€æ¬¡æ‹·è´ï¼‰1234567// ä»¥ä¸‹å£°æ˜å±•ç°äº† bitwise copy semanticsclass Bitwise&#123;int a;public: Bitwise(int a);&#125;; 12345678// ä»¥ä¸‹å£°æ˜æœªå±•ç°å‡º bitwise copy semanticsclass NonBitwise&#123;int a;string b;public: NonBitwise(v);&#125;; å¯¹äºåè€…ï¼Œç¼–è¯‘å™¨å¿…é¡»åˆæˆå‡ºä¸€ä¸ª copy constructorï¼Œä»¥ä¾¿è°ƒç”¨ member class string object çš„ copy constructorã€‚123456// C++ ä¼ªç inline NonBitwise(const NonBitwise&amp; nb)&#123; b.string::string(nb.b); a = nb.a;&#125; ä¸è¦ Bitwise Copy Semantics ï¼class ä¸å±•ç°å‡º â€bitwise copy semanticsâ€œ çš„ 4 ç§æƒ…å†µï¼š å½“ class å†…å«ä¸€ä¸ª member object è€Œåè€…çš„ class å£°æ˜æœ‰ä¸€ä¸ª copy constructos æ—¶ï¼ˆä¸è®ºæ—¶è¢«æ˜¾å¼å£°æ˜æˆ–æ˜¯è¢«åˆæˆè€Œå¾—ï¼‰ã€‚ å½“ class ç»§æ‰¿è‡ªä¸€ä¸ª base class è€Œåè€…å­˜åœ¨ä¸€ä¸ª copy constructor æ—¶ï¼ˆä¸è®ºæ—¶è¢«æ˜¾å¼å£°æ˜æˆ–æ˜¯è¢«åˆæˆè€Œå¾—ï¼‰ã€‚ å½“ class å£°æ˜äº†ä¸€ä¸ªæˆ–å¤šä¸ª virtual functions æ—¶ã€‚ å½“ class æ´¾ç”Ÿè‡ªä¸€ä¸ªç»§æ‰¿ä¸²é“¾ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªæˆ–å¤šä¸ª virtual base classes æ—¶ã€‚ é‡æ–°è®¾å®š Virtual Table çš„æŒ‡é’ˆå½“ class å£°æ˜äº†ä¸€ä¸ªæˆ–å¤šä¸ª virtual functions æ—¶ï¼Œç¼–è¯‘æœŸé—´ä¼šæœ‰ä¸¤ä¸ªç¨‹åºæ‰©å¼ æ“ä½œï¼š å¢åŠ ä¸€ä¸ª virtual function table( vtbl )ï¼Œå†…å«æ¯ä¸€ä¸ªæœ‰ä½œç”¨çš„ virtual function çš„åœ°å€ã€‚ ä¸€ä¸ªæŒ‡å‘ virtual function table çš„æŒ‡é’ˆï¼ˆ vptr ï¼‰ï¼Œå®‰æ’åœ¨æ¯ä¸€ä¸ª class object å†…ã€‚ å¤„ç† Virtual Base Class Subobjectå¦‚æœä¸€ä¸ª class ä»¥å¦ä¸€ä¸ª object ä½œä¸ºåˆå€¼ï¼Œè€Œåè€…æœ‰ä¸€ä¸ª virtual base class subobjectï¼Œé‚£ä¹ˆä¹Ÿä¼šä½¿ â€œbitwise copy semanticsâ€ å¤±æ•ˆã€‚ æ¯ä¸€ä¸ªç¼–è¯‘å™¨å¯¹äºè™šæ‹Ÿç»§æ‰¿çš„æ”¯æŒæ‰¿è¯ºï¼Œéƒ½ä»£è¡¨å¿…é¡»è®©â€œderived class object ä¸­ virtual base class subobject ä½ç½®â€ åœ¨æ‰§è¡ŒæœŸå°±å‡†å¤‡å¦¥å½“ã€‚ç»´æŠ¤â€œä½ç½®çš„å®Œæ•´æ€§â€æ˜¯ç¼–è¯‘å™¨çš„è´£ä»»ã€‚ 123456789class A&#123;...&#125;;class B : public virtual A&#123;...&#125;;class C : public B&#123;...&#125;; 123B ba;B bb = ba;// è¿™ç§æƒ…å†µä½¿ç”¨ bitwise å°±å¤Ÿäº† 12345C ca;B bb = ca;/*ç¼–è¯‘å™¨éœ€è¦åˆæˆä¸€ä¸ª copy constructorï¼Œå®‰æ’ä¸€äº›ä»£ç ä»¥è®¾å®š virtual base class pointer/offser çš„åˆå€¼ï¼ˆæˆ–åªæ˜¯ç®€å•åœ°ç¡®å®šå®ƒæ²¡æœ‰è¢«æŠ¹æ¶ˆï¼‰ï¼Œå¯¹æ¯ä¸€ä¸ª memberwise æ‰§è¡Œå¿…è¦çš„åˆå§‹åŒ–æ“ä½œï¼Œä»¥åŠæ‰§è¡Œå…¶ä»–çš„å†…å­˜ç›¸å…³å·¥ä½œã€‚*/ ç¨‹åºè½¬åŒ–è¯­æ„å­¦ï¼ˆProgram Transformation Semanticsï¼‰12345678#include "X.h"X foo()&#123; X xx; // ... return xx;&#125; ä¸¤ä¸ªå‡è®¾ï¼š æ¯æ¬¡ foo() è¢«è°ƒç”¨ï¼Œå°±ä¼ å› xx çš„å€¼ã€‚ å¦‚æœ class X å®šä¹‰äº†ä¸€ä¸ª copy constructorï¼Œé‚£ä¹ˆå½“ foo() è¢«è°ƒç”¨æ—¶ï¼Œä¿è¯è¯¥ copy constructor ä¹Ÿä¼šè¢«è°ƒç”¨ã€‚ ç¬¬ä¸€ä¸ªå‡è®¾çš„çœŸå®æ€§ï¼Œå¿…é¡»è§† class X å¦‚ä½•å®šä¹‰è€Œå®šã€‚ ç¬¬äºŒä¸ªå‡è®¾çš„çœŸå®æ€§ï¼Œè™½ç„¶ä¹Ÿéƒ¨åˆ†åœ°å¿…é¡»è§† class X å¦‚ä½•å®šä¹‰è€Œå®šï¼Œä½†æœ€ä¸»è¦çš„è¿˜æ˜¯è§†ä½ çš„ C++ ç¼–è¯‘å™¨æ‰€æä¾›çš„è¿›å–æ€§ä¼˜åŒ–å±‚çº§ï¼ˆdegree of aggressive optimizationï¼‰è€Œå®šã€‚ æ˜¾å¼çš„åˆå§‹åŒ–æ“ä½œï¼ˆExplicit Initializationï¼‰åœ¨ä¸¥è°¨çš„ C++ ç”¨è¯ä¸­ï¼Œâ€œå®šä¹‰â€ æ˜¯æŒ‡ â€œå ç”¨å†…å­˜â€ çš„è¡Œä¸ºã€‚ 123X x1( x0 );X x2 = x0;X x3 = X( x0 ); è½¬åŒ–ä¸º -&gt; 12345678X x1;X x2;X x3;// ç¼–è¯‘å™¨å®‰æ’ X copy construction çš„è°ƒç”¨æ“ä½œX1.X::X( x0 );X2.X::X( x0 );X3.X::X( x0 ); å‚æ•°çš„åˆå§‹åŒ–ï¼ˆArgument Initializationï¼‰12345void foo( X x0 );X xx;// ...foo( xx ); ç¬¬ä¸€ç§ç¼–è¯‘å™¨å®ç°çš„è½¬åŒ–ä»£ç 1234X __temp0;__temp0.X::X( xx );foo( __temp0 ); è¦æ±‚å±€éƒ¨å®ä¾‹ï¼ˆlocal instanceï¼‰x0 ä»¥ memberwise çš„æ–¹å¼å°† xx å½“åšåˆå€¼ã€‚å¯¼å…¥ä¸´æ—¶æ€§ objectï¼Œå¹¶è°ƒç”¨ copy constructor å°†å®ƒåˆå§‹åŒ–ï¼Œç„¶åå°†æ­¤ä¸´æ—¶æ€§ object äº¤ç»™å‡½æ•°ã€‚ä½†è¿™é‡Œ foo() å‡½æ•°å£°æ˜å°†æ”¹å˜ä¸º void foo( X&amp; x0 )ã€‚åœ¨å‡½æ•°æ‰§è¡Œå®Œæˆå class X çš„ destrucor å°†ä¼šè¢«è°ƒç”¨ï¼Œå¯¹ä»˜é‚£ä¸ªä¸´æ—¶æ€§çš„ object ã€‚ ç¬¬äºŒç§ç¼–è¯‘å™¨å®ç°ä»¥ â€œæ‹·è´å»ºæ„â€ï¼ˆcopy constructï¼‰çš„æ–¹å¼æŠŠå®é™…å‚æ•°ç›´æ¥å»ºæ„åœ¨å…¶åº”è¯¥çš„ä½ç½®ä¸Šã€‚ è¿”å›å€¼çš„åˆå§‹åŒ–ï¼ˆReturn Value Initializationï¼‰cfront ä¸­çš„åŒé˜¶æ®µè½¬åŒ–123456X bar()&#123; X xx; // ... return xx;&#125; è½¬åŒ–ä¸º -&gt;12345678910void bar( X&amp; __result )&#123; X xx; xx.X::X(); // ... __result.X::X(xx); return;&#125; X xx = bar(); çš„æ“ä½œå°†è¢«è½¬åŒ–ä¸º X xx; bar( xx );ã€‚ bar().memfunc(); å¯èƒ½è¢«è½¬åŒ–ä¸º -&gt;12X __temp0;( bar( __temp0 ), __temp0 ).memfunc(); åœ¨ä½¿ç”¨è€…å±‚é¢åšä¼˜åŒ–ï¼ˆOptimization at the User Levelï¼‰123456X bar( const T &amp;y, const T &amp;z )&#123; X xx; // ... return xx;&#125; bar() å‡½æ•°ä¼šè¦æ±‚ xx è¢« â€œmemberwiseâ€ åœ°æ‹·è´åˆ°ç¼–è¯‘å™¨æ‰€äº§ç”Ÿçš„ __result ä¹‹ä¸­ã€‚Jonathan Shopiro æå‡ºå®šä¹‰å¦ä¸€ä¸ª constructorï¼Œå¯ä»¥ç›´æ¥è®¡ç®— xx çš„å€¼ã€‚ä¸Šé¢çš„ä»£ç è½¬åŒ–ä¸º -&gt;1234X bar( const T &amp;y, const T &amp;z)&#123; return X( y,z );&#125; ç¼–è¯‘å™¨ä¼šå°†å…¶è½¬åŒ–ä¸º -&gt;12345X bar( X &amp;__result, const T &amp;y, const T &amp;z)&#123; __result.X::X( y,z ); return;&#125; __result è¢«ç›´æ¥è®¡ç®—å‡ºæ¥ï¼Œè€Œä¸æ˜¯ç»ç”± copy constructor æ‹·è´è€Œå¾—ï¼ åœ¨ç¼–è¯‘å™¨å±‚é¢åšä¼˜åŒ–ï¼ˆOptimization at the Compiler Levelï¼‰123456X bar()&#123; X xx; // ... return xx;&#125; è½¬åŒ–ä¸º -&gt;123456void bar( X&amp; __result )&#123; __result.X::X(); // ... return;&#125; è¿™ç§ä¼˜åŒ–ï¼Œæœ‰æ—¶å€™è¢«ç§°ä¸º Named Return Value ( NRV ) ä¼˜åŒ–ã€‚NRV ä¼˜åŒ–å¦‚ä»Šè¢«è§†ä¸ºæ ‡å‡† C++ ç¼–è¯‘å™¨çš„ä¸€ä¸ªä¹‰ä¸å®¹è¾çš„ä¼˜åŒ–æ“ä½œã€‚ // æœ¬ä¹¦å¯¹ NRV çš„ä¼˜åŒ–æ€§èƒ½æµ‹è¯•æœ‰ä¸€äº›é”™è¯¯ï¼Œè¿™éƒ¨åˆ†ä¸åšæ‘˜å½•ã€‚ NRV ä¼˜åŒ–çš„äº‰è®®ï¼š ä¼˜åŒ–ç”±ç¼–è¯‘å™¨å®Œæˆï¼Œè€Œå®ƒæ˜¯å¦çœŸçš„è¢«å®Œæˆï¼Œå¹¶ä¸æ˜¯ååˆ†æ¸…æ¥šã€‚ ä¸€æ—¦å‡½æ•°å˜å¾—æ¯”è¾ƒå¤æ‚ï¼Œä¼˜åŒ–ä¹Ÿä¼šå˜å¾—æ¯”è¾ƒéš¾ä»¥å®æ–½ã€‚ ç¨‹åºå‘˜ä¸èƒ½å¤Ÿå®‰å…¨åœ°è§„åˆ’è‡ªå·±çš„ copy constructor çš„å‰¯ä½œç”¨ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œé¢å¯¹ â€œä»¥ä¸€ä¸ª class object ä½œä¸ºå¦ä¸€ä¸ª class object çš„åˆå€¼â€ çš„æƒ…å½¢ï¼Œè¯­è¨€å…è®¸ç¼–è¯‘å™¨æœ‰å¤§é‡çš„è‡ªç”±å‘æŒ¥ç©ºé—´ã€‚ Copy Constructorï¼šè¦è¿˜æ˜¯ä¸è¦ï¼Ÿclass çš„ default copy constructor è¢«è§†ä¸º trivial çš„æƒ…å†µä¸‹ä¸å£°æ˜ explicit copy constructor æ—¢å¿«é€Ÿåˆå®‰å…¨ã€‚åœ¨éœ€è¦ NRV ä¼˜åŒ–æ—¶ï¼Œå¯ä»¥è€ƒè™‘å®ç° copy constructorï¼Œå¯ä»¥ä½¿ç”¨ memcpy() æ¥æ‹·è´æé«˜æ•ˆç‡ã€‚ ä¸ç®¡ä½¿ç”¨ memcpy() è¿˜æ˜¯ memset()ï¼Œéƒ½åªæœ‰åœ¨â€œclasses ä¸å«ä»»ä½•ç”±ç¼–è¯‘å™¨äº§ç”Ÿçš„é‚£éƒ¨ members â€ æ—¶æ‰èƒ½æœ‰æ•ˆè¿è¡Œã€‚ æˆå‘˜ä»¬çš„åˆå§‹åŒ–é˜Ÿä¼ï¼ˆMember Initialization Listï¼‰å¿…é¡»ä½¿ç”¨ member initialization list çš„æƒ…å†µ å½“åˆå§‹åŒ–ä¸€ä¸ª reference member æ—¶ï¼› å½“åˆå§‹åŒ–ä¸€ä¸ª const member æ—¶ï¼› å½“è°ƒç”¨ä¸€ä¸ª base class çš„ constructorï¼Œè€Œå®ƒæ‹¥æœ‰ä¸€ç»„å‚æ•°æ—¶ï¼› å½“è°ƒç”¨ä¸€ä¸ª member class çš„ constructorï¼Œè€Œå®ƒæ‹¥æœ‰ä¸€ç»„å‚æ•°æ—¶ã€‚ ç¼–è¯‘å™¨ä¼šä¸€ä¸€æ“ä½œ initialization listï¼Œä»¥é€‚å½“é¡ºåºä¸­ constructor ä¹‹å†…å®‰æ’åˆå§‹åŒ–æ“ä½œï¼Œå¹¶ä¸”åœ¨ä»»ä½• explicit user code ä¹‹å‰ã€‚ åœ¨ initialization list ä¸­ä½¿ç”¨ member function ä½¿ç”¨æ˜¯åˆæ³•çš„ï¼Œè¿™æ˜¯å› ä¸ºå’Œæ­¤ object ç›¸å…³çš„ this æŒ‡é’ˆå·²ç»è¢«å»ºæ„å¦¥å½“ã€‚ å¦‚æœåœ¨ initialization list ä¸­è°ƒç”¨ derived class member function ï¼Œå…¶è¿”å›å€¼è¢«å½“åš base class constructor çš„ä¸€ä¸ªå‚æ•°ã€‚é‚£ä¸ä¸€å®šæ˜¯ä¸ªå¥½ä¸»æ„ï¼Œå› ä¸º derived class member function å¯èƒ½è¦ç”¨åˆ°çš„ derived class member åœ¨ base class çš„ constructor ä¹‹åæ‰è¢«åˆå§‹åŒ–ã€‚ å‚è€ƒèµ„æ–™ å…³äºNRVä¼˜åŒ–]]></content>
      <categories>
        <category>æ³› - ä¹¦æ‘˜</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>æ„é€ å‡½æ•°</tag>
        <tag>æ‹·è´æ„é€ å‡½æ•°</tag>
        <tag>ç¼ºçœæ„é€ å‡½æ•°</tag>
        <tag>ç¼–è¯‘å™¨ä¼˜åŒ–</tag>
        <tag>Virtual Class</tag>
        <tag>Virtual Base Class</tag>
        <tag>NRVä¼˜åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS ç¾éš¾]]></title>
    <url>%2F2018%2F07%2F21%2Fmac_os_disaster%2F</url>
    <content type="text"><![CDATA[macOS 10.14 beta3 ç¾éš¾æ€§çš„æ•°æ®ä¸¢å¤±äº‹æ•…ï¼Œåšå®¢æ•°æ®é™©äº›å…¨éƒ¨ä¸¢å¤±ï¼ 2018.7.21 å‡Œæ™¨ åšå®¢æ•°æ®åœ¨åºŸçº¸ç¯“é‡Œæ‰¾åˆ°äº†ï¼Œå†åŠ«åº¦äººã€‚ã€‚ã€‚è°ƒæ•´ä¸€ä¸‹ç»§ç»­ï½]]></content>
      <categories>
        <category>æ³› - çºªå¿µ</category>
      </categories>
      <tags>
        <tag>ç¾éš¾</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown æŒ‡å—]]></title>
    <url>%2F2018%2F07%2F15%2Fmarkdown_guide%2F</url>
    <content type="text"><![CDATA[Markdown æ˜¯ä»€ä¹ˆï¼Ÿ Markdown æ˜¯ä¸€ç§è½»é‡çº§æ ‡è®°è¯­è¨€ï¼Œåˆ›å§‹äººä¸ºçº¦ç¿°Â·æ ¼é²ä¼¯ï¼ˆè‹±è¯­ï¼šJohn Gruberï¼‰ã€‚å®ƒå…è®¸äººä»¬â€œä½¿ç”¨æ˜“è¯»æ˜“å†™çš„çº¯æ–‡æœ¬æ ¼å¼ç¼–å†™æ–‡æ¡£ï¼Œç„¶åè½¬æ¢æˆæœ‰æ•ˆçš„ XHTMLï¼ˆæˆ–è€… HTML ï¼‰æ–‡æ¡£â€ã€‚ æ³¨æ„ï¼Markdownæ˜¯æ ‡è®°è¯­è¨€ï¼Œè€Œä¸æ˜¯æ ·å¼è¡¨ã€‚å®ƒåªæ˜¯åœ¨æ ‡æ³¨è¯´æ˜æ–‡æœ¬ä¸­æ¯ä¸€å—æ˜¯ä»€ä¹ˆã€‚æ¯”å¦‚æ ‡é¢˜ã€å¼•ç”¨ã€ä»£ç ã€‚æœ€ç»ˆå®ƒæ˜¾ç¤ºçš„æ˜¯ä»€ä¹ˆæ ·å­çš„å–å†³äºä½ æµè§ˆå®ƒçš„å·¥å…·ï¼Œå¦‚æœè½¬æˆ HTML é‚£å°±ç”±æµè§ˆå™¨å†³å®šï¼Œä½ æƒ³æ”¹å˜å®ƒçš„æ ·å¼å°±éœ€è¦æ·»åŠ  CSSï¼ˆå±‚å æ ·å¼è¡¨ï¼‰ã€‚ æˆ‘ä¸ºä»€ä¹ˆå­¦ Markdownï¼Ÿä¸»è¦æ˜¯åšå®¢å†™ä½œéœ€è¦ç”¨åˆ°ï¼Œç”¨ Markdown å†™ä½œæœ€å¤§çš„å¥½å¤„æ˜¯è‡ªç”±ï¼Œä½ çš„æ–‡æœ¬æ˜¯ç‹¬ç«‹çš„ã€‚å¦‚æœä½ ä½¿ç”¨WordPress è‡ªå¸¦çš„ç¼–è¾‘å™¨å†™ä½œï¼Œå®ƒçš„å¯ç§»æ¤æ€§æ˜¯å¾ˆä½çš„ï¼Œå¯¼å‡º XML æ–‡ä»¶åè½¬æ¢æˆå…¶ä»–æ ¼å¼åå¾ˆå¤šåœ°æ–¹éƒ½éœ€è¦æ‰‹åŠ¨è°ƒæ•´ã€‚è¿˜æœ‰å°±æ˜¯é¡¹ç›®ä¸­ Readme æ–‡ä»¶ä¸€èˆ¬ç”¨ Markdown å†™ï¼Œä½ å†™ä½œæ—¶ä¸éœ€è¦ä»»ä½•é¼ æ ‡æ“ä½œã€‚ è¯­æ³•æ ‡é¢˜123456# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜### ä¸‰çº§æ ‡é¢˜#### å››çº§æ ‡é¢˜##### äº”çº§æ ‡é¢˜###### å…­çº§æ ‡é¢˜ æ–‡æœ¬åŸºç¡€æ ·å¼åŠ ç²—1**åŠ ç²—** æ•ˆæœï¼š**åŠ ç²—** æ–œä½“1**æ–œä½“** æ•ˆæœï¼š*æ–œä½“* æ–œä½“åŠ ç²—1***æ–œä½“åŠ ç²—*** æ•ˆæœï¼š***æ–œä½“åŠ ç²—*** åˆ é™¤1~~åˆ é™¤~~ æ•ˆæœï¼šåˆ é™¤ å¼•ç”¨123&gt; å¼•ç”¨çš„å†…å®¹&gt;&gt; å¼•ç”¨çš„å†…å®¹&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; å¼•ç”¨çš„å†…å®¹ æ•ˆæœï¼š å¼•ç”¨çš„å†…å®¹ å¼•ç”¨çš„å†…å®¹ å¼•ç”¨çš„å†…å®¹ å¯ä»¥å¤šçº§åµŒå¥—å¼•ç”¨ åˆ†å‰²çº¿1234-------******** æ•ˆæœï¼š è¶…é“¾æ¥1234[è¶…é“¾æ¥å](è¶…é“¾æ¥åœ°å€ "è¶…é“¾æ¥title")titleå¯ç¼ºçœ**æ•ˆæœï¼š**[Home](https//pazyx.xyz "pazyx") æ•ˆæœï¼šHome å›¾ç‰‡1234![å›¾ç‰‡alt](å›¾ç‰‡åœ°å€ ''å›¾ç‰‡title'')titleå¯ç¼ºçœ**æ•ˆæœï¼š**![logo](/markdown_basic/logo.png ''blogLogo'') æ•ˆæœï¼šå›¾ç‰‡åœ°å€å¯ä»¥æ˜¯ç›¸å¯¹åœ°å€ä¹Ÿå¯ä»¥æ˜¯è¶…é“¾æ¥ åˆ—è¡¨æ— åºåˆ—è¡¨123- åˆ—è¡¨å†…å®¹+ åˆ—è¡¨å†…å®¹* åˆ—è¡¨å†…å®¹ æ•ˆæœï¼š åˆ—è¡¨å†…å®¹ åˆ—è¡¨å†…å®¹ åˆ—è¡¨å†…å®¹ æœ‰åºåˆ—è¡¨1231.åˆ—è¡¨å†…å®¹2.åˆ—è¡¨å†…å®¹3.åˆ—è¡¨å†…å®¹ æ•ˆæœï¼š 1.åˆ—è¡¨å†…å®¹2.åˆ—è¡¨å†…å®¹3.åˆ—è¡¨å†…å®¹ åˆ—è¡¨åµŒå¥—1234- ä¸€çº§åˆ—è¡¨å†…å®¹ - äºŒçº§åˆ—è¡¨å†…å®¹ - ä¸‰çº§åˆ—è¡¨å†…å®¹ - å››çº§åˆ—è¡¨å†…å®¹ æ•ˆæœï¼š ä¸€çº§åˆ—è¡¨å†…å®¹ äºŒçº§åˆ—è¡¨å†…å®¹ ä¸‰çº§åˆ—è¡¨å†…å®¹ å››çº§åˆ—è¡¨å†…å®¹ ä¸¤çº§ä¹‹é—´å·®ä¸¤ä¸ªç©ºæ ¼å³å¯ è¡¨æ ¼1234|è¡¨å¤´|è¡¨å¤´|è¡¨å¤´|| - | :-: | :- ||å†…å®¹|å†…å®¹|å†…å®¹||å†…å®¹|å†…å®¹|å†…å®¹| æ•ˆæœï¼š è¡¨å¤´ è¡¨å¤´ è¡¨å¤´ å†…å®¹ å†…å®¹ å†…å®¹ å†…å®¹ å†…å®¹ å†…å®¹ é»˜è®¤ä¸ºå·¦å¯¹é½ï¼Œåœ¨ â€œ-â€ å³è¾¹åŠ ä¸Š â€œ:â€ ä¸ºå³å¯¹é½ï¼Œåœ¨ â€œ-â€ ä¸¤ä¾§åŒæ—¶åŠ ä¸Š â€œ:â€ ä¸ºå±…ä¸­å¯¹é½ã€‚ ä»£ç è¡Œå†…ä»£ç 1è¡Œå†… `code` è¡Œå†… æ•ˆæœï¼š è¡Œå†… code è¡Œå†… ä»£ç å—123456789\`\`\`cpp#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World." &lt;&lt; endl; return 0;&#125;\`\`\` æ•ˆæœï¼š 1234567#include &lt;iostream&gt;int main()&#123; std::cout &lt;&lt; "Hello World." &lt;&lt; endl; return 0;&#125; å‚è€ƒèµ„æ–™ markdownåŸºæœ¬è¯­æ³• Markdownæ’å…¥è¡¨æ ¼è¯­æ³• Markdownç»´åŸºç™¾ç§‘ Markdownä¸­æ–‡å®˜ç½‘]]></content>
      <categories>
        <category>æ³› - è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>æ ‡è®°è¯­è¨€</tag>
        <tag>å†™ä½œå·¥å…·</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ•°å­¦å»ºæ¨¡â€”â€”åŠ¨æ€è§„åˆ’]]></title>
    <url>%2F2018%2F07%2F14%2Fmathematical_modeling_dp%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°ä¹‹å‰åœ¨å­¦ç®—æ³•æ—¶æ¥è§¦è¿‡ä¸å°‘åŠ¨æ€è§„åˆ’çš„é¢˜ç›®ï¼Œä½†æœ€è¿‘å®è·µå‘¨åœ¨ä¸Šæ•°å­¦å»ºæ¨¡çš„è¯¾ï¼Œå‘ç°è‡ªå·±åœ¨åŠ¨æ€è§„åˆ’ç®—æ³•ä¸Šæ¬ ç¼ºå¾ˆå¤šã€‚æ­¥éª¤ä¸è§„èŒƒã€æ€è·¯ä¸æ¸…æ™°ã€æ•°å­¦æ¨å¯¼æ¬ ç¼ºï¼Œå¤§å¤šæ•°æ—¶å€™æˆ‘éƒ½æ˜¯é ç›´è§‰æ¨çŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„ã€‚è¿™ç¯‡æˆ‘å¸Œæœ›ä»æ•°å­¦å»ºæ¨¡çš„è§’åº¦é‡æ–°æ€»ç»“ä¸€ä¸‹åŠ¨æ€è§„åˆ’ï¼ˆç®—æ³•ä¸­çš„åŠ¨æ€è§„åˆ’ä¹Ÿä¼šç»§ç»­æ›´æ–°ï¼Œæœ€è¿‘å°†æ›´æ–°çŠ¶å‹DPï¼‰ã€‚ç®—æ³•ç«èµ›å’Œæ•°å­¦å»ºæ¨¡ç«èµ›ä¸­åŠ¨æ€è§„åˆ’ï¼Œåœ¨æ•°æ®å’Œæ–¹ç¨‹çš„è¡¨ç¤ºä¸Šæœ‰å¾ˆå¤§ä¸åŒã€‚ç®—æ³•ç«èµ›ä¸­ä¸€èˆ¬ä»¥æ•°ç»„å•å…ƒçš„å½¢å¼è¡¨ç¤ºä¸€ä¸ªçŠ¶æ€å¹¶ç”¨å…¶æ¨å¯¼çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå¹¶ä¸”ä¸å¯¹æŒ‡æ ‡å‡½æ•°ä¸æœ€ä¼˜å€¼å‡½æ•°çš„å•ç‹¬æ¨å¯¼ã€‚å…¶å½¢å¼æ›´æ¥è¿‘ä¼ªä»£ç ï¼Œæ–¹ä¾¿å°†æ¨¡å‹å¿«é€Ÿè½¬æ¢ä¸ºä»£ç ã€‚æ•°å­¦å»ºæ¨¡ç«èµ›ä¸­æ­¥éª¤ç›¸å½“ä¸¥è°¨å¾ˆå¤šï¼Œå„ä¸ªæ–¹ç¨‹ç›¸äº’ç‹¬ç«‹ï¼Œå„ä¸ªæ–¹ç¨‹ä¹Ÿæ›´æ³¨é‡æ•°å­¦çš„ä¸¥è°¨æ€§ã€‚ æ ‡å‡†æ­¥éª¤ é˜¶æ®µ çŠ¶æ€å˜é‡ï¼ˆæ— åæ•ˆæ€§ï¼‰ \(s_k\) å†³ç­–å˜é‡ \(x_k\) çŠ¶æ€è½¬ç§»æ–¹ç¨‹ \(s_{k+1} = T_k(s_k,x_k)\) æŒ‡æ ‡å‡½æ•° \(V_{k,n} = V_{k,n}(s_k,x_k,s_{k+1},â€¦,s_{n+1},k = 1,2,â€¦,n\) æœ€ä¼˜å€¼å‡½æ•° \[f_k(s_k) = \max_{\{x_k,â€¦,x_n\}} V_{k,n}\] è¾¹ç•Œæ¡ä»¶ ä¾‹é¢˜ä¸€ä¸ªç®€å•çš„å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œå…¶ç®—æ³•æˆ‘åœ¨åŠ¨æ€è§„åˆ’B2â€”â€”å®Œå…¨èƒŒåŒ…ç»™å‡ºã€‚ æœ‰ä¸€ä¸ªå®¹é‡ä¸º V çš„èƒŒåŒ…å’Œ N ç§ç‰©å“ã€‚æ¯ç§ç‰©å“çš„ä»·å€¼ä¸º \(W_k\) ä½“ç§¯ä¸º \(C_k\) ï¼Œæ¯ç§ç‰©å“æœ‰æ— é™ä»¶ï¼Œé—®æœ€å¤§èƒŒåŒ…ä»·å€¼ã€‚ é˜¶æ®µN ç§ç‰©å“æŒ‰ç¼–å·æ’åºï¼Œè§†ä¸º N ä¸ªé˜¶æ®µã€‚ çŠ¶æ€å˜é‡\(s_k\) ç¬¬ k é˜¶æ®µåˆå¯è£…è½½çš„è´¨é‡ å†³ç­–å˜é‡è£…å…¥ç¬¬kç§ç‰©å“çš„æ•°é‡ï¼š\(x_i\) çŠ¶æ€è½¬ç§»æ–¹ç¨‹\[s_{k+1} = s_k - C_kx_k\] æŒ‡æ ‡å‡½æ•°è£…å…¥çš„ç¬¬ k ç§ç‰©å“åˆ°ç¬¬ N ç§ç‰©å“æ€»ä»·å€¼ï¼š\(v_k\) æœ€ä¼˜å€¼å‡½æ•°\[f_k(s_k) = \max_{0â‰¤x_kâ‰¤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\ \ (k = 1â€¦n)\] è¾¹ç•Œæ¡ä»¶ \(s_1 = V\) \(f_{n+1}(s_{n+1}) = 0\) ä¸ç®—æ³•ç«èµ›ä¸­çš„åŠ¨æ€è§„åˆ’å¯¹æ¯” ç®—æ³•ç«èµ›\[F[i, v] = max \{ F[i âˆ’ 1, v âˆ’ kC_i] + kW_i \ \ 0 â‰¤ kC_i â‰¤ v \} \] æ•°å­¦å»ºæ¨¡ç«èµ›$$\begin{cases}f_k(s_k) = \max_{0â‰¤x_kâ‰¤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\} &amp;\text{(k = 1â€¦n)} \\f_{n+1}(s_{n+1}) = 0\end{cases}$$ è¿ç»­å‹åŠ¨æ€è§„åˆ’åœ¨å¤§å¤šæ•°ç®—æ³•ç«èµ›çš„é¢˜ç›®ä¸­ï¼Œå†³ç­–ç‚¹éƒ½æ˜¯ç¦»æ•£çš„ã€‚è€Œåœ¨æ•°å­¦å»ºæ¨¡ç«èµ›ä¸­å¯èƒ½å‡ºç°è¿ç»­å‹çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œè¿™ç§é¢˜ç›®å†™å‡ºå…·ä½“ç®—æ³•ç›¸å½“å›°éš¾ï¼Œå¤šå¤§éœ€è¦ç¬”ç®—ã€‚ ä¾‹é¢˜100 å°æŸç§æœºå™¨å¯åœ¨é«˜ä½ä¸¤ç§ä¸åŒçš„è´Ÿè·ä¸‹è¿›è¡Œç”Ÿäº§ï¼Œè®¾æœºå™¨åœ¨é«˜è´Ÿè·ä¸‹ç”Ÿäº§çš„äº§é‡å‡½æ•°ä¸º g = 9x ï¼Œå…¶ä¸­ x ä¸ºæŠ•å…¥ç”Ÿäº§çš„æœºå™¨æ•°é‡ï¼Œå­£åº¦å®Œå¥½ç‡ä¸º a = 0.65 ã€‚åœ¨ä½è´Ÿè·ä¸‹ç”Ÿäº§çš„äº§é‡å‡½æ•°ä¸º h = 4y ï¼Œå…¶ä¸­ y ä¸ºæŠ•å…¥ç”Ÿäº§çš„æœºå™¨æ•°é‡,å­£åº¦å®Œå¥½ç‡ä¸º b = 0.95 ã€‚ å»ºæ¨¡ æŠŠ4ä¸ªå­£åº¦çœ‹æˆæ˜¯4ä¸ªé˜¶æ®µï¼Œç”¨kè¡¨ç¤ºã€‚ çŠ¶æ€å˜é‡\(s_k\)ï¼šè¡¨ç¤ºç¬¬kå­£åº¦åˆæ‹¥æœ‰çš„å®Œå¥½æœºå™¨æ•°é‡ã€‚(\(s_1\) = 100) å†³ç­–å˜é‡\(x_k\)ï¼šè¡¨ç¤ºç¬¬kå­£åº¦åˆ†é…é«˜è´Ÿè·ä¸‹ç”Ÿäº§çš„æœºå™¨æ•°é‡ï¼Œäºæ˜¯\(s_k-x_k\)ä¸ºè¯¥å­£åº¦åˆ†é…åœ¨ä½è´Ÿè·ä¸‹ç”Ÿäº§çš„æœºå™¨æ•°é‡ã€‚\(s_k\),\(x_k\)ä¸ºè¿ç»­å˜é‡ï¼Œå…¶å°æ•°éƒ¨åˆ†è¡¨ç¤ºä¸€å°æœºå™¨æ­£å¸¸å·¥ä½œæ—¶é—´æ‰€å çš„æ¯”ä¾‹ã€‚å…è®¸å†³ç­–é›†åˆ:\(D_k(s_k) = \{ x_k \ \ |\ \ 0â‰¤x_kâ‰¤s_k \}\) çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\[s_{k+1} = ax_k + b( s_k - x_k ) = 0.65x_k + (s_k - x_k ) \ \ (k = 1,2,3,4) \] æŒ‡æ ‡å‡½æ•°ï¼š\(v_k\) è¡¨ç¤ºç¬¬ k å­£åº¦çš„äº§é‡ \(v_k = 9x_k + 4(s_k+x_k)\) æœ€ä¼˜å€¼å‡½æ•°ï¼š$$\begin{cases}f_k(s_k) = \max_{0â‰¤x_kâ‰¤s_k} \{ v_k + f_{k+1}(s_{k+1}) \} = \max_{0â‰¤x_kâ‰¤s_k} \{ 9x_k + 4(s_k-x_k) + f_{k+1}(s_{k+1}) \}\\f_5(s_5) = 0\end{cases}$$ è§£å½“ k = 4 æ—¶ $$\begin{align}f_4(s_4)&amp; = \max_{0â‰¤x_4â‰¤s_4} \{ 9x_4 + 4(s_4-x_4) + f_5(s_5) \} \\&amp; = \max_{0â‰¤x_4â‰¤s_4} \{ 9x_4 + 4(s_4-x_4) \} \\&amp; = \max_{0â‰¤x_4â‰¤s_4} \{ 5x_4 + 4s_4 \}\end{align}$$\[x^*_4 = s_4 ,f_4(s_4) = 9s_4\] å½“ k = 3 æ—¶ $$\begin{align}f_3(s_3)&amp; = \max_{0â‰¤x_3â‰¤s_3} \{ 9x_3 + 4(s_3-x_3) + f_4(s_4) \} \\&amp; = \max_{0â‰¤x_3â‰¤s_3} \{ 9x_3 + 4(s_3-x_3)+9[0.65x_3+0.95(s_3-x_3)] \} \\&amp; = \max_{0â‰¤x_3â‰¤s_3} \{ 2.3x_3 + 12.55s_3 \}\end{align}$$\[x^*_3 = s_3 ,f_3(s_3) = 14.85s_3\] å½“ k = 2 æ—¶ $$\begin{align}f_2(s_2)&amp; = \max_{0â‰¤x_2â‰¤s_2} \{ 9x_2 + 4(s_2-x_2) + f_3(s_3) \} \\&amp; = \max_{0â‰¤x_2â‰¤s_2} \{ 9x_2 + 4(s_2-x_2)+14.85[0.65x_2+0.95(s_2-x_2)] \} \\&amp; = \max_{0â‰¤x_2â‰¤s_2} \{ 0.545x_2 + 18.1075s_3 \}\end{align}$$\[x^*_2 = s_2 ,f_2(s_2) = 18.6525s_2\] å½“ k = 1 æ—¶ $$\begin{align}f_1(s_1)&amp; = \max_{0â‰¤x_1â‰¤s_1} \{ 9x_1 + 4(s_1-x_1) + f_2(s_2) \} \\&amp; = \max_{0â‰¤x_1â‰¤s_1} \{ 9x_1 + 4(s_1-x_1)+18.6525[0.65x_1+0.95(s_1-x_1)] \} \\&amp; = \max_{0â‰¤x_1â‰¤s_1} \{ -0.596x_1 + 21.72s_1 \}\end{align}$$ \[ x^*_1 = 0 , s_1 = 100 , y^*_1 = s_1 - x^*_1 = 100 , f_1(s_1) = 21.72s_1 = 2172 \] åæ¨ $$\begin{cases}s_2 &amp; = 0.65x_1 + 0.95(s_1 - x_1) = 95; x_2^* = s_2 = 95,y_2^* = 0 \\s_3 &amp; = 0.65x_2 + 0.95(s_2 - x_2) = 61.75,å–æ•´å¾—61,x_3^* = s_3 = 61,y_3^* = 0 \\s_4 &amp; = 0.65x_3 + 0.95(s_3 - x_3) = 39.65,å–æ•´å¾—39,x_4^* = s_4 = 39,y_4^* = 0\end{cases}$$]]></content>
      <categories>
        <category>æ•°å­¦</category>
      </categories>
      <tags>
        <tag>æ•°å­¦å»ºæ¨¡</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>è¿ç»­å‹åŠ¨æ€è§„åˆ’</tag>
        <tag>å®Œå…¨èƒŒåŒ…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3254 Corn Fieldsï¼ˆçŠ¶å‹DPï¼‰]]></title>
    <url>%2F2018%2F07%2F07%2Fpoj-3254-corn-fields%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ï¼šhttp://poj.org/problem?id=3254 Corn FieldsTime Limit: 2000MS Memory Limit: 65536K DescriptionFarmer John has purchased a lush new rectangular pasture composed of M by N (1 â‰¤ M â‰¤ 12; 1 â‰¤ N â‰¤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and canâ€™t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. InputLine 1: Two space-separated integers: M and NLines 2..M+1: Line i+1 describes row i of the pasture with N space-separated integers indicating whether a square is fertile (1 for fertile, 0 for infertile) OutputLine 1: One integer: the number of ways that FJ can choose the squares modulo 100,000,000. Sample Input1232 31 1 10 1 0 Sample Output19 HintNumber the squares as follows: 121 2 3 4 There are four ways to plant only on one squares (1, 2, 3, or 4), three ways to plant on two squares (13, 14, or 34), 1 way to plant on three squares (134), and one way to plant on no squares. 4+3+1+1=9. é¢˜è§£é¢˜ç›®å¤§æ„æœ‰ MÃ—N çš„ç‰ç±³åœ°ï¼Œä½†å…¶ä¸­æœ‰äº›æ˜¯ä¸è‚¥æ²ƒçš„ï¼Œä¸èƒ½ç§æ¤ã€‚ç”¨ 1 æ¥ä»£è¡¨è‚¥æ²ƒï¼Œ0 ä»£è¡¨ä¸è‚¥æ²ƒã€‚å¦å¤–å¥¶ç‰›ä¸å–œæ¬¢æŒ¨ç€åƒç‰ç±³ï¼Œä¹Ÿå°±æ˜¯è¯´è¦é—´éš”ç€ç§æ¤ï¼Œæ±‚æœ‰å‡ ç§ç§æ¤æ–¹å¼ï¼Œå¹¶å°†è®¡ç®—ç»“æœå¯¹ 100000000 å–æ¨¡ã€‚ è§£é¢˜æ€è·¯çŠ¶å‹DPå…¥é—¨é¢˜ç›®ã€‚é¢˜ç›®ä¸­è¦æ±‚ä¸èƒ½æŒ¨ç€ç§ï¼Œä¹Ÿå°±æ˜¯è¡Œå†…ä¸å…è®¸æœ‰ç›¸é‚»çš„åœ°ï¼Œè¡Œå†…æ¯”è¾ƒå¥½æ§åˆ¶ï¼Œè€Œè¡Œé—´æ€è€ƒä¸€ä¸‹å…¶å®åªéœ€è¦è€ƒè™‘ç›¸é‚»ä¸¤è¡Œçš„ç‰ç±³åœ°æ˜¯å¦æœ‰å†²çªã€‚ä½¿ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶æ•°è¡¨ç¤ºä¸€è¡Œçš„ç‰ç±³ç§æ¤æƒ…å†µçŠ¶æ€ï¼šæŸè¡Œçš„ç‰ç±³åœ°åˆ†å¸ƒæƒ…å†µ è½¬ç§»æ–¹ç¨‹ï¼šdp[i][j] = (dp[i][j] + dp[i - 1][k])%modç¬¬ i è¡Œç§æ¤æ–¹æ¡ˆä¸º j çš„ç§æ¤æ–¹å¼æ•°ä¸ºç­‰äºå…¶æœ¬èº«åŠ ä¸Šç¬¬ i-1 è¡Œç§æ¤æ–¹æ¡ˆä¸º k çš„ç§æ¤æ–¹å¼æ•°ï¼Œj å’Œ k æ–¹æ¡ˆä¸å†²çªï¼Œä¸” j å’Œ k æ–¹æ¡ˆæœ¬èº«è¡Œå†…ä¸å†²çªï¼Œä¸”ç§æ¤åœŸåœ°éƒ½ä¸ºè‚¥æ²ƒçš„åœŸåœ°ã€‚ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;const int MAX_N = 20;const int MAX_M = 20;int state[MAX_N + 1];int dp[MAX_N + 1][1 &lt;&lt; MAX_M];const int mod = 100000000;bool fit(int now, int flag)&#123; return (now | flag) == flag;&#125; //æ˜¯å¦éƒ½æ˜¯è‚¥æ²ƒçš„åœŸåœ°bool ok (int x) &#123; return (x &amp; (x / 2)) == 0;&#125; //åˆ¤æ–­è¡Œå†…æ˜¯å¦å†²çªbool not_intersect(int now,int prev)&#123; return (now &amp; prev) == 0;&#125; //åˆ¤æ–­ä¸¤è¡Œé—´æ˜¯å¦å†²çªint main() &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for( int i = 1; i &lt;= n; ++i)&#123; for( int j = 0; j &lt; m; ++j)&#123; int flag; cin &gt;&gt; flag; state[i] |= (1 &lt;&lt; j) * flag; &#125; &#125; for( int i = 0; i &lt;= 20; i++)&#123; if(ok(i)) dp[0][i] = 1; &#125; for( int i = 1; i &lt;= n; ++i)&#123; for( int j = 0; j &lt; (1 &lt;&lt; m); ++j)&#123; //æšä¸¾å½“å‰è¡Œ if(!ok(j) || !fit(j,state[i]))&#123; continue; &#125; for( int k = 0; k &lt; (1 &lt;&lt; m); ++k)&#123; //æšä¸¾ä¸‹ä¸€è¡Œ if(ok(k) &amp;&amp; fit(k,state[i-1]) &amp;&amp; not_intersect(j,k))&#123; dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod; &#125; &#125; &#125; &#125; int ans = 0; for( int i = 0; i &lt; (1 &lt;&lt; m); ++i)&#123; ans = (ans + dp[n][i]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>POJ</tag>
        <tag>çŠ¶å‹DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŒæœèŠ±å¤•æ‹¾ã€0x01 å¯ä¹]]></title>
    <url>%2F2018%2F07%2F04%2Fdiary_1%2F</url>
    <content type="text"><![CDATA[è€ƒè¯•å‘¨ç»ˆäºè¿‡å» æˆ‘æƒ³å†™ç‚¹ä»€ä¹ˆ æƒ³å†™ç‚¹è‡ªç”±çš„ä¸œè¥¿ å› ä¸ºè€ƒè¯•å‘¨å®åœ¨å¤ªè¿‡å‹æŠ‘ æˆ‘å·²ç»ä¸€ä¸ªæœˆæ²¡å»å¦é—¨æ”¾çºµäº† èº«ä½“å’Œå¿ƒç†éƒ½å—åˆ°äº†æŠ˜ç£¨åœ¨ä¸ºæ•°ä¸å¤šçš„å‡ é—¨éœ€è¦å¤§é‡å†™å­—çš„è€ƒè¯•ä¸­ æˆ‘å¤šæ¬¡æåˆ°è‡ªç”±å’Œå¯ä¹ å› ä¸ºæˆ‘æ¸´æœ›è‡ªç”± æˆ‘æƒ³åœ¨ä¸€å †ç­”æ¡ˆé‡Œå†™ç‚¹å¿ƒé‡Œè¯è‡ªç”±ä¸€ä¸‹äº‹å®ä¸Šæˆ‘ä»Šå¤©æƒ³å†™ä¸€å†™ å¯ä¹ æˆ‘æœ¬æƒ³å†™çš„æ­£ç»ä¸€ç‚¹ å› ä¸ºæˆ‘è¦å‘åˆ°æˆ‘çš„åšå®¢ä¸Š ä¸€ç›´ä»¥æ¥æˆ‘å¸Œæœ›æˆ‘çš„åšå®¢èƒ½å¤Ÿä¸¥è°¨è®¤çœŸ å†™å®Œä¸€ç¯‡æ£€æŸ¥å¤šæ¬¡ æœ‰ä»€ä¹ˆé”™è¯¯é©¬ä¸Šæ‰“å¼€ç”µè„‘ä¿®æ”¹æäº¤ä»Šå¤©æˆ‘è§‰å¾—æ—¢ç„¶è¦è°ˆè‡ªç”± æˆ‘å°±è‡ªç”±ä¸€ç‚¹å§ æˆ‘ä¹Ÿä¸æƒ³å†™ä»€ä¹ˆæ ‡ç‚¹ç¬¦å· éšä¾¿å†™å†™ åæ­£è¿™æ˜¯æˆ‘çš„åšå®¢ æˆ‘æ¥å†³å®šå®ƒçš„é£æ ¼ æˆ‘ä¹Ÿä¸åˆ†æ®µè½å’Œä»€ä¹ˆä¹±ä¸ƒå…«ç³Ÿçš„ markdown è¯­æ³•äº† å°±æŒ‰æˆ‘æƒ³çš„æ¥å§ å…¶ä¸­å¯èƒ½æœ‰é”™åˆ«å­—ï¼ˆæˆ‘å·²ç»çœ‹åˆ°äº†ï¼‰æˆ‘ä¹Ÿä¸æƒ³æ”¹äº† ä¸€åˆ‡éƒ½æ³¢æ™® è¯´åˆ°å¯ä¹ æˆ‘å·²ç»åœ¨å¾ˆå¤šåœ°æ–¹å†™è¿‡å¾ˆå¤šç¯‡äº† æˆ‘æƒ³åœ¨è¿™é‡Œæ€»ç»“ä¸€ä¸‹ åˆ«å›æ¥éƒ½æ²¡äº† 2017å¹´8æœˆ28æ—¥ 23:23 å»æ¥¼ä¸‹è¶…å¸‚ä¹°ç½è£…å¯ä¹ å‘ç°ç½è£…çš„é›ªç¢§å’ŒèŠ¬è¾¾éƒ½åœ¨å”¯ç‹¬å°‘äº†æˆ‘çš„å¯ä¹ æˆ‘å¾ˆéš¾è¿‡ ä¹‹åæˆ‘åœ¨ç½è£…çš„é›ªç¢§èŠ¬è¾¾é¢å‰çŠ¹è±«äº†ä¸€ä¼šå„¿ åˆçœ‹äº†çœ‹ç“¶è£…çš„å¯ä¹ æˆ‘æ„Ÿè§‰é‚£äº›éƒ½ä¸æ˜¯æˆ‘æƒ³è¦çš„ ä½ ä»¬çŸ¥é“æˆ‘æ˜¯ä¸ªè´µæ—éå¸¸è®²ç©¶ ç“¶è£…å’Œç½è£…çš„å¯ä¹å®Œå…¨æ˜¯ä¸¤ä¸ªå‘³å„¿ æˆ‘èµ°å‡ºé‚£ä¸ªè¶…å¸‚å†³å®šå»è¿œæ–¹é‚£ä¸ªè¶…å¸‚é—¯è¡ä¸€æ¬¡ ä¹‹åæˆ‘æ¢è®¿äº†ä¸¤å®¶è¶…å¸‚ç»“æœå®ƒä»¬åªæœ‰ç“¶è£…çš„ æœ€åæˆ‘é¼“è¶³å‹‡æ°”èµ°è¿›äº†ä¸€å®¶ç«é”…åº— é—®è€æ¿æœ‰ç½è£…çš„å¯ä¹å— ä»–çŠ¹è±«äº†ä¸€ä¸‹è¯´åªæœ‰â€¦â€¦ è¯´åˆ°è¿™å„¿æˆ‘å¿ƒå‡‰äº† å¿ƒæƒ³è‚¯å®šæ˜¯åªæœ‰ç“¶è£…çš„ äº¤è°ˆé—´è€æ¿å¸¦ç€æˆ‘èµ°åˆ°äº†å†°æŸœå‰ è€æ¿æ„£äº†ä¸€ä¸‹è¯´åªæœ‰ç»¿èŒ¶ ä»–ä¼°è®¡æ˜¯åœ¨æƒ³æ€ä¹ˆç“¶è£…çš„å¯ä¹ä¹Ÿæ²¡äº† çªç„¶ æˆ‘çœ‹åˆ°äº†å†°æŸœä¸Šå±‚çš„åŒ—å†°æ´‹ æˆ‘æƒ³å»ä»–å¦ˆçš„ç½è£…å¯ä¹ çœŸå¤Ÿéº»çƒ¦çš„ ç»™æˆ‘æ¥ç“¶åŒ—å†°æ´‹ æˆ‘å–ç€æˆ‘çš„åŒ—å†°æ´‹èµ°ä¸Šäº†å›å®¶çš„è·¯ æ„Ÿè§‰å‘³é“è¿˜å¯ä»¥ åªæ˜¯æˆ‘æ„Ÿè§‰ä»Šå¤©æˆ‘æœ‰ç‚¹å„¿ä¸è®²ç©¶äº† æ‰€ä»¥è¯´ä»Šå¤©æˆ‘è¿™ä¸ªè´µæ—è½é­„äº† æˆ‘ä»¬ç­‰å¾…æ˜å¤© æ˜å¤©æˆ‘å¸¦ä½ ä»¬çœ‹çœ‹æˆ‘çš„ç½è£…å¯ä¹ å¸¦ä½ ä»¬ä½“éªŒé‚£ç§è‡ªç”±çš„å‘³é“ 2017å¹´10æœˆ24æ—¥ 11:25 è‡ªç”±çš„é˜³å…‰ è‡ªç”±çš„å¯ä¹ å†›è®­è®©æˆ‘ä½“éªŒäº†è‡ªç”± å”¯ä¸€çš„é—æ†¾å°±æ˜¯ä¸ºä»€ä¹ˆä¸­åŒºé£Ÿå ‚çš„å…šå‘˜ç¤ºèŒƒå²—çª—å£çš„èœæœ€å¥½åƒ æˆ‘æƒ³å¦‚æœæˆ‘å†å¤šåƒå‡ å¤© ä¹Ÿè®¸æˆ‘ä¹Ÿèƒ½å‘ç°å®ƒä¸å¦‚äººæ„çš„ä¸€é¢ 2018å¹´3æœˆ16æ—¥ çŸ¥ä¹é—®é¢˜ï¼šä¸ºä»€ä¹ˆæœ‰äººæ„¿æ„ä¹° 2.5 å…ƒ 330ml çš„æ˜“æ‹‰ç½æ±½æ°´ï¼Œè€Œä¸ä¹° 3 å…ƒ 500ml çš„ç“¶è£…ï¼Ÿå›ç­” å¤ªå·§äº†ï¼Ÿæˆ‘å°±æ˜¯ä½ è¯´çš„é‚£ç§ä¹°ç½è£…å¯ä¹çš„äººï¼Œè€Œä¸”æˆ‘åªä¹°ç½è£…çš„ï¼Œæ›´å¤¸å¼ çš„æ˜¯æˆ‘ä»¬å­¦æ ¡ç½è£…å’Œç“¶è£…éƒ½æ˜¯3å—ã€‚æ¯æ¬¡æˆ‘ä¹°ç“¶è£…å¯ä¹éƒ½ä¼šå‰©ä¸€åŠä»¥ä¸Šåæ‰”æ‰ã€‚æˆ‘æƒ³è¯´å•Šï¼Œç½è£…çš„å’Œç“¶è£…çš„å¯ä¹å®ƒå®Œå…¨æ˜¯ä¸¤ä¸ªå‘³é“ã€‚ç½è£…çš„ä¸€èˆ¬ä½ éœ€è¦ä¸€æ¬¡å–å®Œï¼Œæ±½å¾ˆè¶³ã€‚è€Œç“¶è£…çš„ï¼Œæ‰“å¼€æ”¾åŠä¸ªå°æ—¶é‚£å£æ„Ÿæ˜¯å®Œå…¨ä¸èƒ½è¢«æ¥å—çš„ï¼Œåªèƒ½æ‰”æ‰ã€‚å¯¹äºæˆ‘æ¯å¤©åœ¨é£Ÿå ‚åƒé¥­çš„æƒ…å†µæ¥è¯´ï¼Œä¸€ç½ç½è£…çš„å¯ä¹åˆšåˆšå¥½ï¼Œè€Œç“¶è£…çš„500mlæ˜¾å¾—ç•¥å¤šï¼Œæˆ‘è¿˜éœ€è¦æŠŠå®ƒå¸¦å›å®¿èˆå¹¶ä¸”ä¸èƒ½é©¬ä¸Šæ‰”æ‰ï¼Œå› ä¸ºé‚£æ˜¾å¾—æˆ‘å¾ˆæµªè´¹ã€‚é‚£æ ·æˆ‘å°±éœ€è¦æŠŠå®ƒæ”¾ä¸Šä¸€æ®µæ—¶é—´ï¼ˆä¸€èˆ¬æ˜¯å‡ ä¸ªå°æ—¶ï¼‰å¾—åˆ°ä¸€ä¸ªè¶³ä»¥å®‰æ…°æˆ‘å†…å¿ƒçš„ç†ç”±ï¼ˆå®ƒçœŸçš„æ²¡æ±½äº†ï¼‰å†æŠŠå®ƒæ‰”æ‰ã€‚æˆ‘è¿™ä¸ªäººå¾ˆæ‡’ï¼Œä¸æƒ³é‚£ä¹ˆéº»çƒ¦ã€‚è¿˜æœ‰å°±æ˜¯åœ¨æˆ‘å–å®Œç½è£…å¯ä¹å¹¶æ‰”æ‰ç½çš„æ—¶å€™ï¼Œæˆ‘ä¼šæœ‰ä¸€ç§å¥‡å¦™çš„æ„Ÿè§‰ï¼Œå°±æ˜¯æˆ‘æ„Ÿè§‰åˆ°äº†è‡ªç”±ã€‚å› ä¸ºå®ƒä¸åƒç“¶è£…å¯ä¹æ¯æ¬¡å‰©ä¸‹çš„é‚£äº›ç»™æˆ‘ä¸€ç§æŸç¼šæ„Ÿï¼Œæˆ‘ä¸éœ€è¦ä¸ºå®ƒæ‰¾ä¸€ä¸ªç†ç”±å†æ‰”æ‰ã€‚è¦çŸ¥é“è‡ªç”±åœ¨æˆ‘ä»¬è¿™ä¸ªç¤¾ä¼šæ˜¯å¾ˆç¨€ç¼ºçš„ï¼Œæˆ‘å¾ˆäº«å—è¿™ç§æ„Ÿè§‰ï¼Œæˆ‘å¾ˆéœ€è¦ç½è£…å¯ä¹ã€‚æ³¨æ„ï¼æˆ‘ä¹‹å‰è¯´çš„ç“¶è£…éƒ½æ˜¯æŒ‡å¡‘æ–™ç“¶è£…çš„ï¼Œç»ç’ƒç“¶è£…çš„é‚£çœŸæ˜¯å¥½å‘³é“ï¼Œæˆ‘å¯ä»¥ä¿è¯å®ƒæ¯”å¡‘æ–™ç“¶è£…çš„å’Œç½è£…çš„éƒ½æ›´å¥½å–å¹¶ä¸”æ›´èƒ½è®©ä½ æ„Ÿè§‰åˆ°é‚£ç§è‡ªç”±çš„çŠ¶æ€ã€‚ 2018å¹´6æœˆ27æ—¥ æˆ‘æƒ³è¿™å¯ä¹å¯èƒ½ä¹Ÿæ²¡å¤šè‡ªç”± æˆ‘ä¸€æƒ³è±¡åˆ°å¯å£å¯ä¹ä¸­å›½å…¬å¸é‡Œçš„å…šæ”¯éƒ¨å¼€ä¼šçš„åœºé¢å°±æµ‘èº«éš¾å— è¿™å¯ä¹ä»£è¡¨ä¸äº†è‡ªç”± è€ƒå®Œè¯•æˆ‘ä¸€å®šå»ä¹°ä¸€ç“¶è¿›å£å¯ä¹æ„Ÿå—ä¸€ä¸‹è‡ªç”± æ­¤åˆ»è¯·è®©æˆ‘åœ¨å¤–é¢æºœè¾¾ä¸€ä¼šå„¿ è®©æˆ‘å¹ä¸€å¹å¤ªå¹³æ´‹çš„é£ ä»Šæ™šå°±æ˜¯æˆ‘çš„æ³¢æ™®æ—¶é—´ è¦è¯´æˆ‘æœ€å–œæ¬¢è¿™å…¶ä¸­çš„å“ªç¯‡ æˆ‘è§‰å¾—æ˜¯ç¬¬ä¸€ç¯‡ é‚£ç¯‡å†™çš„å¾ˆè‡ªç”± å¾ˆæœ‰ç°åœºæ„Ÿ ä¹Ÿå¾ˆæœ‰Andy Warholçš„é£æ ¼ è€Œä¸”å®ƒè±¡å¾ç€æˆ‘ä¼šå†™æ•…äº‹äº†å¥½äº† è¨€å½’æ­£ä¼  å¯ä¹ä¸ºä»€ä¹ˆèƒ½ä»£è¡¨è‡ªç”±ï¼Ÿ æˆ‘ä¹Ÿçº³é—· æˆ‘ä»”ç»†å›å¿†äº†ä¸€ä¸‹åº”è¯¥æ˜¯æˆ‘çç¼–çš„å§ é«˜ä¸­æˆ‘çœ‹äº†ä¸€äº›Andy Warholçš„ä¹¦ä»–è¯´å•Š Whatâ€™s great about this country is America started the tradition where the richest consumers buy essentially the same things as the poorest. You can be watching TV and see Coca-Cola, and you can know that the President drinks Coke, Liz Taylor drinks Coke, and just think, you can drink Coke, too. A Coke is a Coke and no amount of money can get you a better Coke than the one the bum on the corner is drinking. All the Cokes are the same and all the Cokes are good.ç¿»è¯‘ï¼šè¿™ä¸ªå›½å®¶çš„ä¼Ÿå¤§ä¹‹å¤„åœ¨äºï¼Œç¾å›½å¼€å§‹äº†è¿™æ ·çš„ä¼ ç»Ÿ:æœ€å¯Œæœ‰çš„æ¶ˆè´¹è€…ä¹°çš„ä¸œè¥¿åŸºæœ¬ä¸Šå’Œæœ€ç©·çš„äººä¹°çš„ä¸€æ ·ã€‚ä½ å¯ä»¥çœ‹ç”µè§†ï¼Œçœ‹å¯å£å¯ä¹ï¼Œä½ å¯ä»¥çŸ¥é“æ€»ç»Ÿå–å¯ä¹ï¼Œè‰å…¹Â·æ³°å‹’å–å¯ä¹ï¼Œæƒ³æƒ³ï¼Œä½ ä¹Ÿå¯ä»¥å–å¯ä¹ã€‚å¯å£å¯ä¹å°±æ˜¯å¯ä¹ï¼Œå†å¤šçš„é’±ä¹Ÿä¹°ä¸åˆ°æ¯”è¡—è§’çš„æµæµªæ±‰å–çš„æ›´å¥½çš„å¯ä¹ã€‚æ‰€æœ‰çš„å¯ä¹éƒ½æ˜¯ä¸€æ ·çš„ï¼Œæ‰€æœ‰çš„å¯ä¹éƒ½ä¸€æ ·å¥½ã€‚ ç°å® è¡¨é¢ ç¬é—´ æ„Ÿæ€§ å¿«ä¹ å¹³ç­‰ ç®€å• æœºæ¢° é‡å¤ å¤§ä¼— è¿™æ˜¯æ³¢æ™®ç²¾ç¥ å¯ä¹å…¨å äº† ä½†å°±æ˜¯æ²¡æœ‰è‡ªç”± æˆ‘ä¹Ÿä¸çŸ¥é“ è¿™ä¸ªç²¾ç¥æ˜¯è°æƒ³çš„ è¦æ˜¯æˆ‘å°±ç»™å®ƒåŠ ä¸Šè‡ªç”±å†™åˆ°è¿™å„¿æˆ‘å¤§æ¦‚æ˜ç™½äº† å¯ä¹ä»£è¡¨è‡ªç”±ä¹Ÿè®¸æ˜¯å› ä¸ºå¿«ä¹ æˆ‘åœ¨è‡ªç”±çš„æ—¶åˆ»æœ€å¿«ä¹ è€Œä¸”å–å¯ä¹ä¹Ÿè®¸è¿™ä¸–ä¸Šæœ€ç®€å•çš„è‡ªç”±æ–¹å¼äº† ç”µå½± è‚–ç”³å…‹çš„æ•‘èµ é‡Œä»–ä»¬åœ¨ç›‘ç‹±æˆ¿é¡¶å–ç€å•¤é…’ æ„Ÿå—åˆ°äº†éš¾å¾—çš„è‡ªç”±æˆ‘æƒ³æˆ‘å–å¯ä¹çš„æ—¶å€™è·Ÿä»–ä»¬ä¸€æ · æˆ‘æ„Ÿè§‰è¿™ä¸ªç¤¾ä¼šç®¡å¾—å®åœ¨æ˜¯å¤ªå¤šäº† å„ç§ç½‘ç»œç¤¾äº¤åª’ä½“ä¸èƒ½è¯„è®º ä¸èƒ½å‘ä¸èƒ½å‘çš„ å„ç§å¥½çš„ç½‘ç«™éƒ½éœ€è¦ç¿»å¢™ åª’ä½“éƒ½åœ¨å®£ä¼ æ­£èƒ½é‡ è¯´ç‚¹å…¶ä»–éƒ½ä¸è¡Œ æˆ‘è®¨åŒæ”¿æ²» ä½†ç°åœ¨å“ªéƒ½æ˜¯æ”¿æ²» å¯èƒ½æˆ‘å†™äº†è¿™ä¸€æ®µæˆ‘çš„ç½‘ç«™å°±è¢«å°ç¦äº† è€Œä¸”å®ƒä»¬æ˜¯åˆæ³•çš„ å› ä¸ºæˆ‘æ²¡å¤‡æ¡ˆ åæ­£å•Š æˆ‘æ˜¯æ‰˜ç®¡åœ¨å›½å¤–æœåŠ¡å™¨ä¸Šçš„ åŸŸåä¹Ÿæ˜¯åœ¨å›½å¤–ä¹°çš„ä¹Ÿæ²¡å¤‡æ¡ˆ æˆ‘ä¹Ÿæœ‰äº†è‡ªå·±çš„æ¢¯å­ å°äº†æˆ‘ä¹Ÿå¯ä»¥è‡ªå·±å†™è‡ªå·±çœ‹æˆ‘è¿˜æ˜¯å¸Œæœ›äººæ°‘ä»¬æ„è¯†åˆ°è‡ªå·±çš„è‡ªç”±åœ¨ä¸€ç‚¹ä¸€ç‚¹è¢«å‰¥å¤º å®é™…ä¸Šæˆ‘ä»¬ä¹Ÿæ— åŠ›åæŠ— å¦‚æœä¸èƒ½åƒå®‰è¿ªä¸€æ ·é€ƒå‡ºè‚–ç”³å…‹çš„è¯ è¿˜æ˜¯ä¸æˆ‘ä¸€èµ·å…±é¥®å¯ä¹å§]]></content>
      <categories>
        <category>æ³› - è®°</category>
      </categories>
      <tags>
        <tag>è®°</tag>
        <tag>å¯ä¹</tag>
        <tag>è‡ªç”±</tag>
        <tag>æ³¢æ™®</tag>
        <tag>Andy Warhol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€ã€ŠEffective C++ã€‹ è¯»ä¹¦ç¬”è®°ï¼ˆäºŒï¼‰]]></title>
    <url>%2F2018%2F07%2F03%2Feffective-cpp02%2F</url>
    <content type="text"><![CDATA[æ³¨æ„ï¼è¿™åªæ˜¯æˆ‘çš„è¯»ä¹¦ç¬”è®°ï¼Œå¸®åŠ©æˆ‘è®°å½•ã€‚å…¶ä¸­å¯èƒ½æœ‰ä¸€äº›ä¸ä¸¥è°¨çš„è§£é‡Šæˆ–æ²¡æœ‰åšå¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå¤§å®¶å­¦ä¹ è¿˜æ˜¯å»ºè®®ç›´æ¥çœ‹ä¹¦ï¼ˆè™½ç„¶ä¹¦ä¸­ä¹Ÿæœ‰ä¸ä¸¥è°¨çš„è§£é‡Šï¼‰ã€‚ æ„é€  / ææ„ / èµ‹å€¼è¿ç®—æ¡æ¬¾05ï¼šäº†è§£ C++ é»˜é»˜ç¼–å†™å¹¶è°ƒç”¨å“ªäº›å‡½æ•°ä¸€ä¸ª class å¦‚æœæ²¡æœ‰å£°æ˜ä»»ä½•æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šå¸®ä½ å£°æ˜ä»¥ä¸‹çš„å‡½æ•° default æ„é€ å‡½æ•° copy æ„é€ å‡½æ•° copy assignment æ“ä½œç¬¦ ææ„å‡½æ•°æ‰€æœ‰è¿™äº›ç¼–è¯‘å™¨ä¸ºä½ ç”Ÿæˆçš„å‡½æ•°éƒ½æ˜¯ public çš„ã€å¤§å¤šæ•°éƒ½æ˜¯ inline çš„ï¼ˆ Effective C++ å†™çš„æ˜¯éƒ½æ˜¯ inline ï¼‰ï¼Œä¸”åªåœ¨éœ€è¦æ—¶ç”Ÿæˆã€‚ å½“ä½ å£°æ˜äº†ä»»ä½•ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œç¼–è¯‘å™¨å°†ä¸å†ä¸ºä½ å£°æ˜ default æ„é€ å‡½æ•°ã€‚ å¯¹äºä¸¤ä¸ªè¦åšæ‹·è´çš„å‡½æ•°ï¼Œå®ƒä»¬å¯èƒ½æ˜¯ bitwise æˆ–è€… memberwiseã€‚å…·ä½“çš„ Effective C++ åªåšäº†ç®€ç•¥çš„è§£é‡Šã€‚æƒ³æ·±å…¥äº†è§£çš„å¯ä»¥çœ‹ã€Šæ·±åº¦æ¢ç´¢C++å¯¹è±¡æ¨¡å‹ã€‹ï¼Œä¹‹åæˆ‘ä¹Ÿä¼šå†™è¯»ä¹¦ç¬”è®°æˆ–ä¹¦æ‘˜ã€‚ å¦‚æœç±»ä¸­å­˜åœ¨ä¸å¯é‡æ–°èµ‹å€¼çš„æˆå‘˜å°†æŠ¥é”™ã€‚ æ¯”å¦‚ä¸‹é¢çš„ç±» 12345678template&lt;class T&gt;class NamedObject &#123;public: NamedObject(std::string&amp; name, const T&amp; value):nameValue(name),objectValue(value)&#123;&#125;private: std::string&amp; nameValue; const T objectValue;&#125;; å¼•ç”¨ç±»å‹å’Œ const ä¿®é¥°çš„æˆå‘˜ä¸å¯è¢«é‡æ–°èµ‹å€¼ï¼Œå¦‚æœå­˜åœ¨ä¸¤ä¸ª NamedObject&lt;int&gt; ç±»çš„å¯¹è±¡ a å’Œ b ï¼Œåš a = b å°†ç›´æ¥æŠ¥é”™ã€‚ç¼–è¯‘å™¨æ— æ³•ä¸ºå®ƒå£°æ˜æ‹·è´å‡½æ•°ã€‚å¦‚æœåŸºç±»çš„ copy assignment æ“ä½œç¬¦è¢«å£°æ˜ä¸º private ä¹Ÿæ˜¯ä¼šå¯¼è‡´ç¼–è¯‘å¤±è´¥ã€‚ æ¡æ¬¾06ï¼šè‹¥ä¸æƒ³ä½¿ç”¨ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„å‡½æ•°ï¼Œå°±è¯¥æ˜ç¡®æ‹’ç»å¯ä»¥å°†æ„é€ å‡½æ•°å£°æ˜ä¸º private ç¦æ­¢è°ƒç”¨ã€‚æ¯”å¦‚æœ‰äº›ç±»ä¸å¸Œæœ›è¢«æ‹·è´ï¼Œå¯ä»¥å°† copy æ„é€ å‡½æ•°å’Œ copy assignment æ“ä½œç¬¦å£°æ˜ä¸º private ã€‚12345678class Uncopyable&#123;protected: Uncopyable()&#123;&#125; ~Uncopyable()&#123;&#125;private: Uncopyable(const Uncopyable&amp;); Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;; ä¹Ÿå¯ä»¥è®©ä¸å¸Œæœ›è¢«æ‹·è´çš„ç±»ç›´æ¥ç»§æ‰¿ Uncopyable ç±»ã€‚Boost åº“ä¸­ä¹Ÿæä¾›äº†åä¸º noncopyable çš„class ä¿è¯è¢«ç»§æ‰¿çš„ç±»ä¸è¢«æ‹·è´ã€‚ æ¡æ¬¾07ï¼šä¸ºå¤šæ€åŸºç±»å£°æ˜ virtual ææ„å‡½æ•°åŸºç±»æ— è™šææ„å‡½æ•°ï¼Œä¼šå¯¼è‡´å‘ä¸Šé€ å‹åè¢«éƒ¨åˆ†é”€æ¯å¯¼è‡´å†…å­˜æ³„éœ²ã€‚ è°¨æ…ç»§æ‰¿ä¸å¸¦è™šææ„å‡½æ•°çš„ç±»ï¼Œå¦‚ï¼šstringã€STL åº“ä¸­çš„æ‰€æœ‰å®¹å™¨â€¦ ä¸æ˜¯æ‰€æœ‰çš„ç±»éƒ½éœ€è¦è™šææ„å‡½æ•°ï¼Œvptr å’Œ vtbl ä¼šå æœ‰å¤§é‡ç©ºé—´ï¼Œä¸”é™ä½äº†å¯ç§»æ¤æ€§ï¼ˆä¸å¯ä¼ ç»™å…¶ä»–è¯­è¨€ï¼‰ã€‚ è®¸å¤šäººçš„å¿ƒå¾—æ—¶ï¼šåªæœ‰å½“ class å†…å«è‡³å°‘ä¸€ä¸ª virtual å‡½æ•° æ‰ä¸ºå®ƒå£°æ˜ virtual ææ„å‡½æ•°ã€‚ æ¡æ¬¾08ï¼šåˆ«è®©å¼‚å¸¸é€ƒç¦»ææ„å‡½æ•°C++ ä¸èƒ½åŒæ—¶å¤„ç†å¤šä¸ªå¼‚å¸¸ï¼Œä¸»è¦åŸå› æ˜¯è¢«æŠ›å‡ºçš„å…ƒç´ çš„å†…å­˜ç©ºé—´æ˜¯åˆ†é…åœ¨æ ˆåŒºçš„ï¼ŒæŠ›å‡ºå¼‚å¸¸åä¼šè·³å‡ºé‚£ä¸€å±‚æ‹¬å·ï¼Œæ ˆåŒºåº”è¯¥è¢«æ¸…ç†ã€‚å¦‚æœä½ åœ¨å­˜åœ¨ä¸€ä¸ªå¼‚å¸¸çš„æƒ…å†µä¸‹å»å¤„ç†å¦ä¸€ä¸ªå¼‚å¸¸å¾ˆå¯èƒ½ä¼šè¦†ç›–æ‰ä¹‹å‰å¼‚å¸¸æŠ›å‡ºçš„å…ƒç´ ï¼Œå¯¼è‡´ç¨‹åºè¿‡æ—©ç»“æŸæˆ–å‡ºç°ä¸æ˜ç¡®è¡Œä¸ºã€‚å¦‚æœä½ çš„ç±»ä¸­ææ„ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œé‚£è¿™ä¸ªç±»çš„å®¹å™¨æˆ–æ•°ç»„åœ¨ææ„æ—¶å¾ˆå¯èƒ½é‡åˆ°å¤šä¸ªå¼‚å¸¸ï¼Œé€ æˆä¸¥é‡çš„åæœã€‚ æœ‰æ—¶æˆ‘ä»¬ç±»çš„ææ„å‡½æ•°å¿…é¡»æ‰§è¡Œä¸€ä¸ªå¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„è¡Œä¸ºæ—¶æ€ä¹ˆåŠï¼Ÿæ¯”å¦‚å…³é—­å„ç§è¿æ¥ã€‚ä¹¦ä¸­æä¾›äº†ä¸‰ç§æ–¹æ¡ˆ1234try&#123; A.close(); &#125;catch(...)&#123; std::abort();&#125; //è°ƒç”¨ abort ç»“æŸç¨‹åº 1234try&#123; A.close(); &#125;catch(...)&#123; //è®°ä¸‹è¿è½¬è®°å½•ï¼Œè®°ä¸‹å¯¹ close çš„è°ƒç”¨å¤±è´¥&#125; //åä¸‹å¼‚å¸¸ 123456789101112void close()&#123; db.close(); closed = true;&#125;//ææ„if(!closed)&#123; try&#123; db.close(); &#125; catch(...)&#123; //è®°ä¸‹è¿è½¬è®°å½•ï¼Œè®°ä¸‹å¯¹ close çš„è°ƒç”¨å¤±è´¥ &#125;&#125; ç¬¬ä¸‰ç§å°±æ˜¯ç›´æ¥å°† close å‡½æ•°å¼€æ”¾ç»™ä½¿ç”¨è€…ï¼Œè®©ä½¿ç”¨è€…åœ¨ææ„å‰è°ƒç”¨ã€‚ æ¡æ¬¾09ï¼šç»ä¸åœ¨æ„é€ å’Œææ„è¿‡ç¨‹ä¸­è°ƒç”¨ virtual å‡½æ•°åœ¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ä¸­è°ƒç”¨è™šæˆå‘˜å‡½æ•°ï¼Œå¯èƒ½å¾—ä¸åˆ°ä½ æƒ³è¦çš„ç»“æœï¼Œå®ƒå®é™…ä¸Šä¼šè°ƒç”¨åŸºç±»çš„é‚£ä¸ªå‡½æ•°ã€‚ è§£é‡Šæ„é€ è¿‡ç¨‹æ„é€ è¿‡ç¨‹è¿›å…¥åŸºç±»çš„æ„é€ å‡½æ•°æ—¶ï¼Œæ´¾ç”Ÿç±»çš„æˆå‘˜è¿˜æ²¡è¢«åˆå§‹åŒ–ï¼Œå¦‚æœè°ƒç”¨æ´¾ç”Ÿç±»çš„è™šå‡½æ•°å¯èƒ½ä¼šç”¨åˆ°æ´¾ç”Ÿç±»éƒ¨åˆ†çš„æˆå‘˜ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å°†æ„é€ è¿‡ç¨‹ä¸­çš„å¯¹è±¡å½“åš å½“å‰è¿›å…¥çš„æ„é€ å‡½æ•°æ‰€å±çš„ç±»çš„ä¸€ä¸ªå¯¹è±¡ï¼Œå½“ç„¶åªèƒ½è°ƒç”¨ä¸å½“å‰æ„é€ å‡½æ•°åŒå±ä¸€ä¸ªç±»çš„å‡½æ•°äº†ã€‚ ææ„è¿‡ç¨‹è¿›å…¥ææ„å‡½æ•°ï¼Œå…ˆé”€æ¯æ‰æ´¾ç”Ÿç±»çš„æˆå‘˜ï¼Œåœ¨åˆšè¿›å…¥ææ„å‡½æ•°æ—¶è¿™ä¸ªå¯¹è±¡å·²ç»ä¸æ˜¯å®Œæ•´çš„ä¸€ä¸ªæ´¾ç”Ÿç±»çš„å¯¹è±¡äº†ï¼Œç¼–è¯‘å™¨åªèƒ½æŠŠå®ƒå½“åšå®ƒçš„åŸºç±»çš„ä¸€ä¸ªå¯¹è±¡æ¥çœ‹å¾…ã€‚ åœ¨æ„é€ å’Œææ„æœŸé—´ä¸è¦è°ƒç”¨ virtual å‡½æ•°ï¼Œå› ä¸ºè¿™ä¸ªç±»è°ƒç”¨ä»ä¸ä¸‹é™è‡³ drived class (æ¯”èµ·å½“å‰æ‰§è¡Œæ„é€ å‡½æ•°å’Œææ„å‡½æ•°çš„é‚£å±‚)ã€‚ æ¡æ¬¾10ï¼šä»¤ operator= è¿”å›ä¸€ä¸ª reference to *thisè¿”å› *this çš„å¼•ç”¨ï¼Œå¯ä»¥è®©ä½ çš„ç±»çš„å¯¹è±¡å®ç°è¿é”èµ‹å€¼ã€‚å¦‚ï¼šx = y = z = 15; æ¡æ¬¾11ï¼šåœ¨ operator= ä¸­å¤„ç†â€œè‡ªæˆ‘èµ‹å€¼â€å¦‚æœç±»ä¸­å­˜åœ¨ä¸€ä¸ªæŒ‡å‘å †ä¸­å…ƒç´ çš„æˆå‘˜ï¼Œé‚£å°±è¦æ³¨æ„èµ‹å€¼æ—¶çš„è‡ªæˆ‘èµ‹å€¼ã€‚123456789101112class A&#123;public: string *s; A():s(new string())&#123;&#125; A&amp; operator= (const A rhs) &#123; delete s; s = new string(*rhs.s); return *this; &#125;&#125;; å¦‚æœ this å’Œ &amp;rhs ç›¸ç­‰å°±å°´å°¬äº†ï¼Œå®ƒä¼šå…ˆ delete è‡ªå·±çš„ s ï¼Œå®é™…ä¸Š *this å’Œ rhs é‡Œçš„ s æŒ‡å‘çš„ string å¯¹è±¡éƒ½è¢«é”€æ¯äº†ã€‚æ•°æ®ä¸¢å¤±è€Œå»ä¹‹åä¹Ÿæ²¡åŠæ³•ä½¿ç”¨æˆå‘˜ s äº†ã€‚ ç›¸å¯¹å®‰å…¨çš„ç‰ˆæœ¬æ˜¯1234567891011121314class A&#123;public: string *s; A():s(new string())&#123;&#125; A&amp; operator= (const A&amp; rhs) &#123; if(this == &amp;rhs) return *this; delete s; s = new string(*rhs.s); return *this; &#125;&#125;; åŠ å…¥è®¤åŒæµ‹è¯•ï¼Œä¿è¯äº† â€œè‡ªæˆ‘èµ‹å€¼â€ çš„å®‰å…¨æ€§ï¼Œä½†è¿˜ä¸å…·å¤‡ â€œå¼‚å¸¸å®‰å…¨æ€§â€ã€‚å¦‚æœåœ¨ s = new string(*rhs.s); è¿™ä¸€æ­¥å¯¼è‡´å¼‚å¸¸ï¼Œé‚£ s å°†æŒ‡å‘ä¸€å—å·²è¢«åˆ é™¤çš„ string ã€‚12345678A&amp; operator= (const A&amp; rhs)&#123; string* pOrig = pb; s = new string(*rhs.s); delete pOrig; return *this;&#125; è¿™æ ·å³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œèµ‹å€¼å¤±è´¥ä¹Ÿä¸ä¼šé€ æˆå…¶ä»–å‰¯ä½œç”¨ï¼Œå¯ä»¥å°† s ä¿æŒåŸçŠ¶ã€‚ copy and swap æŠ€æœ¯123456789void swap(A&amp; rhs); //äº¤æ¢*this å’Œ rhs çš„æ•°æ® è§æ¡æ¬¾29A&amp; operator= (const A&amp; rhs)&#123; A temp(rhs); swap(temp); return *this;&#125; by value ä¼ å€¼æ–¹å¼çš„ copy and swap æŠ€æœ¯12345678void swap(A&amp; rhs); //äº¤æ¢*this å’Œ rhs çš„æ•°æ® è§æ¡æ¬¾29A&amp; operator= (const A rhs)&#123; swap(rhs); return *this;&#125; æ¡æ¬¾12ï¼šå¤åˆ¶å¯¹è±¡æ—¶å‹¿å¿˜å…¶æ¯ä¸ªæˆåˆ†12345678910111213141516171819202122232425class A&#123;private: int a;public: A()&#123;&#125; A(A &amp;rhs):a(rhs.a)&#123;&#125; A&amp; operator= (A &amp;rhs)&#123; a = rhs.a; return *this; &#125; &#125;;class B : public A&#123;private: int b;public: B()&#123;&#125; B(B &amp;rhs):b(rhs.b)&#123;&#125; B&amp; operator= (B &amp;rhs)&#123; b = rhs.b; return *this; &#125; &#125;; å°å¿ƒè¿™æ ·çš„ä»£ç ï¼ŒB çš„ä¸¤ä¸ª Copying å‡½æ•°ï¼Œéƒ½æ²¡æœ‰æ‹·è´åŸºç±»çš„æ•°æ®( int a )ã€‚ Copying å‡½æ•°åº”è¯¥ç¡®ä¿èµ‹å€¼â€œå¯¹è±¡å†…çš„æ‰€æœ‰æˆå‘˜å˜é‡â€ åŠ â€œæ‰€æœ‰ base class æˆåˆ†â€ã€‚ 12345678910111213class B : public A&#123;private: int b;public: B()&#123;&#125; B(B &amp;rhs):b(rhs.b),A(rhs)&#123;&#125; // + ! B&amp; operator= (B &amp;rhs)&#123; A::operator=(rhs); // + ! b = rhs.b; return *this; &#125; &#125;; ä¸¤ä¸ª Copying å‡½æ•°ä¸€èˆ¬æœ‰ç›¸è¿‘çš„ä»£ç ï¼Œä½†ä¸è¦åœ¨ä¸€ä¸ª Copying å‡½æ•°å†…è°ƒç”¨å¦ä¸€ä¸ª Copying å‡½æ•°ã€‚ åº”è¯¥å°†å…±åŒæœºèƒ½æ”¾è¿›ç¬¬ä¸‰ä¸ªå‡½æ•°ä¸­ï¼Œå¹¶ç”±ä¸¤ä¸ª Copying å‡½æ•°å…±åŒè°ƒç”¨ã€‚]]></content>
      <categories>
        <category>æ³› - ç¬”è®°</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>æ„é€ å‡½æ•°</tag>
        <tag>è¯»ä¹¦</tag>
        <tag>ç¬”è®°</tag>
        <tag>å¼‚å¸¸</tag>
        <tag>è¿ç®—ç¬¦é‡è½½</tag>
        <tag>Effective C++</tag>
        <tag>æ‹·è´æ„é€ å‡½æ•°</tag>
        <tag>ç¼ºçœæ„é€ å‡½æ•°</tag>
        <tag>virtual å‡½æ•°</tag>
        <tag>è‡ªæˆ‘èµ‹å€¼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ä¸ C++ ç»†èŠ‚å·®å¼‚ ï¼ˆä¸€ï¼‰]]></title>
    <url>%2F2018%2F07%2F01%2Fcpptojava%2F</url>
    <content type="text"><![CDATA[æ³¨é‡Šç›¸æ¯” C++ï¼ŒJavaæä¾›äº†ä¸‰ç§æ³¨é‡Šæ–¹å¼åˆ†åˆ«ä¸º // å•è¡Œæ³¨é‡Š /* ... */ å¤šè¡Œæ³¨é‡Š /** ... */ æ–‡æ¡£æ³¨é‡Šå‰ä¸¤ç§ä¸ C++ ç›¸åŒï¼Œæœ€åä¸€ç§å¯ä»¥è‡ªåŠ¨å°†æ³¨é‡Šå†…å®¹ç”Ÿæˆæ–‡æ¡£ã€‚ä¾›ä½¿ç”¨è€…ç›´æ¥æŸ¥çœ‹ã€‚ åŸºæœ¬æ•°æ®ç±»å‹æ•´æ•° Java å­˜å‚¨ç©ºé—´ C++ å­˜å‚¨ç©ºé—´ int 4 å­—èŠ‚ int è‡³å°‘ 4 å­—èŠ‚ï¼Œä¸”å¤§äºç­‰äº short short 2 å­—èŠ‚ short è‡³å°‘ 2 å­—èŠ‚ long 8 å­—èŠ‚ long è‡³å°‘ 4 å­—èŠ‚ï¼Œä¸”å¤§äºç­‰äº int byte 1 å­—èŠ‚ long long è‡³å°‘ 8 å­—èŠ‚ï¼Œä¸”å¤§äºç­‰äº long Java æä¾›äº† 4 ç§æ•´æ•°ç±»å‹ï¼Œä¸ C++ ç›¸æ¯” Java çš„è§„èŒƒæ›´ä¸ºä¸¥æ ¼ã€‚å¯ä»¥çœ‹å‡º C++ æ›´åœ¨ä¹æ•ˆç‡ï¼Œè€Œ Java æ›´åœ¨ä¹å¯ç§»æ¤æ€§ã€‚ åå…­è¿›åˆ¶æ•°å’Œå…«è¿›åˆ¶æ•°ä¸¤ç§è¯­è¨€å‡å¯ä»¥ä½¿ç”¨ 0x å’Œ 0 ä¸ºå‰ç¼€æ¥è¡¨ç¤ºï¼Œè€Œ Java è¿˜æä¾›äº†å‰ç¼€ 0b æ¥è¡¨ç¤ºäºŒè¿›åˆ¶æ•°ã€‚ æµ®ç‚¹æ•° Java å­˜å‚¨ç©ºé—´ C++ å­˜å‚¨ç©ºé—´ float 4 å­—èŠ‚ float 4 å­—èŠ‚ double 8 å­—èŠ‚ double 8 å­—èŠ‚ long double ( Intel ) 16 å­—èŠ‚ ä¸¤è€…éƒ½éµå¾ª IEEE-754 æ ‡å‡† C++ ç›´æ¥æä¾›äº† 80 ä½çš„æ‰©å±•ç²¾åº¦æµ®ç‚¹æ•°ï¼Œè€Œ Java æ²¡æœ‰æä¾›ã€‚Java æ²¡æœ‰æä¾›çš„åŸå› è¿˜æ˜¯å¯¹å¯ç§»æ¤æ€§çš„è€ƒè™‘ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯å¦‚æœ JVM è¿è¡Œåœ¨ Intel çš„å¤„ç†å™¨ä¸Šæ—¶ï¼Œæµ®ç‚¹æ•°çš„ä¸­é—´è¿ç®—ç»“æœé»˜è®¤æ˜¯é‡‡ç”¨æ‰©å±•ç²¾åº¦å­˜å‚¨çš„ã€‚è¿™æ˜¯å› ä¸ºæˆªæ–­ä¼šä½¿æ•ˆç‡å¤§å¹…é™ä½ï¼Œä½† Java ä¹Ÿæä¾›äº†æˆªæ–­çš„å¯èƒ½æ€§ï¼Œä½¿ç”¨ strictfp å…³é”®å­—æ ‡è®°çš„æ–¹æ³•ï¼ˆå‡½æ•°ï¼‰å¿…é¡»ä¸¥æ ¼çš„å¯¹ä¸­é—´ç»“æœæˆªæ–­ï¼Œä¿è¯åœ¨ä»»ä½•å¤„ç†å™¨ç¯å¢ƒçš„ç»“æœçš„ä¸€è‡´æ€§ã€‚ä¾‹ï¼špublic static strictfp void main(String[] args) åˆå§‹åŒ–Java ç¦æ­¢ä½¿ç”¨æœªåˆå§‹åŒ–çš„æœ¬åœ°å˜é‡ï¼ŒC++ å¯ä»¥ã€‚ å¸¸é‡ä¿®é¥°ç¬¦ä¸åŒï¼ŒJava ä½¿ç”¨ final ä¿®é¥°å¸¸é‡ï¼Œä½† const ä¹Ÿæ˜¯ Java çš„ä¿ç•™å­—ã€‚ Java C++ final type const type å¸¸é‡å¯ä»¥ä¸åœ¨å®šä¹‰å‡ºåˆå§‹åŒ–ï¼Œä½†å¿…é¡»ä¿è¯åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨å‰è¢«åˆå§‹åŒ–ï¼Œä¸”åªåˆå§‹åŒ–ä¸€æ¬¡ã€‚ æ•°ç»„Java æ²¡æœ‰ C++ ä¸­åœ¨æ ˆåŒºåˆ†é…åˆ°æ•°ç»„ï¼Œä½ ä¸å¯ä»¥å†™å‡ºè¿™æ ·çš„ä»£ç 1int a[10]; æ‰€æœ‰çš„æ•°ç»„ï¼Œéƒ½éœ€è¦ä½¿ç”¨ new åœ¨å †ä¸Šåˆ†é…ç©ºé—´ã€‚ Java æä¾›äº†ä¸¤ç§å®šä¹‰æ•°ç»„çš„æ–¹å¼12int[] a = new int[size];int a[] = new int[size]; å¦‚æœä½ æ²¡æœ‰åˆå§‹åŒ–æ•°ç»„ï¼ŒJava ä¼šå¸®ä½ åšæ•°ç»„çš„åˆå§‹åŒ–ã€‚æ•°å­—æ•°ç»„å°†æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–ä¸º 0 ï¼Œboolean æ•°ç»„åˆå§‹åŒ–ä¸º falseï¼Œå¯¹è±¡æ•°ç»„åˆå§‹åŒ–ä¸º null ã€‚ Java ä¸­ []è¿ç®—ç¬¦è¢«å®šä¹‰ä¸ºæ£€æŸ¥æ•°ç»„è¾¹ç•Œï¼Œè€Œä¸” Java æ²¡æœ‰æŒ‡é’ˆè¿ç®—ï¼Œä¸å¯ä»¥é€šè¿‡ a + 1 å¾—åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚ å‘½åè§„åˆ™ Java C++ ä¸€ä¸ªä»¥å­—æ¯å¼€å¤´çš„ç”±å­—æ¯æˆ–æ•°å­—ç»„æˆçš„åºåˆ—ï¼Œå­—æ¯åŒ…æ‹¬{â€˜Aâ€™ ~ â€˜Zâ€™ã€â€™aâ€™ ~ â€˜zâ€™ã€â€™_â€™ã€â€™$â€™ æˆ–åœ¨æŸç§è¯­è¨€ä¸­ä»£è¡¨å­—æ¯çš„ä»»ä½• Unicode å­—ç¬¦ }ã€‚ ä¸€ä¸ªç”±æ•°å­—ï¼Œä¸‹åˆ’çº¿ï¼Œå°å†™å’Œå¤§å†™æ‹‰ä¸å­—æ¯ï¼Œå’Œå¤§å¤šæ•° Unicode å­—ç¬¦ç»„æˆçš„ä»»æ„é•¿åº¦çš„åºåˆ—ã€‚æœ‰æ•ˆçš„æ ‡è¯†ç¬¦å¿…é¡»ä»¥ä¸€ä¸ªéæ•°å­—å­—ç¬¦ï¼ˆæ‹‰ä¸è¯­å­—æ¯ï¼Œä¸‹åˆ’çº¿æˆ– Unicode éæ•°å­—å­—ç¬¦ï¼‰å¼€å¤´ã€‚ æ³¨ï¼šJava ä¸­åœ¨æŸç§è¯­è¨€ä¸­ä»£è¡¨å­—æ¯çš„ä»»ä½• Unicode å­—ç¬¦ï¼Œæ¯”å¦‚å¾·å›½ç”¨æˆ·å¯ä»¥ç”¨ Ã¤ ã€‚å¯ä»¥ä½¿ç”¨ Character ç±»çš„ isJavaIdentifierStart å’Œ isJavaIdentifierPart æ–¹æ³•æ£€æµ‹ã€‚ C++ ä¸­å¤§å¤šæ•° Unicode å­—ç¬¦æ˜¯æŒ‡é™¤ä¸‹è¡¨ä¸­çš„å­—ç¬¦ä»¥å¤–çš„ Unicode å­—ç¬¦ã€‚ ä»£ç ç‚¹ è¯´æ˜ U+0300 - U+036F ç»„åˆç”¨æŠ‘éŸ³ç¬¦ - ç»„åˆç”¨æ‹‰ä¸æ–‡å°å†™å­—æ¯ X U+1DC0 - U+1DFF ç»„åˆç”¨å¸¦ç‚¹æŠ‘éŸ³ç¬¦ - ç»„åˆç”¨ä¸‹å³ç®­å¤´å°–å’Œå‘ä¸‹ç®­å¤´å°– U+20D0 - U+20FF ç»„åˆç”¨ä¸Šå·¦é±¼å‰ - ç»„åˆç”¨ä¸Šæ˜Ÿå· U+FE20 - U+FE2F ç»„åˆç”¨è¿å­—å·¦åŠ - ç»„åˆç”¨è¥¿é‡Œå°”æ–‡ Titlo å³åŠ é‡åé—®é¢˜åœ¨ C++ ä¸­ä½ å¯ä»¥å†™å‡ºè¿™æ ·çš„ä»£ç 12345int a;&#123; int a;&#125; è¿™æ ·è¿›å…¥å¤§æ‹¬å·åï¼Œå¤–å±‚çš„æ•´æ•° a å°±è¢«éšè—äº†ï¼Œçœ‹ä¸åˆ°äº†æ— æ³•è®¿é—®äº†ï¼Œå‡ºå¤§æ‹¬å·å°±å¯ä»¥ç»§ç»­è®¿é—®å¤–å±‚çš„æ•´æ•° a äº†ã€‚ è€Œåœ¨ Java ä¸­ç¼–è¯‘å™¨æ˜¯ä¸å…è®¸ä½ å†™å‡ºè¿™æ ·çš„ä»£ç çš„ã€‚Java å’Œ C++ å¤§ä½“ä¸Šç›¸åŒï¼Œæœ¬åœ°å˜é‡çš„ç”Ÿå­˜æœŸæ˜¯ç”±å…¶æ‰€åœ¨çš„å¤§æ‹¬å·å†³å®šçš„ã€‚å®ƒä»¬ä¸¤è€…çš„ä¸åŒä¹‹å¤„åœ¨äº Java æ˜¯å®Œå…¨ä¸å…è®¸åœ¨ä¸€ä¸ªå˜é‡çš„ç”Ÿå­˜æœŸå†…å‡ºç°å¦ä¸€ä¸ªé‡åçš„å˜é‡ï¼Œè€Œ C++ å…è®¸åœ¨å†…å±‚å®šä¹‰æ–°çš„é‡åå˜é‡éšè—å¤–å±‚å˜é‡ã€‚ ä¾‹ï¼š12int a;int a; è¿™æ ·çš„ä»£ç åœ¨ä¸¤ç§è¯­è¨€ä¸­éƒ½æ˜¯é”™è¯¯çš„ã€‚ 12345&#123; int a;&#125;int a; è¿™æ ·çš„ä»£ç åœ¨ä¸¤ç§è¯­è¨€ä¸­éƒ½æ˜¯æ­£ç¡®çš„ã€‚ äºŒè€…å”¯ä¸€çš„å·®åˆ«å°±æ˜¯æˆ‘åœ¨æœ€å¼€å§‹çš„é‚£ä¸ªä¾‹å­ï¼ŒJava åœ¨å¤–å±‚ a çš„ç”Ÿå­˜æœŸè¿˜æ²¡ç»“æŸå‰ä¸å¯ä»¥å®šä¹‰æ–°çš„é‡åå˜é‡ï¼Œè€Œ C++ å¯ä»¥ã€‚ String ä¸ stringString å’Œ string åˆ†åˆ«ä¸º Java å’Œ C++ åº“é‡Œçš„å­—ç¬¦ä¸²ï¼Œè™½ç„¶åªæ˜¯å·®ä¸€ä¸ªå­—æ¯å¤§å°å†™ï¼Œå®é™…ä¸Šå®ƒä»¬æœ‰ç€å·¨å¤§çš„å·®å¼‚ã€‚string æ›´åƒæ˜¯ char çš„æ•°ç»„ï¼Œå®ƒçš„æ¯ä¸ªå•ä½éƒ½æ˜¯å¯ä»¥ç›´æ¥è¿™æ · s[index] è®¿é—®çš„ï¼Œè€Œä¸”å¯ä»¥è¿›è¡Œä¿®æ”¹ã€‚String å°±æ²¡æœ‰é‚£ä¹ˆæ–¹ä¾¿äº†ï¼ŒJava æ²¡æœ‰è¿ç®—ç¬¦é‡è½½åªèƒ½é€šè¿‡ s.charAt( index ) æ¥è½¬æ¢æˆ char å†è¯»ã€‚æ³¨æ„ï¼String æ²¡æœ‰æä¾›å†™æ“ä½œçš„æ–¹æ³•ã€‚String åœ¨ Java ä¸­æ˜¯ä¸€ç§ä¸å¯ä¿®æ”¹çš„å­—ç¬¦ä¸²ã€‚ è¿™å®é™…ä¸Šæ˜¯æ•ˆç‡ä¼˜åŒ–ä¸Šçš„ä¸åŒæƒ³æ³•ï¼ŒC++ ä¸­æ¯ä¸ª string çš„å¯¹è±¡éƒ½ç‹¬å ä¸€å—å†…å­˜ç©ºé—´ï¼ŒJava çš„ String ä¸å¯ä¿®æ”¹å°±å¯ä»¥å°†å¤šä¸ªç›¸åŒçš„å­—ç¬¦ä¸²å˜é‡å…±äº«ä¸€å—å†…å­˜ç©ºé—´ï¼Œå¤åˆ¶æ“ä½œæ•ˆç‡ä¹Ÿå˜å¾—å¾ˆé«˜ã€‚ä½†è¿™æ ·å°±è¦åœ¨å­—ç¬¦ä¸²æ¯”è¾ƒæ—¶ç‰¹åˆ«æ³¨æ„ï¼ŒJava çš„å¯¹è±¡å˜é‡éƒ½æ˜¯å¯¹è±¡çš„ç®¡ç†è€…ï¼Œä¸” Java æ²¡æœ‰è¿ç®—ç¬¦é‡è½½ï¼Œå¦‚æœä½ æœ‰ä¸¤ä¸ª String çš„å¯¹è±¡ a å’Œ b ï¼Œa == b åªæ˜¯åœ¨åˆ¤æ–­å®ƒä»¬ç®¡ç†çš„æ˜¯ä¸æ˜¯ä¸€å—å†…å­˜ç©ºé—´ã€‚Java ç›¸åŒå­—ç¬¦ä¸²çš„å…±äº«å†…å­˜ç©ºé—´çš„åˆ†é…æ–¹æ¡ˆä¹Ÿä¸æ˜¯ 100% çš„ï¼Œå®ƒåªæ˜¯åœ¨åˆé€‚çš„æƒ…å†µä¸‹å…±äº«ç©ºé—´ï¼Œæ‰€ä»¥ä¸¤ä¸ªå†…å®¹ç›¸åŒçš„å­—ç¬¦ä¸²ä¹Ÿä¸ä¸€å®šæŒ‡å‘åŒä¸€ä¸ªå†…å­˜ç©ºé—´ã€‚å®ƒçš„æ¯”è¾ƒæœ‰æ—¶ç›¸ç­‰æœ‰æ—¶ä¸ç›¸ç­‰éƒ½æ˜¯å¾ˆæœ‰å¯èƒ½çš„ï¼Œæ‰€ä»¥ä¸è¦é‚£ä¹ˆåšï¼æ¯”è¾ƒæ“ä½œ a.equals(b) ä½¿ç”¨ String çš„ equals æ–¹æ³•å³å¯ã€‚ é‚£åˆ°åº•æ€ä¹ˆä¿®æ”¹å­—ç¬¦ä¸²å‘¢ï¼Ÿä½ å¯ä»¥ä½¿ç”¨ + è¿ç®—ç¬¦å’Œ substring æ–¹æ³•è¿›è¡Œæ‹¼æ¥å’Œåˆ‡å‰²å­—ç¬¦ä¸²æœ€åå†èµ‹å€¼ç»™åŸå­—ç¬¦ä¸²ã€‚ä½†è¿™ä¼šæœ‰å¾ˆå¤§çš„å¼€é”€ï¼Œå› ä¸ºä¸­é—´ç»“æœè¦ç”Ÿæˆå¾ˆå¤šä¸å¯æ”¹å˜çš„ String å¯¹è±¡ã€‚å¯ä»¥ä½¿ç”¨ StringBuilder æˆ–è€… StringBufferã€‚ å‚è€ƒèµ„æ–™C++ åŸºç¡€ç±»å‹æ ‡å‡†C++ æ ‡è¯†ç¬¦æ ‡å‡†The JavaÂ® Language SpecificationJava æ ¸å¿ƒæŠ€æœ¯ å·I â€”â€” Cay S. Horstmannã€Gary Cornellæ·±å…¥ç†è§£ Java è™šæ‹Ÿæœº â€”â€” å‘¨å¿—æ˜]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Java</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>æµ®ç‚¹æ•°</tag>
        <tag>Java</tag>
        <tag>æ•´æ•°</tag>
        <tag>å‘½åè§„åˆ™</tag>
        <tag>String</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[basic_ios å¦‚ä½•ç©¿ä¸Šå®ƒçš„ bool]]></title>
    <url>%2F2018%2F06%2F29%2Fcin-return%2F</url>
    <content type="text"><![CDATA[ä¸ºä»€ä¹ˆå¯ä»¥ while( cin &gt;&gt; n ) ï¼Ÿè¿™ä¸ªé—®é¢˜å›°æ‰°äº†æˆ‘å¾ˆä¹…ã€‚æ¯æ¬¡å†™å‡ºé‚£è¡Œä»£ç éƒ½åœ¨ä¸ºä»€ä¹ˆæ²¡æœ‰è¾“å…¥æ—¶å®ƒä¼šåœï¼Œä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·å†™ï¼Œæ¯æ¬¡å†™æ—¶éƒ½æœ‰äº›è™šã€‚ä¸ºäº†ä¿æŒæˆ‘çš„è‡ªä¿¡ï¼Œæˆ‘æƒ³è±¡äº†å¾ˆå¤šæƒ…å†µæ¥å®‰æŠšè‡ªå·±ã€‚èµ·åˆæˆ‘ç±»æ¯” C è¯­è¨€ï¼Œæƒ³ç€åº”è¯¥æ˜¯ cin è¿™ä¸ªé¬¼ä¸œè¥¿è¿”å›äº†ä¸€ä¸ª bool ç±»å‹çš„å€¼ã€‚ä¹‹ååœ¨å­¦ä¹ äº†ç±»ä¸å¯¹è±¡åï¼Œå‘ç° cin ä¸è¿‡æ˜¯ä¸ªå¯¹è±¡ä¸å¯èƒ½è¿”å›ä»€ä¹ˆå€¼ã€‚æˆ‘åˆç»™å‡ºäº†æ–°çš„è§£é‡Šï¼šä¹Ÿè®¸ cin &gt;&gt; n è¿™ä¸ªè¡¨è¾¾å¼æ˜¯ä¸ª bool ç±»å‹çš„å€¼å§ã€‚å†ä¹‹åæˆ‘çœ‹è¿ç®—ç¬¦é‡è½½æ—¶ï¼Œåˆšåˆšçš„è§£é‡Šä¹Ÿå‡‰äº†ã€‚è¡¨è¾¾å¼ cin &gt;&gt; n çš„å€¼æ˜¯ &lt;&lt; çš„è¿ç®—ç¬¦é‡è½½å‡½æ•°è¿”å›çš„ä¸€ä¸ª basic_istream ç±»çš„å¯¹è±¡è€Œå·²ã€‚ æˆ‘çš„æƒ³è±¡åŠ›æœ‰ä¸€äº›æ¯ç«­äº† â€¦ â€¦ ç›´åˆ°è¿™å‡ å¤©æˆ‘åœ¨çœ‹ã€Šæ·±åº¦æ¢ç´¢C++å¯¹è±¡æ¨¡å‹ã€‹ä¹¦æ—¶ï¼Œä¹¦ä¸­çš„ä¾‹å­ä¸­æåˆ°äº† basic_ios çš„ç±»å‹è½¬æ¢å‡½æ•°ï¼Œåˆè®©æˆ‘æƒ³èµ·äº†ä¹‹å‰çš„é—®é¢˜ã€‚æˆ‘æŸ¥é˜…äº†å¤§é‡èµ„æ–™ï¼Œå¤§è‡´ææ¸…æ¥šäº† ç©¶ç«Ÿä¸ºä»€ä¹ˆå¯ä»¥ï¼Ÿå’Œ è§£å†³æ–¹æ¡ˆçš„æ¼”å˜è¿‡ç¨‹ã€‚ while çš„æ‹¬å·é‡Œèƒ½æ”¾ä»€ä¹ˆï¼Ÿ ä»»ä½•èƒ½æŒ‰è¯­å¢ƒè½¬æ¢ä¸º bool çš„è¡¨è¾¾å¼ï¼Œæˆ–å¸¦èŠ±æ‹¬å·æˆ–ç­‰å·åˆå§‹åŒ–å™¨çš„å•ä¸ªå˜é‡å£°æ˜ã€‚æ¯æ¬¡è¿­ä»£å‰æ±‚å€¼æ­¤è¡¨è¾¾å¼ï¼Œè€Œè‹¥å®ƒäº§å‡º false ï¼Œåˆ™é€€å‡ºå¾ªç¯ã€‚è‹¥æ­¤ä¸ºå£°æ˜ï¼Œåˆ™æ¯æ¬¡è¿­ä»£å‰æ±‚å€¼åˆå§‹åŒ–å™¨ï¼Œä¸”è‹¥è¢«å£°æ˜å˜é‡çš„å€¼è½¬æ¢ä¸º false ï¼Œåˆ™é€€å‡ºå¾ªç¯ã€‚ ä»€ä¹ˆå¯ä»¥è½¬æ¢ä¸º boolï¼Ÿå¯¹äºåŸå§‹æ•°æ®ç±»å‹ï¼Œé€‚ç”¨äºC++ æ ‡å‡†ä¸­çš„å¸ƒå°”è½¬æ¢è§„åˆ™è§„åˆ™å¦‚ä¸‹ï¼š æ•´æ•°ã€æµ®ç‚¹ã€æ— ä½œç”¨åŸŸæšä¸¾ã€æŒ‡é’ˆå’ŒæŒ‡å‘æˆå‘˜æŒ‡é’ˆç±»å‹çš„çº¯å³å€¼èƒ½è½¬æ¢æˆ bool ç±»å‹çº¯å³å€¼ã€‚å€¼é›¶ï¼ˆå¯¹äºæ•´æ•°ã€æµ®ç‚¹å’Œæ— ä½œç”¨åŸŸæšä¸¾ï¼‰ã€ç©ºæŒ‡é’ˆå€¼å’Œç©ºæˆå‘˜æŒ‡é’ˆå€¼å˜ä¸º false ã€‚æ‰€æœ‰å…¶ä»–å€¼å˜ä¸º true ã€‚std::nullptr_t ç±»å‹çº¯å³å€¼ï¼ŒåŒ…æ‹¬ nullptr ï¼Œèƒ½åœ¨ç›´æ¥åˆå§‹åŒ–çš„è¯­å¢ƒä¸­è½¬æ¢æˆ bool ç±»å‹çº¯å³å€¼ã€‚ç»“æœå€¼ä¸º false ã€‚(C++11 èµ·) å¯¹äºç”¨æˆ·å®šä¹‰ç±»å‹ï¼Œåˆ™éœ€è¦ç»™å‡º ç±»å‹è½¬æ¢å‡½æ•° æˆ– ä»¥ç›®æ ‡ç±»å‹ä¸ºå‚æ•°çš„æ„é€ å‡½æ•°ã€‚ ç©¶ç«Ÿä¸ºä»€ä¹ˆå¯ä»¥ï¼Ÿæˆ‘ç›´æ¥ç»™å‡ºç­”æ¡ˆï¼šbasic_istream çš„åŸºç±» basic_ios ç±»æœ‰ä¸€ä¸ª bool( ) çš„è¿ç®—ç¬¦é‡è½½å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯ç±»å‹è½¬æ¢å‡½æ•°ã€‚12explicit operator bool() const; // C++11 //è‹¥æµæ— é”™è¯¯åˆ™ä¸º true ï¼Œå¦åˆ™ä¸º false ã€‚ è¿™æ ·å°±è§£å†³äº†ä¸Šè¿°é—®é¢˜ï¼Œè¡¨è¾¾å¼ cin &gt;&gt; n çš„å€¼è¢«è½¬æ¢ä¸º bool ç±»å‹å½“ç„¶å¯ä»¥æ”¾åœ¨ while çš„æ‹¬å·å†…æ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚ æ¼”å˜è¿‡ç¨‹ä¸Šé¢çš„åªæ˜¯ C++11 æ ‡å‡†åº“çš„è§£å†³æ–¹æ¡ˆã€‚å…¶å®æ›´æœ‰æ„æ€çš„æ˜¯ basic_istream çš„å¯¹è±¡è½¬æ¢åˆ° bool ç±»å‹åœ¨å®ç°ä¸Šçš„ä¸€äº›å†å²æ¼”å˜è¿‡ç¨‹ã€‚ operator int() const;ç”±äº C++ æ—©æœŸæ˜¯æ²¡æœ‰ bool ç±»å‹çš„ï¼Œiostream åº“çš„æ„å»ºè€… Jerry Schwarz å¸Œæœ›é€šè¿‡ä¸º basic_ios ç±»ç¼–å†™ä¸€ä¸ªç±»å‹è½¬æ¢å‡½æ•°ï¼Œæä¾›å°† basic_ios ç±»è½¬æ¢ä¸º int ç±»å‹çš„æ–¹å¼ï¼Œå®ç° while( cin &gt;&gt; n )ã€‚å¯è¿™æ ·å†™åä»–å‘ç°ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯æœ‰äººå¯èƒ½å†™å‡ºä¸‹é¢è¿™ç§ä»£ç ï¼š1cin &lt;&lt; intValue; // æ­£ç¡®çš„åº”è¯¥ä¸º cin &gt;&gt; Value; ç”±äº &lt;&lt; å’Œ &gt;&gt; è¿ç®—ç¬¦å¾ˆå®¹æ˜“è®©ç¨‹åºå‘˜ç”¨ä¹±ï¼Œæœ‰çš„äººå¯èƒ½ä¼šå†™å‡ºä¸Šé¢çš„é”™è¯¯ä»£ç ï¼Œä½†å½“æ—¶çš„ç¼–è¯‘å™¨æ²¡æœ‰æŠ¥é”™ã€‚å› ä¸ºç¼–è¯‘å™¨å‘ç° cin æ˜¯æ²¡æœ‰é‡è½½ &lt;&lt; ï¼Œä½† int æ˜¯å¯ä»¥åšå·¦ç§» ( &lt;&lt; ) çš„ï¼Œç¨‹åºå°† basic_ios çš„å¯¹è±¡è½¬æ¢ä¸º int åˆè¿›è¡Œäº†å·¦ç§»æ“ä½œã€‚è¿™ç®—ä¸ä¸Šé”™è¯¯ï¼Œä½†è‡³å°‘å°†å¤§éƒ¨åˆ†ç¨‹åºå‘˜çš„é”™è¯¯éšè—äº†ï¼Œè®©äººéš¾ä»¥å®šä½é”™è¯¯ã€‚è¿™ä¸ªé”™è¯¯ä¹‹åè¢«æˆç§°ä¸ºâ€œSchwarz Errorâ€ï¼Œåœ¨è¿™ä¹‹å Jerry Schwarz ç”¨ä¸‹é¢çš„å‡½æ•°å–ä»£äº† operator int () const; operator void*() const;C++ çš„æ ‡å‡†ä¸­ void* èƒ½éšå¼è½¬æ¢ä¸º bool ç±»å‹ï¼ŒJerry Schwarz æƒ³åˆ°äº†è¿™ç§æ–¹å¼ï¼Œå¹¶ä¸”è¿˜ä¸º basic_ios ç±»é‡è½½äº† ! è¿ç®—ç¬¦ï¼Œä»¥æ”¯æŒ while( ! ( cin &gt;&gt; n ) )ã€‚è¿™ä¸ªå‡½æ•°ä¸€ç›´ç»´æŒåˆ° C++11 çš„å‡ºç°ã€‚ explicit operator bool() const;ä¹‹å‰çš„ operato void*() const; å…¶å®æ˜¯æœ‰å®‰å…¨é£é™©çš„ã€‚ä½ å¯ä»¥ç›´æ¥ç»™ä¸€ä¸ª void* ç±»å‹çš„å˜é‡èµ‹ä¸€ä¸ª basic_ios ç±»çš„å¯¹è±¡ï¼Œå¹¶ä¸”æ²¡æœ‰ä»»ä½•çš„é”™è¯¯æˆ–è­¦å‘Šã€‚è¿™æ˜¯ä¸å®‰å…¨çš„ï¼Œè¿™ç§ç±»å‹è½¬æ¢åº”è¯¥æ˜¯æ˜¾æ€§çš„æ‰å®‰å…¨ã€‚C++11 æ”¹å˜äº†éšå¼è½¬æ¢çš„ä¸€äº›è§„åˆ™ï¼Œè§£å†³äº†å®‰å…¨ bool é—®é¢˜ã€‚C++11 ä¹‹å‰åœ¨ç±»å‹è½¬æ¢è¿ç®—ç¬¦é‡è½½å‡½æ•°å‰åŠ ä¸Š explicit å…³é”®å­—ï¼Œå£°æ˜å®ƒå¿…é¡»æ˜¾å¼ä½¿ç”¨ï¼Œä»¥å¼ºåˆ¶ç±»å‹è½¬æ¢çš„å½¢å¼å»æ“ä½œã€‚æ¯”å¦‚ï¼šbool b = (bool)cin æ‰å¯ä»¥ä½¿ç”¨ç±»å‹è½¬æ¢å‡½æ•°ï¼Œè€Œä¸èƒ½åš bool b = cin è¿™æ ·çš„æ“ä½œã€‚è€Œ C++11 æ ‡å‡†å¯¹ç›®æ ‡ä¸º bool ç±»å‹çš„è½¬æ¢ï¼Œæ”¹å˜äº†æ ‡å‡†ã€‚ å…·ä½“æ ‡å‡†å¦‚ä¸‹ï¼š ä¸‹åˆ—è¯­å¢ƒä¸­ï¼ŒæœŸå¾…ç±»å‹ bool ï¼Œè€Œè‹¥å£°æ˜ bool t(e); ä¸ºè‰¯å¼åˆ™è¿›è¡Œéšå¼è½¬æ¢ï¼ˆå³è€ƒè™‘å¦‚ explicit T::operator bool() const; çš„éšå¼è½¬æ¢å‡½æ•°ï¼‰ã€‚æˆ‘ä»¬è¯´è¿™ç§è¡¨è¾¾å¼ e å¯æŒ‰è¯­å¢ƒè½¬æ¢ä¸º boolã€‚ if ã€ while ã€ for çš„æ§åˆ¶è¡¨è¾¾å¼ï¼› å†…å»ºé€»è¾‘è¿ç®—ç¬¦ ! ã€ &amp;&amp; å’Œ || çš„è¿ç®—æ•°ï¼› æ¡ä»¶è¿ç®—ç¬¦ ?: çš„é¦–ä¸ªè¿ç®—æ•°ï¼› static_assert å£°æ˜ä¸­çš„è°“è¯ï¼›(C++11èµ·) noexcept æŒ‡å®šç¬¦ä¸­çš„è¡¨è¾¾å¼ï¼› explicit æŒ‡å®šç¬¦ä¸­çš„è¡¨è¾¾å¼ï¼›(C++20 èµ·) å¥‘çº¦å±æ€§ çš„è°“è¯ã€‚(C++20 èµ·) è¿™æ ·åœ¨éä¸Šè¿°è¯­å¢ƒä¸‹è½¬æ¢ä¸º bool ç±»å‹å°±éœ€è¦æ˜¾å¼è½¬æ¢ï¼Œè€Œåœ¨æ§åˆ¶è¡¨è¾¾å¼ä¸­å¯ä»¥è‡ªåŠ¨çš„éšå¼è½¬æ¢ã€‚å¢å¼ºå®‰å…¨æ€§çš„åŒæ—¶ä¹Ÿä¿è¯å‘å‰å…¼å®¹ã€‚ å‚è€ƒèµ„æ–™ éšå¼è½¬æ¢ std::basic_ios std::basic_ios::operator bool explicit æŒ‡å®šç¬¦ while å¾ªç¯ if è¯­å¥ ã€Šæ·±åº¦æ¢ç´¢C++å¯¹è±¡æ¨¡å‹ã€‹â€”â€” Stanley B. Lippman ã€ŠC++è¯­è¨€çš„è®¾è®¡ä¸æ¼”åŒ–ã€‹â€”â€” Bjarne Stroustrup]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>bool</tag>
        <tag>basic_ios</tag>
        <tag>è¿ç®—ç¬¦é‡è½½</tag>
        <tag>ç±»å‹è½¬æ¢</tag>
        <tag>Cppæ¼”åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[System.in]]></title>
    <url>%2F2018%2F06%2F16%2FSystem-in%2F</url>
    <content type="text"><![CDATA[Scanner in = new Scanner(System.in) 2018.6.10]]></content>
      <categories>
        <category>æ³› - çºªå¿µ</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>çºªå¿µ</tag>
        <tag>çœèµ›</tag>
        <tag>ACMé¢˜ç›®</tag>
        <tag>Java</tag>
        <tag>Scanner</tag>
        <tag>System.in</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC LD DD å‘½ä»¤é€‰é¡¹]]></title>
    <url>%2F2018%2F05%2F11%2Fgcc-ld-dd-cmd%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°æ­¤ç¯‡ä»…ä»‹ç»ä¸€äº›æˆ‘åœ¨ ucore æ“ä½œç³»ç»Ÿçš„ makefile æ–‡ä»¶ä¸­é‡åˆ°çš„å‘½ä»¤é€‰é¡¹ï¼Œä½œä¸º lab_1 å®éªŒæŠ¥å‘Šçš„ä¸€éƒ¨åˆ†ã€‚ GCC -c è¿›è¡Œé¢„å¤„ç†ã€ç¼–è¯‘ã€æ±‡ç¼–ï¼Œç”Ÿæˆç›®æ ‡ä»£ç æ–‡ä»¶ï¼Œä¸è¿›è¡Œé“¾æ¥ -S ä»…è¿›è¡Œé¢„å¤„ç†ã€ç¼–è¯‘ï¼Œç”Ÿæˆæ±‡ç¼–ä»£ç æ–‡ä»¶ -E ä»…è¿›è¡Œé¢„å¤„ç† -o file æŒ‡å®šè¾“å‡ºæ–‡ä»¶å GCC 8.1 manuals æ‘˜å½• -I (å¤§å†™ i ) æŒ‡å®šå¤´æ–‡ä»¶ä½ç½® -L (å¤§å†™ L ) æŒ‡å®šåº“æ–‡ä»¶ä½ç½® -l (å°å†™ L) æŒ‡å®šåº“åå­— -I -L -l é€‰é¡¹çš„è¯¦è§£åˆ†åˆ«åœ¨ GCC 8.1 manuals çš„ç¬¬ 200ã€201ã€195 é¡µ -Wall å¼€å¯å¤§éƒ¨åˆ†è­¦å‘Šï¼Œåˆ—è¡¨å¦‚ä¸‹ã€‚ä¸€äº›ä¸å¸¸ç”¨çš„è­¦å‘Šå¯åŠ  -Wextra é€‰é¡¹é…åˆ - Wall å…¨éƒ¨æ‰“å¼€ é€‰é¡¹ -Waddress -Warray-bounds=1 (only with â€˜-O2â€™) -Wbool-compare -Wbool-operation -Wc++11-compat -Wc++14-compat -Wcatch-value (C++ and Objective-C++ only) -Wchar-subscripts -Wcomment -Wduplicate-decl-specifier (C and Objective-C only) -Wenum-compare (in C/ObjC; this is on by default in C++) -Wformat -Wint-in-bool-context -Wimplicit (C and Objective-C only) -Wimplicit-int (C and Objective-C only) -Wimplicit-function-declaration (C and Objective-C only) -Winit-self (only for C++) -Wlogical-not-parentheses -Wmain (only for C/ObjC and unless â€˜-ffreestandingâ€™) -Wmaybe-uninitialized -Wmemset-elt-size -Wmemset-transposed-args -Wmisleading-indentation (only for C/C++) -Wmissing-attributes -Wmissing-braces (only for C/ObjC) -Wmultistatement-macros -Wnarrowing (only for C++) -Wnonnull -Wnonnull-compare -Wopenmp-simd -Wparentheses -Wpointer-sign -Wreorder -Wreorder -Wrestrict -Wreturn-type -Wsequence-point -Wsign-compare (only in C++) -Wsizeof-pointer-div -Wsizeof-pointer-memaccess -Wstrict-aliasing -Wstrict-overflow=1 -Wswitch -Wtautological-compare -Wtrigraphs -Wuninitialized -Wunknown-pragmas -Wunused-function -Wunused-label -Wunused-value -Wunused-variable -Wvolatile-register-var -fno-builtin ä¸æ‰¿è®¤ä¸ä»¥ __builtin_ å¼€å¤´çš„å†…å»º ( built-in ) å‡½æ•°ã€‚ -ggdb ç”Ÿæˆç”¨äºGDBçš„è°ƒè¯•ä¿¡æ¯ -gstabs ä½¿ç”¨stabsæ ¼å¼ç”Ÿæˆè°ƒè¯•ä¿¡æ¯ï¼Œ -nostdinc ä¸æœç´¢å¤´æ–‡ä»¶çš„æ ‡å‡†ç³»ç»Ÿç›®å½• -fno-stack-protector ç¦ç”¨å †æ ˆä¿æŠ¤æœºåˆ¶ GNU linker ( ld ) å‘½ä»¤é€‰é¡¹ -m emulation æ¨¡æ‹Ÿä»¿çœŸé“¾æ¥å™¨ å¦‚ï¼š-m elf_i386 -nostdlib åªç”¨åœ¨å‘½ä»¤è¡Œä¸­æ˜¾å¼æŒ‡å®šçš„æœç´¢åº“ç›®å½• -N è®¾ç½®ä»£ç æ®µå’Œæ•°æ®æ®µå‡å¯è¯»å†™ -e æŒ‡å®šå…¥å£ -Ttext è¿æ¥æ—¶é‡å®šå‘åˆå§‹åœ°å€ dd å‘½ä»¤å‚æ•° if ä»£è¡¨è¾“å…¥æ–‡ä»¶ã€‚å¦‚æœä¸æŒ‡å®šifï¼Œé»˜è®¤å°±ä¼šä»stdinä¸­è¯»å–è¾“å…¥ã€‚ of ä»£è¡¨è¾“å‡ºæ–‡ä»¶ã€‚å¦‚æœä¸æŒ‡å®šofï¼Œé»˜è®¤å°±ä¼šå°†stdoutä½œä¸ºé»˜è®¤è¾“å‡ºã€‚ bs ä»£è¡¨å­—èŠ‚ä¸ºå•ä½çš„å—å¤§å°ã€‚ count ä»£è¡¨è¢«å¤åˆ¶çš„å—æ•°ã€‚ /dev/zero æ˜¯ä¸€ä¸ªå­—ç¬¦è®¾å¤‡ï¼Œä¼šä¸æ–­è¿”å›0å€¼å­—èŠ‚ï¼ˆ\0ï¼‰ å‚è€ƒèµ„æ–™ GCC 8.1 manuals ld GNU Development Tools ( man ld ) Linux dd å‘½ä»¤è¯¦è§£]]></content>
      <categories>
        <category>æ³› - è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>æ“ä½œç³»ç»Ÿ</tag>
        <tag>Linux</tag>
        <tag>gcc</tag>
        <tag>ld</tag>
        <tag>dd</tag>
        <tag>linker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X86 è®¡ç®—æœºå¯åŠ¨æµç¨‹]]></title>
    <url>%2F2018%2F05%2F03%2Fx86-cpu-boot%2F</url>
    <content type="text"><![CDATA[ç¡¬ä»¶åŠ ç”µåå¯„å­˜å™¨åˆå§‹å€¼åŠ ç”µå CPU è¿›å…¥å®æ¨¡å¼ï¼ˆä¸ºäº†å…¼å®¹æ—©æœŸçš„8086å¤„ç†å™¨ï¼‰ï¼Œå®æ¨¡å¼ä¸‹ CPU åªæœ‰ 1M çš„å¯»å€ç©ºé—´ï¼Œåœ°å€è®¡ç®—ä¸º: $EA = Base + EIP$ å³åŠ ç”µåçš„èµ·å§‹åœ°å€ä¸º $CS:EIP = FFFF0000H+0000FFF0H = FFFFFFF0H$ ä» FFFFFFF0H åˆ° 00007C00HFFFFFFF0H ä¸­æœ‰ä»€ä¹ˆå‘¢ï¼Ÿè¿™é‡Œæ”¾ç€çš„æ˜¯ CPU è¦æ‰§è¡Œçš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼Œé€šå¸¸æ˜¯ä¸€æ¡é•¿è·³è½¬æŒ‡ä»¤ï¼Œå®ƒä¼šè®¾ç½® CS å’Œ EIP å°†æ§åˆ¶æƒäº¤ç»™ BIOS åšåˆå§‹åŒ–å·¥ä½œã€‚ BIOS çš„æ‰§è¡Œè¿‡ç¨‹ ç¡¬ä»¶è‡ªæ£€ æ£€æµ‹å…³é”®éƒ¨ä»¶çš„å­˜åœ¨å’Œå·¥ä½œçŠ¶æ€ æŸ¥æ‰¾å¹¶æ‰§è¡Œæ¥å£å¡çš„ BIOS è¿›è¡Œè®¾å¤‡åˆå§‹åŒ– æ‰§è¡Œç³»ç»Ÿ BIOS è¿›è¡Œç³»ç»Ÿæ£€æµ‹ï¼Œæ£€æµ‹å’Œé…ç½®å³æ’å³ç”¨è®¾å¤‡ æ›´æ–° CMOS çš„æ‰©å±•ç³»ç»Ÿé…ç½®æ•°æ® ESCD (ç³»ç»Ÿé…ç½®è¡¨) æŒ‰æŒ‡å®šé¡ºåºä»è½¯ç›˜ã€ç¡¬ç›˜æˆ–å…‰é©±å¯åŠ¨ è¯»å–ä¸»å¼•å¯¼æ‰‡åŒºä»£ç ï¼Œæ‹¿åˆ°ä¸»å¼•å¯¼è®°å½• ä¸»å¼•å¯¼æ‰‡åŒºä»£ç è¯»å–æ´»åŠ¨åˆ†åŒºçš„å¼•å¯¼æ‰‡åŒºä»£ç  æ´»åŠ¨åˆ†åŒºçš„å¼•å¯¼æ‰‡åŒºä»£ç è¯»å–æ–‡ä»¶ç³»ç»Ÿçš„åŠ è½½ç¨‹åºåˆ°å†…å­˜ä¸­çš„ 00007C00H å¤„ å°† CS:EIP è®¾ç½®ä¸º 00007C00H æ§åˆ¶æƒäº¤ç»™åŠ è½½ç¨‹åº( bootloader ) è‡³æ­¤è®¡ç®—æœºçš„æ§åˆ¶æƒå·²ç»äº¤ç»™æ“ä½œç³»ç»Ÿçš„ bootloader ç¨‹åºã€‚ bootloader å¯åŠ¨è¿‡ç¨‹ åˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼ï¼Œå¯ç”¨åˆ†æ®µæœºåˆ¶ è¯»ç£ç›˜ä¸­ ELF æ‰§è¡Œæ–‡ä»¶æ ¼å¼çš„æ“ä½œç³»ç»Ÿåˆ°å†…å­˜ æ˜¾ç¤ºå­—ç¬¦ä¸²ä¿¡æ¯ æŠŠæ§åˆ¶æƒäº¤ç»™æ“ä½œç³»ç»Ÿ bootloader ä»£ç ucore asm.h bootasm.S bootmain.c xv6 bootasm.S bootmain.c]]></content>
      <categories>
        <category>æ³› - è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>æ“ä½œç³»ç»Ÿ</tag>
        <tag>å¯„å­˜å™¨</tag>
        <tag>CPU</tag>
        <tag>ç¡¬ä»¶</tag>
        <tag>bootloader</tag>
        <tag>BIOS</tag>
        <tag>å¯åŠ¨æµç¨‹</tag>
        <tag>X86</tag>
        <tag>Intel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AT&T ä¸ Intel æ±‡ç¼–ä¸»è¦è¯­æ³•å·®å¼‚]]></title>
    <url>%2F2018%2F04%2F23%2Fatt-intel-differents%2F</url>
    <content type="text"><![CDATA[æ“ä½œæ•°é¡ºåºåœ¨ä¸€èˆ¬çš„äºŒå…ƒæŒ‡ä»¤ï¼ˆå¦‚ movã€add â€¦ï¼‰ä¸­ï¼Œä¸¤ä¸ªæ“ä½œæ•°åˆ†ä¸ºæºæ“ä½œæ•°å’Œç›®çš„æ“ä½œæ•°ã€‚AT&amp;T ä¸ Intelæ“ä½œæ•°çš„é¡ºåºæ­£å¥½ç›¸åã€‚ â€œOp-code dst srcâ€ in Intel syntax. â€œOp-code src dstâ€ in AT&amp;T syntax. å¯„å­˜å™¨åç§°AT&amp;T è¯­æ³•ä¸­å¯„å­˜å™¨åç§°éœ€è¦åŠ å‰ç¼€ â€™%â€™ ï¼Œè€Œ Intel ä¸éœ€è¦ã€‚ ç«‹å³æ•°AT&amp;T è¯­æ³•ä¸­ç«‹å³æ•°éœ€è¦åŠ å‰ç¼€ â€™$â€™ ï¼Œå¯¹äºé™æ€ â€˜Câ€™ å˜é‡ä¹Ÿä¸€æ ·ã€‚Intelçš„è¯­æ³•æ ‡å‡†ä¸éœ€è¦ã€‚ æ“ä½œæ•°å¤§å°AT&amp;T è¯­æ³•ä¸­ï¼Œæ“ä½œæ•°å¤§å°ç”±æŒ‡ä»¤çš„æœ€åä¸€ä¸ªå­—ç¬¦å†³å®šï¼Œâ€œbâ€ã€â€œwâ€ å’Œ â€œlâ€ çš„æŒ‡ä»¤åç¼€åˆ†åˆ«è¡¨ç¤ºå­—èŠ‚(8ä½)ã€word(16ä½)å’Œé•¿(32ä½)å†…å­˜å¼•ç”¨ã€‚ Intel è¯­æ³•ä¸­ï¼Œç”±æ“ä½œæ•°çš„å‰ç¼€ â€™byte ptrâ€™, â€™word ptrâ€™, å’Œ â€™dword ptrâ€™ å†³å®šã€‚ â€œmov al, byte ptr fooâ€ in Intel syntax â€œmovb foo, %alâ€ in AT&amp;T syntax å¯»å€æ–¹å¼AT&amp;T è¯­æ³•ä¸­åŸºæŒ‡å¯„å­˜å™¨è¢« ( ) æ‹¬èµ·æ¥ï¼Œè€Œ Intel è¯­æ³•ä¸­ä½¿ç”¨ [ ] ã€‚ åœ°å€è¡¨ç¤ºï¼š section:[base + index*scale + disp] in Intel syntax section:disp(base, index, scale) in AT&amp;T syntax sectionï¼šæ®µåœ°å€ dispï¼šåç§»åœ°å€ indexï¼šå˜å€ scaleï¼šæ¯”ä¾‹å› å­ è®¡ç®—å…¬å¼ï¼š[EA = base + ( index * scale ) + disp] å¯¹æ¯” Intel Code AT&amp;T Code mov eax,1 movl $1,%eax mov ebx,0ffh movl $0xff,%ebx int 80h int $0x80 mov ebx,eax movl %eax,%ebx mov eax,[ecx] movl (%ecx),%eax mov eax,[ebx+3] movl 3(%ebx),%eax mov eax,[ebx+20h] movl 0x20(%ebx),%eax add eax,[ebx+ecx*2h] addl (%ebx,%ecx,0x2),%eax lea eax,[ebx+ecx] leal (%ebx,%ecx),%eax sub eax,[ebx+ecx*4h-20h] subl -0x20(%ebx,%ecx,0x4),%eax å‚è€ƒèµ„æ–™ GCC-Inline-Assembly-HOWTO : http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s3]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Assembly</category>
      </categories>
      <tags>
        <tag>æ±‡ç¼–è¯­è¨€</tag>
        <tag>ç¼–ç¨‹è¯­è¨€</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆå››ï¼‰è®¿é—®å±æ€§]]></title>
    <url>%2F2018%2F04%2F15%2Fcpp-class-4%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°C++çš„è®¿é—®å±æ€§æˆ‘åœ¨æœ¬ç³»åˆ—çš„ç¬¬ä¸€ç¯‡ C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆä¸€ï¼‰ å·²ç»æœ‰äº†ä¸€äº›ä»‹ç»ï¼Œä½†é‚£æ—¶æ²¡æœ‰ä»‹ç»ç»§æ‰¿ä¸­çš„è®¿é—®å±æ€§é—®é¢˜ï¼Œè€Œä¸”æœ€è¿‘å¯¹ C++çš„ä¿æŠ¤æ¨¡å‹ä¹Ÿæœ‰äº†ä¸€äº›æ–°çš„ç†è§£ã€‚æ­¤ç¯‡ä¸º C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆä¸€ï¼‰ åœ¨è®¿é—®å±æ€§æ–¹é¢çš„è¡¥å……ã€‚ æ¦‚å¿µåœ¨ C++ è¯­è¨€ä¸­æœ‰ publicã€protected å’Œ private è¿™ä¸‰ç§è®¿é—®å±æ€§ã€‚ publicï¼šä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è®¿é—® protectedï¼šåªæœ‰è¿™ä¸ªç±»å’Œå®ƒçš„æ´¾ç”Ÿç±»å¯ä»¥è®¿é—® privateï¼šåªæœ‰è¿™ä¸ªç±»å¯ä»¥è®¿é—® æ¦‚å¿µ 1 ä¿æŠ¤æ˜¯é€šè¿‡ç¼–è¯‘æ—¶çš„æœºåˆ¶æä¾›çš„ï¼Œç›®æ ‡é˜²æ­¢å‘ç”Ÿæ„å¤–äº‹ä»¶ï¼Œè€Œä¸æ˜¯é˜²æ­¢æ¬ºéª—æˆ–è€…æœ‰æ„ä¾µçŠ¯ã€‚ 2 ä¿æŠ¤çš„å•ä½æ˜¯ç±»ï¼Œè€Œä¸æ˜¯æŸä¸ªå¯¹è±¡ã€‚ 3 å—æ§åˆ¶çš„æ˜¯è®¿é—®æƒï¼Œè€Œä¸æ˜¯å¯è§æ€§ã€‚ è¿™å…¶ä¸­çš„å‰ä¸¤æ¡æˆ‘å·²ç»åœ¨ C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆä¸€ï¼‰ ä¸­è®²è§£å¹¶æ­é…äº†å®éªŒã€‚ è®²è§£æ¸…æ¥šç¬¬ä¸‰æ¡ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šä»€ä¹ˆæ˜¯å¯è§æ€§ã€‚ å¯è§æ€§ï¼š è¿™ä¸ªæ¦‚å¿µå¾ˆå¸¸è§ï¼Œæ¯”å¦‚ä¸‹é¢çš„ä»£ç ï¼š123456789101112#include &lt;iostream&gt;using namespace std;int i = 1;int main()&#123; int i = 2; cout &lt;&lt; i &lt;&lt; endl; return 0;&#125; è¿™æ®µç¨‹åºçš„è¾“å‡ºæ˜¾ç„¶æ˜¯ 2ï¼Œå› ä¸ºåœ¨ main å‡½æ•°ä¸­ç¬¬ 4 è¡Œçš„å…¨å±€çš„æ•´æ•° i æ˜¯ä¸å¯è§çš„ï¼Œå®ƒè¢«ç¬¬ 8 è¡Œçš„å±€éƒ¨æ•´æ•° i æ‰€é®è”½äº†ã€‚ æˆ‘ä»¬å†æ¥çœ‹è¿™ä¸ªç¨‹åº12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int a = 2;class AA&#123;private: int a;&#125;;class AAB : public AA&#123;public: void fun() &#123; a = 1; &#125;&#125;;int main()&#123; AAB x; x.fun(); cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; åœ¨ AA ç±»ä¸­æœ‰ä¸€ä¸ªç§æœ‰çš„æˆå‘˜ a ï¼ŒAAB ç±» public ç»§æ‰¿äº† AA ç±»ã€‚æ˜¾ç„¶ç°åœ¨ AAB ç±»çš„å¯¹è±¡æœ‰äº†ä¸€ä¸ªç§æœ‰æˆå‘˜ a ï¼Œä½†è¿™ä¸ª a æ˜¯ AA ç±»ç§æœ‰çš„ï¼Œa å¯¹äº AAB ç±»çš„ fun å‡½æ•°æœ‰å¯èƒ½æ˜¯ä¸å¯è§çš„ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ä¸å¯è®¿é—®çš„ã€‚ å¦‚æœæ˜¯ä¸å¯è§çš„ï¼šæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä»£ç ä¸­æœ‰ä¸€ä¸ªå…¨å±€å˜é‡ a ï¼Œä¸å¯è§çš„è¯ fun å‡½æ•°ä¸­ä¼šä¿®æ”¹å…¨å±€çš„ a ã€‚ å¦‚æœæ˜¯ä¸å¯è®¿é—®çš„ï¼šé‚£ç¼–è¯‘åº”è¯¥é€šä¸è¿‡ï¼Œå› ä¸ºå®ƒåœ¨è®¿é—®ä¿®æ”¹ä¸€ä¸ª private çš„æˆå‘˜ã€‚ å°è¯•ç¼–è¯‘å¾—åˆ°ä¸‹é¢çš„ç»“æœ12345temp.cpp: In member function &apos;void AAB:fun()&apos;:temp.cpp:17:3 error: &apos;int AA:a&apos; is private within this context a = 1;temp.cpp:9:6: note: declared private here; int a; å®ƒè¯´ AA ç±»ä¸­çš„ a æ˜¯ç§æœ‰çš„ã€‚æ‰€ä»¥è¯´è¿™ä¸‰ä¸ªå…³é”®å­—é™åˆ¶çš„æ˜¯è®¿é—®å±æ€§è€Œä¸æ˜¯å¯è§æ€§ã€‚ è®¿é—®æƒé™ç©¶ç«Ÿæ˜¯åœ¨é™åˆ¶è°ï¼Ÿå®ƒæ˜¯åœ¨é™åˆ¶è¯¥ç±»åç»­çš„ä½¿ç”¨è€…ï¼Œè€Œä¸æ˜¯åœ¨é™åˆ¶è¯¥ç±»ç°åœ¨çš„è®¾è®¡è€…ï¼åœ¨åé¢çš„ç»„åˆå’Œç»§æ‰¿ä¸­çš„è®¿é—®æƒé™ä¼šå‡ºç°è®¿é—®æƒé™çš„å¤šæ¬¡é™åˆ¶ï¼Œå¾ˆå¤šåˆå­¦è€…ä¼šåˆ†ä¸æ¸…æ¥šç±»å†…å’Œç±»å¤–è®¿é—®æƒé™çš„åŒºåˆ«ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œå…ˆè¯´æ˜ä¸€ä¸‹ã€‚è®¿é—®æƒé™æˆ‘ä»¬å…³å¿ƒçš„æ˜¯æˆ‘ä»¬åšçš„è¿™ä¸ªç±»åœ¨æœªæ¥çš„ä½¿ç”¨è€…æ‰‹ä¸­çš„è®¿é—®æƒé™ã€‚å› ä¸ºä¸‰ç§è®¿é—®æƒé™å‡å…è®¸åœ¨ç±»å†…è®¿é—®ï¼Œç±»å†…çš„è®¿é—®æƒé™åªç”±å…¶ä¸­çš„æˆå‘˜ä¹‹å‰è®¾è®¡è®¿é—®æƒé™æœ‰å…³ï¼Œä¸å½“å‰è¦è®¾è®¡çš„ç±»èµ‹äºˆçš„è®¿é—®æƒé™æ— å…³ã€‚ ç±»ä¼šåœ¨å“ªäº›åœ°æ–¹è¢«ä½¿ç”¨ï¼Ÿ ä½œä¸ºå˜é‡è¢«ä½¿ç”¨ åœ¨å…¶æ´¾ç”Ÿç±»ä¸­è¢«ä½¿ç”¨ å‘ä¸Šé€ å‹ï¼Œæ˜¯å¦å¯ä»¥åšæŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹è½¬æ¢ å¯¹è±¡ç»„åˆä¸­çš„è®¿é—®å±æ€§é—®é¢˜åœ¨è®²ç»§æ‰¿ä¸­çš„è®¿é—®æƒé™ä¹‹å‰æˆ‘æƒ³å…ˆä»‹ç»ç»„åˆä¸­çš„è®¿é—®æƒé™ã€‚å®ƒä»¬å¾ˆç›¸è¿‘ï¼ŒåŒºåˆ«ä¹Ÿä¼šåœ¨ä¸‹é¢è®²åˆ°ã€‚1234567891011class AA&#123;public: int a;&#125;;class AAB&#123;private: AA b;&#125;; å¦‚æœåœ¨ AAB ç±»å¤–è®¿é—®æˆå‘˜ b ä¸­çš„æˆå‘˜çš„ aï¼Œä¼šæ€ä¹ˆæ ·å‘¢ï¼Ÿå½“ç„¶æ˜¯ç¼–è¯‘é”™è¯¯ã€‚å› ä¸ºåœ¨è®¿é—®æˆå‘˜ b ä¸­çš„æˆå‘˜ a å®é™…ä¸Šæ˜¯åœ¨è®¿é—®æˆå‘˜ b ï¼Œè€Œæˆå‘˜ b æ˜¯ç§æœ‰çš„ä¸å¯è®¿é—®ã€‚ è¿™é‡Œè®¿é—®æƒé™å‘ç”Ÿäº†å åŠ ï¼Œæˆå‘˜ a çš„è®¿é—®æƒé™ AA ç±»èµ‹äºˆå®ƒçš„ public å†åŠ ä¸Š AAB ç±»èµ‹äºˆæˆå‘˜ b çš„ private ã€‚è¿™é‡Œå‘ç”Ÿäº†è®¿é—®æƒé™çš„å åŠ ã€‚ è®¿é—®æƒé™å åŠ æ—¶ä¼šæ€ä¹ˆæ ·ï¼Ÿ æˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸‹è¿™ä¸‰ç§è®¿é—®æƒé™çš„ç‰¹ç‚¹ï¼Œä» public ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è®¿é—®ï¼Œä¸Šå‡åˆ° protected åªèƒ½åœ¨ç±»å†…å’Œå…¶å­å­å­™å­™çš„ç±»ä¸­å¯ä»¥è®¿é—®ï¼Œå†ä¸Šå‡åˆ° private åªèƒ½åœ¨ç±»å†…è®¿é—®ã€‚ä¸éš¾å‘ç°è¿™ä¸‰ç§è®¿é—®æƒé™çš„ä¸¥æ ¼ç¨‹åº¦é€çº§é€’å¢ï¼Œåœ¨å‘ç”Ÿè®¿é—®æƒé™å åŠ æ—¶åº”é€‰æ‹©æœ€ä¸¥æ ¼çš„è®¿é—®æƒé™å£°æ˜å»é™åˆ¶å…¶è®¿é—®æƒé™ã€‚å› ä¸ºè®¿é—®æ˜¯é€å±‚è¿›è¡Œçš„ã€‚ è¿™å°±æ¯”å¦‚ä½ ç°åœ¨éœ€è¦ä¹˜åå¾ˆå¤šç§äº¤é€šå·¥å…·å›å®¶ï¼Œå‡è®¾ä¸€è·¯ä¸Šè¦ä¹˜åèˆ¹ã€åœ°é“ã€é£æœºã€æ±½è½¦ã€‚ä½ çš„è¡Œæä¸­æœ‰ä¸€ä¸ªæ‰“ç«æœºï¼Œä½ ä¼šæƒ³ä¸€ä¸‹åé£æœºä¸è®©æºå¸¦æ‰“ç«æœºè€Œé€‰æ‹©ä¸å¸¦å®ƒï¼Œè€Œä¸ä¼šå› ä¸ºåèˆ¹ã€æ±½è½¦ã€åœ°é“éƒ½å¯ä»¥æºå¸¦æ‰“ç«æœºè€Œå¸¦ä¸Šå®ƒã€‚å› ä¸ºæ˜¯å¦å¯ä»¥æºå¸¦è¿™äº›è¡Œæå–å†³äºä½ è¿™ä¸€è·¯ä¸Šè¦æ¥å—çš„æ‰€æœ‰å®‰æ£€ä¸­æœ€ä¸¥æ ¼çš„é‚£ä¸€ä¸ªã€‚ ç»§æ‰¿ä¸­çš„è®¿é—®å±æ€§é—®é¢˜å¸¸è§ä¸‰ç§ç»§æ‰¿å°±å¯¹åº”äºè¿™ä¸‰ç§è®¿é—®æƒé™ï¼Œç»§æ‰¿çš„åˆ†ç±»ä¹Ÿç”±è¿™ä¸‰ç§è®¿é—®å±æ€§äº§ç”Ÿçš„ã€‚1234567891011121314151617181920212223242526272829303132class Base1&#123;private: int a1;protected: int b1;public: int c1;&#125;;class Base2&#123;private: int a1;protected: int b1;public: int c1;&#125;;class Base3&#123;private: int a1;protected: int b1;public: int c1;&#125;;class Y : public Base1, protected Base2, private Base3&#123;&#125;; æˆ‘ä»¬è®¨è®ºè¿™æ®µä»£ç ä¸­ Y ç±»æ¯ä¸ªæˆå‘˜çš„èŒƒå›´å±æ€§ã€‚ å†æ¬¡æé†’åˆå­¦è€…ï¼æˆ‘ä»¬è®¨è®ºçš„æ˜¯åœ¨ä¹‹åç”¨åˆ° Y ç±»æ—¶çš„è®¿é—®å±æ€§ï¼Œæ¯”å¦‚ï¼šä»ç”± Y ç±»æ‰€å®šä¹‰çš„å¯¹è±¡å¯¹å…¶ä¸­æˆå‘˜çš„è®¿é—®ã€åœ¨ Y ç±»çš„æ´¾ç”Ÿç±»ä¸­å¯¹å…¶æˆå‘˜çš„è®¿é—®ã€‚åˆå­¦è€…å¯èƒ½ä¼šæƒ³çŸ¥é“åœ¨ Y ç±»å†…éƒ¨å¯¹è¿™äº›æˆå‘˜çš„è®¿é—®å±æ€§é—®é¢˜ã€‚è¿™é‡Œè¯´æ˜ä¸€ä¸‹åœ¨ Y ç±»å†…éƒ¨è®¿é—®ç»§æ‰¿å¾—åˆ°çš„æˆå‘˜æ˜¯å¦å—é™ä¸ç»§æ‰¿æ–¹å¼æ— å…³ï¼Œåªä¸åŸºç±»å£°æ˜çš„è®¿é—®å±æ€§æœ‰å…³ã€‚æ¯”å¦‚åœ¨ Y ç±»å†…éƒ¨è®¿é—®æˆå‘˜ c3 æ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºåœ¨ Base3 ä¸­å£°æ˜å…¶æ˜¯ public çš„è®¿é—®å±æ€§ï¼Œè€Œè¿™ä¸å®ƒæ˜¯ä»¥ private æ–¹å¼ç»§æ‰¿æ— å…³ã€‚ è¿™å°±ä¸å¯¹è±¡ç»„åˆä¸­çš„è®¿é—®å±æ€§é—®é¢˜å¾ˆç›¸ä¼¼äº†ï¼Œæˆ‘ä»¬å†æ¥çœ‹ä¸€æ®µä»£ç ã€‚123456789class Y&#123;public: Base1 a;protected: Base2 b;private: Base3 c;&#125;; å¦‚æœæŠŠ Y ç±»æ”¹å†™æˆè¿™ä¸ªæ ·å­ï¼Œå…¶æ‰€æœ‰æˆå‘˜çš„è®¿é—®å±æ€§ä¸ä¹‹å‰çš„ Y ç±»ç›¸åŒã€‚è™½ç„¶å®ƒä»¬çš„è®¿é—®å±æ€§æ˜¯ä¸€è‡´çš„ï¼Œä½†å› ä¸ºç°åœ¨ Y ç±»ä¸å†æ˜¯ä¸‰ä¸ªBaseç±»çš„æ´¾ç”Ÿç±»äº†ï¼Œæ‰€ä»¥åœ¨ Base ç±»ä¸­è®¿é—®å±æ€§ä¸º protected çš„æˆå‘˜å°†ä¸èƒ½åœ¨ Y ç±»å’Œå…¶æ´¾ç”Ÿç±»ä¸­è¢«è®¿é—®ã€‚ åˆ¤æ–­ä¸€ä¸ªæˆå‘˜åœ¨ç»§æ‰¿è¿‡ç¨‹ä¸­çš„è®¿é—®å±æ€§æ—¶ï¼Œå¯ä»¥é€šè¿‡å°†å…¶è½¬å˜ä¸ºå¯¹è±¡ç»„åˆæ—¶çš„è®¿é—®å±æ€§é—®é¢˜åˆ¤æ–­ã€‚æ³¨æ„è¿™æ ·åˆ¤æ–­çš„æ˜¯å®ƒç©¶ç«Ÿæ˜¯å“ªç§è®¿é—®å±æ€§ï¼Œè€Œä¸æ˜¯å®ƒèƒ½ä¸èƒ½è¢«è®¿é—®ã€‚èƒ½ä¸èƒ½è¢«è®¿é—®åº”æ ¹æ®è®¿é—®å±æ€§å’Œæ˜¯å¦ä¸ºæ´¾ç”Ÿç±»åˆ¤æ–­ã€‚ å…¶ä»–é—®é¢˜å‘ä¸Šé€ å‹ è¿™é‡Œè¦åˆ†ä¸ºä¸¤ä¸ªä½ç½®ï¼š ä¸€ã€åœ¨è¯¥ç±»çš„ public æ´¾ç”Ÿç±»ä¸­ publicï¼šå¯ä»¥ protectedï¼šå¯ä»¥ privateï¼šå½“åšæ— å­çˆ¶ç±»å…³ç³»ï¼Œæ— æ³•åšæŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹è½¬æ¢ äºŒã€åœ¨å…¶ä»–ä½ç½® publicï¼šå¯ä»¥ protectedï¼šå½“åšæ— å­çˆ¶ç±»å…³ç³»ï¼Œæ— æ³•åšæŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹è½¬æ¢ privateï¼šå½“åšæ— å­çˆ¶ç±»å…³ç³»ï¼Œæ— æ³•åšæŒ‡é’ˆæˆ–å¼•ç”¨çš„ç±»å‹è½¬æ¢ å†…éƒ¨ç±»é—®é¢˜ åœ¨å†…éƒ¨ç±»ä¸­å¯¹è¯¥ç±»ä¸­çš„æˆå‘˜è®¿é—®ä¸åœ¨è¯¥ç±»çš„æˆå‘˜å‡½æ•°è®¿é—®ä¸€è‡´ï¼Œä¸å†…éƒ¨ç±»å£°æ˜çš„è®¿é—®å±æ€§æ— å…³ã€‚ æ¨¡æ¿ç±»é—®é¢˜ æ¨¡æ¿ç±»åªæ˜¯å£°æ˜ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®æ¯æ¬¡æŒ‡å®šçš„ç±»å‹æ¯æ¬¡å®šä¹‰ä¸€ä¸ªæ–°çš„ç±»ï¼Œæ‰€ä»¥åŒä¸€ä¸ªæ¨¡æ¿æ˜¯ä½¿ç”¨ä¸¤ä¸ªä¸åŒçš„ç±»å‹å®šä¹‰çš„ç±»æ˜¯å±äºä¸¤ä¸ªä¸åŒçš„ç±»ã€‚1234567891011121314151617181920template&lt;typename T&gt;class X&#123;private: int member;public: template&lt;typename U&gt; void Method(X&lt;U&gt;&amp; y) &#123; &amp;y.member; &#125;&#125;;int main()&#123; X&lt;int&gt; x; X&lt;float&gt; y; x.Method(x); // å¯ä»¥ x.Method(y); // ä¸å¯ä»¥&#125; è¿™é‡Œçš„ 18 å’Œ 19 è¡Œä½œä¸ºå¯¹æ¯”ï¼Œx çš„ Method ä¼ å…¥å®ƒè‡ªå·±ï¼ˆç›¸åŒç±»å‹ï¼‰è®¿é—®å…¶ private æˆå‘˜ä¸ä¼šæŠ¥é”™ï¼Œè€Œ x çš„ Method ä¼ å…¥å®ƒçš„æ¨¡æ¿æ ¹æ® float å®šä¹‰çš„å¯¹è±¡ y å†è®¿é—®å…¶ private æˆå‘˜åˆ™ä¼šæŠ¥é”™ã€‚]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>è®¿é—®å±æ€§</tag>
        <tag>å¯¹è±¡ç»„åˆ</tag>
        <tag>ç»§æ‰¿</tag>
        <tag>å¤šæ€</tag>
        <tag>å¯è§æ€§</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œå…¬å‘Šã€ è¿‘æœŸæ–‡ç« ä¸­çš„é”™è¯¯andåšå®¢è®¡åˆ’]]></title>
    <url>%2F2018%2F04%2F06%2Fnotice-1%2F</url>
    <content type="text"><![CDATA[æœ€çŸ­è·¯ç®—æ³•1â€”â€”Dijkstraæè¿°ä¸æ¸…æ¥šï¼š åœ¨æ—¶é—´å¤æ‚åº¦æœ€åçš„æ€»ç»“ä¸­ï¼Œæˆ‘ä¹‹å‰æåˆ°â€œå¯¹äºç¨ å¯†å›¾æ¥è¯´æœ‰æ—¶ä¸ä¼˜åŒ–æ¯”åˆ©ç”¨æœ€å°å †ä¼˜åŒ–æ›´é«˜æ•ˆâ€ã€‚å®é™…ä¸Šä¸€èˆ¬çš„å›¾ï¼Œç”šè‡³æ˜¯å®Œå…¨å›¾ï¼Œåˆ©ç”¨æœ€å°å †ä¼˜åŒ–æ•ˆç‡éƒ½æ˜¯ä¼˜äºä¸ä¼˜åŒ–çš„ã€‚åªæœ‰ä¸€ç§æƒ…å†µæ˜¯ç›¸åçš„ï¼Œå°±æ˜¯è¾¹ç¡®å®ç‰¹åˆ«å¤šï¼Œæ˜¯é¡¶ç‚¹æ•°çš„é«˜æ¬¡å¹‚ï¼ˆ3ä»¥ä¸Šï¼‰çš„æƒ…å†µã€‚ä¸€èˆ¬æ¥è¯´è¿™ç§å›¾å¾ˆå°‘è§ï¼Œå®Œå…¨å›¾çš„è¾¹æ•°ä¹Ÿå°±æ˜¯é¡¶ç‚¹æ•°çš„å¹³æ–¹é‡çº§çš„ï¼Œå‡ºç°é«˜æ¬¡å¹‚é‡çº§çš„è¾¹åªæœ‰å¯èƒ½æ˜¯æœ‰å­˜åœ¨å¤§é‡é‡è¾¹ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬å¤„ç†çš„æ˜¯æœ€çŸ­è·¯é—®é¢˜æˆ‘ä»¬å¯ä»¥åªä¿ç•™ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æœ€çŸ­çš„è¾¹ï¼Œä»¥æ¶ˆé™¤é‡è¾¹ã€‚ è¡¥å……ï¼š ä¸€èˆ¬çš„æœ€çŸ­è·¯ç®—æ³•ï¼Œè¿˜æœ‰ä¸€ç§é—®æ³•å°±æ˜¯æœ€é•¿è·¯é—®é¢˜ã€‚è¿™ä¸ªå¯ä»¥æŠŠæ‰€æœ‰çš„è¾¹æƒå€¼éƒ½å–ç›¸åæ•°ï¼Œåˆå§‹åŒ–æ—¶å°†distæ•°ç»„åˆå§‹åŒ–ä¸ºæœ€å°å€¼ï¼Œä¸€èˆ¬ä¸ºINT_MINã€‚å°†æ¯”è¾ƒç¬¦åˆå–ç›¸åï¼Œç»“æœå–ç›¸åæ•°ã€‚ C/C++ç¨‹åºä¸­çš„å†…å­˜åˆ†é…é”™è¯¯ï¼š æˆ‘åœ¨â€œè¿è¡Œä¸­çš„å†…å­˜åˆ†é…å›æ”¶æ—¶æœºâ€ä¸­æåˆ°ï¼Œä»£ç æ®µã€æ•°æ®æ®µå’ŒBSSæ®µåœ¨ç¨‹åºåˆšå¼€å§‹è¿è¡Œæ—¶åˆ†é…ã€‚ å®é™…ä¸Šä»£ç æ®µå‡†ç¡®çš„è¯´æ˜¯åœ¨ç¼–è¯‘æ—¶åˆ»åˆ†é…ï¼Œå…¶ä¸­çš„æ•°æ®å†™åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚æ•°æ®æ®µå’ŒBSSæ®µä¸­çš„å±€éƒ¨é™æ€å˜é‡æ˜¯åœ¨ç¬¬ä¸€æ¬¡è¿è¡Œåˆ°å®šä¹‰ä½ç½®åˆ†é…ï¼Œè¿™ä¸ªæˆ‘åœ¨ä¸‹æ–‡æåˆ°ã€‚ é”™è¯¯åŸå› ï¼š è‡ªå·±æƒ³çš„ä¸å¤Ÿæ¸…æ™°ï¼Œè¡¨è¾¾æ—¶ä¸å¤Ÿä¸¥è°¨ã€‚ åŠ¨æ€è§„åˆ’B1â€”â€”01èƒŒåŒ…å’ŒåŠ¨æ€è§„åˆ’B2â€”â€”å®Œå…¨èƒŒåŒ…é”™è¯¯ï¼š å­˜åœ¨ä¸€äº›å­—æ¯å¤§å°å†™é—®é¢˜ï¼Œå¼•èµ·ä¼ªä»£ç æ­§ä¹‰ã€‚ ä¸²åŒ¹é…ç®—æ³•2â€”â€”KMPå±•ç¤ºé—®é¢˜ï¼š ä¾‹å­ä¸­çš„å­—ç¬¦ä¸²å¯¹é½æˆ‘é‡‡ç”¨äº†ç©ºæ ¼å’Œtabå¯¹é½ï¼Œåœ¨ä¸€äº›ä½åˆ†è¾¨ç‡çš„è®¾å¤‡ä¸Šå¯èƒ½å¯¹é½ä¼šæœ‰é”™è¯¯ï¼Œå½±å“ç†è§£ã€‚ æˆ‘æœ¬æƒ³ä»¥å›¾ç‰‡å½¢å¼å±•ç¤ºï¼Œä½†è€ƒè™‘åˆ°ä¾‹å­è¾ƒå¤šã€å›¾ç‰‡æ’ç‰ˆä¸ç¾è§‚ç­‰é—®é¢˜ï¼Œæš‚æ—¶è¿˜æ˜¯ä»¥ç°åœ¨è¿™ç§å½¢å¼ï¼Œä¹‹åå‘ç°ä»€ä¹ˆå¥½çš„æ–¹å¼æˆ‘å†ä¿®æ”¹ã€‚ åšå®¢è®¡åˆ’å¾·å·æ‰‘å…‹çš„å­¦ä¹ ç¬”è®°ä¸€å†delayï¼Œä¸‹å‘¨å‰ä¸€å®šæ›´æ–°ã€‚ å¸Œæœ›å†™ä¸€äº›é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡çš„æ–‡ç« ã€‚å‡†å¤‡å†™å‡ ç¯‡Javaé¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡çš„æ–‡ç« ï¼Œå…³æ³¨è®¾è®¡æ¨¡å¼å’Œä¸€äº›å®ç°æ‰‹æ³•ã€‚è€ŒC++ä¸»è¦è¿˜æ˜¯æƒ³ç ”ç©¶ä¸€ä¸‹å®ƒçš„åº•å±‚å®ç°å’Œå‡†ç¡®çš„æ ‡å‡†å®šä¹‰ç»†èŠ‚é—®é¢˜ã€‚ç»“åˆJava å’Œ C++å­¦ä¹ é¢å‘å¯¹è±¡çš„è®¾è®¡æ¨¡å¼ã€‚ æ•°æ®ç»“æ„å’Œç®—æ³•æ–¹é¢ï¼Œæˆ‘çš„è®¡åˆ’æ˜¯å…ˆå­¦ä¹ ä¸€äº›å¯¹ACMé¢˜ç›®å®ç”¨çš„ç®—æ³•ï¼Œå¯¹å›¾è®ºå’ŒåŠ¨æ€è§„åˆ’æœ‰äº›å…´è¶£ã€‚åŸºç¡€çš„æ•°æ®ç»“æ„ï¼ˆé“¾è¡¨ã€æ ‘â€¦ï¼‰å·²ç»æœ‰ä¸€å®šäº†è§£ï¼Œæš‚æ—¶å…ˆç”¨STLè‹Ÿä½ï¼Œä¹‹åå†ç ”ç©¶å…¶å„ç§å®ç°ç»†èŠ‚ã€‚ä¸€äº›é«˜çº§æ•°æ®ç»“æ„å¹¿æ³›äº†è§£ä¸€ä¸‹ã€‚ é¢˜è§£ï¼Œä¸€ç›´æ²¡æ›´çš„åŸå› æ˜¯ä¸€ç›´æ²¡æœ‰å†™è¿‡é¢˜äº†ï¼Œç”±äºæ—¶é—´ä¸å¤Ÿç”±äºæ‡’æƒ°ã€‚ä¹‹å‰æƒ³å†™ä¸€ç±»é¢˜ç›®ææˆä¸€æ•´ç¯‡å‘å‡ºå»ã€‚ä½†åŒä¸€ç±»é¢˜æˆ‘èƒ½æ‰¾åˆ°çš„æœ‰é™æ„Ÿè§‰ä¸æˆç¯‡å¹…ï¼Œå°±å…ˆå­˜ç€è‰ç¨¿äº†ã€‚ä¹‹åæˆ‘è®¡åˆ’æ˜¯å¯¹äºéš¾åº¦è¾ƒé«˜å’Œæœ‰æ€è€ƒéš¾åº¦çš„é¢˜ç›®å•ç‹¬å‘ï¼Œç®€å•çš„ç®—æ³•åªç»™å‡ºç®€å•æ€è·¯å’Œä»£ç å†™æˆä¸€æ•´ç¯‡æ‰“åŒ…å‘ã€‚ä¹‹åæˆ‘è¿˜è®¡åˆ’å‚åŠ ä¸€äº›çº¿ä¸Šçš„ç«èµ›ï¼Œå†™ä¸€äº›ç«èµ›ä¸­çš„ç»éªŒä½“ä¼šã€‚ å¨±ä¹èŠ‚ç›®ï¼Œä¹‹å‰ä¹°äº†ä¸€å †å¯ä¹å‡†å¤‡åšä¸ªå¯ä¹å¤§è¯„æµ‹ã€‚ä¸€ç›´æ²¡æœ‰å†™ä¹Ÿæ²¡æœ‰å–ï¼ŒåŸå› åœ¨äºæˆ‘ä¸€ç›´å‘ç°æœ‰æ–°çš„å¯ä¹ï¼Œæ€»æƒ³åŠå…¶åä¸€èµ·ä½“éªŒã€‚æˆ‘æƒ³æˆ‘ä¼°è®¡æ˜¯é›†ä¸é½äº†ï¼Œå®åœ¨ä¸è¡Œæˆ‘å°±å¼€ä¸ªç³»åˆ—æ…¢æ…¢ä½“éªŒã€‚è¿™ä¸ªä¹Ÿä¸æ˜¯ä»€ä¹ˆå¤§äº‹ï¼Œæˆ‘å°±çœ‹çœ‹ä»€ä¹ˆæ—¶å€™æœ‰æ—¶é—´æœ‰å¿ƒæƒ…ï¼Œå†™ä¸€äº›å§ã€‚ ä¹¦æ‘˜å’Œç¬”è®°ï¼Œæˆ‘çˆ±ä»€ä¹ˆæ—¶å€™å†™ä»€ä¹ˆæ—¶å€™å†™ï¼ æ·˜å®åº—è®¡åˆ’ï¼Œåº—å·²ç»å¼€å¥½äº†ï¼Œçº¸è¿˜æ²¡æåˆ°ã€‚å¤§æ¦‚ä¾æ—§æ˜¯æ€§å†·æ·¡é£ï¼Œåæ­£ä¹Ÿæ²¡äººä¹°ï¼Œæˆ‘å°±å¼€ä¸ªç©ä¸€ä¸‹ã€‚]]></content>
      <categories>
        <category>æ³› - å…¬å‘Š</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>C</tag>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>å®Œå…¨èƒŒåŒ…</tag>
        <tag>ç®—æ³•</tag>
        <tag>èƒŒåŒ…é—®é¢˜</tag>
        <tag>01èƒŒåŒ…</tag>
        <tag>å…¬å‘Š</tag>
        <tag>è®¡åˆ’</tag>
        <tag>Dijkstra</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ€çŸ­è·¯ç®—æ³•1â€”â€”Dijkstra]]></title>
    <url>%2F2018%2F03%2F23%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°æœ€çŸ­è·¯å¾„é—®é¢˜æœ‰ä¼—å¤šçš„ç®—æ³•ï¼Œå¯¹äºæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„ DFSä¸BFS å°±å¯ä»¥è½»æ¾è§£å†³ã€‚è€Œå¯¹äºæœ‰æƒå›¾æ¥è¯´å°±ç›¸å¯¹å¤æ‚ä¸€äº›ï¼Œæ¥ä¸‹æ¥è¦ä»‹ç»çš„å°±æ˜¯ä¸€ç§æ±‚æœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„çš„ç®—æ³•â€”â€” Dijkstra ç®—æ³•ã€‚éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œçš„ Dijkstra ç®—æ³•è¦æ±‚å›¾ä¸­ä¸èƒ½å‡ºç°è´Ÿå€¼åœˆå’Œè´Ÿæƒè¾¹ï¼Œå‡ºç°è´Ÿå€¼åœˆåœ¨ Dijkstra ç®—æ³•çš„æŸäº›ä¼˜åŒ–ä¸‹ä¼šé€ æˆç¨‹åºçš„æ— é™å¾ªç¯ï¼ˆå¯å¤„ç†ï¼‰ï¼Œè€Œå‡ºç°è´Ÿæƒè¾¹ä¼šå¾—å‡ºé”™è¯¯ç»“æœã€‚ è´Ÿæƒè¾¹çš„é”™ä¾‹ï¼šDijkstra çš„å±€é™ æ€æƒ³æ— æƒå›¾å¯ä»¥è®¤ä¸ºæ˜¯ç‰¹æ®Šçš„æœ‰æƒå›¾ï¼Œåªæ˜¯å®ƒçš„è¾¹æƒå…¨éƒ½ä¸º $1$ ã€‚æƒ³ä¸€æƒ³ BFS æ˜¯æ€ä¹ˆæ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„ï¼Œå®ƒæ˜¯é€šè¿‡ä¸€å±‚ä¸€å±‚çš„æ‰©å±•ï¼ŒæŒ‰ç…§éé€’å‡çš„é¡ºåºå»æ”¶å½•æ¯ä¸ªç‚¹ã€‚Dijkstra ç®—æ³•çš„æ€æƒ³ä¹Ÿæ˜¯æŒ‰ç…§éé€’å‡çš„é¡ºåºæ”¶å½•æ¯ä¸ªç‚¹ï¼Œæœ€ç»ˆæ‰¾åˆ°æœ€çŸ­è·¯å¾„ã€‚ ä¸ BFS ä¸åŒçš„æ˜¯ï¼Œæœ‰æƒå›¾ä¸­ä»€ä¹ˆç®—ä¸€å±‚å‘¢ï¼Ÿå®é™…ä¸Š BFS è¯´æ˜¯æŒ‰å±‚æ‰©å±•ï¼Œå¦ä¸€ç§ç†è§£å¯ä»¥æ˜¯æŒ‰ç…§è·ç¦»çš„ä»è¿‘åˆ°è¿œå»æ‰©å±•ã€‚Dijkstra ç®—æ³•å°±æ˜¯æ¯æ¬¡æ”¶å½•ä¸€ä¸ªè·ç¦»æœ€è¿‘ä¸”æœªè¢«æ”¶å½•çš„ç‚¹ã€‚è¿™é‡Œè¿˜æœ‰ä¸€äº›å°é—®é¢˜ï¼Œæ¯”å¦‚æ”¶è¿›æ¥çš„ç‚¹ä¼šä¸ä¼šå½±å“å…¶ä»–ç‚¹åˆ°èµ·å§‹ç‚¹çš„è·ç¦»ï¼Ÿæ€ä¹ˆåˆå§‹åŒ–ï¼Ÿæ€ä¹ˆæ‰¾å‡ºæœ€è¿‘çš„ç‚¹ï¼Ÿæˆ‘ä»¬å…ˆä¸Šä»£ç ä¹‹åç»™å‡ºç­”æ¡ˆã€‚ å®ç°ä»£ç ï¼šUbuntu Pastebin : https://pastebin.ubuntu.com/p/vfwbH7QHF3/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int MAX_N = 100;int map[MAX_N][MAX_N]; // ä½¿ç”¨é‚»æ¥çŸ©é˜µè¡¨ç¤ºå›¾bool collected[MAX_N]; // æ¯ä¸ªç»“ç‚¹æ˜¯å¦è¢«æ”¶å½•int dist[MAX_N]; // æ¯ä¸ªç»“ç‚¹åˆ°èµ·å§‹ç‚¹çš„è·ç¦»int path[MAX_N]; // æœ€çŸ­è·¯å¾„ä¸­çš„æ¯ä¸ªç»“ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹æ ‡int n; // ç»“ç‚¹ä¸ªæ•°void init() // åˆå§‹åŒ–&#123; memset(collected,false,sizeof(collected)); memset(dist,0x7f,sizeof(dist)); memset(path,-1,sizeof(path));&#125;void Dijkstra(int start)&#123; init(); dist[start] = 0; while(true)&#123; int min = INT_MAX; int min_index = -1; for( int i = 1; i &lt;= n; i++)&#123; if(min &gt; dist[i] &amp;&amp; !collected[i])&#123; min = dist[i]; min_index = i; &#125; &#125; //æ‰¾å‡ºæœ€è¿‘çš„æœªè¢«æ”¶å½•çš„ç‚¹ if(min_index == -1)&#123; //å¦‚æœæ‰¾ä¸åˆ°ï¼Œè·³å‡ºå¾ªç¯ break; &#125; collected[min_index] = true; //å°†è¯¥ç‚¹æ”¶å½•ï¼Œ for( int i = 1; i &lt;= n; i++)&#123; //éå†è¯¥ç‚¹çš„é‚»æ¥ç‚¹ if(map[min_index][i] != -1 &amp;&amp; !collected[i])&#123; int temp = dist[min_index] + map[min_index][i]; if(temp &lt; dist[i])&#123; dist[i] = temp; path[i] = min_index; &#125; &#125; &#125; &#125;&#125; æ ¸å¿ƒæ­¥éª¤ åˆå§‹åŒ–ï¼ˆåŒ…å«æ›´æ–°èµ·å§‹ç‚¹ dist å€¼ï¼‰ æ‰¾åˆ°å¹¶æ”¶å½•æœ€è¿‘çš„æœªè¢«æ”¶å½•çš„ç‚¹ æ›´æ–°è¯¥ç‚¹çš„é‚»æ¥ç‚¹ å¾ªç¯ $1,2$ ç›´è‡³æ‰€æœ‰è¿é€šç‚¹å‡è¢«æ”¶å½• dist æ•°ç»„ä¸­ä¿å­˜ç€ä»€ä¹ˆï¼Ÿå®ƒä¿å­˜çš„æ˜¯ä»èµ·ç‚¹å¼€å§‹ç»è¿‡å·²è¢«æ”¶å½•çš„ç‚¹åˆ°è¾¾æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œåˆå§‹çŠ¶æ€ä¸‹æ²¡æœ‰ä»»ä½•ç‚¹è¢«æ”¶å½•æ‰€ä»¥å…¨ä¸ºæ­£æ— ç©·ã€‚ å½“ç¨‹åºå°†ä¸€ä¸ªæœ€è¿‘çš„ç‚¹æ”¶å½•è¿›æ¥æ—¶ï¼Œè¯¥ç‚¹æ˜¯æœ‰å¯èƒ½ä¼šå½±å“å…¶ä»–çš„ç‚¹åˆ°èµ·å§‹ç‚¹çš„è·ç¦»ã€‚æ¯”å¦‚è¿™ä¸ªå›¾ï¼Œä» $1$ èµ°åˆ° $3$ã€‚æˆ‘ä»¬å…ˆæ”¶å½•äº† $1$ ç‚¹ï¼Œæ›´æ–° $2$ çš„è·ç¦»ä¸º $1$ ï¼Œ$3$ çš„è·ç¦»ä¸º $5$ï¼Œä¸‹ä¸€æ­¥æˆ‘ä»¬å°†æ”¶å½• $2$ ï¼Œæ”¶å½•ä¹‹åå°±ä¼šå½±å“åˆ°å®ƒçš„é‚»æ¥ç‚¹ï¼ˆä¹Ÿå°±æ˜¯ $3$ ï¼‰çš„è·ç¦»ã€‚æˆ‘ä»¬ä¼šæŠŠ $3$ çš„è·ç¦»æ›´æ–°ä¸º $2$ ã€‚è¿™å°±æ˜¯ 36-44 è¡Œçš„æ„ä¹‰ã€‚ åˆå§‹åŒ–é—®é¢˜ï¼š ä¸€å¼€å§‹å°†æ‰€æœ‰ç‚¹çš„è·ç¦»åˆå§‹åŒ–ä¸ºæ­£æ— ç©·ï¼Œå°†è·¯å¾„æ•°ç»„åˆå§‹åŒ–ä¸º $-1$ã€‚å¦‚æœæœ€ç»ˆæŸç‚¹çš„è·ç¦»ä»ä¸ºæ­£æ— ç©·æˆ–è·¯å¾„æ•°ç»„ä»ä¸º $-1$ï¼Œè¯´æ˜è¯¥ç‚¹åˆ°èµ·å§‹ç‚¹ä¹‹é—´ä¸è¿é€šã€‚ é‡è¾¹é—®é¢˜ï¼šå¦‚æœå›¾ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºçš„è¯ä¸ä¼šæœ‰é‡è¾¹é—®é¢˜ï¼Œè€Œé‚»æ¥çŸ©é˜µçš„è¯å¦‚æœä¸¤ç‚¹é—´æœ‰å¾ˆå¤šæ¡è¾¹ï¼Œå®ƒåªä¼šä¿å­˜æœ€åæ’å…¥çš„è¾¹ã€‚å¦‚æœæ˜¯æœ€çŸ­è·¯é—®é¢˜çš„è¯æˆ‘ä»¬å¯ä»¥åœ¨æ’å…¥è¾¹æ—¶æ£€æŸ¥å½“å‰è¿™æ¡è¾¹çš„æƒé‡æ˜¯å¦å°äºä¹‹å‰æ’å…¥çš„è¾¹ï¼Œæ˜¯åˆ™æ’å…¥è¦†ç›–ï¼Œå¦åˆ™ä¸æ’å…¥å½“å‰è¾¹ã€‚ è¾“å‡ºè·¯å¾„é—®é¢˜ï¼šä¸€èˆ¬çš„å¯ä»¥ç”¨ä¸€ä¸ªæ ˆä¾æ¬¡å‹å…¥ path æ•°ç»„ä¸­çš„å€¼ï¼Œå†å°†å®ƒä»¬ä¾æ¬¡å¼¹å‡ºè¾“å‡ºã€‚æœ‰äº›é¢˜ç›®ç»™çš„æ˜¯ä¸€ä¸ªæ— å‘å›¾ä¸”åªé—®èµ·ç‚¹ä¸ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¯ä»¥é¢ å€’èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œpath æ•°ç»„ä¹Ÿå°±è¢«é¢ å€’å°±ä¸ç”¨æ ˆå°±è¾“å‡ºæœ€çŸ­è·¯å¾„äº†ã€‚ ä¼˜åŒ–æˆ‘ä»¬ä¸Šé¢çš„ä»£ç æœ€æµªè´¹æ—¶é—´çš„å°±æ˜¯æ‰¾å‡ºæœªæ”¶å½•çš„ç‚¹ä¸­æœ€è¿‘çš„ç‚¹çš„æ“ä½œï¼Œæ¯æ¬¡éƒ½è¦éå†æ‰€æœ‰çš„ç‚¹å»æŸ¥æ‰¾ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æˆ–æœ€å°å †å»ä¼˜åŒ–å®ƒã€‚æ¥ä¸‹æ¥æˆ‘å…ˆç»™å‡ºåˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–åçš„ä»£ç ï¼Œæ­¤ä»£ç å°†ç”¨é‚»æ¥è¡¨æ¥ä¿å­˜å›¾ä»¥åŒºåˆ«äºä¹‹å‰çš„ä»£ç ï¼Œå¸®åŠ©å¤§å®¶æ›´å¥½çš„äº†è§£ Dijkstra ç®—æ³•çš„å„ç§å®ç°ã€‚ åˆ©ç”¨STLåº“ä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ä»£ç ï¼šUbuntu Pastebin : https://paste.ubuntu.com/p/ttngrNMyf7/123456789101112131415161718192021222324252627282930313233343536373839const int MAX_N = 100;struct edge &#123; int next, weight;&#125;;typedef pair&lt;int ,int&gt; P;vector&lt;edge&gt;G[MAX_N]; //é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾int dist[MAX_N];int path[MAX_N];void Dijkstra(int start)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt;que; //å»ºç«‹ä¸€ä¸ªä»¥å°æ•°å€¼ä¸ºé«˜ä¼˜å…ˆçº§çš„çš„ä¼˜å…ˆé˜Ÿåˆ— dist[start] = 0; que.push(P(0,start)); //å°†èµ·å§‹ç‚¹å…¥é˜Ÿ while(!que.empty())&#123; //å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¯´æ˜æ‰€æœ‰ç‚¹éƒ½å·²è¢«æ”¶å½•ï¼Œç»“æŸè¯¥ç®—æ³• P p = que.top(); que.pop(); int v = p.second; if(dist[v] &lt; p.first)&#123; //å¦‚æœæ‰¾åˆ°çš„èŠ‚ç‚¹ä¸ç¬¦åˆéé€’å‡è§„åˆ™ï¼Œæ‰¾ä¸‹ä¸€ä¸ªé˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ continue; &#125; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(dist[e.next] &gt; dist[v] + e.weight)&#123; dist[e.next] = dist[v] + e.weight; path[e.next] = v; que.push(P(dist[e.next],e.next)); //å°†é‚»æ¥ç‚¹å…¥é˜Ÿ &#125; &#125; &#125;&#125; è¿™é‡Œæˆ‘ä»¬çœ‹åˆ°è·Ÿä¹‹å‰çš„ä»£ç é€»è¾‘å¯èƒ½æœ‰ä¸€äº›ä¸å¤ªä¸€æ ·ï¼ŒæŒ‰ç…§ä¹‹å‰çš„é€»è¾‘ while å¾ªç¯åº”è¯¥æŒ‰ä¸‹é¢çš„æ–¹å¼å®ç°ã€‚1234567891011121314151617181920212223while(!que.empty())&#123; //å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¯´æ˜æ‰€æœ‰ç‚¹éƒ½å·²è¢«æ”¶å½•ï¼Œç»“æŸè¯¥ç®—æ³• P p = que.top(); que.pop(); int v = p.second; collected[v] = true; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(!collected[e.next] &amp;&amp; dist[e.next] &gt; dist[v] + e.weight) &#123; dist[e.next] = dist[v] + e.weight; path[e.next] = v; if(!in_que[e.next])&#123; //åœ¨å®šä¹‰ä¸€ä¸ªå…¨å±€çš„boolæ•°ç»„æ ‡è®°ç‚¹æ˜¯å¦å…¥é˜Ÿ que.push(P(dist[e.next],e.next)); //å°†é‚»æ¥ç‚¹å…¥é˜Ÿ in_que[e.next] = true; &#125; &#125; &#125;&#125; è¿™æ˜¯å¾ˆå¸¸è§çš„ä¸€ç§é”™è¯¯ä¼˜åŒ–ï¼Œæˆ‘ä¹‹å‰ä¹Ÿå†™å‡ºè¿‡è¿™æ ·çš„ä»£ç ã€‚é”™è¯¯æ˜¯å› ä¸ºå·²å…¥é˜Ÿçš„å…ƒç´ æ˜¯æ— æ³•å®æ—¶æ›´æ–°ï¼Œæ— æ³•ä¿è¯æ›´æ–° dist æ•°ç»„æ—¶åŒæ—¶æ›´æ–°é˜Ÿåˆ—ä¸­çš„å…ƒç´ ï¼Œæ‰€ä»¥æˆ‘ä»¬æ”¹ä¸ºå…è®¸ç»“ç‚¹å¤šæ¬¡å…¥é˜Ÿä¸æ”¶å½•å®ƒï¼Œåƒä¹‹å‰çš„ä»£ç è™½ç„¶æ•ˆç‡æœ‰æ‰€ä¸‹é™ä½†ä¿è¯äº†ä»£ç çš„æ­£ç¡®æ€§ã€‚ åˆ©ç”¨æœ€å°å †ä¼˜åŒ–ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–æ—¶é‡åˆ°çš„é—®é¢˜æ˜¯ä¸èƒ½åŠæ—¶æ›´æ–°é˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¿¡æ¯ï¼Œè€Œæœ€å°å †å¯ä»¥å¿«é€Ÿçš„æŸ¥æ‰¾åˆ é™¤å†æ’å…¥å¯ä»¥éšæ—¶æ›´æ–°æƒ³æ›´æ–°çš„ç»“ç‚¹çš„ä¿¡æ¯ï¼Œè§£å†³ä¹‹å‰ä½¿ç”¨STLåº“ä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—æ‰€é‡åˆ°çš„é—®é¢˜ã€‚ä»£ç ï¼šUbuntu Pastebin : https://paste.ubuntu.com/p/thKfPjDRvd/12345678910111213141516171819202122232425262728293031323334353637383940const int MAX_N = 100;struct edge &#123; int next, weight;&#125;;typedef pair&lt;int ,int&gt; P;vector&lt;edge&gt;G[MAX_N]; //é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾int dist[MAX_N];int path[MAX_N];bool collected[MAX_N]; //æ ‡è®°æ¯ä¸ªé¡¶ç‚¹æ˜¯å¦è¢«æ”¶å½•void Dijkstra(int start)&#123; set&lt;P, less&lt;P&gt; &gt; min_heap; //ç”¨ set æ¥ä¼ªå®ç°ä¸€ä¸ªå°æ ¹å †ï¼Œå¹¶å…·æœ‰æ˜ å°„äºŒå‰å †çš„åŠŸèƒ½ã€‚ dist[start] = 0; min_heap.insert(make_pair(0, start)); collected[start] = true; while(min_heap.size())&#123; //å¦‚æœå †ä¸ºç©ºï¼Œè¯´æ˜æ‰€æœ‰ç‚¹éƒ½å·²è¢«æ”¶å½•ï¼Œç»“æŸè¯¥ç®—æ³• auto iter = min_heap.begin(); int v = iter-&gt;second; min_heap.erase(*iter); collected[v] = true; for( int i = 0; i &lt; G[v].size(); i++)&#123; edge e = G[v][i]; if(!collected[e.next] &amp;&amp; dist[e.next] &gt; dist[v] + e.weight) &#123; min_heap.erase(make_pair(dist[e.next], e.next)); //åˆ é™¤ä¹‹å‰æ’å…¥å †ä¸­çš„æ•°æ® dist[e.next] = dist[v] + e.weight; path[e.next] = v; min_heap.insert(make_pair(dist[e.next], e.next)); //æ›´æ–°ä¹‹åé‡ä¿®æ’å…¥è¯¥ç»“ç‚¹ &#125; &#125; &#125;&#125; æ—¶é—´å¤æ‚åº¦åˆ†æ$V$ ä»£è¡¨ç»“ç‚¹çš„ä¸ªæ•°ï¼Œ$E$ ä»£è¡¨è¾¹çš„ä¸ªæ•°ã€‚ å®Œå…¨æ²¡æœ‰ä¼˜åŒ–ï¼šæ¯ä¸ªé¡¶ç‚¹è¢«æ”¶å½•ä¸€æ¬¡ï¼Œæ‰€ä»¥å¤–å±‚çš„ while å¾ªç¯æ˜¯ $O(V)$ çš„ï¼Œwhileä¸­æ¯æ¬¡éœ€è¦éå†ä¸€æ¬¡æ‰€æœ‰çš„é¡¶ç‚¹ï¼Œåˆæ˜¯ä¸€ä¸ª $O(V)$ çš„æ‰«æã€‚å†åŠ ä¸Šæ¯æ¡è¾¹éƒ½è¦è¢«è®¿é—®ä¸€æ¬¡æ—¶é—´å¤æ‚åº¦ä¸º $O(V^2 + E)$ã€‚ åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ï¼šè™½ç„¶èŠ‚ç‚¹ä¼šå¤šæ¬¡å…¥é˜Ÿï¼Œä½†æ¯æ¡è¾¹æœ€å¤šå¯¼è‡´ä¸€æ¬¡å…¥é˜Ÿï¼Œæ‰€ä»¥å…¶æ—¶é—´å¤æ‚åº¦ä¸º $O( E \log E )$ã€‚ åˆ©ç”¨æœ€å°å †ä¼˜åŒ–ï¼šåˆ©ç”¨æœ€å°å †ä¹‹åæˆ‘ä»¬ä¸ç”¨åœ¨å†…å±‚éœ€è¦è¿›è¡Œ $O(V)â€‹$ çš„æ‰«æäº†ï¼Œè·å¾—æœ€è¿‘çš„ç»“ç‚¹çš„æ“ä½œæ—¶é—´å¤æ‚åº¦å˜ä¸º $O(\log V)â€‹$ï¼Œè€Œæ¯æ¬¡æ›´æ–° dist æ•°ç»„çš„æ“ä½œå› ä¸ºè¦åˆ é™¤å†æ’å…¥å †ä¸­å¤æ‚åº¦ä» $O(1)â€‹$ å˜ä¸º $O(\log V)â€‹$ã€‚æ€»ä½“çš„æ—¶é—´å¤æ‚åº¦ä¸º $O( (V + E) \log V )â€‹$ã€‚ å¯¹äºä¸€ä¸ªç¨€ç–å›¾æ¥è¯´åˆ©ç”¨æœ€å°å †åšä¼˜åŒ–åæ•ˆç‡ä¼šé«˜å¾ˆå¤šï¼Œè€Œå¯¹äºä¸€ä¸ªç¨ å¯†å›¾æ¥è¯´ä¸¤è€…æ•ˆç‡æ˜¯å·®ä¸å¤šçš„ã€‚åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„ä¼˜åŒ–æ–¹å¼ç¼–ç¨‹å¤æ‚åº¦ç›¸å¯¹æœ€å°å †ä¼˜åŒ–çš„æ–¹å¼ä¼šä½ä¸€äº›ï¼Œæ–¹ä¾¿å¿«é€Ÿå®ç°è¯¥ç®—æ³•ã€‚ Demo &amp; Keynoteæˆ‘è®²è§£ Dijkstra ç®—æ³•ç”¨çš„è¯¾ä»¶ä¸­é™„æœ‰ç®—æ³•çš„åŠ¨ç”»æ¼”ç¤ºï¼Œå¸Œæœ›å¯¹å¤§å®¶ç†è§£ Dijkstra ç®—æ³•æœ‰æ‰€å¸®åŠ©ã€‚HTMLç‰ˆæœ¬åœ¨ GitHub Pages æ‰˜ç®¡ï¼Œå¯ åœ¨çº¿æ”¾æ˜  æˆ– ä¸‹è½½ã€‚å¦‚éœ€ Keynote ç‰ˆæœ¬è¯·è”ç³»æˆ‘ pazyx728@gmail.comè¯¾ä»¶é‡‡ç”¨ç½²å(BY)-éå•†ä¸šæ€§(NC)-ç›¸åŒæ–¹å¼åˆ†äº«(SA)åè®®å‘å¸ƒï¼Œè¯·å¤§å®¶ç»´æŠ¤äº’è”ç½‘åº•çº¿ã€‚ å‚è€ƒèµ„æ–™ [1]é‚“ä¿Šè¾‰.æ•°æ®ç»“æ„ï¼ˆC++è¯­è¨€ç‰ˆï¼‰[M].åŒ—äº¬:æ¸…åå¤§å­¦å‡ºç‰ˆç¤¾,2013. [2]é™ˆè¶Š.æœ€çŸ­è·¯å¾„ç®—æ³•-è®²ä¹‰.[DB/OL].æ•°æ®ç»“æ„ï¼ˆæµ™æ±Ÿå¤§å­¦ï¼‰,2018. [3]éƒ­ç‚œ.ç¨‹åºè®¾è®¡ä¸ç®—æ³•ï¼ˆäºŒï¼‰ç®—æ³•åŸºç¡€[EB/OL].uml,2017-11-13/2018-11-30.]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ACM</tag>
        <tag>ä¼˜åŒ–</tag>
        <tag>Dijkstra</tag>
        <tag>ä¼˜å…ˆé˜Ÿåˆ—</tag>
        <tag>æœ€çŸ­è·¯å¾„</tag>
        <tag>æœ€å°å †</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€ã€ŠEffective C++ã€‹ è¯»ä¹¦ç¬”è®°ï¼ˆä¸€ï¼‰]]></title>
    <url>%2F2018%2F03%2F16%2Feffective-cpp01%2F</url>
    <content type="text"><![CDATA[æ³¨æ„ï¼è¿™åªæ˜¯æˆ‘çš„è¯»ä¹¦ç¬”è®°ï¼Œå¸®åŠ©æˆ‘è®°å½•ã€‚å…¶ä¸­å¯èƒ½æœ‰ä¸€äº›ä¸ä¸¥è°¨çš„è§£é‡Šæˆ–æ²¡æœ‰åšå¾ˆè¯¦ç»†çš„è§£é‡Šï¼Œå¤§å®¶å­¦ä¹ è¿˜æ˜¯å»ºè®®ç›´æ¥çœ‹ä¹¦ï¼ˆè™½ç„¶ä¹¦ä¸­ä¹Ÿæœ‰ä¸ä¸¥è°¨çš„è§£é‡Šï¼‰ã€‚ è®©è‡ªå·±ä¹ æƒ¯C++æ¡æ¬¾01ï¼šè§† C++ ä¸ºè¯­è¨€è”é‚¦C++ æ˜¯ä¸€ä¸ªå¤šé‡èŒƒå‹ç¼–ç¨‹è¯­è¨€ï¼Œä¸€ä¸ªåŒæ—¶æ”¯æŒè¿‡ç¨‹å½¢å¼ã€å¯¹è±¡å½¢å¼ã€å‡½æ•°å½¢å¼ã€æ³›å‹ç¼–ç¨‹ã€å…ƒç¼–ç¨‹å½¢å¼çš„è¯­è¨€ã€‚ å°† C++ çš„ç†è§£ä¸ºä¸€ä¸ªç”±ç›¸å…³è¯­è¨€ç»„æˆçš„è”é‚¦è€Œéå•ä¸€è¯­è¨€ã€‚è®°ä½ä»¥ä¸‹å››ä¸ªæ¬¡è¯­è¨€ä½ å°±ä¼šå‘ç°C++på®¹æ˜“ç†è§£å¾ˆå¤šã€‚ C++ ä¸»è¦çš„å››ç§æ¬¡è¯­è¨€ï¼š Cï¼šC++ä»¥Cä¸ºåŸºç¡€ï¼ŒåŸºæœ¬çš„è¯­å¥ã€åŸºç¡€æ•°æ®ç±»å‹ã€é¢„å¤„ç†å™¨ç­‰ç­‰éƒ½æ¥è‡ªäº Cï¼Œè®¸å¤šæ—¶å€™ C++ å¯¹é—®é¢˜çš„è§£æ³•å…¶å®ä¸è¿‡å°±æ˜¯é«˜çº§çš„Cè¯­è¨€è§£æ³•ã€‚ Objective-Oriented C++ï¼šC++ è¯ç”Ÿä¹‹åˆå°±æ˜¯æƒ³åœ¨ C è¯­è¨€é«˜æ•ˆçš„åŸºç¡€ä¸Šï¼Œå¢åŠ  Simula è¯­è¨€çš„ç‰¹æ€§ã€‚Classã€å°è£…ã€ç»§æ‰¿ã€å¤šæ€ã€virtual å‡½æ•°ç­‰ç­‰ï¼Œæ”¹å–„äº† C çš„ä»£ç å¯è¯»æ€§ã€å¹¶å‘æ€§ã€ç¼–è¯‘é”™è¯¯çš„æç¤ºç­‰ç­‰ã€‚ Template C++ï¼šæ³›å‹ç¼–ç¨‹ï¼Œå¤§å¤šæ•°ç¨‹åºå‘˜ç»éªŒæœ€å°‘çš„éƒ¨åˆ†ã€‚å®ƒå¸¦æ¥çš„å´­æ–°çš„ç¼–ç¨‹èŒƒå‹ï¼Œæ‰€è°“çš„æ¨¡æ¿å…ƒç¼–ç¨‹ã€‚TMP ç›¸å…³è§„åˆ™å¾ˆå°‘ä¸ C++ ä¸»æµç¼–ç¨‹äº’ç›¸å½±å“ã€‚ STLï¼šSTL æ˜¯ä¸ª Template ç¨‹åºåº“ã€‚å®ƒå¯¹å®¹å™¨ã€è¿­ä»£å™¨ã€ç®—æ³•ã€å‡½æ•°å¯¹è±¡çš„è§„çº¦æœ‰æä½³çš„ç´§å¯†é…åˆä¸åè°ƒã€‚STLæœ‰è‡ªå·±ç‰¹æ®Šçš„åŠäº‹æ–¹å¼ï¼Œå½“ä½ åŒ STL ä¸€èµ·å·¥ä½œï¼Œä½ å¿…é¡»éµå®ˆå®ƒçš„è§„çº¦ã€‚ C++é«˜æ•ˆç¼–ç¨‹å®ˆåˆ™è§†çŠ¶å†µè€Œå˜åŒ–ï¼Œå–å†³äºä½ ä½¿ç”¨C++çš„å“ªä¸€éƒ¨åˆ†ã€‚ æ¡æ¬¾02ï¼šå°½é‡ä»¥ constã€enumã€inline æ›¿æ¢ #defineé™ä½å¯¹ç¼–è¯‘é¢„å¤„ç†çš„ä½¿ç”¨ã€‚ #define çš„ç¼ºç‚¹ï¼š è®©ç¼–è¯‘å™¨çš„é”™è¯¯æç¤ºä¸æ˜“å®šä½ ç¼ºä¹ç±»å‹æ£€æŸ¥ ä¸é‡è§†ä½œç”¨åŸŸï¼Œé™¤éåœ¨æŸå¤„ #undefï¼Œä¸èƒ½ç”¨æ¥å®šä¹‰classä¸“å±å¸¸é‡ï¼Œä¸èƒ½æä¾›ä»»ä½•å°è£… æœªè®°å…¥ç¬¦å·è¡¨ï¼Œå¢å¤§ç›®æ ‡ä»£ç æ–‡ä»¶ æ—§å¼çš„ç¼–è¯‘å™¨ä¸æ”¯æŒâ€œin-class åˆå€¼è®¾å®šâ€ï¼Œå¯ä»¥ç”¨æšä¸¾æ¥æ›¿æ¢å¸¸é‡ã€‚ ç›¸æ¯” constï¼Œenum æ›´åƒ #defineï¼Œå¯ä»¥å¯¹ const å¸¸é‡å–åœ°å€ï¼Œè€Œä¸å¯ä»¥å¯¹ enum çš„åœ°å€ã€‚å¦‚æœä¸æƒ³ç”¨æŒ‡é’ˆå’Œå¼•ç”¨å€¼æŒ‡å‘ä½ çš„æŸä¸ªå¸¸é‡ï¼Œenum å¯ä»¥å¸®åŠ©ä½ å®ç°è¿™ä¸ªçº¦æŸã€‚ å¯¹äºå®å‡½æ•°ï¼Œå¯è¯»æ€§å·®ã€å†™å®å‡½æ•°æ—¶éœ€è¦å°å¿ƒæ³¨æ„å¸¦ä¸Šå¾ˆå¤šæ‹¬å·ï¼Œä¸€ä¸å°å¿ƒå°±ä¼šå‡ºç°éš¾ä»¥æ£€æŸ¥çš„é”™è¯¯ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ inline å…³é”®è¯ä»£æ›¿å®å‡½æ•°ï¼Œæé«˜ä»£ç å¯è¯»æ€§å’Œå®‰å…¨æ€§ã€‚ å¯¹äºå•çº¯å¸¸é‡ï¼Œæœ€å¥½ä»¥ const å¯¹è±¡æˆ– enums ä»£æ›¿ #definesã€‚ å¯¹äºå½¢ä¼¼å‡½æ•°çš„å®ï¼Œæœ€å¥½æ”¹ç”¨ inline å‡½æ•°æ›¿æ¢ #definesã€‚ æ¡æ¬¾03ï¼šå°½å¯èƒ½ä½¿ç”¨ constä»¤å‡½æ•°çš„è¿”å›å€¼ä¸º const ï¼Œå¾€å¾€å¯ä»¥é™ä½å› ç”¨æˆ·é”™è¯¯è€Œé€ æˆçš„æ„å¤–ï¼Œè€Œåˆä¸è‡³äºæ”¾å¼ƒå®‰å…¨æ€§å’Œé«˜æ•ˆæ€§ã€‚ ä¸¤ä¸ªæˆå‘˜å‡½æ•°å¦‚æœåªæ˜¯å¸¸é‡æ€§ä¸åŒå¯ä»¥è¢«é‡è½½ï¼Œä¼ å…¥å‡½æ•°å‚æ•°æ˜¯ const å’Œé const æ—¶è¦åŒºåˆ†å¤„ç†ï¼Œå¦‚åœ¨é‡è½½è¿ç®—ç¬¦ [] æ—¶ï¼Œé const è¦è¿”å›å…¶å•å…ƒçš„å¼•ç”¨ï¼Œconst æ—¶è¦è¿”å›å…¶å•å…ƒçš„ const å¼•ç”¨ã€‚ æˆå‘˜å‡½æ•°æ˜¯ const æ„å‘³ç€å®ƒåœ¨æŸç§ç¨‹åº¦ä¸Šæ˜¯ä¸å¯ä»¥ä¿®æ”¹å¯¹è±¡ä¸­çš„ä»»ä½•æˆå‘˜å˜é‡ï¼Œä½†å¯¹äºæˆå‘˜å˜é‡æ˜¯æŒ‡é’ˆæ—¶ï¼Œå®ƒä¸èƒ½ä¿è¯è¯¥æˆå‘˜å‡½æ•°ä¸ä¿®æ”¹æŒ‡é’ˆæˆå‘˜æŒ‡å‘ä½ç½®çš„æ•°æ®ã€‚ å¯ä»¥ä½¿ç”¨ mutableï¼ˆå¯å˜çš„ï¼‰é‡Šæ”¾æ‰é staic æˆå‘˜å˜é‡çš„ bitwise constness çº¦æŸã€‚ ä¸º const é‡è½½çš„å‡½æ•°ï¼Œä¼šé€ æˆä»£ç å¤åˆ¶çš„æƒ…å†µã€‚å¯ä»¥é€šè¿‡å•ç‹¬å†™ä¸€ä¸ªç§æœ‰å‡½æ•°è¿è¡Œä¸å†²çªçš„éƒ¨åˆ†ï¼Œåªé‡è½½ä¸ const ç›¸å…³çš„éƒ¨åˆ†ã€‚ä¹Ÿå¯ä»¥é€šè¿‡åœ¨ non-consté‡Œç”¨ const_cast å»é™¤ const å±æ€§å†è¿”å›çš„æ–¹å¼å‡å°‘ä»£ç å¤åˆ¶ã€‚ä½†ä¸è¦ç”¨åœ¨ const å‡½æ•°ä¸­è°ƒ non-const å‡½æ•°å†è¿”å›çš„æ–¹å¼å®ç°ï¼Œè¿™æ ·ä¼šè¿èƒŒä½ åœ¨ const ç‰ˆæœ¬ä¸­ç»ä¸æ”¹å˜å…¶å¯¹è±¡çš„é€»è¾‘çŠ¶æ€çš„æ‰¿è¯ºï¼Œå› ä¸º non-const ç‰ˆæœ¬æ²¡æœ‰åšè¿‡æ­¤æ‰¿è¯ºã€‚ å°†æŸäº›ä¸œè¥¿å£°æ˜ä¸º const å¯å¸®åŠ©ç¼–è¯‘å™¨ä¾¦æµ‹å‡ºé”™è¯¯ç”¨æ³•ã€‚constå¯è¢«æ–½åŠ äºä»»ä½•ä½œç”¨åŸŸå†…çš„å¯¹è±¡ã€å‡½æ•°å‚æ•°ã€å‡½æ•°è¿”å›ç±»å‹ã€æˆå‘˜å‡½æ•°ä¸»ä½“ã€‚ ç¼–è¯‘å™¨å¼ºåˆ¶å®æ–½ bitwise constness ï¼Œä½†ä½ å˜å½¢ç¨‹åºæ—¶åº”è¯¥ä½¿ç”¨â€œæ¦‚å¿µä¸Šçš„å¸¸é‡æ€§â€ï¼ˆconceptual constnessï¼‰ã€‚ å½“ const å’Œ non-const æˆå‘˜å‡½æ•°æœ‰ç€å®è´¨ç­‰ä»·çš„å®ç°æ—¶ï¼Œä»¤ non-const ç‰ˆæœ¬è°ƒç”¨ const ç‰ˆæœ¬å¯é¿å…ä»£ç é‡å¤ã€‚ æ¡æ¬¾04ï¼šç¡®å®šå¯¹è±¡è¢«ä½¿ç”¨å‰å·²å…ˆè¢«åˆå§‹åŒ–ä¸è¦æ··æ·†èµ‹å€¼å’Œåˆå§‹åŒ–ï¼Œä¸€å®šè¦åœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­åˆå§‹åŒ–æˆå‘˜ã€‚åœ¨æˆ‘ä¹‹å‰çš„åšæ–‡ C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆäºŒï¼‰æ„é€ å‡½æ•° ä¸­å¯¹æ„é€ å‡½æ•°ä¸­çš„èµ‹å€¼å’Œåˆå§‹åŒ–é—®é¢˜æœ‰ä¸€å®šçš„è§£é‡Šã€‚ ç»§æ‰¿å…³ç³»çš„åˆå§‹åŒ–é¡ºåºï¼šåŸºç±»ï¼ˆbase classesï¼‰æ›´æ—©äºå…¶æ´¾ç”Ÿç±»ï¼ˆderived classesï¼‰è¢«åˆå§‹åŒ–ã€‚ å¯¹äºæŸä¸ªç¼–è¯‘å•å…ƒå†…çš„æŸä¸ª non-local static å¯¹è±¡çš„åˆå§‹åŒ–åŠ¨ä½œä½¿ç”¨äº†å¦ä¸€ä¸ªç¼–è¯‘å•å…ƒå†…çš„æŸä¸ª non-local static å¯¹è±¡ï¼Œå®ƒæ‰€ç”¨åˆ°çš„è¿™ä¸ªå¯¹è±¡å¯èƒ½å°šæœªè¢«åˆå§‹åŒ–ï¼Œå› ä¸º C++ å¯¹â€œå®šä¹‰äºä¸åŒç¼–è¯‘å•å…ƒå†…çš„ non-local static å¯¹è±¡â€ çš„åˆå§‹åŒ–æ¬¡åºå¹¶æ— æ˜ç¡®å®šä¹‰ã€‚å¯ä»¥å°†æœ‰åˆå§‹åŒ–ä¾èµ–çš„å‡ ä¸ª non-local static å¯¹è±¡æ”¾åœ¨ä¸€ä¸ªç¼–è¯‘å•å…ƒè§£å†³ã€‚ ä¹¦ä¸­çš„è§£å†³æ–¹æ¡ˆä¸ºï¼šå°†æ¯ä¸ª non-local static å¯¹è±¡æ¬åˆ°è‡ªå·±çš„ä¸“å±å‡½æ•°å†…ï¼ˆè¯¥å¯¹è±¡åœ¨æ­¤å‡½æ•°å†…è¢«å£°æ˜ä¸º static ï¼‰ã€‚è¿™äº›å‡½æ•°è¿”å›ä¸€ä¸ª reference æŒ‡å‘å®ƒæ‰€å«çš„å¯¹è±¡ã€‚æˆ‘ä»¬å°†è¿™äº›å‡½æ•°ç§°ä¸º reference-returning å‡½æ•°ã€‚ ä¸ºå†…ç½®å‹å¯¹è±¡è¿›è¡Œæ‰‹å·¥åˆå§‹åŒ–ï¼Œå› ä¸º C++ ä¸ä¿è¯åˆå§‹åŒ–å®ƒä»¬ã€‚ æ„é€ å‡½æ•°æœ€å¥½ä½¿ç”¨æˆå‘˜åˆå€¼åˆ—ï¼Œè€Œä¸è¦åœ¨æ„é€ å‡½æ•°æœ¬ä½“å†…ä½¿ç”¨èµ‹å€¼æ“ä½œã€‚åˆå€¼åˆ—åˆ—å‡ºçš„æˆå‘˜å˜é‡ï¼Œå…¶æ’åˆ—æ¬¡åºåº”è¯¥å’Œå®ƒä»¬åœ¨ class ä¸­çš„å£°æ˜æ¬¡åºç›¸åŒã€‚ ä¸ºå…é™¤â€œè·¨ç¼–è¯‘å•å…ƒä¹‹åˆå§‹åŒ–æ¬¡åºâ€é—®é¢˜ï¼Œè¯·ä»¥ local staic å¯¹è±¡æ›¿æ¢ non-local static å¯¹è±¡ã€‚]]></content>
      <categories>
        <category>æ³› - ç¬”è®°</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>è¯»ä¹¦</tag>
        <tag>ç¬”è®°</tag>
        <tag>Effective C++</tag>
        <tag>å¤šé‡èŒƒå‹</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‚è´¨æ•°è¡¨2â€”â€”çº¿æ€§ç­›æ³•]]></title>
    <url>%2F2018%2F03%2F09%2Fisprimes-2%2F</url>
    <content type="text"><![CDATA[åˆæ•°çš„æ ‡å‡†åˆ†è§£æ¯ä¸ªåˆæ•°å¯ä»¥åˆ†è§£è´¨å› æ•°ï¼Œå¯¹äº 60ï¼Œæœ€å°è´¨å› å­ï¼ˆLPFï¼‰ä¸º 2ï¼Œæœ€å¤§è´¨å› å­ï¼ˆGPFï¼‰ä¸º 5ã€‚ æ ¹æ® LPF å’Œ GPFï¼Œå¯ä»¥å°† 60 åˆ†è§£ä¸º 2 * 30 æˆ– 5 * 12ã€‚è¿™é‡Œçš„ 30 ä¸º LPF çš„è¡¥ï¼Œ12 ä¸ºGPFçš„è¡¥ã€‚ æ¬§æ‹‰ç­›å¯¹äº 60 ä¹‹å‰çš„åŸƒæ°ç­›æ³•æœ€å¤§çš„é—®é¢˜å°±æ˜¯åœ¨ 2ã€3ã€5 éƒ½ä¼šåˆ’å»ä¸€æ¬¡ï¼Œæµªè´¹äº†å¾ˆå¤šæ—¶é—´ã€‚æ¬§æ‹‰ç­›çš„æ”¹è¿›æ–¹æ³•å°±æ˜¯ä¿è¯æ¯ä¸ªåˆæ•°åªè¢«åˆ’æ‰ä¸€æ¬¡ã€‚ æšä¸¾æœ€å°è´¨å› å­ï¼ˆLPFï¼‰ï¼ŒæŠŠå®ƒä¸æœªç­›æ‰çš„å„æ•°ç›¸ä¹˜ï¼Œç­›æ‰ä¹˜ç§¯ã€‚ é‚£æ€ä¹ˆæ‰¾åˆ°æœªç­›æ‰çš„æ•°å‘¢ï¼Ÿæˆ‘ä»¬ä¸èƒ½å†ç”¨ä¸€ä¸ª bool æ•°ç»„æ¥ä¿å­˜æ˜¯å¦è¢«ç­›æ‰äº†ï¼Œå› ä¸ºé‚£æ ·ä½ ä¾ç„¶æ˜¯åœ¨éå†æ•°ç»„çœ‹çœ‹é‚£ä¸ªæ•°æ˜¯å¦è¢«åˆ’æ‰ï¼Œå¦‚æœæ²¡æœ‰çš„è¯å°±å°†å®ƒä¸æœ€å°è´¨å› å­çš„ç§¯åˆ’æ‰ã€‚è¿™æ ·è¿˜æ˜¯éå†äº†æ‰€æœ‰çš„æ•°ï¼Œæˆ‘ä»¬åªæƒ³è¦éå†æ²¡æœ‰è¢«åˆ’æ‰çš„æ•°ã€‚ æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ•°æ®ç»“æ„å¯ä»¥é«˜æ•ˆçš„è¿›è¡Œéå†ã€æŸ¥æ‰¾ã€åˆ é™¤æ“ä½œã€‚é“¾è¡¨çš„éå†å’Œåˆ é™¤éƒ½å¯ä»¥æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œä½†æŸ¥æ‰¾è¿‡æ…¢ã€‚ æˆ‘ä»¬ç”¨æ•°ç»„æ¨¡æ‹Ÿé“¾è¡¨æ¥ä¿è¯è¿™ä¸‰ä¸ªæ“ä½œçš„é«˜æ•ˆã€‚12345678910int prev[MAX_N + 2]; //ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼int next[MAX_N + 2]; //ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹çš„å€¼for( int i = 2; i &lt;= N; i++)&#123; //åˆå§‹åŒ– prev[i] = i - 1; prev[i] = i + 1;&#125;next[prev[x]] = next[x];prev[next[x]] = prev[x]; //åˆ é™¤ x èŠ‚ç‚¹çš„æ“ä½œ æ•°ç»„æ¨¡æ‹Ÿçš„é“¾è¡¨çš„å®ç°åŠç›¸å…³æ“ä½œè§£å†³â€œé“¾è¡¨â€é—®é¢˜åï¼Œæˆ‘ä»¬åœ¨åŸƒæ°ç­›æ³•çš„åŸºç¡€ä¸Šæ”¹è¿›åˆ’æ‰çš„æ“ä½œå°±å¯ä»¥ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/CCWTJHjSYJ/123456789101112131415161718192021222324int prev[MAX_N + 2];int next[MAX_N + 2];int euler(int N)&#123; for( int i = 2; i &lt;= N; i++)&#123; prev[i] = i - 1; prev[i] = i + 1; &#125; int nPrimes = 0; for( int p = 2; p * p &lt;= N; p = next[p])&#123; for( int f = p; p * f &lt;= N; f = next[f])&#123; int x = p * f; next[prev[x]] = next[x]; prev[next[x]] = prev[x]; &#125; &#125; for( int p = 2; p &lt;= N; p = next[p])&#123; primes[nPrimes++] = p; &#125; return nPrimes;&#125; ä½†æ­¤ä»£ç æœ‰ä¸ªå¤§BUGï¼Œå› ä¸ºæˆ‘ä»¬åœ¨é€‰å®šä¸€ä¸ª p æ—¶æƒ³åˆ’å»çš„æ˜¯å½“æ—¶åœ¨å®ƒä¹‹åæ²¡æœ‰è¢«åˆ’æ‰çš„æ•°ä¸å®ƒçš„ç§¯ï¼Œä½†é€‰å®š p æ˜¯åœ¨æ‰¾æ²¡æœ‰è¢«åˆ’æ‰çš„æ•°ä¹‹å‰çš„ã€‚ä¼šå‘ç”Ÿè¿™æ ·çš„äº‹æƒ…ï¼Œæ¯”å¦‚æˆ‘ä»¬ p ä¸º 2ï¼Œæˆ‘ä»¬åˆ’æ‰äº† 4ï¼Œé‚£æˆ‘ä»¬å°±æ²¡åŠæ³•é€šè¿‡ 2 * 4 åˆ’æ‰ 8ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œäººä»¬æƒ³å‡ºäº†ä¸¤ç§è§£å†³æ–¹æ¡ˆã€‚ ç¬¬ä¸€ç§ï¼šä»å¤§åˆ°å°çš„å»åˆ’æ‰éœ€è¦åˆ’æ‰çš„æ•°ï¼Œè¿™ä¸ªæ–¹æ¡ˆéœ€è¦è§£å†³çš„é—®é¢˜æ˜¯éœ€è¦å®šä½é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚ ç¬¬äºŒç§ï¼šä¸ºä»€ä¹ˆ 8 ä¸èƒ½é€šè¿‡ 2 * 4 åˆ’æ‰ï¼Œå› ä¸º 8 å­˜åœ¨å¤šä¸ªè´¨å› å­ä¸º 2ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨åˆ’å»p * fæ—¶ï¼Œå¯ä»¥é¡ºä¾¿åˆ’æ‰p * p * fï¼Œp * p * p * fâ€¦â€¦ è§£å†³ã€‚ ç¬¬ä¸€ç§Ubuntu Pastebin : https://paste.ubuntu.com/p/4cPKvKw6ys/ 12345678910111213141516171819202122232425262728int prev[MAX_N + 2];int next[MAX_N + 2];int euler(int N)&#123; for( int i = 2; i &lt;= N; i++)&#123; prev[i] = i - 1; prev[i] = i + 1; &#125; int nPrimes = 0; for( int p = 2; p * p &lt;= N; p = next[p])&#123; primes[nPrimes++] = p; int f = p; while(p * next[f] &lt;= N)&#123; //éå†é“¾è¡¨æ‰¾åˆ°æœ€å¤§çš„f f = next[f]; &#125; while(f &gt;= p)&#123; //åå‘éå†é“¾è¡¨åˆ’å»p * f int x = p * f; next[prev[x]] = next[x]; prev[next[x]] = prev[x]; f = prev[f]; &#125; &#125; return nPrimes;&#125; ç¬¬äºŒç§Ubuntu Pastebin :https://paste.ubuntu.com/p/rnjmh7vTPF/1234567891011121314151617181920212223242526int prev[MAX_N + 2];int next[MAX_N + 2];int euler(int N)&#123; for( int i = 2; i &lt;= N; i++)&#123; prev[i] = i - 1; prev[i] = i + 1; &#125; int nPrimes = 0; for( int p = 2; p * p &lt;= N; p = next[p])&#123; for( int f = p; p * f &lt;= N; f = next[f])&#123; for( int x = p * f; ; x *= p)&#123; next[prev[x]] = next[x]; prev[next[x]] = prev[x]; if(x &gt; N / p) break; //xå¢é•¿è¾ƒå¿«ï¼Œé˜²æ­¢xæº¢å‡º &#125; &#125; &#125; for( int p = 2; p &lt;= N; p = next[p])&#123; primes[nPrimes++] = p; &#125; return nPrimes;&#125; æ—¶é—´å¤æ‚åº¦æ¯ä¸ªæ•°åªè¢«åˆ’æ‰ä¸€æ¬¡æ‰€ä»¥æ˜¯ \(O(N)\)ã€‚ä½†åˆ’æ‰çš„é€Ÿåº¦è¦é€šè¿‡é“¾è¡¨ï¼Œå…¶å®å¯¼è‡´é€Ÿåº¦é€šå¸¸è¿˜ä¸å¦‚åŸƒæ°ç­›æ³•ã€‚ ç©ºé—´å¤æ‚åº¦åªå¼€äº†ä¸¤ä¸ªé“¾è¡¨çš„æ•°ç»„å’Œä¸€ä¸ªprimesæ•°ç»„ï¼Œ\(O(N)\)ã€‚ ç®€æ˜“æ¬§æ‹‰ç­›å†è€ƒè™‘æ¬§æ‹‰ç­›çš„ç¼ºç‚¹ï¼Œå®ƒæ—¶é—´å¤æ‚åº¦å·²ç»è¾¾åˆ°çº¿æ€§ï¼Œä½†é“¾è¡¨æ“ä½œå¤ªæ…¢ã€‚æ€ä¹ˆå¯ä»¥ä¸ä½¿ç”¨é“¾è¡¨å®ç°æ¬§æ‹‰ç­›å‘¢ï¼Ÿ æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦ç”¨åˆ°é“¾è¡¨ï¼Ÿå› ä¸º f æ˜¯åŠ¨æ€å˜åŒ–çš„ã€‚æˆ‘ä»¬æ¢ä¸€ç§æ–¹å¼ï¼Œè€ƒè™‘æšä¸¾LPFçš„è¡¥ä¹Ÿå°±æ˜¯å…ˆæšä¸¾ p ï¼ˆä»è´¨æ•°è¡¨ primes æ•°ç»„ä¸­å–å³å¯ï¼‰å†æšä¸¾ f ã€‚æ ¹æ®LPFçš„å®šä¹‰æˆ‘ä»¬ç»™å®š p åï¼Œf åªéœ€æšä¸¾åˆ°ç¬¬ä¸€ä¸ªæ•´é™¤ p çš„æ•°ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/xfVS3ctQWr/12345678910111213141516171819202122232425bool flag[MAX_N + 1];int simple_euler(int N)&#123; memset(flag, true, (N + 1) * sizeof(bool)); int nPrimes = 0; for( int f = 2; f &lt;= N / 2; f++)&#123; if(flag[f])&#123; primes[nPrimes++] = f; &#125; for( int u = 0; u &lt; nPrimes; u++)&#123; int p = primes[u]; if(p * f &gt; N) break; flag[p * f] = false; if(f % p == 0) break; &#125; &#125; for( int i = N / 2 + 1; i &lt;= N; i++)&#123; if(flag[i])&#123; primes[nPrimes++] = i; &#125; &#125; return nPrimes;&#125; æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯ \(O(N)\)ï¼Œä½†æ²¡æœ‰äº†å¤æ‚æ“ä½œï¼Œæ•ˆç‡ä¼˜äºä¹‹å‰çš„åŸƒæ°ç­›å’Œæšä¸¾LPFçš„æ¬§æ‹‰ç­›ã€‚ ç©ºé—´å¤æ‚åº¦ï¼š \(O(N)\) ä¸æ¬§æ‹‰ç­›ç›¸åŒã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>è´¨æ•°</tag>
        <tag>æ±‚è´¨æ•°è¡¨</tag>
        <tag>ä¼˜åŒ–</tag>
        <tag>æ¬§æ‹‰ç­›æ³•</tag>
        <tag>ç®€æ˜“æ¬§æ‹‰ç­›æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ±‚è´¨æ•°è¡¨1â€”â€”æœ´ç´ ç®—æ³•]]></title>
    <url>%2F2018%2F03%2F08%2Fisprimes-1%2F</url>
    <content type="text"><![CDATA[è¯•é™¤æ³•å¯¹æ¯ä¸ªæ•´æ•° i ï¼Œç”¨ 2 åˆ° \(\sqrt{i}\) çš„æ‰€æœ‰è´¨æ•°å»è¯•é™¤å®ƒã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/wmGwPfGvGW/12345678910111213141516171819int primes[MAX_PRIMES];int trial_division(int N)&#123; int nPrimes = 0; for( int i = 2; i &lt;= N; i++)&#123; bool ok = true; for( int u = 0; u &lt; nPrimes; u++)&#123; int p = primes[u]; if(p * p &gt; i) break; if(i % p == 0)&#123; ok = false; break; &#125; &#125; if(ok) primes[nPrimes++] = i; &#125; return nPrimes;&#125; æ—¶é—´å¤æ‚åº¦\(O(\frac{N\sqrt{N}} { (logN)^2})\) æ£€æŸ¥Nä¸ªæ•°æ¯ä¸ªæ•°æ£€æŸ¥åˆ°å®ƒçš„å¹³æ–¹æ ¹ï¼Œ\(\frac{1}{logN}\) æ˜¯è´¨æ•°çš„å¯†åº¦ï¼Œåªç”¨è´¨æ•°å»è¯•é™¤æ‰€ä»¥ä¹˜ \(\frac{1}{logN}\)ï¼Œåªæœ‰è´¨æ•°å¯ä»¥å®Œå…¨ç»å—ä½è€ƒéªŒå†ä¹˜ \(\frac{1}{logN}\)ã€‚$$O(\frac{N\sqrt{N}} { (logN)^2}) â‰ˆ N^{1.5}$$ ç©ºé—´å¤æ‚åº¦Nä»¥å†…è´¨æ•°çš„å¯†åº¦ä¸º \(\frac{1}{logN}\) ï¼Œæ‰€ä»¥ primes æ•°ç»„éœ€è¦å¼€åˆ° \(\frac{N}{logN}\)ã€‚ åŸƒæ°ç­›æ³•åŸƒæ‹‰æ‰˜è‰²å°¼ç­›é€‰æ³•(the Sieve of Eratosthenes)ç®€ç§°åŸƒæ°ç­›æ³•ï¼Œæ˜¯å¤å¸Œè…Šæ•°å­¦å®¶åŸƒæ‹‰æ‰˜è‰²å°¼(Eratosthenes 274B.C.ï½194B.C.)æå‡ºçš„ä¸€ç§ç­›é€‰æ³•ã€‚ æšä¸¾æ¯ä¸ªå› å­ï¼Œçœ‹å“ªäº›æ•°å¯ä»¥æ•´é™¤å®ƒï¼Œåˆ’æ‰å®ƒã€‚ åŠ¨ç”»æ¼”ç¤ºå›¾ç‰‡æ¥è‡ªç»´åŸºç™¾ç§‘ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/cymfGPHgMW/123456789101112131415161718192021bool flag[MAX_N + 1];int eratosthenes(int N)&#123; memset( flag, true, (N + 1) * sizeof(bool)); for( int p = 2; p * p &lt;= N; p++)&#123; if(flag[p])&#123; for( int x = p * p; x &lt;= N; x += p)&#123; flag[x] = false; &#125; &#125; &#125; int nPrimes = 0; for( int i = 2; i &lt;= N; i++)&#123; if(flag[i])&#123; primes[nPrimes++] = i; &#125; &#125; return nPrimes;&#125; ä¸ºä»€ä¹ˆ x ä» p * p å¼€å§‹å‘¢ï¼Ÿå› ä¸ºæ•° p * (p-i) ( 1 â‰¤ i â‰¤ p ) å·²ç»åœ¨ä¹‹å‰åˆ’æ‰è¿‡äº†ï¼Œæ¯”å¦‚åœ¨æ£€æŸ¥ 3 æ—¶ï¼Œä¸éœ€è¦åˆ’æ‰ 3 * 2 å› ä¸ºåœ¨æ£€æŸ¥ 2 çš„æ—¶å€™å·²ç»åˆ’è¿‡äº†ã€‚ ä¸ºä»€ä¹ˆ p åˆ° \(\sqrt{N}\) æˆªæ­¢ï¼Ÿ å› ä¸ºå†…å±‚å¾ªç¯ä¸­çš„ x æ˜¯ä» p * p å¼€å§‹çš„ï¼Œ\( p &gt; sqrt{N}\) æ—¶å°±ä¸èƒ½åˆ’æ‰æ›´å¤šçš„æ•°äº†ï¼Œæ²¡æœ‰æ„ä¹‰ã€‚ æ—¶é—´å¤æ‚åº¦$$\frac{N}{2} + \frac{N}{3} + \frac{N}{5} + \frac{N}{7} + â€¦â€¦ = O( N loglogN ) $$ è¯æ˜å‚è€ƒ https://www.zhihu.com/question/21105642 https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes ç©ºé—´å¤æ‚åº¦N ä¸ªå•ä½çš„ bool æ•°ç»„ï¼Œç©ºé—´å¤æ‚åº¦ä¸º \(O(N)\) ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>è´¨æ•°</tag>
        <tag>æ±‚è´¨æ•°è¡¨</tag>
        <tag>è¯•é™¤æ³•</tag>
        <tag>åŸƒæ°ç­›æ³•</tag>
        <tag>ä¼˜åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆä¸‰ï¼‰ææ„å‡½æ•°]]></title>
    <url>%2F2018%2F03%2F07%2Fcpp-class-3%2F</url>
    <content type="text"><![CDATA[ææ„å‡½æ•°Destructorææ„å‡½æ•°ä¸æ„é€ å‡½æ•°ç›¸ä¼¼ï¼Œéƒ½æ˜¯ç‰¹æ®Šçš„æˆå‘˜å‡½æ•°ã€‚ä¸åŒåœ¨äºæ„é€ å‡½æ•°ç”¨äºå¯¹è±¡çš„åˆå§‹åŒ–ï¼Œææ„å‡½æ•°ç”¨äºå¯¹è±¡çš„æ¸…ç†å·¥ä½œã€‚ åç§°ä¸º~åŠ ç±»çš„åç§°ï¼Œä¸å¯ä»¥é‡è½½ï¼Œæ— è¿”å›ç±»å‹ã€‚12345678class A&#123;private: int a;public: A():a(10)&#123;&#125; //Açš„æ„é€ å‡½æ•° ~A()&#123;&#125; //Açš„ææ„å‡½æ•°&#125; ä¸æ„é€ å‡½æ•°ç›¸ä¼¼ï¼Œå¦‚æœæˆ‘ä»¬æ²¡æœ‰å®šä¹‰ææ„å‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªä»€ä¹ˆéƒ½ä¸åšçš„ææ„å‡½æ•°ã€‚ ææ„å‡½æ•°çš„è°ƒç”¨æ—¶æœº æ ˆä¸­å®šä¹‰çš„å¯¹è±¡ï¼Œç¦»å¼€ä½œç”¨åŸŸå‰æˆ–ç¨‹åºç»“æŸå‰è°ƒç”¨ã€‚ å †ä¸­å®šä¹‰çš„å¯¹è±¡ï¼Œåœ¨deleteæ—¶è°ƒç”¨ã€‚ ææ„çš„é¡ºåºå¯¹äºæ ˆä¸­ç›´æ¥å®šä¹‰çš„å¯¹è±¡ï¼Œææ„é¡ºåºç”±æ„é€ é¡ºåºå†³å®šã€‚é¡ºåºæ˜¯ä¸€ç§æ ˆçš„æ€æƒ³ï¼Œå…ˆæ„é€ çš„å¯¹è±¡åææ„ã€‚12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123;private: int a;public: A(int i):a(i)//Açš„æ„é€ å‡½æ•° &#123; cout &lt;&lt; a &lt;&lt; " Constructor" &lt;&lt; endl; &#125; ~A()//Açš„ææ„å‡½æ•° &#123; cout &lt;&lt; a &lt;&lt; " Destructor" &lt;&lt; endl; &#125;&#125;;int main()&#123; A a(1); A b(2); return 0;&#125; è¾“å‡ºä¿¡æ¯ä¸ºï¼š12341 Constructor2 Constructor2 Destructor1 Destructor å¯ä»¥çœ‹å‡ºå®ƒæ˜¯ä¸€ç§â€œå…ˆè¿›åå‡ºâ€çš„é¡ºåºå»æ„é€ å’Œææ„ã€‚ å¯¹äºæ²¡æœ‰æ„é€ çš„å¯¹è±¡ï¼Œä¸ä¼šè¿›è¡Œææ„ã€‚ deleteä¸delete[]1234int *p = new int[10];delete p;delete[] p; å¯¹äºä¸Šé¢ä»£ç ä¸­åŸºç¡€æ•°æ®ç±»å‹çš„æ•°ç»„çš„å›æ”¶ç©ºé—´æ¥è¯´ï¼Œåé¢ä¸¤è¡Œçš„deleteæ•ˆæœæ˜¯ä¸€æ ·çš„ã€‚ ä½†å¦‚æœæ˜¯ç”¨æˆ·å®šä¹‰çš„ç±»å‹å°±ä¼šæœ‰æ‰€ä¸åŒã€‚ 1234A *p = new A[10];delete p;delete[] p; åƒè¿™æ ·çš„æƒ…å†µä¸‹ï¼Œç¬¬ä¸‰è¡Œçš„deleteå’Œç¬¬å››è¡Œçš„delete[]éƒ½ä¼šå›æ”¶newæ—¶åˆ†é…çš„ç©ºé—´ï¼Œä½†ç¬¬ä¸‰è¡Œçš„deleteåªä¼šè°ƒç”¨ä¸€æ¬¡Açš„ææ„å‡½æ•°ï¼Œè€Œç¬¬å››è¡Œçš„delete[]ä¼šè°ƒç”¨10æ¬¡Açš„ææ„å‡½æ•°ã€‚ deleteå’Œdelete[]éƒ½ä¼šå›æ”¶ç©ºé—´ï¼Œä½†delete[]ä¼šé€ä¸ªè°ƒç”¨æ¯ä¸ªå¯¹è±¡çš„æ„é€ å‡½æ•°ã€‚ç‰¹åˆ«æ˜¯å¯¹äºæˆå‘˜å‡½æ•°ä¸­æœ‰newæ“ä½œçš„ç±»æ¥è¯´ï¼Œå¿…é¡»åœ¨ææ„å‡½æ•°ä¸­å»deleteï¼Œdeleteæ—¶è¦æ³¨æ„åŒºåˆ†deleteå’Œdelete[]ï¼Œå¦åˆ™å¯èƒ½ä¼šé€ æˆå†…å­˜æ³„æ¼ã€‚]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>ææ„å‡½æ•°</tag>
        <tag>delete</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€è®¸å²‘ï¼šæœ‰æ•ˆè®­ç»ƒä½ çš„ç ”ç©¶èƒ½åŠ›]]></title>
    <url>%2F2018%2F03%2F07%2Fxcxx-02%2F</url>
    <content type="text"><![CDATA[ç ”ç©¶å’Œå­¦ä¹ çš„åŒºåˆ«ä¾é æ¨¡ä»¿è€Œè¿›è¡Œçš„å­¦ä¹ æˆ–è€…è¯´ç»ƒä¹ ï¼Œæœ€é«˜å¢ƒç•Œä¹Ÿå°±æ˜¯è¾¾åˆ°è·Ÿä½ çš„å­¦ä¹ å¯¹è±¡ä¸€æ ·å¥½ï¼Œè€Œè¦è¶…è¶Šå®ƒï¼Œå°±éœ€è¦ç ”ç©¶èƒ½åŠ›äº†ã€‚ æœ‰æ—¶å€™æ˜¯è·å–æ›´æ‰å®çš„çŸ¥è¯†ï¼Œæœ‰æ—¶å€™æ˜¯æŒæ¡æ›´å…ˆè¿›çš„æŠ€èƒ½ã€‚ ä¸å­¦ä¹ ç›¸æ¯”ï¼Œç ”ç©¶ä¸åŒ…å«ç»ƒä¹ ï¼Œç ”ç©¶éœ€è¦æ›´åŠ ä¸»åŠ¨ï¼Œç ”ç©¶çš„æ–‡æœ¬æ›´åŠ å®½æ³›ã€‚ç ”ç©¶ä»…ä»…å¯¹æ–‡æœ¬è¿›è¡Œå‰–æï¼Œè€Œä¸ç”¨å»æŒæ¡æ–‡æœ¬ã€‚ ä¸‰ç§æ„è¯† ä½œå“æ„è¯†ï¼šå»ºç«‹ç ”ç©¶çš„é©±åŠ¨ï¼Œä½œå“æ„è¯†æ˜¯ç ”ç©¶ç²¾ç¥çš„èµ·ç‚¹ã€‚å‘Šè¯‰è‡ªå·±â€œæˆ‘è¦ä»äº‹è¿™ä»¶äº‹äº†â€ï¼Œä¸æ˜¯åšè¿™ä»¶äº‹ï¼Œè€Œæ˜¯ä»äº‹ã€‚ ç›®æ ‡æ„è¯†ï¼šç ”ç©¶çš„è¿‡ç¨‹å½“ä¸­è¦æ—¶åˆ»ç›¯ä½è‡ªå·±åˆå§‹çš„ç ”ç©¶ç›®æ ‡ï¼Œå¹¶æ—¶åˆ»é—®è‡ªå·±ï¼Œæˆ‘æ­£åœ¨åšçš„äº‹æƒ…ä¼šä¸ä¼šå½±å“ç ”ç©¶çš„ä¸»çº¿ã€‚ç”¨ä¸€ç§ä¸Šå¸çš„è§†è§’æ¥ä¿¯è§†æ•´ä¸ªäº‹æƒ…çš„å…¨è²Œï¼Œæ‰èƒ½å®ˆä½ç›®æ ‡ä¸è·‘åã€‚ å±€å¤–æ„è¯†ï¼šé¿å…è¿‡åº¦æ²‰æººäºæ–‡æœ¬ï¼›å¯¹äººçš„ç ”ç©¶è¦å»ç²‰ä¸åŒ–ï¼›é¿å…æƒ…ç»ªåŒ–ã€‚ æœé›†èµ„æ–™ï¼šè¶³é‡ï¼Œä½†èŠ‚åˆ¶è¶³é‡ ä¸»åŠ¨æ€§æ˜¯è¶³é‡çš„ä¿éšœ å®½æ³›æ€§èƒ½è®©ä½ è¯„åˆ¤è¶³é‡çš„ç¨‹åº¦ ç ”ç©¶èµ„æ–™çš„æœé›†åšä¸åˆ°è¶³é‡ï¼Œå¾€å¾€æ˜¯ç ”ç©¶è€…è‡ªå·±çš„ä¸»åŠ¨æ€§ä¸å¤Ÿã€‚è¶…å¼ºçš„ä¸»åŠ¨æ€§æ˜¯èµ„æ–™æœé›†åšåˆ°è¶³é‡çš„ä¿éšœã€‚ è·³å‡ºå•ä¸€ç»´åº¦ï¼Œå¸¦æœ‰ç›®æ ‡æ„è¯†çš„å¤š èŠ‚åˆ¶ é¿å…è¿‡åº¦æ²‰æººäºæ–‡æœ¬ï¼Œé¿å…è·‘é¢˜ å¯¹äººè¿›è¡Œç ”ç©¶çš„æ—¶å€™ï¼Œä¸€å®šè¦å»ç²‰ä¸è¡Œä¸ºã€‚åœ¨æœé›†èµ„æ–™çš„æ—¶å€™è¦å¤šè§†è§’ï¼Œæ±‚å®¢è§‚ â€œæ— æƒ…â€æ˜¯åšç ”ç©¶çš„é«˜è´µå“è´¨ï¼Œæƒ…ç»ªåŒ–æ˜¯åšç ”ç©¶çš„å¤©æ•Œ å¤„ç†èµ„æ–™æŠŠæ¡å¥½ä¸¤ä¸ªé‡è¦çš„æ–¹å‘ï¼Œä¸€ä¸ªæ˜¯æŠ“æœ¬è´¨ï¼Œå¦ä¸€ä¸ªå°±æ˜¯æ‰¾è§„å¾‹ã€‚ æŠ“æœ¬è´¨å°±æ˜¯æ‰¾ä¸åŒï¼Œè¦æ‰¾ä¸åŒå°±éœ€è¦åšå¯¹æ¯”ï¼›ç»™ä½ çš„ç ”ç©¶å¯¹è±¡æ ‘ç«‹ä¸€ä¸ªç›¸ä¼¼å¯¹è±¡æˆ–è€…æ˜¯ç«äº‰å¯¹æ‰‹ï¼Œå»æ‰¾ç ”ç©¶å¯¹è±¡å’Œç±»ä¼¼å¯¹è±¡çš„ä¸åŒã€‚é€šè¿‡ä¸åŒè®¤æ¸…äº‹ç‰©çš„æœ¬è´¨ã€‚ æ‰¾è§„å¾‹åˆ™æ˜¯æ±‚ç›¸ä¼¼ï¼Œè¦æ±‚ç›¸ä¼¼å°±éœ€è¦åšç±»æ¯”ã€‚æ±‚ç›¸ä¼¼ï¼Œæ˜¯ä¸ºäº†æé«˜æ•ˆç‡ï¼Œç¡®ä¿è‡ªå·±æ¥ä¸‹æ¥åœ¨é¢å¯¹è¿™æ ·çš„äº‹ç‰©å’Œç±»ä¼¼äº‹ç‰©çš„æ—¶å€™èƒ½æ›´å¿«åœ°æŠŠæ¡ã€‚æ‰¾åˆ°è§„å¾‹ä»¥æ±‚æ›´å¿«åœ°è®¤æ¸…å®ƒä»¬ã€‚ åˆ›é€ è¾“å‡ºå¦‚æœç ”ç©¶è®©ä½ æœ‰äº†æ–°çš„å‘ç°å’Œæ”¶è·ï¼Œåº”è¯¥æŠŠå®ƒå†™æˆä¸€ç¯‡ç³»ç»Ÿçš„ã€æœ‰æ–‡æœ¬æ”¯æŒçš„ã€é€»è¾‘è®ºè¯ä¸¥å¯†çš„å¥½æ–‡ç« ã€‚è¿™å¯¹ä½ å’Œåˆ«äººéƒ½æœ‰éå¸¸å¤§çš„ä»·å€¼ã€‚ ç”¨å†™ä½œä¿ƒè¿›ä½ çš„ç ”ç©¶ ç”¨å­¦æœ¯çš„æ ‡å‡†æ¥è¦æ±‚è‡ªå·±ã€‚å­¦æœ¯æ€§çš„ä¸‰ä¸ªåŸºæœ¬çš„ç‰¹å¾ï¼Œè¶³å¤Ÿç³»ç»Ÿã€æœ‰ç›¸å…³çš„æ–‡æœ¬æ”¯æ’‘ã€æœ‰ä¸¥å¯†çš„é€»è¾‘è®ºè¯ã€‚ å‚¨å­˜ä¿¡æ¯é‡è¦è¶³å¤Ÿå¤§ï¼Œæ‰€ä»¥è¯´ä¿¡æ¯æœé›†è¦â€œè¶³é‡â€ã€‚ å­¦æœ¯æ€§éœ€è¦æ–‡æœ¬æ”¯æŒã€‚åœ¨ç ”ç©¶çš„è¿‡ç¨‹ä¸­è¦æœ‰è‡ªå·±çš„åˆ¤æ–­ï¼Œä½†è¿™ç§åˆ¤æ–­ä¸èƒ½æ˜¯å‡­æƒ³è±¡çš„ã€‚ å¥½æ–‡ç« è¦æœ‰ä¸¥å¯†çš„é€»è¾‘è®ºè¯ã€‚ ç»™ä½ çš„å†™ä½œæ‰¾ä¸€ä¸ªâ€œå¯¼å¸ˆâ€ï¼Œå¯¼å¸ˆåœ¨å­¦æœ¯ç ”ç©¶ä¸­çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Œä¸€æ–¹é¢æ˜¯ä»–æ¯”ä½ çš„å­¦æœ¯ä¿¡æ¯é‡å’Œæ–‡æœ¬æ”¯æŒèƒ½åŠ›æ›´å¤§ï¼Œå¦ä¸€æ–¹é¢ä»–ä¼šåœ¨ä½ çš„é€»è¾‘è®ºè¯è¿‡ç¨‹ä¸­æŒ‡å‡ºä½ çš„é”™è¯¯ã€‚]]></content>
      <categories>
        <category>æ³› - ç¬”è®°</category>
      </categories>
      <tags>
        <tag>è®¸å²‘</tag>
        <tag>ç¾è²Œå¤§ç‹</tag>
        <tag>å­¦ä¹ </tag>
        <tag>ç ”ç©¶</tag>
        <tag>æœé›†èµ„æ–™</tag>
        <tag>åˆ›é€ </tag>
        <tag>è¾“å‡º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œå…¬å‘Šã€å…³äºé‡‡ç”¨CCåè®®çš„è¯´æ˜]]></title>
    <url>%2F2018%2F03%2F01%2Fcc-by-nc-sa%2F</url>
    <content type="text"><![CDATA[æœ¬åšå®¢å°†é‡‡ç”¨ç½²å(BY)-éå•†ä¸šæ€§(NC)-ç›¸åŒæ–¹å¼åˆ†äº«(SA)åè®®å‘å¸ƒï¼Œå¹¶æ³¨æ˜äºå…³äºâ€¦é¡µé¢ã€‚ ä¸ºä»€ä¹ˆé‡‡ç”¨CCåè®®ï¼Ÿä¹‹å‰çš„æ–‡ç«  åŠ¨æ€è§„åˆ’B1â€”â€”å®Œå…¨èƒŒåŒ… ä¸­å¼•ç”¨äº†ã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹ä¸­çš„ä¸€äº›å†…å®¹ã€‚å› ä¸ºå…¶é‡‡ç”¨äº†ç½²å(BY)-éå•†ä¸šæ€§(NC)-ç›¸åŒæ–¹å¼åˆ†äº«(SA)å‘å¸ƒï¼Œä¸ºäº†éµå®ˆSAæ¡æ¬¾ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸ºäº†ä¿æŠ¤æˆ‘çš„ç‰ˆæƒï¼Œæœ¬åšå®¢å°†é‡‡ç”¨CCåè®®å‘å¸ƒã€‚ åè®®æ‰€æœ‰å…è®¸çš„è¡Œä¸º åˆ†äº« â€“ åœ¨ä»»ä½•åª’ä»‹æˆ–æ ¼å¼ä¸‹å†åˆ†å‘ã€ä¼ æ’­æœ¬åˆ›ä½œã€‚ ä¿®æ”¹ â€“ é‡æ··ã€è½¬æ¢ã€ä¾æ®æœ¬åˆ›ä½œè¿›è¡Œå†åˆ›ä½œã€‚ åªè¦éµå®ˆæ¡æ¬¾è§„å®šï¼Œæˆæƒäººå°†ä¸èƒ½æ’¤å›ä½ ä½¿ç”¨æœ¬åˆ›ä½œçš„è‡ªç”±ã€‚ åè®®æ‰€æœ‰é™åˆ¶çš„è¡Œä¸º ç½²åï¼ˆBYï¼‰ â€“ ä½ å¿…é¡»ä»¥ç»™äºˆå§“åæ ‡æ³¨ï¼Œå¹¶æä¾›æœ¬è®¸å¯è¯çš„é“¾æ¥ã€‚åŒæ—¶ä½ éœ€è¦å£°æ˜å…¬å¼€çš„åˆ›ä½œæ˜¯å¦ç»è¿‡ä¿®æ”¹ã€‚ä½ å¯ä»¥é‡‡ç”¨æ°å½“çš„å½¢å¼å°†ç›¸å…³ä¿¡æ¯è¡¨è¿°å‡ºæ¥ï¼Œä½†ä¸å¾—ä»¥ä»»ä½•å½¢å¼æš—ç¤ºæˆæƒäººå·²æ­£å¼è®¤å¯äº†ä½ ä»¥åŠä½ çš„ä½¿ç”¨è¡Œä¸ºã€‚ éå•†ä¸šæ€§ï¼ˆNCï¼‰ â€“ ä½ ä¸å¾—å°†æœ¬åˆ›ä½œè¿ç”¨äºå•†ä¸šç›®çš„ã€‚ ç›¸åŒæ–¹å¼å…±äº«ï¼ˆSAï¼‰ â€“ å¦‚æœä½ å¯¹æœ¬åˆ›ä½œè¿›è¡Œäº†é‡æ··ã€è½¬æ¢ã€ä¾æ®æœ¬åˆ›ä½œè¿›è¡Œå†åˆ›ä½œï¼Œä½ å¿…é¡»ä¾æ®æœ¬åˆ›ä½œé‡‡ç”¨çš„è®¸å¯è¯æ¥åˆ†å‘ä½ çš„åˆ›ä½œã€‚ ä¸å¾—å¢åŠ é¢å¤–é™åˆ¶ â€“ ä½ ä¸èƒ½å¢è®¾ä»»ä½•æ³•å¾‹é™åˆ¶æˆ–æ˜¯æŠ€æœ¯é™åˆ¶ï¼Œæ¥é™åˆ¶ä»–äººè¿›è¡Œæœ¬è®¸å¯è¯å·²ç»å…è®¸çš„è¡Œä¸ºã€‚]]></content>
      <categories>
        <category>æ³› - å…¬å‘Š</category>
      </categories>
      <tags>
        <tag>å…¬å‘Š</tag>
        <tag>CCåè®®</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ¨æ€è§„åˆ’B2â€”â€”å®Œå…¨èƒŒåŒ…]]></title>
    <url>%2F2018%2F03%2F01%2Fcp-bp%2F</url>
    <content type="text"><![CDATA[é—®é¢˜æœ‰ä¸€ä¸ªå®¹é‡ä¸º V çš„èƒŒåŒ…å’Œ N ç§ç‰©å“ã€‚æ¯ç§ç‰©å“çš„ä»·å€¼ä¸º \(W_i\) ä½“ç§¯ä¸º \(C_i\) ï¼Œæ¯ç§ç‰©å“æœ‰æ— é™ä»¶ï¼Œé—®æœ€å¤§èƒŒåŒ…ä»·å€¼ã€‚ åˆ†ææ­¤é—®é¢˜ä¸01èƒŒåŒ…çš„å·®åˆ«åªåœ¨äºç‰©å“æ˜¯æ— é™ä»¶çš„ï¼Œä½†ç”±äºèƒŒåŒ…å®¹é‡ V çš„é™åˆ¶ï¼Œå®é™…ä¸Šç‰©å“ä¾ç„¶å¯ä»¥ç†è§£ä¸ºæœ‰é™ä»¶ï¼Œåªæ˜¯ä»¶æ•°ä¸å†æ˜¯1è€Œæ˜¯\( âŒŠV/C_iâŒ‹\) ä»¶ã€‚ ç”± åŠ¨æ€è§„åˆ’B0â€”â€”01èƒŒåŒ… ä¸­ç»™å‡ºçš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹åŠ ä»¥ä¿®æ”¹å°±å¯ä»¥å¾—å‡ºå®Œå…¨èƒŒåŒ…çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚\[F[i, v] = max{ F[i âˆ’ 1, v âˆ’ kC_i] + kW_i \ \ |\ \ 0 â‰¤ kC_i â‰¤ v }\]åªéœ€åœ¨01èƒŒåŒ…ä»£ç çš„åŸºç¡€ä¸ŠåŠ ä¸€å±‚å¾ªç¯å³å¯ï¼Œå¯¹äºçŠ¶æ€ \(F[i, v]\) æ±‚è§£çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(V/C_i)\) æ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(N\sum V/C_i)\) ï¼Œè¿™ç§è§£æ³•å®é™…ä¸Šå°±æ˜¯æŠŠæ¯ç§ç‰©å“æ‹†åˆ†ä¸ºå¤šä¸ªç‰©å“è½¬åŒ–ä¸º01èƒŒåŒ…ã€‚ ä¼˜åŒ–0 é¢„å¤„ç†æ•°æ®è‹¥ä¸¤ä»¶ç‰©å“ iã€j æ»¡è¶³ \(C_i â‰¤ C_j ä¸” W_i â‰¥ W_j\) ï¼Œåˆ™å°†å¯ä»¥å°†ç‰©å“ j ç›´æ¥å»æ‰ï¼Œä¸ç”¨è€ƒè™‘ã€‚åœ¨è¿›å…¥ä¸»ç®—æ³•å‰é¢„å¤„ç†ä¸€éç‰©å“æ•°æ®å³å¯ã€‚å¯¹äºéšæœºç”Ÿæˆçš„æ•°æ®ï¼Œè¿™ä¸ªæ–¹æ³•å¾€å¾€ä¼šå¤§å¤§å‡å°‘ç‰©å“çš„ä»¶æ•°ï¼Œä»è€ŒåŠ å¿«é€Ÿåº¦ã€‚ç„¶è€Œè¿™ä¸ªå¹¶ä¸èƒ½æ”¹å–„æœ€åæƒ…å†µçš„å¤æ‚åº¦ï¼Œå› ä¸ºæœ‰å¯èƒ½ç‰¹åˆ«è®¾è®¡çš„æ•°æ®å¯ä»¥ä¸€ä»¶ç‰©å“ä¹Ÿå»ä¸æ‰ã€‚ 1 äºŒè¿›åˆ¶æ€æƒ³ä»»ä½•äºŒè¿›åˆ¶å¯ä»¥è¡¨ç¤ºä»»ä½•åè¿›åˆ¶çš„æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³ä¸€ä¸‹äºŒè¿›åˆ¶æ˜¯å¦‚ä½•è½¬æˆåè¿›åˆ¶çš„å‘¢ï¼Ÿ 101001 å¦‚æœä½ æ‹¿åˆ°ä¸€ä¸ªè¿™æ ·çš„äºŒè¿›åˆ¶æ•°ï¼Œåªéœ€å°†äºŒè¿›åˆ¶ç¬¬ k ä½çš„æ•°ä¹˜ 2 çš„ k-1 æ¬¡æ–¹å†æ±‚å’Œå³å¯ã€‚è¿™æ ·æˆ‘ä»¬å¯ä»¥å‘ç°æ‰€æœ‰çš„æ•°éƒ½å¯ä»¥æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ª 2 çš„ k æ¬¡æ–¹çš„å’Œã€‚ æœ‰äº†ä¸Šé¢çš„ç†è®ºæ”¯æŒï¼Œæˆ‘ä»¬å¯ä»¥ä¸å¿…å°†ç‰©å“ä¸€ä¸ªä¸€ä¸ªæ‹†å¼€æ”¾å…¥èƒŒåŒ…ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬æ‹†æˆè‹¥å¹²ä¸ª2çš„kæ¬¡æ–¹ä¸ªç‰©å“æ‰“åŒ…æ”¾å…¥ã€‚ è¿™æ ·æˆ‘ä»¬å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–åˆ° \(O(log âŒŠV/C_iâŒ‹ )\) ï¼Œæ¯”ä¹‹å‰çš„ \(O(N\sum V/C_i)\) å¥½äº†å¾ˆå¤šã€‚ ä¹‹åçš„å¤šé‡èƒŒåŒ…ä¹Ÿæœ‰åŸºäºæ­¤æ€æƒ³çš„ä¼˜åŒ–ã€‚ 2 O(VN)ä¼ªä»£ç 12for i 1 -&gt; N for j Ci -&gt; V F[i][j] = max&#123;F[j], F[j-Ci] + Wi&#125; çœ‹ä¸Šå»å¥½åƒä¸ 01 èƒŒåŒ…çš„ä¼ªä»£ç å‡ ä¹ä¸€æ ·ï¼Œåªæ˜¯ç¬¬äºŒæ¬¡å¾ªç¯çš„æ–¹å‘åšäº†å˜åŒ–ã€‚ èµ·åˆæˆ‘åœ¨å†™èƒŒåŒ…é¢˜ç›®æ—¶åœ¨ç½‘ä¸Šçœ‹åˆ°è¿™ä¸ªç®—æ³•æ—¶ï¼Œå¾ˆæ˜¯ä¸ç†è§£ã€‚ä¹‹ååœ¨çœ‹å®Œ ã€ŠèƒŒåŒ…é—®é¢˜ä¹è®²ã€‹ çš„è®²è§£å’Œè‡ªå·±æ‰‹åŠ¨è°ƒè¯•å‡ æ¬¡åæ„Ÿè§‰å¾ˆæ·±åˆ»ã€‚æˆ‘è§‰å¾—å¯¹æ­¤ç®—æ³•ä¸ç†è§£çš„å¯ä»¥åœ¨å……åˆ†ç†è§£ 01 èƒŒåŒ…ç®—æ³•åæ‰‹åŠ¨è°ƒè¯•è¿è¡Œè¿™ä¸ªç®—æ³•å»ç†è§£ã€‚ èƒŒåŒ…ä¹è®²ä¸­çš„è§£é‡Šæˆ‘å¾ˆå–œæ¬¢ï¼Œä»¥æˆ‘ç°åœ¨çš„æ–‡é‡‡æˆ‘æ„Ÿè§‰ä¸è¶³ä»¥å†™å‡ºæ›´å¥½çš„è§£é‡Šï¼Œæˆ‘åœ¨æ­¤å¼•ç”¨å…¶ä¸­çš„ä¸€æ®µã€‚ ä¸ºä»€ä¹ˆè¿™ä¸ªç®—æ³•å°±å¯è¡Œå‘¢ï¼Ÿé¦–å…ˆæƒ³æƒ³ä¸ºä»€ä¹ˆ 01 èƒŒåŒ…ä¸­è¦æŒ‰ç…§ v é€’å‡çš„æ¬¡åºæ¥å¾ªç¯ã€‚ è®© v é€’å‡æ˜¯ä¸ºäº†ä¿è¯ç¬¬ i æ¬¡å¾ªç¯ä¸­çš„çŠ¶æ€ \(F[i, v]\) æ˜¯ç”±çŠ¶æ€ \(F[i âˆ’ 1, v âˆ’ Ci]\) é€’æ¨è€Œæ¥ã€‚ æ¢å¥è¯è¯´ï¼Œè¿™æ­£æ˜¯ä¸ºäº†ä¿è¯æ¯ä»¶ç‰©å“åªé€‰ä¸€æ¬¡ï¼Œä¿è¯åœ¨è€ƒè™‘â€œé€‰å…¥ç¬¬ i ä»¶ç‰©å“â€è¿™ä»¶ç­–ç•¥æ—¶ï¼Œä¾æ®çš„æ˜¯ä¸€ä¸ªç»æ— å·²ç»é€‰å…¥ç¬¬ i ä»¶ç‰©å“çš„å­ç»“æœ \(F[i âˆ’ 1, v âˆ’ Ci]\)ã€‚è€Œç°åœ¨å®Œå…¨èƒŒ åŒ…çš„ç‰¹ç‚¹æ°æ˜¯æ¯ç§ç‰©å“å¯é€‰æ— é™ä»¶ï¼Œæ‰€ä»¥åœ¨è€ƒè™‘â€œåŠ é€‰ä¸€ä»¶ç¬¬ i ç§ç‰©å“â€è¿™ç§ç­–ç•¥æ—¶ï¼Œå´æ­£éœ€è¦ä¸€ä¸ªå¯èƒ½å·²é€‰å…¥ç¬¬ i ç§ç‰©å“çš„å­ç»“æœ \(F[i, v âˆ’ Ci]\)ï¼Œæ‰€ä»¥å°±å¯ä»¥å¹¶ä¸”å¿…é¡»é‡‡ç”¨ v é€’å¢çš„é¡ºåºå¾ªç¯ã€‚è¿™å°±æ˜¯è¿™ä¸ªç®€å•çš„ç¨‹åºä¸ºä½•æˆç«‹çš„é“ç†ã€‚ èƒŒåŒ…é—®é¢˜ä¹è®² 2.0 beta1.2 ç¬¬6é¡µ è¿™ä¸ªè§£é‡Šæˆ‘è®¤ä¸ºåªæ˜¯åœ¨äººçš„æ€ç»´å±‚é¢çš„è§£é‡Šï¼ŒçœŸæ­£è¦ç†è§£å®ƒçš„è¿è¡Œè¿‡ç¨‹æˆ‘è§‰å¾—æ²¡æœ‰ä»€ä¹ˆæ¯”è‡ªå·±è·‘å‡ éæ¥çš„å®åœ¨ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>å®Œå…¨èƒŒåŒ…</tag>
        <tag>ç®—æ³•</tag>
        <tag>èƒŒåŒ…é—®é¢˜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ¨æ€è§„åˆ’B1â€”â€”01èƒŒåŒ…]]></title>
    <url>%2F2018%2F02%2F23%2F01-bp%2F</url>
    <content type="text"><![CDATA[é—®é¢˜æœ‰ä¸€ä¸ªå®¹é‡ä¸º V çš„èƒŒåŒ…å’Œ N ä»¶ç‰©å“ã€‚æ¯ä»¶ç‰©å“çš„ä»·å€¼ä¸º \(W_i\) ä½“ç§¯ä¸º \(C_i\) ï¼Œé—®æœ€å¤§èƒŒåŒ…ä»·å€¼ã€‚ åˆ†ææ­¤é—®é¢˜çš„ç‰¹ç‚¹æ˜¯æ¯ä»¶ç‰©å“åªæœ‰ä¸€ä»¶ï¼Œåªèƒ½é€‰æ‹©æ”¾æˆ–ä¸æ”¾ã€‚ åŠ¨æ€è§„åˆ’è®¾è®¡æœ‰ä¸€å®šçš„æ¨¡å¼ï¼Œä¸€èˆ¬åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼Œæˆ‘ä»¬æŒ‰ç…§ä¸€èˆ¬çš„æ¨¡å¼è§£å†³æ­¤é—®é¢˜ã€‚ åˆ’åˆ†é˜¶æ®µï¼šåˆ†è§£ä¸ºå°çš„å­é—®é¢˜ï¼Œç”¨ \(F[i, v]\) è¡¨ç¤ºå‰ i ä»¶ç‰©å“æ”¾å…¥ä¸€ä¸ªå®¹é‡ä¸º v çš„èƒŒåŒ…å¯ä»¥è·å¾—çš„æœ€å¤§ä»·å€¼ã€‚ é€‰æ‹©çŠ¶æ€ï¼šå¯¹ç¬¬ i ä»¶ç‰©å“æ˜¯å¦æ”¾å…¥é€‰æ‹©ã€‚ ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\(F[i, v] = max{ F[iâˆ’1, v], F[iâˆ’1, v âˆ’ C_i] + W_i } \) ç¡®å®šè¾¹ç•Œï¼šå¯¹äºæ¯ä¸ªç‰©å“æˆ‘ä»¬åªéœ€è¦æ›´æ–°å¤§äºç­‰äºå…¶ä½“ç§¯çš„èƒŒåŒ…å®¹é‡çš„çŠ¶æ€ã€‚ å…·ä½“å®ç°ç”±çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºå®ƒæœ‰ä¸¤ä¸ªçŠ¶æ€å‚æ•°ï¼Œæ˜¾ç„¶æˆ‘ä»¬å¼€ä¸€ä¸ªäºŒç»´æ•°ç»„è®°å½•æ¯ä¸ªçŠ¶æ€çš„å€¼ã€‚ ä¸¤å±‚å¾ªç¯ï¼Œå¤–å±‚å¾ªç¯éå†Nç‰©å“ï¼Œå†…å±‚èƒŒåŒ…å®¹é‡çŠ¶æ€ã€‚ ä¼ªä»£ç 12for i 1 -&gt; N for j Ci -&gt; V F[i][j] = max&#123;F[i-1][j], F[i-1][j-Ci] + Wi&#125; ä¼˜åŒ–ç®€å•åˆ†æä¸Šé¢çš„ä¼ªä»£ç å¯ä»¥å¾—å‡ºæ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½ä¸º O(NV)ï¼Œå¯¹äºç©ºé—´å¤æ‚åº¦æˆ‘ä»¬è¿˜å¯ä»¥ä¼˜åŒ–åˆ° O(V)ã€‚ æˆ‘ä»¬è§‚å¯ŸçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œå‘ç°å½“å‰éœ€è¦æ›´æ–°çš„çŠ¶æ€åªä¸ \(i - 1\) è¡Œçš„ä¸€ä¸ªçŠ¶æ€æœ‰å…³ï¼Œæˆ‘ä»¬åªéœ€ä¿ç•™ \(i - 1\) è¡Œä¸­çš„æ•°æ®å³å¯ã€‚ ä¹Ÿå°±æ˜¯æˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªä¸€ç»´å¤§å°ä¸º \(V + 1\) çš„æ•°ç»„ï¼Œæˆ‘ä»¬ä¸æ–­çš„ç»´æŠ¤å®ƒå°±å¯ä»¥å¾—åˆ°æœ€ç»ˆç­”æ¡ˆã€‚è¿™æ ·ç©ºé—´å¤æ‚åº¦å°±å¯ä»¥é™åˆ° O(V)ã€‚ è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™æ ·ä¼˜åŒ–åæˆ‘ä»¬è¦ä»¥é€’å‡çš„é¡ºåºå»éå†è¿™ä¸ªæ•°ç»„ã€‚å› ä¸ºæˆ‘ä»¬éœ€è¦ \(v - C_i\) çš„çŠ¶æ€ï¼Œè¿™ä¸ªçŠ¶æ€æ˜¯åœ¨å½“å‰ v ä¹‹å‰çš„ï¼Œæˆ‘ä»¬ä»¥é€’å‡é¡ºåºå»æ›´æ–°å®ƒæ‰èƒ½å–åˆ° \(i - 1\) è¡Œçš„ \(v - C_i\) çš„çŠ¶æ€æ•°æ®ã€‚ ä¼ªä»£ç 12for i 1 -&gt; N for j V -&gt; Ci F[j] = max&#123;F[j], F[j-Ci] + Wi&#125; åˆå§‹åŒ–é—®é¢˜å¯¹äºèƒŒåŒ…é—®é¢˜ä¸€èˆ¬ä¼šæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯æœ‰è¦æ±‚èƒŒåŒ…â€œæ°å¥½æ”¾æ»¡â€çš„ï¼Œå¦ä¸€ç§æ˜¯æ²¡æœ‰è¦æ±‚çš„ã€‚ æ²¡æœ‰æ­¤è¦æ±‚çš„æˆ‘ä»¬æŠŠFæ•°ç»„å…¨éƒ¨åˆå§‹åŒ–ä¸º 0ï¼Œå› ä¸ºåˆå§‹æ—¶ä¹Ÿå°±æ˜¯ä¸æ”¾ä»»ä½•ä¸œè¥¿æ—¶ï¼Œä»»ä½•å®¹é‡çš„èƒŒåŒ…ä»·å€¼éƒ½ä¸º 0ã€‚ è¦æ±‚â€œæ°å¥½æ”¾æ»¡â€çš„ï¼Œæˆ‘ä»¬å°† F0 åˆå§‹åŒ–ä¸º 0ï¼Œå…¶ä»–çš„å•å…ƒåˆå§‹åŒ–ä¸º -âˆã€‚è´Ÿæ— ç©·è¡¨ç¤ºä¸èƒ½æ°å¥½æ”¾æ»¡ã€‚å› ä¸ºä¸æ”¾ä»»ä½•ä¸œè¥¿æ—¶ï¼Œå®¹é‡ä¸º 0 çš„èƒŒåŒ…ä»·å€¼åˆšåˆšå¥½ä¸º 0ï¼Œå…¶ä»–çš„éƒ½ä¸èƒ½æ”¾æ»¡ã€‚ ä¸ºä»€ä¹ˆæ˜¯ -âˆ è€Œä¸æ˜¯ -1 å‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜å¯ä»¥è‡ªå·±æ¨¡æ‹Ÿè¿è¡Œç†è§£ã€‚ è¿™é‡Œçš„åˆå§‹åŒ–æ–¹æ¡ˆé€‚ç”¨äºå¤§å¤šæ•°èƒŒåŒ…é—®é¢˜ï¼Œä¹‹åçš„èƒŒåŒ…é—®é¢˜è®²è§£å°†ä¸å†è¯´æ˜åˆå§‹åŒ–æ–¹å¼ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
        <tag>ç®—æ³•</tag>
        <tag>èƒŒåŒ…é—®é¢˜</tag>
        <tag>01èƒŒåŒ…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸²åŒ¹é…ç®—æ³•2â€”â€”KMP]]></title>
    <url>%2F2018%2F02%2F22%2Fstrkmp-2%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°ä¹‹å‰çš„è›®åŠ›åŒ¹é…æ³•æ•ˆç‡å¤ªä½ï¼Œè¿™é‡Œæˆ‘ä»¬ä»‹ç»ä¸€ç§æ›´å¥½çš„ä¸²åŒ¹é…ç®—æ³•ã€‚KMPç®—æ³•ï¼Œå®ƒç”±Donald Knuthã€Vaughan Prattã€James H. Morrisä¸‰äººäº1977å¹´è”åˆå‘è¡¨ï¼Œæ•…ä»¥ä¸‰äººå§“æ°å‘½åæ­¤ç®—æ³•ã€‚å®ƒå³ä¾¿æ˜¯åœ¨æœ€åçš„æƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ä¹Ÿå¯ä»¥ä¿è¯åœ¨çº¿æ€§ä»¥å†…ã€‚ æˆ‘å°†ä»ä¹‹å‰çš„è›®åŠ›ç®—æ³•å¼€å§‹ï¼Œåˆ†æè›®åŠ›ç®—æ³•çš„ä¸è¶³ï¼Œæ”¹è¿›å®ƒå¼•å‡ºKMPç®—æ³•ã€‚æ–‡ç« ä¼šæœ‰ä¸€äº›ä¸²çš„æœ¯è¯­ï¼Œæˆ‘åœ¨ä¹‹å‰çš„ä¸€ç¯‡æ–‡ç«  ä¸²åŒ¹é…ç®—æ³•0â€”â€”è›®åŠ›åŒ¹é… ä¸­å·²ç»æœ‰æ‰€ä»‹ç»ã€‚ ä¸ºä»€ä¹ˆæ…¢ï¼Ÿäººä»¬æ˜¯æ€æ ·åŒ¹é…çš„ï¼Ÿæ–‡æœ¬ä¸²ï¼š00000000â€¦00000001 æ¨¡å¼ä¸²ï¼š00001 è¿™æ˜¯è›®åŠ›ç®—æ³•ä¸­æœ€åæƒ…å†µçš„ä¾‹å­ï¼Œè›®åŠ›ç®—æ³•åœ¨åŒ¹é…è¿™ä¸€ç»„å­—ç¬¦ä¸²æ—¶ï¼Œå¤§éƒ¨åˆ†æ—¶é—´éƒ½æ¶ˆè€—åœ¨äº†æ¨¡å¼ä¸²ä¸­çš„å‰å››ä¸ª0ä¸­äº†ï¼Œæ¯è½®åŒ¹é…éƒ½ä¼šåœ¨æ­£ç¡®åŒ¹é…å››ä¸ª0åå› ä¸ºæœ€åé‚£ä¸ª1è€Œå¤±è´¥ã€‚ æˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸ªä¾‹å­ æ–‡æœ¬ä¸²ï¼šabcabcabcabcabcabcabcdabcabc æ¨¡å¼ä¸²ï¼šabcd å¦‚æœç°åœ¨è®©ä½ æ¥åŒ¹é…è¿™ç»„å­—ç¬¦ä¸²ä½ ä¼šæ€ä¹ˆåŒ¹é…å‘¢ï¼Ÿä½ ä¼šåƒè›®åŠ›ç®—æ³•ä¸€æ ·å»é€ä¸ªæ¯”å¯¹å°è¯•å—ï¼Ÿæˆ‘æƒ³å¤§å¤šæ•°äººä¸ä¼šï¼Œå¤§å¤šæ•°äººä¼šå‘ç°æ–‡æœ¬ä¸²ä¸­æœ‰å¾ˆå¤šabcçš„é‡å¤ï¼Œè€Œä¸å»æ¯”å¯¹abcç›´æ¥å»æ‰¾då»åŒ¹é…å®ƒã€‚å½“ç„¶ä½ è¿˜æ˜¯è¦æ‰«æè¿‡ä¸€è¾¹æ–‡æœ¬ä¸²ï¼Œè¿™æ ·æ¯”è›®åŠ›ç®—æ³•çœæ—¶é—´çš„åŸå› æ˜¯åœ¨äºä½ ä¸ç”¨åœ¨é€ä¸ªçš„æ¯”å¯¹å‰ä¸‰ä¸ªabcï¼Œè€Œä¸”æ¯æ¬¡å³ç§»3ä¸ªå•ä½ï¼Œå¯ä»¥å°†æ¨¡å¼ä¸²å¿«é€Ÿå³ç§»è€Œä¸”çœå»å¾ˆå¤šæ¯”å¯¹æ“ä½œã€‚ æˆ‘ä»¬å†å†æ¥çœ‹ä¸€ä¸ªä¾‹å­ æ–‡æœ¬ä¸²ï¼šabcdabcfghijk æ¨¡å¼ä¸²ï¼šabcdaf æˆ‘ä»¬ç°åœ¨ç”¨è›®åŠ›ç®—æ³•æ¥åŒ¹é…è¿™ç»„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬ä»¥å¼€å§‹å‡è®¾æ–‡æœ¬ä¸²ä¸­ç¬¬ä¸€ä¸ªaä¸ºæ¨¡å¼ä¸²çš„å¤´ï¼Œé€ä¸ªå»æ¯”å¯¹åç»­å­—ç¬¦ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³åˆ°æ¨¡å¼ä¸²ä¼šåœ¨ç¬¬äºŒä¸ªbå¤„æ¯”å¯¹å¤±è´¥ï¼Œæ¥ä¸‹å»æˆ‘ä»¬ä¼šå‡è®¾æ–‡æœ¬ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªbä¸ºæ¨¡å¼ä¸²çš„å¤´å†å»é€ä¸ªæ¯”å¯¹ã€‚å®é™…ä¸Šæ²¡æœ‰å¿…è¦ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„æ¯”å¯¹ä¸­å·²ç»éå†äº†æ–‡æœ¬ä¸²ä¸­çš„å‰äº”ä¸ªå­—ç¬¦ï¼Œå·²ç»çŸ¥é“å®ƒä»¬éƒ½æ˜¯ä»€ä¹ˆäº†ï¼Œä¸ºä»€ä¹ˆè¿˜è¦å»å°è¯•bå‘¢ï¼Ÿèªæ˜çš„äººåº”è¯¥ç›´æ¥å‡è®¾æ–‡æœ¬ä¸²ä¸­ç¬¬äºŒä¸ªaä¸ºæ¨¡å¼ä¸²çš„å¤´å†å»é€ä¸ªæ¯”å¯¹ã€‚ è®¡ç®—æœºçš„è®°å¿†åŠ›è®¡ç®—æœºæ¯•ç«Ÿä¸æ˜¯äººï¼Œé‚£æˆ‘ä»¬æ¥åˆ†æäººæ˜¯æ€æ ·åšåˆ°å¿«é€ŸåŒ¹é…çš„ï¼Œèƒ½å¦è®©è®¡ç®—æœºæ¨¡ä»¿äººçš„æ€ç»´å»æ”¹è¿›ä¹‹å‰çš„ç®—æ³•å‘¢ï¼Ÿ æ–‡æœ¬ä¸²ï¼šabcdabcfghijk æ¨¡å¼ä¸²ï¼šabcdaf è¿˜æ˜¯è¿™ä¸ªçš„ä¾‹å­ï¼Œä¸ºä»€ä¹ˆä¸ç”¨å†å»å°†bcdå‡è®¾ä¸ºæ¨¡å¼ä¸²çš„å¤´äº†å‘¢ï¼Ÿè¿™ä¸ªæ˜¾è€Œæ˜“è§ï¼Œå½“ç„¶æ˜¯å› ä¸ºbcdä¸æ˜¯aå‘—ã€‚è¿™ä¸ªå¾ˆç®€å•è®¡ç®—æœºä¹Ÿæ˜¯çŸ¥é“çš„å•Šï¼Œä¸ºä»€ä¹ˆå®ƒæ²¡æœ‰è·³è¿‡å‘¢ï¼Ÿå› ä¸ºè®¡ç®—æœºè®°ä¸ä½å•Šï¼Œå®ƒè®°å¿†åŠ›å¤ªå·®ï¼Œåœ¨è›®åŠ›ç®—æ³•çš„è¿‡ç¨‹ä¸­è®¡ç®—æœºåªå…³æ³¨å½“å‰æ¯”å¯¹çš„ä¸¤ä¸ªå­—ç¬¦ï¼Œå…¶ä»–çš„ä¸€æ¦‚ä¸å…³å¿ƒã€‚åœ¨è¦é€‰æ‹©å‘å³ç§»å‡ ä¸ªå•ä½æ—¶ï¼Œå®ƒæƒ³äº†æƒ³è¯´â€œæˆ‘ä¹Ÿä¸çŸ¥é“ï¼Œä¿é™©ä¸€ç‚¹ç§»åŠ¨ä¸€ä¸ªå•ä½è¯•ä¸€ä¸‹å§ã€‚â€ ä½œä¸ºäººç±»ï¼Œæˆ‘ä»¬å½“ç„¶å¯ä»¥èµ‹äºˆè®¡ç®—æœºè®°å¿†åŠ›ï¼Œå®ƒå·²ç»æœ‰äº†ä¼˜è¶Šçš„æ¡ä»¶ï¼ˆå¾ˆå¤§çš„å†…å­˜ï¼‰ï¼Œåªéœ€è¦æˆ‘ä»¬å¸®åŠ©å®ƒä¸€ä¸‹ï¼Œè¦æ±‚å®ƒè®°ä½è¿™äº›ä¸œè¥¿å°±å¥½äº†ã€‚ æˆ‘ä»¬è§‚å¯Ÿ abcda è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œå®ƒçš„å‰ç¼€aå’Œåç¼€aæ˜¯ä¸€æ ·çš„ï¼Œå¦‚æœè®¡ç®—æœºçŸ¥é“è¿™ä»¶äº‹ï¼Œå®ƒå°±å¯ä»¥å°†ä¸¤ä¸ªå­—ç¬¦ä¸²å‘ä¸‹é¢çš„ä½ç½®å¯¹å…¶ç»§ç»­æ¯”å¯¹ï¼Œä»bå¼€å§‹æ¯”å¯¹ï¼Œå› ä¸ºåœ¨ abcda ä¸­æœ‰ä¸€ä¸ªç›¸åŒçš„å‰ç¼€åç¼€ã€‚ abcdabcfghijk â€”â€”-abcdaf æ€ä¹ˆè®©è®¡ç®—æœºçŸ¥é“è¿™ä»¶äº‹å‘¢ï¼Ÿæˆ‘ä»¬å¼€ä¸€ä¸ªæ•°ç»„int next[P.length()]ï¼Œæ¯ä¸ªå•å…ƒä¿å­˜è¯¥å­—ç¬¦å‰çš„å­—ç¬¦ä¸²çš„æœ€å¤§ç›¸åŒå‰åç¼€çš„é•¿åº¦ï¼Œå¯¹äºåˆšåˆšé‚£ä¸ªæ¨¡å¼ä¸²çš„ç¬¬5å·ä½båœ¨nextæ•°ç»„ä¸­çš„å€¼å°±åº”è¯¥ä¸º1ã€‚ åœ¨æ¯”å¯¹ä¹‹å‰æˆ‘ä»¬åªéœ€è¦é¢„å¤„ç†æ¨¡å¼ä¸²å¾—åˆ°nextæ•°ç»„çš„å€¼å³å¯ã€‚ä¸ºä»€ä¹ˆåªéœ€è¦å¤„ç†æ¨¡å¼ä¸²ï¼Ÿæœ‰äº›äººä¼šæƒ³æˆ‘ä»¬æ˜æ˜æ˜¯åœ¨æ–‡æœ¬ä¸²ä¸­æ¯”å¯¹ä¸ºä»€ä¹ˆåªéœ€è¦é¢„å¤„ç†æ¨¡å¼ä¸²ã€‚æˆ‘ä»¬æ¥çœ‹ä¸Šé¢ç»¿è‰²æ ‡æ³¨çš„ä½ç½®ï¼Œåœ¨æ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²ä¸­ä¸¤è€…æ˜¯ä¸€æ¨¡ä¸€æ ·çš„ï¼Œå› ä¸ºå®ƒä»¬æ˜¯æ¯”å¯¹æˆåŠŸçš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬åªéœ€è¦å¤„ç†æ¨¡å¼ä¸²å°±å¯ä»¥çŸ¥é“åº”è¯¥å°†æ¨¡å¼ä¸²çš„å¤´ç§»åˆ°æ–‡æœ¬ä¸²çš„ä»€ä¹ˆä½ç½®ã€‚ æ€æ ·é¢„å¤„ç†å‘¢ï¼Ÿåªéœ€è¦æ¨¡å¼ä¸²è‡ªå·±å’Œè‡ªå·±åšä¸€æ¬¡åŒ¹é…å³å¯ï¼Œå…·ä½“çš„ç­‰æ¥ä¸‹æ¥ä¸Šäº†ä»£ç å†åšä»‹ç»ã€‚ åˆ°æ­¤æˆ‘ä»¬å·²ç»å¤§æ¦‚äº†è§£äº†KMPç®—æ³•çš„æ€æƒ³å’Œå¤§è‡´å®ç°æ–¹å¼ã€‚ å°‘åºŸè¯ï¼Œä¸Šä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/p/9wZ3gyZCnP/12345678910111213141516171819202122232425262728293031323334int* buildNext(string P) &#123; int size_n = P.length(), j = 0; //ä¸»æŒ‡é’ˆ int* N = new int[size_n]; //å»ºè¡¨ int t = N[0] = -1; //æ¨¡å¼ä¸²æŒ‡é’ˆï¼ˆp[-1]ä¸ºé€šé…ç¬¦ï¼‰ while(j &lt; size_n -1)&#123; if(0 &gt; t || P[j] == P[t])&#123; N[++j] = ++t; &#125;else&#123; t = N[t]; &#125; &#125; return N;&#125;int match(string P, string T)&#123; int *next = buildNext(P); //æ„é€ nextè¡¨ int size_n = T.length(), i = 0; int size_m = P.length(), j = 0; while( j &lt; size_m &amp;&amp; i &lt; size_n)&#123; //ä»å·¦å‘å³é€ä¸ªæ¯”å¯¹å­—ç¬¦ if(0 &gt; j || T[i] == P[i])&#123; i++; j++;&#125; //è‹¥åŒ¹é…ï¼Œåˆ™è½¬åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦ else&#123; j = next[j];&#125; //å¦åˆ™ï¼ŒTä¸å›é€€ï¼Œæ–‡æœ¬ä¸²På³ç§» &#125; delete[] next; //é”€æ¯nextè¡¨ return i - j;&#125; å¯¹äºä¸»å‡½æ•°ä¸è›®åŠ›åŒ¹é…ç®—æ³•å‡ ä¹æ˜¯ä¸€æ ·çš„ï¼Œæ–‡æœ¬ä¸²På³ç§»æ—¶ç”¨åˆ°äº†nextæ•°ç»„ã€‚å¦‚æœä¸ç†è§£è¿™ä¸€æ­¥çš„è¯å¯ä»¥è‡ªå·±ç”¨çº¸ç¬”æ¨¡æ‹ŸåŒ¹é…ï¼Œåº”è¯¥å¯ä»¥ç†è§£ã€‚ ç°åœ¨é—®é¢˜çš„å…³é”®åœ¨äºæ„é€ nextæ•°ç»„çš„buildNextè¿™ä¸ªå‡½æ•°çš„å®ç°ã€‚ nextæ•°ç»„çš„æ„é€ è¿™é‡Œçš„æ€æƒ³ä¸KMPçš„ä¸»å‡½æ•°æ€æƒ³æ˜¯ä¸€è‡´çš„ï¼Œåªä¸è¿‡è¿™æ¬¡åŒ¹é…çš„å­—ç¬¦ä¸²æ˜¯ä¸¤ä¸ªä¸€æ ·çš„æ¨¡å¼ä¸²ã€‚ æˆ‘ä»¬é‡‡ç”¨é€’æ¨ç­–ç•¥ï¼Œå‡è®¾æˆ‘ä»¬å·²ç»æ„é€ äº†nextæ•°ç»„çš„å‰ j é¡¹ï¼Œå¦‚ä½•è®¡ç®—å®ƒçš„ j+1 é¡¹å‘¢ï¼Ÿ å¦‚æœ P[j] == P[N[j]] ï¼Œè¯´æ˜å‰ç¼€å’Œåç¼€åˆæ¯”å¯¹ä¸Šä¸€é¡¹ï¼ŒN[j]å°±ç­‰äºä¸Šä¸€é¡¹çš„å€¼åŠ 1ã€‚ å¦‚æœ P[j] != P[N[j]] ï¼Œè¯´æ˜è¯¥åç¼€å˜çŸ­äº†ï¼Œé‚£åº”è¯¥æ€ä¹ˆæ‰¾ä¸‹ä¸€ä¸ªæœ‰å¯èƒ½æˆä¸ºç›¸åŒå‰åç¼€çš„ä½ç½®å‘¢ï¼Ÿè¿™ä¸ªå¦‚æœç°åœ¨tæ‰€æŒ‡ä½ç½®ä¸ºä¸€ä¸ªå‰ç¼€çš„æœ«å°¾ï¼Œè¯¥ä½ç½®åŒ¹é…å¤±è´¥äº†ã€‚æˆ‘ä»¬åº”è¯¥ä¿è¯ j ä¸åŠ¨ï¼Œå°†tæ›¿æ¢ä¸ºnext[t]ï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰tæ‰€åœ¨å‰ç¼€çš„å‰ç¼€çš„æœ«å°¾ç»§ç»­ä¸ j æ‰€æŒ‡çš„ä½ç½®æ¯”å¯¹ã€‚ å“¨å…µå¤§å®¶æˆ–è®¸æœ‰ç–‘é—®ï¼Œtä¸ºä»€ä¹ˆè¦åˆå§‹åŒ–ä¸º0ï¼Ÿifè¯­å¥ä¸­0 &gt; tè¿™ä¸ªæ¡ä»¶æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ è¿™ä¸ª-1å®é™…ä¸Šæ˜¯ä¸€ä¸ªå“¨å…µï¼Œæˆ‘ä»¬æƒ³è±¡nextæ•°ç»„æœ‰next[-1]è¿™ä¸ªå•å…ƒï¼Œå®ƒé‡Œé¢æ”¾ç€ä¸€ä¸ªé€šé…ç¬¦ã€‚å®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬åœ¨ç¨‹åºé‡Œé¢çœå»ä¸€ä¸ªåˆ¤æ–­åˆ†æ”¯ã€‚å¦‚æœä¸ç†è§£ä¸€æ ·æ˜¯å¯ä»¥ç”¨çº¸ç¬”æ¨¡æ‹Ÿä¸€ä¸‹ã€‚ ä¼˜åŒ– ä¼˜åŒ– ä¼˜åŒ–â€¦æˆ‘ä»¬å†å†å†æ¥çœ‹ä¸€ä¸ªä¾‹å­ æ–‡æœ¬ä¸²ï¼š000100001 æ¨¡å¼ä¸²ï¼š00001 å¦‚æœç”¨ä¹‹å‰ç»™å‡ºçš„ç®—æ³•è¿è¡Œï¼Œå®ƒä¼šåœ¨ç¬¬ä¸€ä¸ª1å¤„åŒ¹é…å¤±è´¥ï¼Œä¹‹åå†ç”¨å‰ä¸€ä¸ª0æ¯”å¯¹ä¾ç„¶å¤±è´¥ï¼Œæ¯”å¯¹3æ¬¡åé‡åˆ°-1å¤„çš„é€šé…ç¬¦åæˆåŠŸåŒ¹é…ï¼Œæ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²çš„æŒ‡é’ˆåŒæ—¶å‘å³ç§»åŠ¨ä¸€ä½ï¼Œå†ä»æ–‡æœ¬ä¸²çš„ç¬¬4ä¸ªå•å…ƒå¼€å§‹æ¯”å¯¹ã€‚ è¿™ä¸ªå¥½åƒè¿˜æ˜¯æœ‰ç‚¹å‚»å•Šï¼Œäººä¸ä¼šè¿™æ ·æ— ç”¨çš„ç”¨1å’Œ0æ¯”å¯¹3æ¬¡ã€‚è¿™3æ¬¡æ¯”å¯¹å®é™…ä¸Šæ˜¯å¯ä»¥ä¼˜åŒ–æ‰çš„ã€‚å®é™…ä¸ŠKMPç®—æ³•ä¸»å‡½æ•°çš„ä¸»è¦æ˜¯å—nextæ•°ç»„çš„å½±å“çš„ï¼Œæˆ‘ä»¬åªéœ€è¦æ”¹è¿›buildNextå‡½æ•°å³å¯ã€‚æ”¹è¿›åçš„bulidNextå‡½æ•°å¦‚ä¸‹ï¼šUbuntu Pastebin : https://paste.ubuntu.com/p/RftpTzKsVX/123456789101112131415161718int* buildNext(string P) &#123; int size_n = P.length(), j = 0; //ä¸»æŒ‡é’ˆ int* N = new int[size_n]; //å»ºè¡¨ int t = N[0] = -1; //æ¨¡å¼ä¸²æŒ‡é’ˆï¼ˆp[-1]ä¸ºé€šé…ç¬¦ï¼‰ while(j &lt; size_n -1)&#123; if(0 &gt; t || P[j] == P[t])&#123; j++; t++; N[j] = P[j] != P[t] ? t : N[t]; //* &#125;else&#123; t = N[t]; &#125; &#125; return N;&#125; è¿™æ ·ä¼˜åŒ–åå¯¹äºä¸Šé¢çš„ä¾‹å­å°±ä¸ä¼šå‡ºç°å¤šæ¬¡çš„é‡å¤æ¯”å¯¹ï¼Œä¸€æ¬¡æ¯”å¯¹å¤±è´¥åï¼Œæ¨¡å¼ä¸²ä¼šæ•´ä½“å³ç§»4ä¸ªå•ä½ç»§ç»­æ¯”å¯¹ã€‚ æ•´ä½“å¤æ‚åº¦åˆ†æä¸»å‡½æ•°ä¸­çš„æŒ‡å‘æ–‡æœ¬ä¸²çš„æŒ‡é’ˆ i ä¸€ç›´åœ¨é€’å¢ï¼Œå³ä¾¿æ˜¯åœ¨æœ€åæƒ…å†µä¸‹ä¸»å‡½æ•°ä¸­çš„whileå¾ªç¯ä¸è¿‡æ‰§è¡Œäº†T.length()æ¬¡ï¼Œæ˜¯çº¿æ€§çš„å¤æ‚åº¦ã€‚ å¯¹äºbuildNextå‡½æ•°ï¼Œå®ƒä¸ä¸»å‡½æ•°æ€æƒ³æ˜¯ä¸€è‡´çš„ï¼Œå¤æ‚åº¦ä¹Ÿæ˜¯çº¿æ€§çš„ã€‚ æ‰€ä»¥æ•´ä½“çš„å¤æ‚åº¦å°±æ˜¯ O(P.length() + T.length())ã€‚ ä¸€èˆ¬ P.length() æ˜¯è¿œè¿œå°äº T.length() çš„æ‰€ä»¥å®ƒçš„å¤æ‚åº¦å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚æœ€ç»ˆå¤æ‚åº¦ä¸ºO(T.length())ã€‚å¾—å‡ºç»“è®ºï¼šKMPç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹ä¹Ÿèƒ½ä¿è¯å¤æ‚åº¦åœ¨çº¿æ€§ä»¥å†…ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ä¼˜åŒ–</tag>
        <tag>KMP</tag>
        <tag>ä¸²åŒ¹é…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸²åŒ¹é…ç®—æ³•1â€”â€”è›®åŠ›åŒ¹é…]]></title>
    <url>%2F2018%2F02%2F21%2Fstrma-1%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°ä¸²åŒ¹é…é—®é¢˜æœ‰å¾ˆå¤šçš„ç®—æ³•ï¼Œæˆ‘ä»¬è¿™é‡Œè¦ä»‹ç»çš„è›®åŠ›åŒ¹é…æ³•åœ¨åº”ç”¨ä¸­ä¸€èˆ¬ä¸ä¼šç”¨åˆ°ï¼Œå› ä¸ºå®ƒçš„æ•ˆç‡ç›¸å¯¹åé¢é«˜çº§çš„ç®—æ³•æ˜¯å¾ˆä½çš„ã€‚ä½†åç»­é«˜çº§çš„ç®—æ³•éƒ½å¯ä»¥ç†è§£ä¸ºåŸºäºè¿™ç§è›®åŠ›åŒ¹é…ç®—æ³•çš„æ”¹è¿›å’Œä¼˜åŒ–ï¼Œç†è§£å®ƒæ‰èƒ½æ›´å¥½çš„å­¦ä¹ åç»­çš„ç®—æ³•ã€‚ æˆ‘ä»¬é¦–å…ˆä»‹ç»å­—ç¬¦ä¸²ç›¸å…³çš„æœ¯è¯­å’Œå®ƒçš„åŸºæœ¬æ¥å£ï¼Œä¹‹åå†ä»‹ç»å…·ä½“çš„ç®—æ³•ã€‚ æœ¯è¯­ ç›¸ç­‰ï¼šé•¿åº¦ç›¸ç­‰ï¼Œä¸”æ¯ä¸ªå¯¹åº”å­—ç¬¦éƒ½ç›¸ç­‰ å­ä¸²ï¼šä»S[I]èµ·çš„è¿ç»­kä¸ªå­—ç¬¦ S.substr(i, k) å‰ç¼€ï¼šSä¸­æœ€é å‰çš„kä¸ªå­—ç¬¦ S.prefix(k) = S.substr(0, k) åç¼€ï¼šSä¸­æœ€é åçš„kä¸ªå­—ç¬¦ S.suffix(k) = S.substr(n - k, k) æ–‡æœ¬ä¸²Pï¼šéœ€è¦è¢«æŸ¥æ‰¾çš„å­—ç¬¦ä¸² æ¨¡å¼ä¸²Tï¼šéœ€è¦æ‰¾çš„å­—ç¬¦ä¸²ï¼ˆå…³é”®è¯ï¼‰ æ¥å£ length() è¿”å›ä¸²çš„é•¿åº¦ charAt(i) è¿”å›ç»™å®šä¸‹æ ‡ä½ç½®çš„å­—ç¬¦ substr(i, k) æˆªå– [i, i + k) ä½ç½®çš„å­—ç¬¦ä¸² prefix(k) Sä¸­æœ€é å‰çš„kä¸ªå­—ç¬¦ suffix(k) Sä¸­æœ€é åçš„kä¸ªå­—ç¬¦ concat(T) åœ¨å½“å‰å­—ç¬¦ä¸²åé¢è¿æ¥ä¸€ä¸ªå­—ç¬¦ä¸² equal(T) æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ é—®é¢˜ æ¨¡å¼ä¸²æ˜¯å¦å‡ºç°ï¼Ÿ é¦–æ¬¡åœ¨å“ªé‡Œå‡ºç°ï¼Ÿ æ€»å…±å‡ºç°å‡ æ¬¡ï¼Ÿ å„å‡ºç°åœ¨å“ªé‡Œï¼Ÿ ä¸²åŒ¹é…ç®—æ³•æ•ˆç‡è¯„æµ‹æ ‡å‡†æˆ‘ä»¬å¯ä»¥éšæœºç”Ÿæˆæ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²è¿›è¡ŒåŒ¹é…æ¥è¯„æµ‹ä¸²åŒ¹é…ç®—æ³•çš„æ•ˆç‡å—ï¼Ÿ æˆ‘ä»¬åº”è¯¥å°†éšæœºç”Ÿæˆçš„æ•°æ®çš„åŒ¹é…ç»“æœåˆ†ä¸ºåŒ¹é…æˆåŠŸå’ŒåŒ¹é…å¤±è´¥ï¼Œåˆ†åˆ«æµ‹è¯•ã€‚è¿™æ˜¯å› ä¸ºéšæœºç”Ÿæˆçš„æ•°æ®å¯¹äºä¸²åŒ¹é…æ¥è¯´å¤±è´¥çš„æ¦‚ç‡å¾ˆå¤§ï¼Œå¤±è´¥æ—¶çš„æ•ˆç‡ä¼šæ©ç›–æˆåŠŸæ—¶çš„æ•ˆç‡ã€‚éšæœºç”Ÿæˆçš„æ•°æ®åŒ¹é…æˆåŠŸä¸å¦ä¸€èˆ¬è¿˜ä¸å­—ç¬¦çš„ç§ç±»ç›¸å…³ï¼Œæ¯”å¦‚äºŒè¿›åˆ¶çš„å­—ç¬¦ä¸²å°±æ¯”å­—æ¯ç»„åˆçš„å­—ç¬¦ä¸²è¾ƒå®¹æ˜“åŒ¹é…æˆåŠŸã€‚ è›®åŠ›åŒ¹é…ç®—æ³•å¯¹äºæœ‰ä¸€å®šç¼–ç¨‹åŸºç¡€çš„äººé‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Œéƒ½å¾ˆå®¹æ˜“æƒ³åˆ°è¿™ä¸ªç®—æ³•ã€‚å¾ˆç®€å•ï¼Œæˆ‘ä»¬éœ€è¦å‡å®šæ–‡æœ¬ä¸²çš„æŸä¸ªä½ç½®æ˜¯æ¨¡å¼ä¸²çš„å¤´ï¼Œå‘ååŒ¹é…ä¸¤è€…ï¼Œå¦‚æœé‡åˆ°ä¸åŒ¹é…çš„å­—ç¬¦å°±è¯´æ˜è¿™ä¸ªå¤´ä¸å¯¹ã€‚æˆ‘ä»¬éå†æ–‡æœ¬ä¸²ä¸Šæ‰€æœ‰å¯èƒ½æˆä¸ºæ¨¡å¼ä¸²å¤´çš„ä½ç½®ï¼ˆä¸‹æ ‡åœ¨S.length()-P.length()ä¹‹å‰çš„å­—ç¬¦ï¼‰ï¼Œæœ€ç»ˆå°±å¯ä»¥å¾—å‡ºç»“æœã€‚ ç‰ˆæœ¬1Ubuntu Pastebin : https://paste.ubuntu.com/p/y6QZ2sFY8Q/123456789101112131415int match(string P, string T)&#123; int size_n = T.length(), i = 0; int size_m = P.length(), j = 0; while( j &lt; size_m &amp;&amp; i &lt; size_n)&#123; //ä»å·¦å‘å³é€ä¸ªæ¯”å¯¹å­—ç¬¦ if(T[i] == P[i])&#123; i++; j++;&#125; //è‹¥åŒ¹é…ï¼Œåˆ™è½¬åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦ else&#123; i -= j-1; j = 0;&#125; //å¦åˆ™ï¼Œæ¨¡å¼ä¸²Tå›é€€ï¼Œæ–‡æœ¬ä¸²På¤ä½ &#125; return i - j;&#125; å¦‚æœåŒ¹é…æˆåŠŸè¿”å› i - j ï¼Œå³æ¨¡å¼ä¸²å¤´åœ¨æ–‡æœ¬ä¸²ä¸­çš„ä½ç½®ä¸‹æ ‡ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…æˆåŠŸï¼Œè¯´æ˜å¾ªç¯å› ä¸ºi &lt; size_né€€å‡ºï¼Œæ­¤æ—¶i = size_n è€Œï¼Œè¿”å›å€¼ i - j å°†å¤§äº size_n - size_mã€‚è°ƒç”¨è€…åªéœ€ä¸€æ­¥åˆ¤æ–­å³å¯ã€‚ ç‰ˆæœ¬2Ubuntu Pastebin : https://paste.ubuntu.com/p/n88Jkz2ypM/1234567891011121314151617int match(string P, string T)&#123; int size_n = T.length(), i; int size_m = P.length(), j; for( i = 0; i &lt; size_n - size_m + 1; i++)&#123; //éå†æ‰€æœ‰å¯èƒ½æˆä¸ºæ¨¡å¼ä¸²å¤´çš„å…ƒç´  for( j = 0; j &lt; size_m; j++)&#123; //å‡è®¾T[i]ä¸ºP[i]å¤´é€ä¸ªæ¯”å¯¹ if(T[i + j] != P[j]) break; //å¦‚æœæœ‰ä¸€ä¸ªå¤±é…ï¼Œè¯´æ˜æ­¤å‡è®¾ä¸å¯¹ &#125; if(j &gt;= size_m) break; //æ‰¾åˆ°åŒ¹é…å­ä¸² &#125; return i;&#125; ç‰ˆæœ¬2çš„å®ç°æ›´å®¹æ˜“ç†è§£ï¼Œå®ƒå°±å¦‚ä¹‹å‰è®²è§£çš„æƒ³æ³•æ˜¯ä¸€æ ·çš„ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æè¿™ä¸¤ç§å®ç°å…¶å®æ€æƒ³å’Œæ•ˆç‡éƒ½æ˜¯ä¸€æ ·çš„ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æä¸€ä¸‹å®ƒä»¬çš„æ—¶é—´å¤æ‚åº¦ æœ€å¥½æƒ…å†µï¼ˆåªç»è¿‡ä¸€è½®æ¯”å¯¹ï¼Œå³å¯ç¡®å®šåŒ¹é…æˆåŠŸï¼‰ï¼šO(size_m) æœ€åæƒ…å†µï¼ˆæ¯è½®éƒ½å¯¹æ¯”è‡³Pçš„æœ«å­—ç¬¦ï¼Œä¸”åå¤å¦‚æ­¤ï¼‰ï¼šO(m (size_n - size_m + 1)) ä¸€èˆ¬ m &lt;&lt; n å¤æ‚åº¦è¿‘ä¼¼ä¸º O(n m) æœ€åæƒ…å†µæ˜¯å¦ä¼šå‡ºç°ï¼Ÿè¿™é‡Œä¸¾ä¸ªä¾‹å­ï¼š æ–‡æœ¬ä¸²ï¼š00000000â€¦00000001 æ¨¡å¼ä¸²ï¼š00001 æœ€åæƒ…å†µçš„ç‰¹ç‚¹ æœ€åæƒ…å†µå‡ºç°çš„æ¦‚ç‡ä¸å­—æ¯è¡¨çš„å¤§å°æœ‰å…³ï¼Œå­—æ¯è¡¨è¶Šå°è¶Šå®¹æ˜“å‡ºç°å±€éƒ¨åŒ¹é…çš„æƒ…å†µå¯¼è‡´æµªè´¹å¤§é‡æ—¶é—´ size_m è¶Šå¤§ï¼Œæœ€åæƒ…å†µå‡ºç°çš„åæœè¶Šä¸¥é‡]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>ä¸²åŒ¹é…</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œç¬”è®°ã€è®¸å²‘ï¼šå¦‚ä½•æˆä¸ºæœ‰æ•ˆå­¦ä¹ çš„é«˜æ‰‹]]></title>
    <url>%2F2018%2F02%2F18%2Fxcxx-01%2F</url>
    <content type="text"><![CDATA[è‡ªç„¶ä¸»ä¹‰ä¸ç»“æ„ä¸»ä¹‰ è‡ªç„¶ä¸»ä¹‰æ ¸å¿ƒå®ƒæ˜¯æ¨¡ä»¿ï¼Œé‡åˆ°ä»€ä¹ˆå­¦ä»€ä¹ˆï¼Œå­¦ä¹ è¿‡ç¨‹å¯ä»¥æ˜¯ç¢ç‰‡åŒ–çš„ï¼Œç§¯å°‘æˆå¤šï¼Œæ³¨é‡é‡çš„ç§¯ç´¯ æ¯”å¦‚ï¼šè¯­è¨€ã€ä¹å™¨ã€ä¹¦æ³• ç»“æ„ä¸»ä¹‰å­¦ä¸œè¥¿æ›´æ³¨é‡ç»“æ„ï¼Œä½“ç³»åŒ–çš„å»å­¦ï¼Œå­¦ä¼šä¹‹åçš„ç›®çš„æ˜¯åˆ›é€ ã€‚ä¸ºçš„æ˜¯ä¸€ç§è´¨å˜ã€‚é€‰æ‹©äº†æ­£ç¡®çš„å­¦ä¹ æ–¹æ³•ä¹‹åï¼ŒæŠŠè¿™ä¸ªç›®æ ‡æ‹†ç¢ï¼Œé’ˆå¯¹ç»†èŠ‚è¿›è¡Œåå¤çš„ç»ƒä¹  æ¯”å¦‚ï¼šåŒ»å­¦ã€è‰ºæœ¯ã€ç¼–ç¨‹ã€ç»æµå­¦ é€Ÿåº¦å’Œæ•ˆç‡ é¿å…æ— æ•ˆå­¦ä¹  å°†ç›®æ ‡æ‹†ç¢ï¼Œé’ˆå¯¹ç»†èŠ‚è¿›è¡Œåå¤ç»ƒä¹  ä¸è¦ä¸€å¼€å§‹å°±ç…§é¡¾å…¨å±€ ç¢ç‰‡åŒ–å­¦ä¹  å¸¦ç€å›°æƒ‘å’Œé—®é¢˜è¿›è¡Œå­¦ä¹  åŸºäºæœç´¢ æœ€ç»ˆçš„æ•ˆæœè¦æŠŠç¢ç‰‡é“¾æ¥èµ·æ¥ å°å­©å­å¯èƒ½ä¸é€‚åˆç¢ç‰‡åŒ–å­¦ä¹  å‡çš„ç¢ç‰‡åŒ–å­¦ä¹ ï¼šæ”¶è— é©±åŠ¨åŠ› æˆå¹´äººçš„å­¦ä¹ ä¸éœ€è¦åŸ¹å…»å…´è¶£ï¼Œåº”è¯¥ä»¥ä»»åŠ¡ä¸ºé©±åŠ¨ æ²¡æœ‰ä»»åŠ¡æˆ‘ä»¬è‡ªå·±æ¥åˆ¶é€ ä»»åŠ¡ å¸¦ç€èŒä¸šå¼ºè¿«å»ç»ƒä¹  è‡ªå·±è˜è¯·è‡ªå·± ä»¥æ•™ä¸ºå­¦ï¼Œä¸€æ–¹é¢å¯ä»¥æ˜¯è‡ªå·±å¯¹è‡ªå·±è®¾ç½®çš„ä¸€ä¸ªä»»åŠ¡ï¼Œè®¾å®šçš„ä¸€ä¸ªç›®æ ‡ï¼Œè§£å†³äº†ä»»åŠ¡é©±åŠ¨çš„é—®é¢˜ã€‚å¦ä¸€æ–¹é¢ï¼Œä»¥æ•™ä¸ºå­¦ï¼Œå…¶å®ä¼šè®©ä½ å­¦çš„æ›´å¥½ æ‹–å»¶ç—‡ å°†ä»»åŠ¡â€œä¸¥å³»åŒ–â€ ä¸€ç”Ÿå½“ä¸­ä¸å¯èƒ½åªåšè‡ªå·±å–œæ¬¢çš„äº‹ï¼Œæ€ä¹ˆæŠŠè‡ªå·±ä¸å–œæ¬¢ï¼Œå´å¿…é¡»è¦åšçš„äº‹ç»™åšäº†ï¼Œæ‰æ˜¯æˆ‘ä»¬éœ€è¦è§£å†³çš„éš¾é¢˜ ä½ è¦å‘æ‰€æœ‰è®¤è¯†ä½ çš„äººäº¤ä»£ è®¾å®šå°ç›®æ ‡ï¼Œå½¢æˆæƒ¯æ€§ ä¸“æ³¨åŠ›åŸ¹å…» åœ¨å¹³å¸¸çš„ç”Ÿæ´»å½“ä¸­è¥é€ ä»ªå¼æ„Ÿ è´­ä¹°æ˜‚è´µçš„å­¦ä¹ å·¥å…· ä¾¿å®œä¸œè¥¿æœ¬æ¥å°±ä¸æ˜¯é ä¸“æ³¨åŠ›åˆ¶é€ å‡ºæ¥çš„ï¼Œä½ æŠŠä¸€æ ·ä¸œè¥¿ä¹°æ¥è‡ªå·±ç”¨ï¼Œè¿™æ ·ä¸œè¥¿è¦ä½¿ä½ æ„ŸçŸ¥åˆ°é‚£ç§ä¸“æ³¨åŠ›ï¼Œæ‰èƒ½å¤Ÿå¯¹ä½ è‡ªå·±çš„ä¸“æ³¨åŠ›å½¢æˆä¸€ç§è®­ç»ƒã€‚ å›¾ä¾¿å®œç»å¯¹ä¼šåˆ†æ•£æˆ‘ä»¬çš„æ³¨æ„åŠ›ã€‚ å¦‚æœæˆ‘ä»¬æœ‰ä¸€ç¬”é’±ç”¨æ¥ä¹°ä¸œè¥¿ï¼Œä¹°ä¸€æ ·è´µçš„ä¸œè¥¿ï¼Œå¥½å¤„è¿˜æœ‰å¦å¤–ä¸€ä¸ªæ–¹é¢ï¼Œå°±æ˜¯æˆ‘ä»¬æ²¡é’±å†å»ä¹°é‚£äº›ä¾¿å®œçš„ä¸œè¥¿äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬æ‹¥æœ‰çš„ä¸œè¥¿å°‘ä¸€äº›ï¼Œä¸œè¥¿è¶Šå¤šè¶Šä¸èƒ½ä½¿äººä¸“æ³¨ å­¦ä¼šä¸€ä¸ªäººå¥½å¥½åƒé¥­ å°½é‡åƒç‚¹å¥½çš„ï¼Œå°‘åƒé€Ÿé£Ÿï¼Œå°‘ç‚¹å¤–å–ï¼Œå°½é‡å°‘åƒè‡ªåŠ©é¤ æˆ‘ä»¬æ¯ä¸ªäººçœŸçš„è¦å­¦ä¼šè‡ªå·±è®¤è®¤çœŸçœŸçš„åƒä¸€é¡¿ç«é”…ã€‚æœ€å¥½ï¼Œèƒ½å­¦ä¼šå¥½å¥½åšä¸€é¡¿é¥­ç»™è‡ªå·±åƒã€‚è¿™æ˜¯è¥é€ ä»ªå¼æ„Ÿéå¸¸å¥½çš„è¡Œä¸ºæ´»åŠ¨ ä½¿ç”¨å°„ç¯ è¿›å…¥é«˜è´¨é‡çš„ç¡çœ  ç¡çœ ä¸å¤Ÿï¼Œäººå¾ˆéš¾åšåˆ°ä¸“æ³¨ ä¸è¦å·²ç»å›°å¾—ä¸è¡Œäº†ï¼Œè¿˜è¦ç¡¬æ’‘ç€åšäº‹ï¼Œè¿™ä¸ªæ•ˆç‡æ˜¯éå¸¸ä½çš„ã€‚ä¸å¦‚ç«‹å³è¿›å…¥åˆ°é«˜è´¨é‡çš„ç¡çœ  è¿åŠ¨ è®¾å®šæœ‰æ•ˆçš„ç›®æ ‡ ä¸€å®šè¦æœ‰ä¸€ä¸ªæ˜ç¡®çš„ç›®æ ‡ï¼Œå¹¶ä¸”æ‰¾å‡†å­¦ä¹ çš„åˆ‡å…¥ç‚¹ ç›´å¥”å¤§å¸ˆï¼Œä¸å¿…ä»åŸºç¡€å¼€å§‹ã€‚å½“ç„¶è¿™ä¸ªå¤§å¸ˆåœ¨è¿™é‡Œè¾¹å®ƒæŒ‡ä»£çš„æ˜¯ä¸€ç§ç‰¹å®šçš„ä¸€ç§æƒ…å¢ƒï¼Œè¿™ä¸ªå¤§å¸ˆä¸ä¸€å®šæ˜¯æŒ‡ä¸€ä¸ªäººäº†ï¼Œè€Œæ˜¯ä½ çš„æœ€ç»ˆç›®æ ‡ è¦å»åˆ°å“ªé‡Œå°±ä»å“ªé‡Œå¼€å§‹ æ€¯åœºæ˜¯æœ€ç³Ÿç³•çš„è‡ªè§‰ã€‚ä¸€ä¸ªäººä»–èƒ†å­å˜çš„æ¯”ä¹‹å‰å¤§ä¸€ç‚¹ï¼Œèƒ½èµ°çš„è·¯å¯èƒ½å°±ä¼šé•¿ä¸€ç‚¹ å¯¹äºè¦ç”¨ç»“æ„ä¸»ä¹‰æ–¹æ³•å»ç ”ç©¶çš„ä¸œè¥¿ï¼Œè¿˜æ˜¯è¦è¸è¸å®å®ä»åˆçº§å¼€å§‹ åé¦ˆ è‡ªå·±ç»™è‡ªå·±åˆ¶é€ åé¦ˆ åˆ¶é€ æ–‡å­—ï¼Œè¯­éŸ³å’Œè‚¢ä½“çš„åé¦ˆ å½“å­¦ä¹ ç‰¹åˆ«å®¹æ˜“çŠ¯é”™çš„ä¸œè¥¿æ—¶ï¼Œæœ€éœ€è¦åŠæ—¶åé¦ˆ çªç ´å­¦ä¹ ç“¶é¢ˆ ç“¶é¢ˆä¸æ˜¯æé™ çªç ´ç“¶é¢ˆå¯èƒ½æ˜¯éœ€è¦æ–¹æ³•çš„è°ƒæ•´ï¼Œä¹Ÿå¯èƒ½æ˜¯éœ€è¦å¿ƒæ€çš„è°ƒæ•´ã€‚å¿ƒæ€è°ƒæ•´çš„å¥½ï¼Œåšä¸€äº›äº‹ä¼šç›¸å¯¹æ¯”è¾ƒå®¹æ˜“ å¢å¼ºä¿¡å¿ƒ æ‰©å¤§æ¶‰çŒèŒƒå›´ æ›´åŠ ä¸“æ³¨ï¼Œè¯·æ•™åå¸ˆ æŠŠæ³¨æ„åŠ›é›†ä¸­åœ¨ä¸€ä¸ªæ›´ç‹­çª„çš„èŒƒå›´å†…ï¼Œä»¥åšåˆ°ä¸å»åˆ†å¿ƒ æœ‰äº›äº‹çœŸçš„æ˜¯ä¸€é€šç™¾é€šï¼Œä½ æŠŠä¸€ä¸ªä¸œè¥¿æ‹¿ä¸‹äº†ï¼Œå†å»æ‹¿åˆ«çš„ï¼Œä¼šç›¸å¯¹æ¯”è¾ƒå®¹æ˜“ã€‚è¿™å¯èƒ½æ˜¯è‡ªä¿¡å¸¦æ¥çš„å¹»è§‰ï¼Œä¹Ÿå¯èƒ½ä¸æ˜¯å¹»è§‰ã€‚å¦‚æœè‡ªä¿¡æ¥è‡ªäºè‡ªå¾‹ï¼Œé‚£å°±æ˜¯æ‰æ‰å®å®çš„è‡ªä¿¡ã€‚å¦‚æœè‡ªä¿¡æ¥æºäºæƒ³è±¡ï¼Œé‚£å°±æ˜¯ç›²ç›®è‡ªä¿¡äº†ã€‚]]></content>
      <categories>
        <category>æ³› - ç¬”è®°</category>
      </categories>
      <tags>
        <tag>è®¸å²‘</tag>
        <tag>ç¾è²Œå¤§ç‹</tag>
        <tag>æœ‰æ•ˆå­¦ä¹ </tag>
        <tag>æ‹–å»¶ç—‡</tag>
        <tag>è‡ªç„¶ä¸»ä¹‰</tag>
        <tag>ç»“æ„ä¸»ä¹‰</tag>
        <tag>ä¸“æ³¨åŠ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Œä¹¦æ‘˜ã€ã€Šæ‘©æ‰˜è½¦ä¿®ç†åº—çš„æœªæ¥å·¥ä½œå“²å­¦ã€‹]]></title>
    <url>%2F2018%2F02%2F17%2Fbooks-0%2F</url>
    <content type="text"><![CDATA[æ‰‹è‰ºäººçš„å®ç”¨è‰ºæœ¯ ä¿®ç†å·¥åœ¨åšæ¯ä¸€ä»¶å·¥ä½œæ—¶ï¼Œéƒ½è¦å…ˆæŠ›å¼€è‡ªå·±çš„æƒ³æ³•ï¼Œä¸“æ³¨äºè¦ä¿®ç†çš„ä¸œè¥¿ä¸Šï¼šä»–å¿…é¡»ä»”ç»†å»çœ‹ã€å»å¬ã€‚ å½“æˆ‘çš„ç”µè·¯å®‰è£…å·¥ä½œå®Œæˆå¾—ç¾è§‚æ¼‚äº®æ—¶ï¼Œæˆ‘æ€»ä¼šæ„Ÿåˆ°è‡ªè±ªã€‚ä¹Ÿè®¸æŸå¤©ä¼šæœ‰å…¶ä»–ç”µå·¥çœ‹åˆ°æˆ‘çš„å·¥ä½œæˆç»©ã€‚ å·¥åŒ çš„éª„å‚²æ˜¯æœ‰å‡­æ®çš„ï¼Œå®Œå…¨ä¸æ˜¯æ•™è‚²è€…ä¼ æˆç»™å­¦ç”Ÿçš„é‚£ç§æ¯«æ— æ ¹æ®çš„â€œè‡ªè´Ÿâ€ã€‚ æˆ‘æ›¾ä¸æƒœä»£ä»·åœ°è‡ªå·±åšäº†ä¸€ä¸ªçº¢æœ¨çš„å’–å•¡æ¡Œã€‚å½“æ—¶æˆ‘è¿˜æ²¡æœ‰æƒ³è¿‡è¦åšçˆ¶äº²ï¼Œä½†æˆ‘å´æƒ³è±¡è¿™ä¸ªæ¡Œå­èƒ½ç»™æˆ‘çš„å­©å­ç•™ä¸‹éš¾ä»¥ç£¨ç­çš„å°è±¡ï¼Œä»–ä¼šçŸ¥é“è¿™æ˜¯è‡ªå·±çˆ¶äº²çš„ä½œå“ã€‚ å·¥åŒ æƒ¯æœ‰çš„åå·®ä¸æ˜¯åå‘æ–°äº‹ç‰©ï¼Œè€Œæ˜¯åå‘ä»–çš„å¯è§‚å·¥è‰ºæ ‡å‡†ã€‚ æŠ€æœ¯å‹çš„ä½“åŠ›åŠ³åŠ¨éœ€è¦å¯¹ç‰©è´¨ä¸–ç•Œæœ‰ç³»ç»Ÿçš„äº†è§£ï¼Œæ­£æ˜¯è¿™ç§äº†è§£æ¨åŠ¨äº†è‡ªç„¶ç§‘å­¦çš„è¯ç”Ÿå’Œå‘å±•ã€‚ ç»éªŒçš„ç¼ºä¹å‰Šå¼±äº†æˆ‘ä»¬å…¨é¢å®¡è§†å…¬è®¤äº‹å®çš„èƒ½åŠ›ã€‚ æ‰‹å·¥è‰ºå®è·µå’Œæ‰‹å·¥è‰ºæ¶ˆè´¹çš„ç²¾ç¥æ¨¡å¼å’Œè±¡å¾æ¨¡å¼ä»£è¡¨äº†å¯¹ç¨‹å¼åŒ–çš„ã€å®˜åƒšä¸»ä¹‰åŒ–çš„å·¥ä½œæ–°æ¨¡å¼çš„è¡¥å¿ï¼Œä¸€ç§è°ƒé€‚ã€‚ åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œé—®é¢˜æœ¬èº«å¹¶ä¸ä¼šè¢«é¢„å…ˆç®€åŒ–ï¼›é€šå¸¸ä¼šå‡ºç°ä¿¡æ¯è¿‡å¤šçš„æƒ…å†µï¼Œä½¿äººéš¾ä»¥è¾¨åˆ«å“ªäº›ç›¸å…³ï¼Œå“ªäº›ä¸ç›¸å…³ã€‚è¦æ‡‚å¾—è‡ªå·±é¢å¯¹çš„æ˜¯ä½•ç§é—®é¢˜ï¼Œä¹Ÿå°±æ„å‘³ç€å¿…é¡»æ¸…æ¥šå“ªäº›æƒ…å†µå¯ä»¥è¢«å¿½ç•¥ã€‚ ä¿®ç†å·¥çš„ä»·å€¼å’Œå·¥ä½œç¨³å®šæ€§å°±åœ¨äºä»–æ‹¥æœ‰ä¸€æ‰‹çš„çŸ¥è¯†å’Œç»éªŒã€‚ åŠ¨æ‰‹ä¸åŠ¨è„‘ å·¥ä½œçš„é€€åŒ–ç»ˆç©¶æ˜¯è®¤çŸ¥é—®é¢˜ï¼Œæ ¹æ¤äºåŠ¨è„‘ä¸åŠ¨æ‰‹çš„è„±èŠ‚ã€‚ æœ¨æ–™ä¸åº”è¯¥æ˜¯æœºå™¨çš„ç‰ºç‰²å“ï¼Œå®ƒç‰¹æœ‰çš„ä¼˜ç‚¹åº”è¯¥ç•™ç»™æ‡‚å¾—å¦‚ä½•é›•ç¢å®ƒçš„äººã€‚ é›‡ä¸»ä»¬æ‡‚å¾—è¦ä¿ƒä½¿å·¥äººä»¬æ›´å‹¤å¥‹åœ°å·¥ä½œï¼Œå”¯ä¸€çš„åŠæ³•å°±æ˜¯å€ŸåŠ©æƒ³è±¡åŠ›ï¼Œåˆºæ¿€æ–°çš„éœ€æ±‚å’Œæ¬²æœ›ã€‚æ¶ˆè´¹å’Œç”Ÿäº§ä¸€æ ·ï¼Œéœ€è¦è¿›è¡Œç§‘å­¦çš„æ¬²æœ›ç®¡ç†ã€‚ å¦‚æœçŸ¥è¯†è¢«é›†ä¸­åˆ°è§„æ¨¡è¶Šæ¥è¶Šå°çš„ç²¾è‹±æ‰‹ä¸­ï¼ŒçœŸæ­£çš„çŸ¥è¯†å·¥ä½œæ•°é‡å°±ä¸æ˜¯åœ¨å¢é•¿ï¼Œè€Œæ˜¯åœ¨èç¼©ã€‚ å¯¼è‡´åˆ¤æ–­åŠ›æ°´å¹³è¿œä½äºä¸“ä¸šäººå£«çš„å¹¶ä¸ä¸€å®šæ˜¯åˆ©æ¶¦å› ç´ ï¼Œæœ‰æ—¶å…¬å…±æ”¿ç­–ä¹Ÿä¼šå½±å“åˆ¤æ–­åŠ›ã€‚æ ‡å‡†åŒ–è€ƒè¯•è®©æ•™å¸ˆå¤±å»äº†å¯¹è¯¾ç¨‹çš„åˆ¤æ–­åŠ›ï¼Œä¸¥æ ¼çš„å®¡åˆ¤æŒ‡å¯¼æ–¹é’ˆè®©æ³•å®˜å¤±å»äº†å¯¹è¿æ³•è¡Œä¸ºçš„åˆ¤æ–­åŠ›ã€‚ åˆ›é€ åŠ›æ˜¯ç²¾é€šçš„å‰¯äº§å“ï¼Œè€Œç²¾é€šåªèƒ½é€šè¿‡é•¿æœŸçš„å®è·µæ¥åŸ¹å…»ã€‚ åšè‡ªå·±ç‰©å“çš„ä¸»äºº è¦åšè‡ªå·±ç‰©å“çš„ä¸»äººï¼Œé¦–å…ˆè¦æœ‰ä¸€å®šçš„å‹‡æ°”ï¼Œç„¶åè¿˜è¦æœ‰æ¢ç´¢çš„ç²¾ç¥ã€‚è¿™æ˜¯ä»¤äººéª„å‚²çš„äº‹æƒ…ï¼Œä¹Ÿæ˜¯è‡ªåŠ›æ›´ç”Ÿçš„åŸºç¡€ã€‚ é€šè¿‡å€ŸåŠ©æŸç§è´¹è§£çš„æ–‡åŒ–é€»è¾‘ï¼Œå‚»ç“œåŒ–å˜æˆäº†äººäººå‘å¾€çš„ä¸œè¥¿ã€‚ ç›´æ¥ä¸æˆ‘ä»¬ä½¿ç”¨çš„æœºå™¨æ‰“äº¤é“ï¼Œè™½ç„¶ä¼šæŠŠæŒ‡ç”²å¼„è„ï¼Œä½†ä¼šç»™æˆ‘ä»¬å¸¦æ¥ä¸€ç§ä¸»ä½“æ„Ÿã€‚ç„¶è€Œéšç€ç§‘æŠ€è¿›æ­¥ï¼Œè¿™ç§ç›´æ¥æ¥è§¦å‡å°‘ï¼Œå°½ç®¡æ¨åŠ¨ç§‘æŠ€è¿›æ­¥çš„åˆè¡·æ˜¯å¢åŠ è‡ªä¸»æƒã€‚è¿™ä¸­é—´æ˜¯å¦å­˜åœ¨çŸ›ç›¾ï¼Ÿ é€‰æ‹©ã€è‡ªç”±ã€æ²¡æœ‰æé™çš„æ—¶é—´ã€è¶…è¶Šå¯èƒ½æ€§ï¼Œä»¥åŠæ¶ˆè´¹ä¸»ä¹‰å…¶ä»–ä»¤äººé™¶é†‰çš„å­˜åœ¨ä¸»ä¹‰å¼å£å·å¼•å‘çš„æ­¤èµ·å½¼ä¼çš„å‹è¿«æ„Ÿï¼Œå¥½åƒå·²ç»å½¢æˆäº†ä¸€ä¸ªæˆ’å¾‹ä½“ç³»ã€‚ä¸çŸ¥ä½•æ•…ï¼Œå¯¹è‡ªæˆ‘å®ç°å’Œè‡ªç”±çš„è¿½æ±‚ï¼Œä¿ƒä½¿æˆ‘ä»¬å»è´­ä¹°æ–°ä¸œè¥¿ï¼Œæ‰”æ‰æ—§ä¸œè¥¿ã€‚ åœ¨æ‰€æœ‰å…·æœ‰éš¾åº¦çš„ä¸“ä¸šé¢†åŸŸï¼Œä¸ç®¡æ˜¯å›­è‰ºã€ç»“æ„å·¥ç¨‹è¿˜æ˜¯ä¿„è¯­ï¼Œäººä»¬éƒ½è¦å±ˆæœäºè¯¥é¢†åŸŸé‚£äº›æ£˜æ‰‹çš„å¯¹è±¡ã€‚ éŸ³å“æ˜¯ä¸€ç§è®¾å¤‡ï¼Œä¸èº«ä¸ºç‰©å“çš„ä¹å™¨ä¸åŒã€‚æˆ‘æ‰€æŒ‡çš„â€œç‰©å“â€ï¼Œå…¶ç‰¹æ€§éœ€è¦ä½¿ç”¨è€…å»é¢†æ‚Ÿå’Œæ¥è§¦ï¼Œéœ€è¦ä¸€å®šçš„æŠ€å·§ï¼Œä¹Ÿéœ€è¦ç§¯æåœ°å‚ä¸ã€‚â€œç‰©å“â€å¿…é¡»è¢«å®è·µï¼Œè€Œâ€œè®¾å¤‡â€åªéœ€è¦è¢«æ¶ˆè´¹ã€‚ç‰©å“å…·æœ‰æŒ‡æŒ¥å‹çš„ç°å®ç‰¹å¾ï¼Œè€Œè®¾å¤‡åªæœ‰è¢«æ”¯é…å‹çš„ç°å®ç‰¹å¾ã€‚ ä¸ªä½“çš„ä¸»ä½“æ€§å¯ä»¥é€šè¿‡ä¸€ç³»åˆ—çš„é€‰æ‹©å¾—ä»¥å®ç°ï¼Œä½†æ˜¯é€‰æ‹©å¹¶ä¸ç­‰äºåˆ›é€ ã€‚ å¯¹äºæ—©æœŸçš„å“²å­¦å®¶æµ·å¾·æ ¼å°”æ¥è¯´ï¼Œâ€œä¸Šæ‰‹çŠ¶æ€â€æ˜¯ä¸–ç•Œä¸‡ç‰©å‘ˆç°åœ¨æˆ‘ä»¬é¢å‰çš„æœ€åˆæ¨¡å¼ï¼šâ€œæœ€äº²å¯†çš„æ¥è§¦å¹¶éæ„Ÿæ€§è®¤çŸ¥ï¼Œè€Œæ˜¯å»æŠŠç©ã€ä½¿ç”¨å’Œç…§é¡¾é‚£äº›æœ‰è‡ªå·±â€˜çŸ¥è¯†â€™çš„ä¸œè¥¿ã€‚â€ é»‘æ‰‹çš„æ•™è‚² ä¼˜ç§€çš„é’»çŸ³åˆ‡å‰²å·¥äººä¸ä¼˜ç§€çš„è®­çŠ¬å¸ˆåœ¨æ€§æƒ…ä¸Šè‚¯å®šä¸åŒï¼šå‰è€…éå¸¸è°¨æ…ï¼Œåè€…åˆ™æ›´å–„äºå‘å·æ–½ä»¤ã€‚ å½“å¹´è½»äººæ€è€ƒä»–å¯ä»¥è°‹ç”Ÿçš„å„ç§æ–¹æ³•ï¼Œä»¥åŠè¿™äº›æ–¹æ³•å¦‚ä½•èƒ½å¸®åŠ©ä»–æ›´å¥½åœ°ç”Ÿæ´»æ—¶ï¼Œæœ€é‡è¦çš„é—®é¢˜ä¹Ÿè®¸å¹¶éä»–çš„æ™ºå•†æœ‰å¤šé«˜ï¼Œè€Œæ˜¯åƒâ€œä»–ç©¶ç«Ÿæ˜¯ä¸ªè°¨æ…çš„äººï¼Œè¿˜æ˜¯ä¸€ä¸ªå–œæ¬¢å‘å·æ–½ä»¤çš„äººâ€è¿™æ ·çš„é—®é¢˜ã€‚å¦‚æœä»–çš„ç›®æ ‡æ˜¯æ‰¾åˆ°é€‚åˆè‡ªå·±çš„å·¥ä½œï¼Œå°±åº”è¯¥åœ¨æ¥å—é‚€çº¦ä¹‹å‰åœä¸‹æ¥å¥½å¥½æ€è€ƒã€‚ ä¸åŒçš„å·¥ä½œä¼šå¸å¼•ä¸åŒçš„äººï¼Œé‚£ä¹ˆåè¿‡æ¥å·¥ä½œä¹Ÿä¼šå¡‘é€ äººã€‚ æœºæ¢°è‰ºæœ¯å¯¹æˆ‘ä»¬è¿™ä¸ªæ—¶ä»£è€Œè¨€å…·æœ‰ç‰¹åˆ«çš„æ„ä¹‰ï¼Œå› ä¸ºå®ƒä»¬åŸ¹å…»çš„ä¸æ˜¯æˆ‘ä»¬çš„åˆ›é€ åŠ›ï¼Œè€Œæ˜¯æ³¨æ„å€¾å¬çš„èƒ½åŠ›ã€‚ ç‰©å“éœ€è¦ä¿®ç†å’Œç…§é¡¾ï¼Œå°±åƒå®ƒéœ€è¦è¢«åˆ›é€ ã€‚ ç°ä»£ç§‘å­¦å…³äºæˆ‘ä»¬å¦‚ä½•äº†è§£è‡ªç„¶çš„è§‚ç‚¹è„±ç¦»äº†æˆ‘ä»¬æ‰€åœ¨çš„ä¸–ç•Œï¼šé€šè¿‡æ€ç»´ç»“æ„æ¥äº†è§£è‡ªç„¶æ¯”é€šè¿‡ç‰©è´¨ä¸–ç•Œæ›´å®¹æ˜“æ“ä½œï¼Œè€Œä¸”å¯ä»¥ç”¨æ•°å­¦è¡¨è¾¾å¼è¿›è¡ŒéªŒç®—ã€‚é€šè¿‡æ­¤ç±»è½¬æ¢ï¼Œæˆ‘ä»¬æˆä¸ºäº†å¤§è‡ªç„¶çš„ä¸»äººï¼Œä½†åŸºäºç†æƒ³åŒ–çš„æ€è€ƒä»¤æˆ‘ä»¬å¤±æœ›ï¼Œå› ä¸ºå®ƒæ²¡æœ‰å……åˆ†è€ƒè™‘åˆ°ç»†èŠ‚é—®é¢˜ã€‚ ä¿®ç†å·¥å’ŒåŒ»ç”Ÿæ¯å¤©éƒ½ä¼šä¸å¤±è´¥æ‰“äº¤é“ï¼Œå³ä½¿æˆä¸ºä¸“å®¶åä¹Ÿæ— æ³•å¹¸å…ï¼›ä½†å»ºç­‘å·¥ä¸ç”¨ï¼Œè¿™æ˜¯å› ä¸ºä¿®ç†å·¥å’ŒåŒ»ç”Ÿä¿®ç†çš„ä¸œè¥¿å¹¶éç”±è‡ªå·±æ‰“é€ ï¼Œæ‰€ä»¥ä»–ä»¬æ— æ³•å…¨é¢æˆ–å½»åº•åœ°äº†è§£å®ƒã€‚ è§„åˆ’æ˜¯ä¸€ä¸ªæå…¶è€—æ—¶çš„è¿‡ç¨‹ï¼Œè€Œä¸”éš¾ä»¥ç¡®åˆ‡åœ°åˆ’åˆ†å“ªä¸€æ®µå±äºè®¤çœŸçš„è£…é…å·¥ä½œï¼Œå“ªä¸€æ®µåˆå±äºè§„åˆ’å·¥ä½œï¼Œå› ä¸ºæ”¹é€ æ—§é©¬è¾¾åœ¨ä¸€å¼€å§‹å°±æ¶‰åŠå¤§é‡çš„æµ‹é‡å’Œåˆ¤æ–­ã€‚ è¦æƒ³æˆä¸ºä¸€åä¼˜ç§€çš„ä¿®ç†å·¥ï¼Œä¸€æ–¹é¢ï¼Œä½ å¿…é¡»çœŸæ­£åœ°æŠ•å…¥ï¼Œä»å†…å¿ƒæ·±å¤„è®¤åŒâ€œæˆ‘æ˜¯ä¸€ä¸ªä¿®ç†å·¥â€ï¼›å¦ä¸€æ–¹é¢ï¼Œä½ è¦æœ‰æ•é”çš„æ„Ÿè§‰ï¼Œèƒ½å¤Ÿçªç ´è‡ªæˆ‘çš„ã€ç‹¬æœ‰çš„ä¸–ç•Œã€‚ åœ¨å¯»æ‰¾è§£å†³æ–¹æ¡ˆçš„è¿‡ç¨‹ä¸­æš‚åœä¸€ä¸‹ï¼Œåæ€è‡ªå·±å¯¹é—®é¢˜çš„ç†è§£æ˜¯å¦å……åˆ†ã€‚ ä½œä¸ºä¼˜ç§€çš„ä¿®ç†å·¥ï¼Œä½ å¿…é¡»ä¸æ–­ç•™æ„è‡ªå·±çŠ¯é”™çš„å¯èƒ½æ€§â€”â€”è¿™æ˜¯ä¸€ç§ç¾å¾·ã€‚ ä»»ä½•å¤„ç†å¯é è€Œç‹¬ç«‹çš„ç°å®æƒ…å†µçš„å­¦é—®ï¼Œéƒ½éœ€è¦è¯šå®å’Œè°¦è™šã€‚ ä»ä¸šä½™åˆ°ä¸“ä¸š åœ¨è¿™ä¸ªä¸–ç•Œä¸Šï¼Œæƒ³å¯¹ä¸€åˆ‡äº‹ç‰©æ­£ç¡®åœ°åšå‡ºå›åº”ï¼Œå°±å¿…é¡»æ¸…æ™°æ˜äº†åœ°çœ‹ç©¿å®ƒï¼Œè€Œå®ç°è¿™ç‚¹çš„å‰ææ˜¯è¾¾åˆ°â€œæ— æˆ‘â€çš„å¢ƒç•Œã€‚ ç‹¬ç«‹å·¥åŒ çš„ç”Ÿæ´»ç¾å¥½è€Œè‡ªç”±ï¼Œè®©äººå¼€å§‹æ€è€ƒè‡ªå·±è¦é€‰æ‹©ä»€ä¹ˆæ ·çš„ç”Ÿæ´»æ–¹å¼ã€‚ è‹±æ–‡ä¸­çš„â€œè‡ªç”±â€(liberal)ä¸€è¯ï¼Œæœ€æ—©è¢«ç”¨æ¥åŒºåˆ†â€œè‡ªç”±è‰ºæœ¯â€(liberal arts)å’Œâ€œåŠŸåˆ©è‰ºæœ¯â€(servile arts)ã€‚å‰è€…è¿½æ±‚çš„æ˜¯é€‚åˆè‡ªç”±äººçš„è‰ºæœ¯ï¼Œè€Œåè€…è¢«è§†ä¸ºæœºæ¢°æ€§çš„è‰ºæœ¯ã€‚ ä¿®ç†æ‘©æ‰˜è½¦çš„çœŸå®æ—¶é—´ä¸åº”è¯¥æ”¶è´¹çš„æ—¶é—´ä¹‹é—´çš„å·®è·ï¼Œæ­£æ˜¯æ‘©æ‰˜è½¦ç»´ä¿®ä¼¦ç†é“å¾·å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ã€‚ ä¿®ç†å·¥é¢ä¸´çš„æŒ‘æˆ˜å°±æ˜¯çªç ´è‡ªå·±çš„æƒ³æ³•ã€‚ å¥½å¥‡å¿ƒå—é™äºå¥½å¥‡å¯¹è±¡ï¼Œè€Œå¥½å¥‡å¯¹è±¡å¸¸å¸¸ä¼šè¢«å­¤ç«‹èµ·æ¥è€ƒè™‘ï¼›å¥½å¥‡å¿ƒå¼•å¯¼æˆ‘ä»¬å»äº†è§£ä¸€äº›äº‹æƒ…ï¼Œå°±å¥½åƒé‚£äº›ä¸œè¥¿æ˜¯æˆ‘ä»¬åœ¨è¿™ä¸–ä¸Šå”¯ä¸€æƒ³è¦æ‹¥æœ‰çš„ä¸œè¥¿ã€‚ å®è·µæ™ºæ…§éœ€è¦â€œæˆ‘ä»¬å……åˆ†äº†è§£æ‰€å¤„ç‰¹å®šç¯å¢ƒçš„æ˜¾è‘—çš„é“å¾·ç‰¹è‰²ï¼Œå¯¹è¿™äº›ç‰¹è‰²çš„äº†è§£å°†å¸®åŠ©æˆ‘ä»¬åšå‡ºæ­£ç¡®çš„ååº”â€ã€‚å› æ­¤ï¼Œè¦è·å¾—å®è·µæ™ºæ…§ï¼Œå°±è¦å…‹æœç™½ç—´èˆ¬çš„è‡ªæˆ‘ä¸“æ³¨ï¼Œçªç ´å¥½å¥‡ä¹‹äººçš„ç‹­éš˜è§†çº¿ã€‚ æ ¼å­é—´çš„çŸ›ç›¾ ä½ å¯¹ç‰¹å®šçŠ¶å†µçš„ååº”æ›´å¤šåœ°å‡ºäºè‡ªæˆ‘æ„è¯†ï¼Œè¿˜æ˜¯æ›´å¤šåœ°ä¸ºâ€œåšå¯¹äº‹â€ï¼Ÿå…ˆå½»åº•æƒ³æ¸…æ¥šè¿™ä¸ªé—®é¢˜ã€‚å¦‚æœä½ å‘ç°è‡ªå·±çš„ååº”èƒŒåæ˜¯è‡ªæˆ‘æ„è¯†åœ¨ä½œç¥Ÿï¼Œé‚£è¯·å°†å®ƒæ”¾åˆ°ä¸€æ—â€¦â€¦ é«˜ç­‰æ•™è‚²çš„è¿‡åº¦æ‰©å¼ å¯¼è‡´åŠ³åŠ¨åŠ›å¸‚åœºä¾›è¿‡äºæ±‚ï¼Œç”±æ­¤å¯¼è‡´ç™½é¢†å·¥äººâ€œè–ªæ°´æ¯”å¾…é‡ä¸é”™çš„åŠ³åŠ¨å·¥äººè¿˜å·®â€ã€‚æ­¤å¤–ï¼Œâ€œè¿™å¯èƒ½ä¼šå¯¼è‡´æŸç§ä»¤äººä¸å®‰çš„å¤±ä¸šæƒ…å†µã€‚å¤§å­¦æ¯•ä¸šç”Ÿä¸ä¸€å®šèƒ½æ‰¾åˆ°ä¸“ä¸šå¯¹å£çš„å·¥ä½œï¼Œå¿ƒç†ä¸Šå´åˆæ— æ³•æ¥å—ä½“åŠ›å·¥ä½œâ€ã€‚ æˆ‘ä»¬çš„é€‚åº”èƒ½åŠ›æå¼ºï¼Œç¯å¢ƒä¼šäº§ç”Ÿè‡ªå·±çš„é“å¾·è§„èŒƒï¼Œè€Œäººä»¬å†…å¿ƒçš„é“å¾·å‡†åˆ™ä¼šå› æŸäº›æ•æ„Ÿæ€§å’Œæ•é”æ€§åšå‡ºè®©æ­¥ã€‚ äººä»¬çš„ä¸ªæ€§å¤šç§å¤šæ ·ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰æ€§æ ¼çš„äººéƒ½é€‚åˆä¸Šå¤§å­¦ï¼Œäº‹å®ä¸Šï¼Œæœ‰äº›éå¸¸èªæ˜çš„äººå®Œå…¨ä¸é€‚åˆæ¥å—é«˜ç­‰æ•™è‚²ï¼Œä¹Ÿä¸é€‚åˆä»äº‹é‚£äº›äººä»¬è®¤ä¸ºæ‹¥æœ‰å­¦ä½çš„äººåº”è¯¥ä»äº‹çš„å·¥ä½œï¼Œä½†å¤§å®¶å¹¶æœªæ„è¯†åˆ°è¿™ç‚¹ã€‚å°†æ¯ä¸ªäººéƒ½é€å…¥å¤§å­¦ä¼šå¯¼è‡´åŠ³åŠ¨åŠ›å¸‚åœºå‡ºç°å¼‚å¸¸ã€‚ å¯¹æ–‡å‡­çš„è¦æ±‚è¶Šæ¥è¶Šé«˜ï¼Œé€ æˆäº†â€œè¿™æ˜¯ä¸€ä¸ªå‰æ‰€æœªæœ‰çš„çŸ¥è¯†åŒ–çš„ç¤¾ä¼šï¼Œå…¶æˆå‘˜çš„è®¤çŸ¥æ°´å‡†æ˜¯ä»–ä»¬é‚£äº›æ²¡æœ‰ä¸Šè¿‡å­¦çš„çˆ¶æ¯ä»¬æ— æ³•æƒ³è±¡çš„ã€‚â€çš„å‡è±¡ã€‚ å­¦æ ¡æ•™è‚²çš„å½¢å¼ç‰¹å¾ï¼ˆä¾‹å¦‚æˆç»©ã€å¥–æƒ©å’Œå­¦ä½ç­‰ï¼‰å˜å¾—æ¯”å…¶æœ¬è´¨ç‰¹å¾æ›´é‡è¦ã€‚åœ¨å­¦æ ¡å­¦ä¹ æœŸé—´ï¼Œäº‰å–å¥–åŠ±å˜å¾—æ¯”åˆ‡å®å­¦åˆ°ä¸œè¥¿æ›´é‡è¦â€¦â€¦æ•™å­¦è¢«æ’åˆ°äº†å­¦æ ¡æ’åçš„åé¢ï¼Œåè€…çš„ç¤¾ä¼šæ•ˆåº”æ›´ä¸ºæ˜æ˜¾ï¼›æ‰“åˆ†æ›´çœ‹é‡çš„æ˜¯å…¶ç¤¾ä¼šå½±å“ï¼Œè€Œéå®ç°æ•™å­¦çš„ç›®æ ‡ã€‚ äººä»¬å¸¸è¯´çš„æ™®åŠé«˜ç­‰æ•™è‚²çš„ç†ç”±æ˜¯ï¼Œç¤¾ä¼šå¯¹æ‹¥æœ‰ä¸°å¯ŒçŸ¥è¯†çš„å‘˜å·¥çš„éœ€æ±‚è¶Šæ¥è¶Šè¿«åˆ‡ï¼Œå…¶å®è¿™ç§æƒ…å†µåŸºäºä¸€ä¸ªåå¸¸çš„ç†ç”±ï¼šå¤§å­¦è®©å¹´è½»äººä¹ æƒ¯äºæ¥å—å½¢å¼å’Œå†…å®¹çš„ä¸åŒ¹é…ï¼Œæ¥å—å®˜æ–¹è¨€è®ºå’Œç°å®æƒ…å†µçš„ä¸ç›¸ç¬¦ã€‚ åŸ¹å…»å¹´è½»äººè‡ªå°Šï¼Œä¼¼ä¹æ˜¯ä¸ºäº†å¸®åŠ©ä»–ä»¬é€‚åº”ç¼ºå°‘å®¢è§‚æ ‡å‡†çš„å·¥ä½œï¼Œä¿è¯ä»–ä»¬å›´ç€å›¢é˜Ÿæ‰“è½¬ã€‚å½“è‡ªå°Šæ˜¯è¢«äººä¸ºåŸ¹å…»å‡ºæ¥æ—¶ï¼Œå°±å¾ˆå®¹æ˜“è¢«æ“çºµã€‚å®ƒæ˜¯ä¸€ç§ç¤¾ä¼šæŠ€å·§çš„äº§ç‰©ï¼Œè€Œä¸æ˜¯å»ºç«‹åœ¨è‡ªèº«æˆå°±ä¸Šçš„ä¸€ç§ä¿éšœã€‚ å­©å­ä»¬å¾—åˆ°çš„è¡¨æ‰¬è¶Šå¤šï¼Œå°±è¶Šä¼šåŠªåŠ›ç»´æŒè‡ªå·±å¿ƒç›®ä¸­çš„è‡ªæˆ‘å½¢è±¡ï¼›é‚£äº›è¢«ä»–äººç§°èµèªæ˜çš„å­©å­åœ¨è¢«åˆ†é…æ–°ä»»åŠ¡æ—¶ï¼Œä¼šé€‰æ‹©ç›¸å¯¹ç®€å•çš„å¤„ç†æ–¹æ³•ã€‚ä»–ä»¬ä¼šå¼€å§‹é€ƒé¿é£é™©ï¼Œä¾èµ–ä»–äººã€‚ è¾¹åšè¾¹æƒ³ å»ºç«‹åœ¨é€šç”¨ã€å‘½é¢˜å¼çŸ¥è¯†ä¸Šçš„èŒä¸šå«é‡‘é‡æ¯”è¾ƒé«˜ï¼Œä½†ä¹Ÿé¢ä¸´ç€æ¥è‡ªå…¨çƒçš„ç«äº‰ï¼Œå› ä¸ºä¸€æ–¹é¢ï¼Œåœ¨å…¨çƒç»æµä¸­ï¼Œä¹¦æœ¬çŸ¥è¯†çš„ä¼ æ’­èŒƒå›´è¶Šæ¥è¶Šå¹¿ã€‚å¦ä¸€æ–¹é¢ï¼Œå®ç”¨æŠ€æœ¯å§‹ç»ˆä¸ä¸ªäººçš„ç»éªŒå¯†åˆ‡ç›¸è¿ã€‚å®ƒæ— æ³•é€šè¿‡ä¸‹è½½è·å¾—ï¼Œåªèƒ½ä»å®è·µä¸­è·å–ã€‚ é€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸èƒ½å¯¹äº‹ç‰©åšåˆ°ä¸åä¸å€šã€‚åŸå› å¾ˆç®€å•ï¼šé‚£äº›ä¸æˆ‘ä»¬æ— å…³çš„äº‹æƒ…ä¸å¥½å¼•èµ·æˆ‘ä»¬çš„æ³¨æ„ï¼Œè€Œä¸”æˆ‘ä»¬çš„æ³¨æ„åŠ›ä¹Ÿæ˜¯æœ‰é™çš„ã€‚ ç›¸äº’ä½œç”¨çš„å˜é‡æ•°é‡å¤ªå¤§ï¼Œå› æ­¤äººè„‘æ— æ³•åŒæ—¶æ­£ç¡®å¤„ç†â€¦â€¦ç›´è§‰åˆ¤æ–­æ˜¯å¯¹ç›´è§‰çš„å› æœå…³ç³»çš„ååº”ï¼Œè¿™æ­£æ˜¯ç®€å•ç³»ç»Ÿçš„ç‰¹ç‚¹ã€‚ å›½é™…è±¡æ£‹å¤§å¸ˆä¹‹æ‰€ä»¥æ˜¯å¤§å¸ˆï¼Œå¹¶ä¸æ˜¯å› ä¸ºä»–è®°å¿†åŠ›æ¯”ä»–äººå¼ºï¼Œè€Œæ˜¯å› ä¸ºä»–ä»¬è§è¿‡é‚£äº›å›½é™…è±¡æ£‹çš„å¸ƒå±€æ¨¡å¼ã€‚ â€œè¡Œå®¶ä»¬æ‡‚å¾—å»å¯Ÿè§‰é‚£äº›æ–°æ‰‹ä»¬æ³¨æ„ä¸åˆ°çš„äº‹ç‰©ï¼Œä¾‹å¦‚ç‰¹å®šæƒ…å†µä¸‹çš„æŸäº›ç‰¹å¾ã€‚â€ åœ¨ç¼–å†™ç»´ä¿®æ‰‹å†Œçš„äººçœ‹æ¥ï¼Œä¿®ç†å·¥å°±æ˜¯æ™ºåŠ›æŠ€æœ¯å’Œç›¸åº”çš„ç¤¾ä¼šæŠ€æœ¯ä¸­çš„å°é½¿è½®ï¼Œè€Œä¸æ˜¯ç‹¬ç«‹æ€è€ƒçš„äººã€‚ ç¼–å†™ç»´ä¿®æ‰‹å†Œçš„åº”è¯¥æ˜¯é‚£äº›åŒæœºå™¨ä¸€èµ·å·¥ä½œå’Œç”Ÿæ´»çš„äººã€‚ä»–ä»¬ä½¿ç”¨çš„è¯­è¨€è®©äººæ„Ÿè§‰æœ‰ä¸€ä¸ªçœŸå®çš„äººå­˜åœ¨ï¼Œä½ æ„¿æ„å’Œä»–åä¸‹æ¥ï¼Œå‘ä»–å­¦ä¹ ã€‚ æŠ€å·¥ä¸ºäº†æŠŠä»–çš„å·¥ä½œåšå¥½ï¼Œæœ‰æ—¶å€™å¿…é¡»é‡‡å–åˆç†è¡ŒåŠ¨ï¼›è€ŒçŸ¥è¯†ç§‘æŠ€æ–­è¨€ï¼Œç”¨åˆ†å·¥æ¥å–ä»£ä¸ªäººçŸ¥è¯†æ˜¯ä¸€ç§ä¼ªè£…çš„åˆç†è¡ŒåŠ¨ã€‚ å·¥ä½œã€ä¼‘é—²ä¸å…¨å¿ƒæŠ•å…¥ äººä»¬é€‰æ‹©ä¼‘é—²æ´»åŠ¨å¸¸å¸¸æ˜¯ä¸ºäº†â€œè¿½æ±‚çœŸæ­£çš„è‡ªæˆ‘â€ã€‚ä¸æ­¤ç›¸åº”ï¼Œæ‰€è°“â€œå¥½å·¥ä½œâ€å°±æ˜¯èƒ½è®©äººæ°‘æ‹¥æœ‰æœ€å¤§çš„è´¢åŠ›ï¼Œæ¥è¿½æ±‚é‚£äº›èƒ½è®©ç”Ÿå‘½å˜å¾—æœ‰æ„ä¹‰çš„ä¼‘é—²æ´»åŠ¨ã€‚ é‡è¦çš„ä¸åœ¨äºä½ èƒ½è·‘å¤šå¿«ï¼Œè€Œåœ¨äºä½ ç”¨ä»€ä¹ˆæ–¹æ³•è·‘å¾—å¿«ã€‚ äººç±»ä¸åŠ¨ç‰©çš„åŒºåˆ«åœ¨äºåŠ¨ç‰©åœ¨ä¸€å¼€å§‹å°±çŸ¥é“é¢„æœŸè¦è¾¾åˆ°çš„æ•ˆæœï¼Œç„¶åæ‰ä¼šå»å¯»æ‰¾èƒ½æ»¡è¶³è¦æ±‚çš„å·¥å…·ï¼›è€Œæˆ‘ä»¬äººç±»èƒ½å¤Ÿå°†æ‰€æœ‰ä¸œè¥¿è§†ä½œæ½œåœ¨çš„å·¥å…·ã€‚ çŒªå–œæ¬¢åœ¨æ³¥å·´é‡Œæ‰“æ»šï¼Œæµ·è±šåœ¨æ°´é‡Œå¬‰æˆï¼Œè¿™äº›çœ‹ä¸Šå»éƒ½åƒä¼‘é—²æ´»åŠ¨ã€‚ä½†è®¸å¤šåŠ¨ç‰©åšçš„äº‹æƒ…å¾ˆåƒå·¥ä½œï¼Œè¿™äº›äº‹æƒ…åœ¨æ”¹å˜ç€è‡ªç„¶çš„å½¢æ€ï¼Œå‘æŒ¥ç€ä½œç”¨ã€‚ è¦æƒ³åœ¨æ´»åŠ¨ä¸­æ‰¾åˆ°å¿«ä¹ï¼Œå°±è¦å‚ä¸å¹¶å…¨å¿ƒæŠ•å…¥æ´»åŠ¨ä¸­ï¼Œè¿™ç§æŠ•å…¥æ˜¯ä¸€å¿ƒä¸€æ„ã€å…¨ç¥è´¯æ³¨çš„ï¼Œä½¿æ•´ä¸ªæ´»åŠ¨å€¼å¾—è¢«è¿½æ±‚â€¦â€¦å¦‚æœåªæ˜¯åœ¨ä¹æ´»åŠ¨çš„å·¥å…·ä»·å€¼â€¦â€¦å…¶å¯¹ä»·å€¼çš„å…³æ³¨å°±ä¼šä»æ´»åŠ¨æœ¬èº«è½¬ç§»åˆ°é¢„æœŸç»“æœä¸Šï¼Œå³ä¸å†å…³å¿ƒæ­£åœ¨åšä»€ä¹ˆã€‚è¿™ç§å…³æ³¨â€¦â€¦è®©æˆ‘ä»¬åœ¨æ´»åŠ¨ä¸­å¿ƒä¸åœ¨ç„‰ï¼Œä½¿æ´»åŠ¨å˜æˆä¸€ç§è´Ÿæ‹…ã€‚ å¦‚æœæˆ‘ä»¬è®©è‡ªå·±çš„è¡ŒåŠ¨å›å½’æ ¹æœ¬ï¼Œå°±èƒ½æ›´å¥½åœ°ç†è§£ä»€ä¹ˆæ˜¯ç¾å¥½çš„ç”Ÿæ´»ã€‚]]></content>
      <categories>
        <category>æ³› - ä¹¦æ‘˜</category>
      </categories>
      <tags>
        <tag>è¯»ä¹¦</tag>
        <tag>å·¥åŒ ç²¾ç¥</tag>
        <tag>ä¹¦æ‘˜</tag>
        <tag>æ‘©æ‰˜è½¦ä¿®ç†åº—çš„æœªæ¥å·¥ä½œå“²å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆäºŒï¼‰æ„é€ å‡½æ•°]]></title>
    <url>%2F2018%2F02%2F11%2Fcpp-class-2%2F</url>
    <content type="text"><![CDATA[æ„é€ å™¨Constructoræ„é€ å™¨(å‡½æ•°)ä¸€ç§ç‰¹æ®Šçš„æˆå‘˜å‡½æ•°ï¼Œç”¨äºå¯¹è±¡çš„åˆå§‹åŒ–ã€‚åç§°ä¸ç±»çš„åç§°ç›¸åŒï¼Œå¯ä»¥é‡è½½ï¼Œæ— è¿”å›ç±»å‹ã€‚123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class A&#123; private: int a,b; public: A(int aa,int bb) &#123; a = aa; b = bb; &#125;&#125;;int main()&#123; A a(1,2); return 0;&#125; åœ¨è¿™é‡Œæˆ‘ä»¬å®šä¹‰çš„Aç±»çš„ä¸€ä¸ªå‚æ•°ä¸ºä¸¤ä¸ªintçš„æ„é€ å‡½æ•°ï¼Œåœ¨mainå‡½æ•°ä¸­aè¢«åˆ›å»ºæ—¶éœ€è¦ç”¨æ‹¬å·ä¼ å‚ã€‚ åˆå§‹åŒ–åˆ—è¡¨Initializer Listå¯¹äºä¸Šé¢çš„æ„é€ å‡½æ•°C++è¿˜æœ‰å…¶ä»–çš„åšæ³•ï¼Œåƒä¸‹é¢ä»£ç ä¸­çš„æ„é€ å‡½æ•°ã€‚ åˆå§‹åŒ–åˆ—è¡¨çš„åŠ¨ä½œæ˜¯åœ¨æ„é€ å‡½æ•°ä½“æ‰§è¡Œä¹‹å‰è¿›è¡Œçš„ï¼Œåˆå§‹åŒ–é¡ºåºæ˜¯æŒ‰ç…§æˆå‘˜å˜é‡çš„å£°æ˜é¡ºåºè¿›è¡Œçš„ä¸åˆå§‹åŒ–åˆ—è¡¨ä¸­çš„é¡ºåºæ— å…³ã€‚ 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class A&#123; private: int a,b; public: A(int aa,int bb):a(aa),b(bb)&#123;&#125;&#125;;int main()&#123; A a(1,2); return 0;&#125; åœ¨è¿™é‡Œä½ å¯ä»¥ç®€å•çš„è®¤ä¸ºä¸¤è€…æ•ˆæœæ˜¯ä¸€è‡´çš„ï¼Œä½†å¦‚æœæˆå‘˜ä¸æ˜¯åŸºç¡€æ•°æ®ç±»å‹ä¸¤è€…å°±ä¼šæœ‰å¾ˆå¤§ä¸åŒã€‚ ä¸¾ä¸ªä¾‹å­ï¼š 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class B&#123; private: int a,b; public: B(int aa,int bb) &#123; a = aa; b = bb; &#125;&#125;;class A&#123; private: int a,b; B c; public: A(int aa,int bb) &#123; a = aa; b = bb; c(1,2); &#125;&#125;;int main()&#123; A a(1,2); return 0;&#125; è¿™é‡Œæˆ‘ä»¬åˆå£°æ˜äº†ä¸€ä¸ªBç±»ï¼Œåœ¨Aç±»ä¸­æ·»åŠ äº†ä¸€ä¸ªæˆå‘˜cä¸ºBç±»çš„å¯¹è±¡ã€‚ æˆ‘ä»¬ç”¨g++ç¼–è¯‘è¿™ä¸ªç¨‹åºä¼šå¾—åˆ°è¿™æ ·çš„ä¸€æ¡é”™è¯¯ï¼š error: constructor for â€˜Aâ€™ must explicitly initialize the member â€˜câ€™ which does not have a default constructor å®ƒè¯´æˆ‘ä»¬å¿…é¡»æ˜¾å¼åˆå§‹åŒ–æˆå‘˜cï¼Œå› ä¸ºcæ²¡æœ‰ç¼ºçœæ„é€ å‡½æ•°ï¼ˆç¼ºçœæ„é€ å‡½æ•°åœ¨ä¸‹é¢ä¼šè®²è§£ï¼‰ã€‚ è¿™ä¸ªé”™è¯¯å¾ˆå¥‡æ€ªï¼Œæˆ‘ä»¬æ˜æ˜é‚£ä¹ˆæ˜æ˜¾çš„åˆå§‹åŒ–äº†cï¼Œå®ƒç«Ÿç„¶è¯´æˆ‘ä»¬æ²¡æœ‰æ˜¾å¼åˆå§‹åŒ–ï¼Œè¿˜è¦ä»€ä¹ˆç¼ºçœæ„é€ å‡½æ•°ã€‚ è¿™é‡Œçš„åŸå› å°±åœ¨äºå®ƒåœ¨è¿›æ„é€ å‡½æ•°ä¹‹å‰å°±è¦è¿›è¡Œåˆå§‹åŒ–ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹åŒ–åˆ—è¡¨ç¼–è¯‘å™¨ä¼šå»æ‰¾ç¼ºçœæ„é€ å‡½æ•°å»åˆå§‹åŒ–å®ƒã€‚å¦‚æœBç±»æœ‰ç¼ºçœæ„é€ å‡½æ•°ï¼Œè¿™ä¸ªä»£ç ä»ç„¶æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºåœ¨26è¡Œè¿™ä¸ªä¸æ˜¯æ­£ç¡®çš„åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡è¦ä¹ˆåœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­ï¼Œè¦ä¹ˆåœ¨å®ƒå®šä¹‰æ˜¯åœ°æ–¹åˆå§‹åŒ–ï¼Œ26è¡Œè¿™ç§æ–¹å¼ç¼–è¯‘å™¨ä¼šå»æ‰¾()çš„è¿ç®—ç¬¦é‡è½½å‡½æ•°ã€‚12345678class A&#123; private: int a,b; B c; public: A(int aa,int bb):a(aa),b(bb),c(1,2)&#123;&#125;&#125;; æ­£ç¡®çš„Aç±»çš„æ„é€ å‡½æ•°åº”è¯¥è¿™æ ·å†™ï¼Œåœ¨åˆå§‹åŒ–cæ—¶å®ƒä¼šè°ƒç”¨cçš„æ„é€ å‡½æ•°æ¥åˆå§‹åŒ–å®ƒã€‚ ç‰¹æ®Šçš„æ„é€ å‡½æ•°ç¼ºçœæ„é€ å‡½æ•°Default Constructorå¯¹äºä¸Šé¢çš„Aç±»æ¥è¯´å¦‚æœéœ€è¦åˆ›å»ºä¸€ä¸ªAç±»çš„æ•°ç»„ï¼Œæˆ‘ä»¬éœ€è¦è¿™æ ·ä¸€å¥è¯å®šä¹‰ä¸€ä¸ªä¸‰å•å…ƒçš„æ•°ç»„é‡Œé¢æ¯ä¸ªéƒ½è¦ç”¨æ‹¬å·ç»™å‡ºå‚æ•°ã€‚1A b[3] = &#123;A(1,2),A(2,3),A(3,4)&#125;; å¦‚æœæˆ‘ä»¬è¦åˆ›å»ºä¸€ä¸ª100å•å…ƒçš„æ•°ç»„ï¼Œå¦‚æœæ˜¯intçš„ï¼Œæˆ‘ä»¬ä¸€èˆ¬æ˜¯å…ˆå®šä¹‰å¥½å†ç”¨å¾ªç¯èµ‹å€¼ã€‚ æˆ‘ä»¬æƒ³è¿™æ ·å†™ï¼š1A c[100]; ä½†å¯¹äºAè¿™æ ·æ˜¯ä¸å¯ä»¥çš„ï¼Œå› ä¸ºå®ƒçš„æ„é€ å‡½æ•°éœ€è¦ä¸¤ä¸ªintä½œä¸ºå‚æ•°è€Œè¿™é‡Œåˆ›å»ºæ—¶å¹¶æ²¡æœ‰ç»™å‡ºå‚æ•°ï¼Œåœ¨å®šä¹‰æ—¶å®ƒä¸èƒ½åˆå§‹åŒ–è¿™äº›å¯¹è±¡ã€‚ æˆ‘ä»¬éœ€è¦å¦ä¸€ç§æ„é€ å‡½æ•°ï¼Œç¼ºçœæ„é€ å‡½æ•°ã€‚åªè¦æ˜¯æˆ‘ä»¬å†™çš„æ²¡æœ‰å‚æ•°çš„æ„é€ å‡½æ•°å°±å«åšç¼ºçœæ„é€ å‡½æ•°ã€‚1A()&#123;&#125; é‡è½½æ„é€ å‡½æ•°å°±å¯ä»¥åˆ›å»ºå‡ºcæ•°ç»„ã€‚ å¦‚æœä¸€ä¸ªç±»æ²¡æœ‰å£°æ˜ä»»ä½•æ„é€ å‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªä¸æ¥å—ä»»ä½•å‚æ•°ä¸åšä»»ä½•æ“ä½œçš„ç¼ºçœæ„é€ å‡½æ•°ã€‚ æ‹·è´æ„é€ å‡½æ•°Copy Constructor123A a(1,2);A b = a;// A b(a); å¦‚æœæˆ‘ä»¬å®šä¹‰äº†aè¿™ä¸ªå¯¹è±¡ï¼Œå¦‚æœåœ¨å®šä¹‰åˆå§‹åŒ–bæ—¶æƒ³ç›´æ¥æ‹¿açš„å€¼æ¥åˆå§‹åŒ–bï¼ˆéœ€è¦æ˜ç™½è¿™é‡Œçš„ç­‰å·ä¸æ‹¬å·åˆå§‹åŒ–ç­‰ä»·ï¼Œä¸èµ‹å€¼æ— å…³ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°æ‹·è´æ„é€ å‡½æ•°ï¼Œæ‹·è´æ„é€ å‡½æ•°éœ€è¦æ‹¿å¦ä¸€ä¸ªè¯¥ç±»çš„å¯¹è±¡ï¼ˆå¼•ç”¨ï¼‰ä½œä¸ºå‚æ•°ï¼Œåˆå§‹åŒ–æ—¶å¯ä»¥ç”¨ç­‰å·æˆ–ç”¨æ‹¬å·ã€‚12345A(const A &amp;p)&#123; a = p.a; b = p.b;&#125; å¯¹äºAç±»ç®€å•çš„æ‹·è´æ„é€ å‡½æ•°å°±æ˜¯è¿™æ ·ï¼Œæ‹·è´æ„é€ å‡½æ•°åªæ˜¯è¯´å®ƒçš„å‚æ•°æ˜¯è¯¥ç±»çš„å¯¹è±¡çš„å¼•ç”¨ï¼Œå‡½æ•°ä½“é‡Œä½ å¯ä»¥åšå…¶ä»–æ“ä½œã€‚ å¦‚æœä¸€ä¸ªç±»æ²¡æœ‰å£°æ˜æ‹·è´æ„é€ å‡½æ•°ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªéšå¼çš„æ‹·è´æ„é€ å‡½æ•°(Implicitly Copy Constructor)ï¼Œå®ƒå°†å¯¹åšæˆå‘˜æ‹·è´ï¼ˆMemberwise Copyï¼‰ï¼Œå¦‚æœæˆå‘˜æ˜¯åŸºç¡€æ•°æ®ç±»å‹å°±æ˜¯åŸºæœ¬çš„åˆå§‹åŒ–ï¼Œå¦‚æœæˆå‘˜æ˜¯å…¶ä»–å¯¹è±¡å°±è°ƒç”¨é‚£ä¸ªå¯¹è±¡çš„æ‹·è´æ„é€ å‡½æ•°åšåˆå§‹åŒ–ï¼ŒC++ä¸­çš„éšå¼æ‹·è´æ„é€ å¹¶ä¸æ˜¯ä½æ‹·è´ï¼ˆBitwise Copyï¼‰ã€‚ æ‹·è´æ„é€ å‡½æ•°çš„å‚æ•°ä¸ºä»€ä¹ˆå¿…é¡»æ˜¯å¼•ç”¨ï¼Ÿå› ä¸ºå‡½æ•°ä¼ å€¼è°ƒç”¨éœ€è¦åšä¸€æ­¥æ‹·è´æ„é€ ï¼Œå¦‚æœæ‹·è´æ„é€ å‡½æ•°æ˜¯ä¼ å€¼è°ƒç”¨ï¼Œé‚£ä¹ˆå°±ä¼šåœ¨ä¼ å€¼æ—¶å†æ¬¡è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ï¼Œå°±ä¼šå¼•èµ·æ— é™çš„é€’å½’ã€‚ æ‹·è´æ„é€ å‡½æ•°åœ¨å“ªé‡Œä¼šè¢«è°ƒç”¨ï¼Ÿ å¯¹è±¡åˆå§‹åŒ– å‡½æ•°çš„ä¼ å€¼è°ƒç”¨ å‡½æ•°çš„è¿”å›å€¼ ç¬¬ä¸€ç§æƒ…å†µå‰é¢å·²ç»æœ‰æ‰€ä»‹ç»ï¼Œåä¸¤ç§æƒ…å†µéœ€è¦æ³¨æ„ä¸åŒçš„ç¼–è¯‘å™¨ä¼šæœ‰ä¸åŒçš„è¡¨ç°ï¼Œä¸€èˆ¬æ¥è¯´ç¼–è¯‘å™¨ä¼šæŠŠå¾ˆå¤šä¸å¿…è¦çš„æ‹·è´æ„é€ ä¼˜åŒ–æ‰ã€‚ æ¯”å¦‚è¿™æ®µä»£ç ï¼šUbuntu Pastebin : https://paste.ubuntu.com/=rCHw4pHhMn/123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int num = 0;class A&#123; private: int a,b; public: A()&#123;&#125; A(int aa,int bb):a(aa),b(bb)&#123;&#125; A(const A &amp;p) &#123; num++; cout &lt;&lt; num &lt;&lt; "copy" &lt;&lt; endl; a = p.a; b = p.b; &#125;&#125;;A f(A a) //1&#123; A re(a); //2 return re; //3&#125;int main()&#123; A a(1,2); A b = f(a); //4 cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; å¦‚æœæ˜¯æŒ‰åˆšåˆšè®²çš„é€»è¾‘åº”è¯¥å‘ç”Ÿå››æ¬¡æ‹·è´æ„é€ ï¼Œæˆ‘åœ¨ä»£ç ä¸­æ ‡æ³¨çš„å››å¤„ã€‚ä½†å¦‚æœä½ ç”¨ä¸åŒç¼–è¯‘å™¨æˆ–è€…ä¸åŒçš„ç¼–è¯‘é€‰é¡¹ç¼–è¯‘éƒ½ä¼šæœ‰ä¸åŒçš„ç»“æœï¼Œåœ¨è¿™é‡Œæˆ‘ä½¿ç”¨CentOSä¸‹çš„g++ã€MacOSä¸‹çš„g++å’ŒWindows 10ä¸‹çš„DevC++ï¼ˆMinGWï¼‰æµ‹è¯•çš„ç»“æœéƒ½ä¸ºè°ƒç”¨äº†ä¸¤æ¬¡ã€‚1234567[zyx@centos-linux c]$ g++ test.cpp[zyx@centos-linux c]$ ./a.out1copy2copy2//CentOS g++ 64bit è€Œåœ¨Windows 10çš„Visual Studio 2013çš„ç»“æœä¸ºä¸‰æ¬¡ã€‚1234561copy2copy3copy3//Visual Studio 2013 64bit å¯¹äºVisual Studio 2017ä¾ç„¶å¦‚æ­¤ 1234561copy2copy3copy3//Visual Studio 2017 64bit Windowsä¸‹CBçš„ä¸g++å’ŒMinGWç›¸åŒ123451copy2copy2//CB 64bit å¯ä»¥è¯´æ˜ä¸åŒçš„ç¼–è¯‘å™¨åœ¨æ‹·è´æ„é€ ä¸Šæœ‰ä¸åŒçš„ä¼˜åŒ–ç­–ç•¥ã€‚ æ·±å…¥æ¢ç©¶æ‹·è´æ„é€ å‡½æ•°çš„ç¼–è¯‘å™¨ä¼˜åŒ–ï¼šä¹‹å‰è¯´çš„è°ƒç”¨æ‹·è´æ„é€ çš„è§„åˆ™åœ¨ç¼–è¯‘å™¨çš„ä¼˜åŒ–é¢å‰å¥½åƒå°±æ²¡äº†è§„åˆ™ï¼Œä¸ºä»€ä¹ˆä¼šè¿™æ ·å‘¢ï¼Ÿå¯¹äºå‘ç”Ÿäº†ä¸‰æ¬¡å’Œä¸¤æ¬¡æ‹·è´æ„é€ çš„æƒ…å†µå®ƒä»¬ç©¶ç«Ÿä¼˜åŒ–æ‰äº†å“ªä¸€æ¬¡æˆ–ä¸¤æ¬¡å‘¢ï¼Ÿ C++æ ‡å‡†(N4527) Â§ 12.8 Copying and moving class objects ç¬¬31æ¡ï¼ˆP.293/294ï¼‰ä¸­è¿™æ ·å†™åˆ°ï¼š When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side eï¬€ects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two diï¬€erent ways of referring to the same object. If the ï¬rst parameter of the selected constructor is an rvalue reference to the objectâ€™s type, the destruction of that object occurs when the target would have been destroyed; otherwise, the destruction occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies): è¿™é‡Œåªæ˜¯è¯´ç¼–è¯‘å™¨å¯ä»¥åœ¨ä¸€äº›æƒ…å†µä¸‹ä¸è€ƒè™‘å‰¯ä½œç”¨å¯¹æ‹·è´æˆ–è€…ç§»åŠ¨æ„é€ å‡½æ•°è¿›è¡Œä¼˜åŒ–ï¼Œè€Œä¸”å¯¹äºæ ‡å‡†ä¸­çš„å››ç§æƒ…å†µå¯ä»¥åˆ é™¤å¤šä»½ã€‚ ä¹‹ååˆ—ä¸¾äº†å››æ¡åŸºæœ¬æƒ…å†µï¼Œæˆ‘ä»¬åªå…³å¿ƒç¬¬ä¸€å’Œç¬¬ä¸‰æ¡ï¼š (31.1) â€” in a return statement in a function with a class return type, when the expression is the name of a nonvolatile automatic object (other than a function parameter or a variable introduced by the exceptiondeclaration of a handler (15.3)) with the same type (ignoring cv-qualiï¬cation) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the functionâ€™s return value. (31.3) â€” when the exception-declaration of an exception handler (Clause 15) declares an object of the same type (except for cv-qualiï¬cation) as the exception object (15.1), the copy operation can be omitted by treating the exception-declaration as an alias for the exception object if the meaning of the program will be unchanged except for the execution of constructors and destructors for the object declared by the exception-declaration. [ Note: There cannot be a move from the exception object because it is always an lvalue. â€” end note ] ç¬¬ä¸€æ¡ï¼šå‡½æ•°çš„ return è¯­å¥ä¸­çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªé volatile çš„å¯¹è±¡ï¼Œå¹¶ä¸”å…¶éconst&amp;volatileç±»å‹å’Œå‡½æ•°è¿”å›å€¼çš„éconst&amp;volatileç±»å‹ç›¸åŒï¼Œæ­¤æ—¶å¯ä»¥çœç•¥ä¸€æ¬¡æ‹·è´æˆ–ç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆç§»åŠ¨æ„é€ å‡½æ•°ä¸ºC++11çš„æ‰©å±•ï¼‰ã€‚ ç¬¬ä¸‰æ¡ï¼šå¯¹äºä¸€ä¸ªéconst&amp;volatileçš„ä¸´æ—¶å¯¹è±¡ä¸”æ²¡æœ‰ç»‘å®šå¼•ç”¨ï¼Œå®ƒçš„å¤åˆ¶/ç§»åŠ¨æ“ä½œï¼Œå¯ä»¥çœç•¥ã€‚ å¯¹äºç¬¬ä¸€æ¡æ˜ç¡®çš„æ ‡å‡†å‡ ä¹æ‰€æœ‰çš„ç¼–è¯‘å™¨å¯¹æ­¤éƒ½åšäº†ä¼˜åŒ–ï¼Œä¹Ÿå°±æ˜¯ä»£ç ä¸­ç¬¬3å·ç‚¹è¢«ä¼˜åŒ–æ‰äº† å¯¹äºç¬¬ä¸‰æ¡åœ¨G++å’ŒCBä¸­ç¬¬4å·ç‚¹å› æ­¤è¢«ä¼˜åŒ–ï¼Œä¹Ÿå°±æ˜¯å¯¹è±¡bçš„æ„é€ æ²¡æœ‰è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ã€‚g++æä¾›äº†ä¸€ä¸ªç¼–è¯‘é€‰é¡¹ï¼š-fno-elide-constructors å¼€å¯è¿™ä¸ªé€‰é¡¹ç¼–è¯‘å™¨ä¼šå…³é—­ä¸Šè¿°å…³äºæ‹·è´å’Œç§»åŠ¨æ„é€ å‡½æ•°çš„ä¼˜åŒ–ã€‚ 123456789[zyx@centos-linux c]$ g++ -fno-elide-constructors test.cpp[zyx@centos-linux c]$ ./a.out1copy2copy3copy4copy4//CentOS g++ 64bit è¿è¡Œç»“æœç¡®å®æ˜¯4æ¬¡ è¿™æ ·æˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹æ¯”æ±‡ç¼–ä»£ç æ¥çœ‹å…·ä½“å®ƒåœ¨å“ªé‡Œä¼˜åŒ–äº†æ‹·è´æ„é€ ã€‚ ä»£ç ï¼šé»˜è®¤ä¼˜åŒ–Ubuntu Pastebin : https://paste.ubuntu.com/=Wm88H4Vhxf/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 .globl __Z1f1A .p2align 4, 0x90__Z1f1A: ## @_Z1f1A .cfi_startproc## BB#0: pushq %rbpLcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp subq $16, %rsp movq %rdi, %rax movq %rax, -8(%rbp) ## 8-byte Spill callq __ZN1AC1ERKS_ movq -8(%rbp), %rax ## 8-byte Reload addq $16, %rsp popq %rbp retq .cfi_endproc .globl __ZN1AC1ERKS_ .weak_def_can_be_hidden __ZN1AC1ERKS_ .p2align 4, 0x90_main: ## @main .cfi_startproc## BB#0: pushq %rbpLcfi6: .cfi_def_cfa_offset 16Lcfi7: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi8: .cfi_def_cfa_register %rbp subq $64, %rsp leaq -32(%rbp), %rdi movl $1, %esi movl $2, %edx movl $0, -20(%rbp) callq __ZN1AC1Eii leaq -48(%rbp), %rdi leaq -32(%rbp), %rsi callq __ZN1AC1ERKS_ leaq -40(%rbp), %rdi leaq -48(%rbp), %rsi callq __Z1f1A movq __ZNSt3__14coutE@GOTPCREL(%rip), %rdi movl _num(%rip), %esi callq __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi leaq __ZNSt3__14endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rdi movq %rax, -8(%rbp) movq %rdi, -16(%rbp) movq -8(%rbp), %rdi callq *-16(%rbp) xorl %edx, %edx movq %rax, -56(%rbp) ## 8-byte Spill movl %edx, %eax addq $64, %rsp popq %rbp retq .cfi_endproc å…³é—­ä¼˜åŒ–Ubuntu Pastebin : https://paste.ubuntu.com/=7CV893KdNY/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 .globl __Z1f1A .p2align 4, 0x90__Z1f1A: ## @_Z1f1A .cfi_startproc## BB#0: pushq %rbpLcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp subq $32, %rsp movq %rdi, %rax leaq -8(%rbp), %rcx movq %rdi, -16(%rbp) ## 8-byte Spill movq %rcx, %rdi movq %rax, -24(%rbp) ## 8-byte Spill callq __ZN1AC1ERKS_ leaq -8(%rbp), %rsi movq -16(%rbp), %rdi ## 8-byte Reload callq __ZN1AC1ERKS_ movq -24(%rbp), %rax ## 8-byte Reload addq $32, %rsp popq %rbp retq .cfi_endproc .globl _main .p2align 4, 0x90_main: ## @main .cfi_startproc## BB#0: pushq %rbpLcfi6: .cfi_def_cfa_offset 16Lcfi7: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi8: .cfi_def_cfa_register %rbp subq $64, %rsp leaq -32(%rbp), %rdi movl $1, %esi movl $2, %edx movl $0, -20(%rbp) callq __ZN1AC1Eii leaq -56(%rbp), %rdi leaq -32(%rbp), %rsi callq __ZN1AC1ERKS_ leaq -48(%rbp), %rdi leaq -56(%rbp), %rsi callq __Z1f1A leaq -40(%rbp), %rdi leaq -48(%rbp), %rsi callq __ZN1AC1ERKS_ movq __ZNSt3__14coutE@GOTPCREL(%rip), %rdi movl _num(%rip), %esi callq __ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi leaq __ZNSt3__14endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rdi movq %rax, -8(%rbp) movq %rdi, -16(%rbp) movq -8(%rbp), %rdi callq *-16(%rbp) xorl %edx, %edx movq %rax, -64(%rbp) ## 8-byte Spill movl %edx, %eax addq $64, %rsp popq %rbp retq .cfi_endproc é»˜è®¤ä¼˜åŒ–ä¸‹ç¨‹åºåœ¨17å’Œ51è¡Œè°ƒç”¨äº†Açš„æ‹·è´æ„é€ å‡½æ•°ï¼Œè€Œåœ¨å…³é—­æ‹·è´æ„é€ åç¨‹åºåˆ†åˆ«åœ¨20ã€23ã€55ã€61è¡Œè°ƒç”¨äº†æ‹·è´æ„é€ å‡½æ•°ã€‚è¿™é‡Œåˆ†æå¯ä»¥å‘ç°ç¼–è¯‘å™¨ä¼˜åŒ–æ‰äº† å‡½æ•°è¿”å›å€¼çš„æ„é€  å’Œ å¯¹è±¡bçš„æ„é€ ã€‚Visual Studio 2013 64bit åæ±‡ç¼–ä»£ç ï¼šUbuntu Pastebin : https://paste.ubuntu.com/=h3mV88hjrn/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778A f(A a) //1&#123;00395850 55 push ebp 00395851 8B EC mov ebp,esp 00395853 81 EC D4 00 00 00 sub esp,0D4h 00395859 53 push ebx 0039585A 56 push esi 0039585B 57 push edi 0039585C 8D BD 2C FF FF FF lea edi,[ebp-0D4h] 00395862 B9 35 00 00 00 mov ecx,35h 00395867 B8 CC CC CC CC mov eax,0CCCCCCCCh 0039586C F3 AB rep stos dword ptr es:[edi] 0039586E A1 00 00 3A 00 mov eax,dword ptr ds:[003A0000h] 00395873 33 C5 xor eax,ebp 00395875 89 45 FC mov dword ptr [ebp-4],eax A re(a); //200395878 8D 45 0C lea eax,[a] 0039587B 50 push eax 0039587C 8D 4D F0 lea ecx,[re] 0039587F E8 37 BB FF FF call A::A (03913BBh) return re; //300395884 8D 45 F0 lea eax,[re] 00395887 50 push eax 00395888 8B 4D 08 mov ecx,dword ptr [ebp+8] 0039588B E8 2B BB FF FF call A::A (03913BBh) 00395890 8B 45 08 mov eax,dword ptr [ebp+8] &#125;int main()&#123;00F16060 55 push ebp 00F16061 8B EC mov ebp,esp 00F16063 81 EC F0 00 00 00 sub esp,0F0h 00F16069 53 push ebx 00F1606A 56 push esi 00F1606B 57 push edi 00F1606C 8D BD 10 FF FF FF lea edi,[ebp-0F0h] 00F16072 B9 3C 00 00 00 mov ecx,3Ch 00F16077 B8 CC CC CC CC mov eax,0CCCCCCCCh 00F1607C F3 AB rep stos dword ptr es:[edi] 00F1607E A1 00 00 F2 00 mov eax,dword ptr ds:[00F20000h] 00F16083 33 C5 xor eax,ebp 00F16085 89 45 FC mov dword ptr [ebp-4],eax A a(1, 2);00F16088 6A 02 push 2 00F1608A 6A 01 push 1 00F1608C 8D 4D F0 lea ecx,[a] 00F1608F E8 81 B3 FF FF call A::A (0F11415h) A b = f(a); //400F16094 83 EC 08 sub esp,8 00F16097 8B CC mov ecx,esp 00F16099 8D 45 F0 lea eax,[a] 00F1609C 50 push eax 00F1609D E8 19 B3 FF FF call A::A (0F113BBh) 00F160A2 8D 4D E0 lea ecx,[b] 00F160A5 51 push ecx 00F160A6 E8 6D B0 FF FF call f (0F11118h) 00F160AB 83 C4 0C add esp,0Ch cout &lt;&lt; num &lt;&lt; endl;00F160AE 8B F4 mov esi,esp 00F160B0 68 E8 13 F1 00 push 0F113E8h 00F160B5 8B FC mov edi,esp 00F160B7 A1 20 03 F2 00 mov eax,dword ptr ds:[00F20320h] 00F160BC 50 push eax 00F160BD 8B 0D A0 10 F2 00 mov ecx,dword ptr ds:[0F210A0h] 00F160C3 FF 15 94 10 F2 00 call dword ptr ds:[0F21094h] 00F160C9 3B FC cmp edi,esp 00F160CB E8 64 B2 FF FF call __RTC_CheckEsp (0F11334h) 00F160D0 8B C8 mov ecx,eax 00F160D2 FF 15 90 10 F2 00 call dword ptr ds:[0F21090h] 00F160D8 3B F4 cmp esi,esp 00F160DA E8 55 B2 FF FF call __RTC_CheckEsp (0F11334h) return 0;00F160DF 33 C0 xor eax,eax &#125; VSçš„åæ±‡ç¼–ä»£ç ä¸­æœ‰C++ä»£ç æ³¨é‡Šï¼Œå®ƒåˆ†åˆ«åœ¨20ã€25ã€57è¡Œè°ƒç”¨äº†Açš„æ‹·è´æ„é€ å‡½æ•°ï¼Œå¯ä»¥çœ‹å‡ºVSåªæ˜¯ä¼˜åŒ–æ‰äº†å¯¹è±¡bçš„æ„é€ ã€‚]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>æ±‡ç¼–è¯­è¨€</tag>
        <tag>æ„é€ å‡½æ•°</tag>
        <tag>æ‹·è´æ„é€ å‡½æ•°</tag>
        <tag>ç¼ºçœæ„é€ å‡½æ•°</tag>
        <tag>ç¼–è¯‘å™¨ä¼˜åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFSä¸BFS]]></title>
    <url>%2F2018%2F02%2F05%2Fdfs-bfs%2F</url>
    <content type="text"><![CDATA[ç®€ä»‹DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰å’ŒBFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰éƒ½æ˜¯åº”ç”¨å¹¿æ³›çš„æœç´¢ç®—æ³•ï¼ŒåŒå±äºå›¾ç®—æ³•ã€‚ä¸¤ç§ç®—æ³•å®é™…ä¸Šå°±æ˜¯ä¸¤ç§ä¸åŒçš„æœç´¢ç­–ç•¥ã€‚ åŒºåˆ« DFSçš„è®¿é—®é¡ºåºï¼š1 -&gt; 2 -&gt; 4 -&gt; 7 -&gt; 8 -&gt; 3 -&gt; 5 -&gt; 6 BFSçš„è®¿é—®é¡ºåºï¼š1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 DFSæ²¿ç€ä¸€ä¸ªåˆ†æ”¯ä¸€ç›´é€’å½’åˆ°æœ€åï¼Œè€ŒBFSä»èµ·ç‚¹ä¸€å±‚ä¸€å±‚å‘å¤–æ‰©å±•ã€‚DFSç”¨æ ˆæ¥å®ç°ï¼ŒBFSç”¨é˜Ÿåˆ—æ¥å®ç°ã€‚ å®ç°ä¸‹é¢ç»™å‡ºä¸¤ç§ç®—æ³•çš„ä¼ªä»£ç  DFS12345678910void dfs(int deep)&#123; if(åˆ°è¾¾è¾¹ç•Œ)&#123; // åšä¸€äº›å¤„ç†åè¿”å› &#125;else&#123; for(æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©)&#123; dfs(deep + 1); &#125; &#125;&#125; BFS1234567891011121314void bfs(èµ·å§‹ç‚¹) &#123; å°†èµ·å§‹ç‚¹æ”¾â¼Šé˜Ÿåˆ—ä¸­; while(å¦‚æœé˜Ÿåˆ—ä¸ä¸ºç©º)&#123; è®¿é—®é˜Ÿåˆ—ä¸­é˜Ÿâ¾¸å…ƒç´ x; åˆ é™¤é˜Ÿâ¾¸å…ƒç´ ; for(x æ‰€æœ‰ç›¸é‚»ç‚¹)&#123; if(è¯¥ç‚¹æœªè¢«è®¿é—®è¿‡ä¸”åˆæ³•)&#123; å°†è¯¥ç‚¹åŠ â¼Šé˜Ÿåˆ—æœ«å°¾; &#125; &#125; &#125; é˜Ÿåˆ—ä¸ºç©ºï¼Œâ¼´æœç»“æŸ;&#125; ä¾‹å­ä¸ºäº†ä¾¿äºç†è§£è¿™ä¸¤ç§ç®—æ³•çš„ä¼˜ç¼ºç‚¹ï¼Œæˆ‘åœ¨æˆ‘çš„é¢˜åº“ä¸­ç»™å‡ºä¸€é¢˜â€œèµ°è¿·å®«â€ï¼Œæ­¤é¢˜ä¸ºä¸€é“æ— æƒå›¾çš„æœ€çŸ­è·¯é¢˜ã€‚ DFSå’ŒBFSç®—æ³•éƒ½å¯ä»¥è½»æ¾è§£å†³æ­¤é¢˜ï¼Œä¸‹é¢æˆ‘ç›´æ¥ç»™å‡ºä»£ç ååˆ†æä¼˜ç¼ºç‚¹ã€‚ DFSå®ç°Ubuntu Pastebin : https://paste.ubuntu.com/26527945/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;#define MAX_MAP 20int minP = INT_MAX;char map[MAX_MAP][MAX_MAP];bool collected[MAX_MAP][MAX_MAP];struct dir&#123; int x,y;&#125;dir[4] = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;struct point&#123; point()&#123;&#125; point(int xx,int yy,int s):x(xx),y(yy),step(s)&#123;&#125; int x; int y; int step;&#125;;void dfs(point now)&#123; if(map[now.x][now.y] == 'T')&#123; if(now.step &lt; minP)&#123; minP = now.step; &#125; return; &#125; collected[now.x][now.y] = true; for( int i = 0; i &lt; 4; i++)&#123; if(!collected[now.x+dir[i].x][now.y+dir[i].y])&#123; point next(now.x+dir[i].x,now.y+dir[i].y,now.step+1); dfs(next); &#125; &#125; collected[now.x][now.y] = false; return;&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for( int i = 0 ; i &lt; MAX_MAP; i++)&#123; for( int j = 0; j &lt; MAX_MAP; j++)&#123; map[i][j] = '#'; collected[i][j] = true; &#125; &#125; point begin; for( int i = 1; i &lt;= n; i++)&#123; for( int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; map[i][j]; if(map[i][j] != '#')&#123; collected[i][j] = false; &#125; if(map[i][j] == 'S')&#123; begin.x = i; begin.y = j; begin.step = 0; &#125; &#125; &#125; dfs(begin); if(minP &lt; INT_MAX)&#123; cout &lt;&lt; minP; &#125;else&#123; cout &lt;&lt; -1; &#125; return 0;&#125; BFSå®ç°Ubuntu Pastebin : https://paste.ubuntu.com/26527953/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;#define MAX_MAP 20int n,m;char map[MAX_MAP][MAX_MAP];bool collected[MAX_MAP][MAX_MAP];struct Dir&#123; int x,y;&#125;dir[] = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;struct point&#123; int x; int y; int step;&#125;;int bfs(point begin)&#123; queue&lt;point&gt; Q; collected[begin.x][begin.y] = true; Q.push(begin); while(!Q.empty())&#123; point temp = Q.front(); Q.pop(); if(map[temp.x][temp.y] == 'T')&#123; return temp.step; &#125; for( int i = 0; i &lt; 4; i++)&#123; int x = temp.x + dir[i].x; int y = temp.y + dir[i].y; if(!collected[x][y] &amp;&amp; map[x][y] != '#')&#123; collected[x][y] = true; point rd; rd.x = x; rd.y = y; rd.step = temp.step + 1; Q.push(rd); &#125; &#125; &#125; return -1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for( int i = 0; i &lt; MAX_MAP; i++)&#123; for( int j = 0; j &lt; MAX_MAP; j++)&#123; map[i][j] = '#'; collected[i][j] = true; &#125; &#125; point begin; for( int i = 1; i &lt;= n; i++)&#123; for( int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; map[i][j]; collected[i][j] = false; if(map[i][j] == 'S')&#123; begin.x = i; begin.y = j; begin.step = 0; &#125; &#125; &#125; cout &lt;&lt; bfs(begin); return 0;&#125; åœ¨æ­¤é¢˜ä¸­BFSç®—æ³•æ˜¯å¾ˆå ä¼˜åŠ¿çš„ï¼Œå› ä¸ºå®ƒä¸éœ€è¦æšä¸¾æ‰€æœ‰æƒ…å†µï¼Œå¦‚æœåœ¨æŸä¸€å±‚é‡åˆ°ç»ˆç‚¹é‚£æœ€å°æ­¥æ•°å¿…ç„¶æ˜¯å½“å‰å±‚æ•°ï¼Œè€ŒDFSç®—æ³•éœ€è¦æšä¸¾æ‰€æœ‰æƒ…å†µæ¥æ›´æ–°æœ€å°æ­¥æ•°æœ€åæ‰èƒ½ç¡®å®šã€‚ç‰¹æ®Šæƒ…å†µä¸‹å¦‚æœèµ·ç‚¹å’Œç»ˆç‚¹æ˜¯é‚»å±…ï¼ŒBFSåªéœ€ä¸€å±‚æœç´¢å°±å¯ä»¥è§£å†³ï¼Œè€ŒDFSä»ç„¶éœ€è¦æšä¸¾æ‰€æœ‰ç»“æœã€‚å½“ç„¶DFSå¯ä»¥è¿›è¡Œå‰ªæä¼˜åŒ–ä½†åœ¨æ­¤é¢˜ä¸­æ•ˆç‡æ˜æ˜¾æ˜¯ä¸å¦‚BFSçš„ã€‚ å¦‚æœå°†æ­¤é¢˜æ”¹ä¸ºé—®é€šè¿‡è¿·å®«çš„æ–¹æ³•æ•°ï¼Œé‚£ä¹ˆæ­¤é¢˜å°±ä¸èƒ½ç”¨BFSè§£å†³ï¼Œå› ä¸ºBFSæ±‚çš„åªæ˜¯æœ€çŸ­è·¯å¹¶æ²¡æœ‰æšä¸¾æ‰€æœ‰çš„è·¯çº¿ã€‚æ­¤å›¾ä¸­ï¼Œå¦‚æœé¢˜ç›®é—®ä»1èµ°åˆ°3æœ‰å¤šå°‘ç§æ–¹æ³•ã€‚ å¦‚æœæ˜¯DFSå®ƒä¼šæ‰¾åˆ°ä¸¤ç§è·¯çº¿ï¼š1 -&gt; 3 å’Œ 1 -&gt; 2 -&gt; 3ã€‚ è€ŒBFSåœ¨ç¬¬ä¸€å±‚æ—¶æ‰¾åˆ°1 -&gt; 3è¿™æ¡è·¯åå°±å°†3æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œä¹‹åæ‰€æœ‰ç‚¹éƒ½å·²è¢«è®¿é—®å°±ä¸å­˜åœ¨ç¬¬äºŒå±‚äº†ä¹Ÿå°±ä¸å­˜åœ¨1 -&gt; 2 -&gt; 3è¿™æ¡è·¯äº†ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>ACM</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>å›¾æœç´¢</tag>
        <tag>å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¹¶æŸ¥é›†]]></title>
    <url>%2F2018%2F01%2F31%2Funion-find-sets%2F</url>
    <content type="text"><![CDATA[æ¦‚è¿°å¹¶æŸ¥é›†æ˜¯ä¸€ç§æ ‘å½¢æ•°æ®ç»“æ„ï¼Œç”¨äºå¤„ç†é›†åˆçš„åˆå¹¶åŠæŸ¥è¯¢é—®é¢˜ï¼Œå¸¸å¸¸ä»¥æ£®æ—çš„å½¢å¼è¡¨ç¤ºã€‚è¿™é‡Œéœ€è¦æ³¨æ„å¹¶æŸ¥é›†è™½ç„¶å¯ä»¥è¿›è¡Œåˆå¹¶æ“ä½œï¼Œä½†æ— æ³•è¿›è¡Œåˆ†å‰²æ“ä½œã€‚ å¹¶æŸ¥é›†ä¸€èˆ¬ç”¨æ•°ç»„æ¥å®ç°ï¼Œå¦‚æœæ˜¯æ— æƒå¹¶æŸ¥é›†åªéœ€è¦ä¸€ä¸ªä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„æ•°ç»„å°±å¯ä»¥å®ç°ã€‚ æ¥å£å¹¶æŸ¥é›†ä¸€èˆ¬æä¾›ä¸‰ä¸ªæ¥å£ï¼Œåˆå§‹åŒ–ï¼ŒæŸ¥è¯¢ï¼Œåˆå¹¶ã€‚ åˆå§‹åŒ–åˆå§‹çŠ¶æ€æ—¶ï¼Œæ¯ä¸ªå…ƒç´ å„ä¸ºä¸€æ£µæ ‘ï¼Œå…¶çˆ¶èŠ‚ç‚¹åˆå§‹ä¸ºå®ƒæœ¬èº«ã€‚ï¼ˆå›¾1ï¼‰ åˆå§‹åŒ–å‡½æ•°ä»£ç 123456void init()&#123; for( int i = 1; i &lt;= n; i++)&#123; pre[i] = i; &#125;&#125; preæ•°ç»„ä¿å­˜æ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹ã€‚ æŸ¥è¯¢æŸ¥è¯¢æ˜¯æŒ‡æŸ¥è¯¢ç»™å‡ºèŠ‚ç‚¹æ‰€åœ¨çš„é›†åˆçš„æ ¹èŠ‚ç‚¹ã€‚ é€’å½’æ€æƒ³ï¼šå¦‚æœå®ƒçš„çˆ¶èŠ‚ç‚¹å°±æ˜¯å®ƒæœ¬èº«ï¼Œé‚£å½“ç„¶å®ƒè‡ªå·±å°±æ˜¯å®ƒçš„æ ¹èŠ‚ç‚¹ã€‚å¦‚æœä¸æ˜¯é‚£å®ƒçˆ¶äº²çš„æ ¹èŠ‚ç‚¹å°±æ˜¯å®ƒçš„è·ŸèŠ‚ç‚¹ã€‚ æŸ¥è¯¢å‡½æ•°ä»£ç 123456789int get(int x)&#123; if(pre[x] == x)&#123; //x èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹ return x; &#125; return get(pre[x]); //è¿”å›çˆ¶èŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹&#125; è¿™é‡Œçš„æŸ¥è¯¢å‡½æ•°ï¼ˆåŒ…æ‹¬ä¸‹é¢çš„åˆå¹¶å‡½æ•°ï¼‰éƒ½å¯ä»¥ç”¨å¾ªç¯æ–¹å¼å®ç°ã€‚ åˆå¹¶ï¼š åˆå¹¶å°±æ˜¯æŠŠä¸¤ä¸ªé›†åˆåˆå¹¶æˆä¸€ä¸ªï¼Œä¹Ÿå°±æ˜¯å°†ä¸¤æ£µæ ‘åˆå¹¶ä¸ºä¸€æ£µæ ‘ã€‚ ï¼ˆå›¾2ï¼‰ åˆå¹¶å‡½æ•°ä»£ç 12345678void merge(int x,int y)&#123; x = get(x); y = get(y); if(x != y)&#123; // ä¸ä½åŒä¸€ä¸ªé›†åˆ pre[y] = x; &#125;&#125; è¿™é‡Œæˆ‘ä»¬å…ˆæ˜¯æ‰¾å‡ºä¸¤è¯¾æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå†å°†ä¸€ä¸ªèŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹è®¾ç½®ä¸ºå¦ä¸€ä¸ªèŠ‚ç‚¹çš„è·ŸèŠ‚ç‚¹å³å¯ã€‚ è·¯å¾„å‹ç¼©å¹¶æŸ¥é›†æœ€é‡è¦çš„æ“ä½œå°±æ˜¯æŸ¥æ‰¾ï¼Œæˆ‘ä»¬å…³å¿ƒçš„æ˜¯æ¯ä¸ªèŠ‚ç‚¹åœ¨å“ªæ£µæ ‘ä¸Šï¼Œå¹¶ä¸éœ€è¦çŸ¥é“æ ‘å…·ä½“çš„å½¢çŠ¶ï¼Œåƒå›¾2ä¸­çš„6ã€5ã€7èŠ‚ç‚¹å¦‚æœå°†6å·èŠ‚ç‚¹ç»§ç»­å’Œ4æˆ–8å·èŠ‚ç‚¹åˆå¹¶ä¼šäº§ç”Ÿä¸€æ£µåæ ‘ï¼Œæœ€åæƒ…å†µä¸‹å¯¼è‡´æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦è¾¾åˆ°O(n)ã€‚ æˆ‘ä»¬å¯ä»¥å°†6ã€5ã€7å·èŠ‚ç‚¹æ¢ä¸ºå›¾3ä¸­çš„æ ‘æ•ˆæœæ˜¯ä¸€æ ·çš„ã€‚æˆ‘ä»¬åªéœ€è°ƒæ•´getå‡½æ•°ï¼Œåœ¨æ¯æ¬¡è°ƒç”¨getå‡½æ•°æ—¶å‹ç¼©ä¸€æ¬¡è·¯å¾„ï¼Œä¸æ–­çš„ç»´æŠ¤è¿™ä¸ªå¹¶æŸ¥é›†ã€‚ä¼˜åŒ–åçš„æŸ¥è¯¢ä»£ç ï¼š123456789int get(int x)&#123; if(pre[x] == x)&#123; //x èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹ return x; &#125; return pre[x] = get(pre[x]); //è¿”å›çˆ¶èŠ‚ç‚¹çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶å¦å½“å‰èŠ‚ç‚¹çˆ¶èŠ‚ç‚¹ç›´æ¥ä¸ºæ ¹èŠ‚ç‚¹&#125; è¿™æ ·ä¼˜åŒ–ä¹‹åçš„å¹¶æŸ¥é›†æ•ˆç‡éå¸¸é«˜ã€‚æ‰§è¡Œä¸€æ¬¡æŸ¥è¯¢æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä»…ä¸ºO(Î±(n))ï¼Œè¿™é‡Œçš„Î±(n)æ˜¯é˜¿å…‹æ›¼å‡½æ•°çš„åå‡½æ•°ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦å°†æ¯”O(logn)è¿˜è¦å¿«ã€‚ å¸¦æƒå¹¶æŸ¥é›†å¸¦æƒå¹¶æŸ¥é›†æ˜¯æŒ‡å­˜æœ‰æƒå€¼çš„å¹¶æŸ¥é›†ï¼ŒèŠ‚ç‚¹çš„æƒå€¼ä¸€èˆ¬ä¿å­˜ä¸æ ¹èŠ‚ç‚¹çš„å…³ç³»ä¿¡æ¯ï¼Œæ¯”å¦‚æƒå€¼å¯ä»¥ä¿å­˜è¯¥èŠ‚ç‚¹ä¸è·ŸèŠ‚ç‚¹çš„è·ç¦»ã€‚è¿™é‡Œä¸ºäº†ä¾¿äºè®²è§£æˆ‘ä»¬ä»¥ä¸€é“é¢˜ä¸ºä¾‹ï¼š POJ 1182 é£Ÿç‰©é“¾é¢˜ç›®é“¾æ¥ï¼šhttp://poj.org/problem?id=1182Ubuntu Pastebin : https://paste.ubuntu.com/26527937/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#define N 500000using namespace std;int pre[N],weight[N];int ans,c;int get(int x)&#123; if(x != pre[x]) &#123; int temp = pre[x]; pre[x] = get(temp); weight[x]=(weight[x] + weight[temp]) % 3; &#125; return pre[x];&#125;void merge(int x,int y)&#123; int xRoot = get(x); int yRoot = get(y); if(xRoot != yRoot)&#123; pre[xRoot] = yRoot; weight[xRoot] = (weight[y]-weight[x] + c + 3) % 3; &#125;else if((weight[x]-weight[y] + 3) % 3 != c)&#123; ans++; &#125;&#125;void init(int n)&#123; for( int i = 0; i &lt;= n+10; i++)&#123; pre[i] = i; weight[i] = 0; &#125; ans = 0; &#125;int main()&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); init(n); for( int i = 0; i &lt; m; i++)&#123; int a,b; scanf("%d%d%d",&amp;c,&amp;a,&amp;b); if(a &gt; n || b &gt; n || (c == 2 &amp;&amp; a == b) )&#123; ans++; &#125;else&#123; c--; merge(a,b); &#125; &#125; printf("%d\n",ans);&#125; æ­¤é¢˜åªéœ€ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹åˆ°å…¶æ ¹èŠ‚ç‚¹çš„è·ç¦»å¯¹3å–ä½™çš„ç»“æœå³å¯ï¼Œè·¯å¾„å‹ç¼©æ—¶éœ€è¦æ³¨æ„ç»´æŠ¤æƒå€¼ã€‚ å…¶ä»–ä¸€äº›ç®€å•çš„å¹¶æŸ¥é›†é¢˜ç›®æˆ‘ä¼šä¹‹ååœ¨æˆ‘çš„vijosé¢˜åº“ä¸­ç»™å‡ºä½œä¸ºç»ƒä¹ ã€‚æ­¤é¢˜çš„è¯¦ç»†é¢˜è§£æˆ‘ä¹Ÿè®¸ä¼šä¹‹ååœ¨æˆ‘çš„åšå®¢æ›´æ–°ã€‚]]></content>
      <categories>
        <category>æ•°æ®ç»“æ„</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>ä¼˜åŒ–</tag>
        <tag>POJ</tag>
        <tag>æ•°æ®ç»“æ„</tag>
        <tag>å¹¶æŸ¥é›†</tag>
        <tag>å¸¦æƒå¹¶æŸ¥é›†</tag>
        <tag>æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ç±»ä¸å¯¹è±¡æ€»ç»“ï¼ˆä¸€ï¼‰]]></title>
    <url>%2F2018%2F01%2F26%2Fcpp-class-1%2F</url>
    <content type="text"><![CDATA[ç±»ä¸å¯¹è±¡çš„å…³ç³»ç±»æ˜¯ä¸€ç§æ ‡å‡†ï¼Œè€Œå¯¹è±¡æ˜¯ç±»çš„å®ä½“ï¼Œå°±å¦‚intæ˜¯ä¸€ç§æ•°æ®ç±»å‹ï¼ˆç±»ï¼‰ï¼Œè€Œint i;æ˜¯intç±»å‹çš„ä¸€ä¸ªå®ä½“å˜é‡ï¼ˆå¯¹è±¡ï¼‰ã€‚ æˆå‘˜å˜é‡ä¸æˆå‘˜å‡½æ•°ä¸€ä¸ªç±»ä¸­å¯ä»¥åŒ…å«å¤šä¸ªæˆå‘˜å‡½æ•°ï¼Œç±»çš„æ¯ä¸ªå¯¹è±¡å¯ä»¥åŒ…å«å¤šä¸ªæˆå‘˜å˜é‡ï¼ˆä¹Ÿå¯ä»¥æ˜¯å…¶ä»–çš„ç±»ï¼‰ï¼Œæ¯”å¦‚ä¸‹é¢çš„è¿™ä¸ªAç±»çš„å£°æ˜ä¸­å°±å£°æ˜äº†Aç±»æœ‰ä¸€ä¸ªæˆå‘˜å‡½æ•°bï¼Œå®ƒæ¯ä¸ªå¯¹è±¡ä¸­åŒ…å«ä¸€ä¸ªintç±»å‹çš„å˜é‡iã€‚1234class A&#123; int i; void b();&#125; è¿™é‡Œè¦æ³¨æ„çš„æ˜¯æˆå‘˜å‡½æ•°æ˜¯å±äºç±»çš„ï¼Œæˆå‘˜å˜é‡ï¼ˆé™æ€å˜é‡é™¤å¤–ï¼‰æ˜¯å±äºå¯¹è±¡çš„ã€‚ è®¿é—®å±æ€§åœ¨ç±»å£°æ˜ä¸­æˆ‘ä»¬å¯ä»¥å£°æ˜æ¯ä¸ªæˆå‘˜çš„è®¿é—®å±æ€§ï¼ˆå¦‚æœä¸å£°æ˜å…¶è®¿é—®å±æ€§ï¼Œé»˜è®¤ä¸ºprivateï¼‰ï¼Œåœ¨C++ä¸­æœ‰ publicã€protected å’Œ private è¿™ä¸‰ç§è®¿é—®å±æ€§ã€‚å£°æ˜çš„æ–¹æ³•è§ä»£ç 1234567class A&#123;private: int i;public: void b();&#125;; publicï¼šä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è®¿é—® protectedï¼šåªæœ‰è¿™ä¸ªç±»å’Œå®ƒçš„æ´¾ç”Ÿç±»å¯ä»¥è®¿é—® privateï¼šåªæœ‰è¿™ä¸ªç±»å¯ä»¥è®¿é—® éœ€è¦è¯´æ˜çš„æ˜¯C++çš„è¿™ç§è®¿é—®é™åˆ¶æ˜¯ç±»çš„è®¿é—®å±æ€§è€Œä¸æ˜¯å¯¹è±¡çš„ã€‚1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class A&#123;private: int i;public: A()&#123;&#125; A(int i):i(i)&#123;&#125; void c(A *p) &#123; cout &lt;&lt; p-&gt;i &lt;&lt; endl; &#125;&#125;;int main()&#123; A a(1),b(2); a.c(&amp;b); //è¾“å‡º2 return 0;&#125; åƒè¿™æ®µä»£ç ï¼Œæˆ‘ä»¬æ‹¿åˆ°äº†bçš„åœ°å€å°±å¯ä»¥è®¿é—®bçš„ç§æœ‰æˆå‘˜ã€‚ C++çš„è¿™ç§è®¿é—®é™åˆ¶åªæ˜¯ç¼–è¯‘å™¨çº§åˆ«çš„é™åˆ¶ï¼Œåªæ˜¯ç¼–è¯‘å™¨åœ¨æ£€æŸ¥è®¿é—®å±æ€§ï¼Œå¦‚æœéª—è¿‡ç¼–è¯‘å™¨ä¸€æ ·å¯ä»¥è®¿é—®å…¶ä»–ç±»çš„å¯¹è±¡çš„privateçš„æˆå‘˜ã€‚Ubuntu Pastebin : https://paste.ubuntu.com/26535160/123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class B&#123;private: int i;public: B()&#123;&#125; B(int ii):i(ii)&#123;&#125;&#125;;class A&#123;private: int i;public: A()&#123;&#125; A(int ii):i(ii)&#123;&#125; void d(B *p) &#123; cout &lt;&lt; *(int*)p &lt;&lt; endl; &#125;&#125;;int main()&#123; A a(1); B b(3); a.d(&amp;b); //è¾“å‡º3 return 0;&#125; è¿™æ®µä»£ç ä¸­æˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªç±»ï¼Œæˆ‘ä»¬æŠŠBç±»çš„å¯¹è±¡bçš„åœ°å€ä¼ åˆ°Aç±»çš„då‡½æ•°ä¸­é€šè¿‡å¼ºåˆ¶ç±»å‹è½¬æ¢ä¸€æ ·å¯ä»¥è®¿é—®bçš„privateçš„æˆå‘˜ï¼Œè¿™å°±è¯´æ˜äº†è®¿é—®å±æ€§çš„é™åˆ¶åªæ˜¯ç¼–è¯‘å™¨çº§åˆ«çš„ï¼Œåœ¨è¿è¡Œæ—¶å¦‚æœä½ æ‹¿åˆ°å®ƒçš„åœ°å€è¿˜æ˜¯å¯ä»¥ä¸ºæ‰€æ¬²ä¸ºçš„ã€‚ friendå…³é”®å­—ä¸Šè¿°éæ³•çš„æ‰‹æ®µåªæ˜¯ä½œä¸ºäº†è§£ï¼Œå¦‚æœåœ¨ç¨‹åºä¸­ç¡®å®æœ‰ä¸Šé¢æ¼”ç¤ºä¸­çš„åœºæ™¯ï¼ŒC++ä¹Ÿæœ‰å…¶ä»–çš„æ–¹æ¡ˆã€‚Ubuntu Pastebin : https://paste.ubuntu.com/26535171/1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class B;class A&#123;private: int i;public: A()&#123;&#125; A(int ii):i(ii)&#123;&#125; void d(B *p) &#123; cout &lt;&lt; *(int*)p &lt;&lt; endl; &#125;&#125;;class B&#123;private: int i;public: B()&#123;&#125; B(int ii):i(ii)&#123;&#125; friend void A::d(B*p);&#125;;int main()&#123; A a(1); B b(3); a.d(&amp;b); //è¾“å‡º3 return 0;&#125; friendå…³é”®å­—å¯ä»¥å£°æ˜åˆ«çš„ç±»ï¼ˆä¹Ÿå¯ä»¥æ˜¯åˆ«çš„å‡½æ•°æˆ–è€…åˆ«çš„ç±»çš„æˆå‘˜å‡½æ•°ï¼‰æ˜¯ä½ è¿™ä¸ªç±»çš„æœ‹å‹ï¼Œå£°æ˜ä¹‹åå®ƒå°±å¯ä»¥è®¿é—®ä½ è¿™ä¸ªç±»æ‰€æœ‰çš„æˆå‘˜ã€‚è¿™æ ·ä¹Ÿå°±åˆæ³•çš„å®ç°äº†ä¸Šé¢æˆ‘ä»¬éæ³•å®ç°çš„åŠŸèƒ½ã€‚åŒæ ·çš„friendçš„æˆæƒä¹Ÿæ˜¯ç¼–è¯‘å™¨çº§åˆ«çš„ã€‚ classå’Œstructçš„åŒºåˆ«structåœ¨Cè¯­è¨€ä¸­å°±å­˜åœ¨ï¼Œåœ¨Cè¯­è¨€ç»“æ„ä¸æ•°ç»„ç±»ä¼¼ï¼Œæ•°ç»„æ˜¯å­˜å‚¨å¤šä¸ªç›¸åŒç±»å‹çš„å˜é‡ï¼Œç»“æ„å¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å˜é‡ã€‚è€Œåˆ°äº†C++ä¸­structæœ‰äº†æ›´å¤šçš„åŠŸèƒ½ä¸classåŸºæœ¬ä¸€è‡´ã€‚åªæ˜¯åœ¨é»˜è®¤è®¿é—®å±æ€§æœ‰æ‰€å·®åˆ«ã€‚å¦‚æœåœ¨classä¸­ä¸å£°æ˜è®¿é—®å±æ€§åˆ™é»˜è®¤ä¸ºprivateï¼Œåœ¨structä¸­é»˜è®¤ä¸ºpublicã€‚]]></content>
      <categories>
        <category>ç¼–ç¨‹è¯­è¨€ - Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>ç±»æˆå‘˜</tag>
        <tag>è®¿é—®å±æ€§</tag>
        <tag>ç±»ä¸å¯¹è±¡</tag>
        <tag>class</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3253 Fence Repairï¼ˆè´ªå¿ƒï¼‰]]></title>
    <url>%2F2018%2F01%2F24%2Fpoj-3253-fence-repair%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ï¼šhttp://poj.org/problem?id=3253 Fence RepairTime Limit: 2000MS Memory Limit: 65536K DescriptionFarmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs _N_ (1 â‰¤ _N_ â‰¤ 20,000) planks of wood, each having some integer length _Li_ (1 â‰¤ _Li_ â‰¤ 50,000) units. He then purchases a single long board just long enough to saw into the _N_planks (i.e., whose length is the sum of the lengths _Li_). FJ is ignoring the â€œkerfâ€, the extra length lost to sawdust when a sawcut is made; you should ignore it, too. FJ sadly realizes that he doesnâ€™t own a saw with which to cut the wood, so he mosies over to Farmer Donâ€™s Farm with this long board and politely asks if he may borrow a saw. Farmer Don, a closet capitalist, doesnâ€™t lend FJ a saw but instead offers to charge Farmer John for each of the _N_-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents. Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the _N_ planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths. InputLine 1: One integer _N_, the number of planks Lines 2.._N_+1: Each line contains a single integer describing the length of a needed plank OutputLine 1: One integer: the minimum amount of money he must spend to make _N_-1 cuts Sample Input3858 Sample Output34 HintHe wants to cut a board of length 21 into pieces of lengths 8, 5, and 8. The original board measures 8+5+8=21. The first cut will cost 21, and should be used to cut the board into pieces measuring 13 and 8. The second cut will cost 13, and should be used to cut the 13 into 8 and 5. This would cost 21+13=34. If the 21 was cut into 16 and 5 instead, the second cut would cost 16 for a total of 37 (which is more than 34). é¢˜è§£é¢˜ç›®å¤§æ„å°†ä¸€å—æœ¨æ¿åˆ‡å‰²æˆNå—ï¼Œæ¯æ¬¡åˆ‡å‰²æœ¨æ¿æ—¶çš„å¼€é”€ä¸ºè¿™å—æœ¨æ¿çš„é•¿åº¦ã€‚ä¾‹å¦‚é•¿åº¦ä¸º21çš„æœ¨æ¿è¦åˆ‡æˆé•¿åº¦ä¸º5ã€8ã€8çš„ä¸‰å—æœ¨æ¿ã€‚é•¿21çš„æœ¨æ¿åˆ‡æˆä¸º13å’Œ8çš„æ¿æ—¶ï¼Œå¼€é”€ä¸º21ã€‚å†å°†é•¿åº¦ä¸º13çš„æ¿åˆ‡æˆ5å’Œ8çš„æ¿æ—¶ï¼Œå¼€é”€æ˜¯13ã€‚äºæ˜¯åˆè®¡å¼€é”€ä¸º34ã€‚æ±‚æŒ‰ç…§ç›®æ ‡è¦æ±‚åˆ‡å‰²æœ¨æ¿æœ€å°çš„å¼€é”€ã€‚ è§£é¢˜æ€è·¯å¯ä»¥é€†å‘çš„ç»„åˆæœ¨æ¿ï¼Œè®¡ç®—æŠŠè¾“å…¥çš„å¤šä¸ªæœ¨æ¿æ•°æ®æœ€ç»ˆç»„åˆä¸ºä¸€ä¸ªé•¿æœ¨æ¿çš„å¼€é”€ï¼Œä¸åˆ‡å‰²å¼€é”€ç›¸åŒã€‚å¦‚æœæƒ³è¦ç»„åˆå¼€é”€æœ€å°ï¼Œæ¯æ¬¡ä»æ‰€æœ‰çš„æœ¨æ¿ä¸­é€‰æ‹©ä¸¤ä¸ªæœ€çŸ­çš„ç»„åˆå³å¯ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527927/12345678910111213141516171819202122232425262728293031323334353637383940//POJ 3253 Fence Repairï¼ˆè´ªå¿ƒï¼‰//2018-01-24#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std; class Int &#123; public: int num; Int(int a):num(a) &#123;&#125; &#125;; bool operator &gt; (const Int &amp;t1, const Int &amp;t2) &#123; return t1.num &gt; t2.num; &#125; //å®šä¹‰ä¸€ä¸ªIntç±»ä»£æ›¿intï¼Œå› ä¸ºè¦å°†ä¼˜å…ˆé˜Ÿåˆ—é€†åºéœ€è¦åšè¿ç®—ç¬¦é‡è½½int main()&#123; int n; cin &gt;&gt; n; priority_queue&lt;Int, vector&lt;Int&gt;, greater&lt;Int&gt; &gt; q; for( int i = 0; i &lt; n; i++)&#123; //æŠŠnå—æœ¨æ¿çš„é•¿åº¦å…¥é˜Ÿ int temp; cin &gt;&gt; temp; q.push((Int)temp); &#125; long long sum = 0; //åˆè®¡å¼€é”€ while(q.size() &gt; 1)&#123; //å¦‚æœè¿˜æ²¡æœ‰åˆæˆä¸€å—æœ¨æ¿å°±ç»§ç»­åˆå¹¶ int minOne,minTwo; minOne = q.top().num; q.pop(); minTwo = q.top().num; q.pop(); //ä»é˜Ÿå¤´æ‹¿å‡ºä¸¤ä¸ªæœ€çŸ­çš„æœ¨æ¿ sum += (minOne + minTwo); //åŠ ä¸Šè¿™æ¬¡åˆå¹¶çš„å¼€é”€ q.push((Int)(minOne+minTwo)); //å°†åˆå¹¶åçš„æœ¨æ¿å…¥é˜Ÿ &#125; cout &lt;&lt; sum; return 0; &#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>DFS</tag>
        <tag>è¿ç®—ç¬¦é‡è½½</tag>
        <tag>POJ</tag>
        <tag>è´ªå¿ƒæ³•</tag>
        <tag>ä¼˜å…ˆé˜Ÿåˆ—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ’åºç®—æ³•1â€”â€”å†’æ³¡æ’åº]]></title>
    <url>%2F2018%2F01%2F18%2Fbubble-sort%2F</url>
    <content type="text"><![CDATA[å†’æ³¡æ’åºå†’æ³¡æ’åºæ˜¯ä¸€ç§å®ç°èµ·æ¥å¾ˆç®€å•çš„æ’åºç®—æ³•ï¼Œé€‚åˆåˆå­¦è€…å…¥é—¨ã€‚ ç”±äºå®ƒçš„æ—¶é—´å¤æ‚åº¦è¾ƒé«˜åœ¨å®é™…ä½¿ç”¨ä¸­å¾ˆå°‘ç”¨åˆ°ã€‚ä½†å®ƒä¹Ÿæœ‰å­˜åœ¨çš„ä»·å€¼ï¼Œæ¯”å¦‚å¾…æ’åºåˆ—å­˜å‚¨åœ¨ä¸€ä¸ªå•å‘é“¾è¡¨ä¸­æ—¶å…¶ä»–çš„æ’åºç®—æ³•å®ç°èµ·æ¥å°±ç›¸å¯¹æ¯”è¾ƒå›°éš¾ï¼Œè€Œä¸”å†’æ³¡æ’åºç›¸ç­‰çš„å…ƒç´ ä¸ä¼šè¿›è¡Œäº¤æ¢æ‰€ä»¥å®ƒä¹Ÿæ˜¯ä¸€ç§ç¨³å®šçš„æ’åºç®—æ³•ã€‚ æ¼”ç¤ºå†’æ³¡æ’åºåœ¨æ¯ä¸€è¶Ÿæ’åºä¸­ä»ä¸Šåˆ°ä¸‹æ‹¿ä¸¤ä¸ªç›¸åŒå…ƒç´ æ¯”è¾ƒå¦‚æœä¸ç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸå°±äº¤æ¢å®ƒï¼ˆæ¯”å¦‚è¦æ±‚ä»å°åˆ°å¤§æ’åºï¼Œå¦‚æœç›¸é‚»ä¸¤ä¸ªå…ƒç´ ä¸æ»¡è¶³å‰é¢å°åé¢å¤§å°±äº¤æ¢å®ƒï¼‰ï¼Œåœ¨å®Œæˆä¸€è¶Ÿæ’åºåå¯ä»¥ç¡®å®šæœ€ä¸‹é¢çš„å…ƒç´ ä¸€å®šæ˜¯æœ€å¤§çš„ï¼ˆæŒ‰ä»å°åˆ°å¤§æ’åºï¼‰ã€‚æ¯ä¸€è¶Ÿæ’åºå¯ä»¥ç¡®å®šä¸€ä¸ªå…ƒç´ çš„ä½ç½®ï¼Œæˆ‘ä»¬é€šè¿‡n-1è¶Ÿæ’åºå°±å¯ä»¥å°†æ•°æ®æ’å¥½åºã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26535079/1234567891011void BubbleSort(int a[],int size)&#123; for( int i = size-1; i &gt;= 0; i--)&#123; for( int j = 0; j &lt; i; j++)&#123; if(a[j] &gt; a[j+1])&#123; swap(a[j],a[j+1]); &#125; &#125; &#125;&#125; å®é™…ä¸Šè¯¥ä»£ç è¿˜å¯ä»¥å†è¿›è¡Œä¼˜åŒ–ï¼Œå¦‚æœåœ¨ä¸€è¶Ÿæ’åºä¸­æ²¡æœ‰äº¤æ¢è¿‡å°±è¯´æ˜åºåˆ—å·²ç»æœ‰åºï¼Œæˆ‘ä»¬å°±ä¸éœ€è¦å†æ¯”è¾ƒä¸‹å»ã€‚ ä¼˜åŒ–åçš„ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26535087/12345678910111213void BubbleSort(int a[],int size)&#123; for( int i = size-1; i &gt;= 0; i--)&#123; bool flag = false; //è®°å½•åœ¨ä¸€è¶Ÿæ’åºä¸­æ˜¯å¦æœ‰äº¤æ¢ for( int j = 0; j &lt; i; j++)&#123; if(a[j] &gt; a[j+1])&#123; swap(a[j],a[j+1]); flag = true; &#125; &#125; if(!flag) break; &#125;&#125; ç”±æ­¤æˆ‘ä»¬å¯ä»¥åˆ†æå¾—å‡ºæœ€å¥½æƒ…å†µï¼ˆå·²æœ‰åºï¼‰ä¸‹å…¶æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œåœ¨æœ€åæƒ…å†µï¼ˆé€†åºï¼‰ä¸‹æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>æ’åºç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XUJCOJ 1065 èµ°è¿·å®«-2ï¼ˆBFSå¤šçŠ¶æ€æ— æƒå›¾æœ€çŸ­è·¯å¾„ï¼‰]]></title>
    <url>%2F2018%2F01%2F16%2Fxujcoj-1065-maze2%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ï¼šhttp://www.xujcoj.org/Home/Problems/status/pro_id/1065/ èµ°è¿·å®«-2æè¿°äº”æ¯’æ•™æ€»å›æœ‰ä¸€ä¸ªå¤æ‚çš„è¿·å®«ç”¨äºé˜»æŒ¡å¤–äººè¿›å…¥ï¼Œä½†å¤æ‚çš„è¿·å®«å¹¶ä¸ä¼šé˜»ç¢è‰åŸæ•™ä¸»é€šè¿‡ã€‚ä¸ºäº†èƒ½å¤Ÿæ›´å¿«åœ°ç©¿è¶Šè¿·å®«ï¼Œé™¤äº†èµ°è¿·å®«æ­£å¸¸çš„ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä¸€æ¬¡ç§»åŠ¨ä¸€æ ¼å¤–ï¼Œè‰åŸæ•™ä¸»éšèº«å¸¦äº†ä¸€ä¸ªç«ç®­èƒŒåŒ…ï¼Œå¯ä»¥è®©å¥¹èƒ½å¤Ÿè·³è¿‡ä¸€æ ¼éšœç¢ï¼ˆå½“ç„¶ä¸­é—´æ²¡æœ‰éšœç¢ä¹Ÿèƒ½è·³ï¼‰ï¼Œè·³çš„æ–¹å‘å¯ä»¥æ˜¯ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä¹‹ä¸€ã€‚ä¾‹å¦‚åœ¨ä¸‹å›¾ä¸­ï¼Œçº¢è‰²è¡¨ç¤ºéšœç¢ï¼Œç°è‰²è¡¨ç¤ºé€šè·¯ï¼Œé‚£ä¹ˆä»Aç‚¹å¯ä»¥è·³åˆ°Bç‚¹ï¼Œä¹Ÿå¯ä»¥ä»Aç‚¹è·³åˆ°Cç‚¹ï¼Œä½†ä¸èƒ½ä»Cç‚¹è·³åˆ°Dç‚¹ã€‚ä¸è¿‡ç«ç®­èƒŒåŒ…çš„èƒ½é‡æœ‰é™ï¼Œæœ€å¤šåªèƒ½è·³3æ¬¡ï¼Œå¹¶ä¸”ç«ç®­èƒŒåŒ…çš„è´¨é‡å¾ˆå¥½ï¼Œå¯ä»¥è·³å®Œä¸€æ¬¡ä»¥åç«‹å³è·³ä¸‹ä¸€æ¬¡ã€‚å‡è®¾èµ°ä¸€æ ¼å’Œè·³ä¸€æ¬¡èŠ±è´¹çš„æ—¶é—´éƒ½æ˜¯1ç§’ï¼Œé‚£ä¹ˆä»æŒ‡å®šçš„æŸä¸ªèµ·ç‚¹åˆ°è¾¾æŸä¸ªç»ˆç‚¹ï¼Œæœ€å¿«éœ€è¦èŠ±è´¹å¤šå°‘ç§’æ—¶é—´ï¼Ÿ è¾“å…¥åªæœ‰ä¸€ç»„æ¡ˆä¾‹ã€‚ ä¸¤ä¸ªæ­£æ•´æ•°må’Œnï¼ˆm&lt;=100ï¼Œn&lt;=100ï¼‰ï¼Œè¡¨ç¤ºè¿·å®«çš„é«˜åº¦å’Œå®½åº¦ã€‚ ç„¶åæ˜¯mè¡Œæ•°æ®ï¼Œæ¯è¡Œæ•°æ®æœ‰nä¸ªæ•´æ•°ï¼Œä»¥ç©ºæ ¼ç›¸éš”ã€‚æ¯ä¸ªæ•°å­—ä»£è¡¨çš„å«ä¹‰æ˜¯ï¼š-1è¡¨ç¤ºè¯¥ç‚¹æ˜¯éšœç¢ç‰©ï¼Œ1è¡¨ç¤ºè¯¥ç‚¹æ˜¯é€šè·¯ï¼Œ0è¡¨ç¤ºè¯¥ç‚¹æ˜¯èµ·ç‚¹æˆ–è€…ç»ˆç‚¹ã€‚è¿™m*nä¸ªæ•°å­—ä¸­åªä¼šæœ‰2ä¸ªæ•°å­—æ˜¯0ã€‚ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä»èµ·ç‚¹åˆ°ç»ˆç‚¹æœ€å¿«éœ€è¦å¤šå°‘ç§’ã€‚å¦‚æœä»èµ·ç‚¹æ— æ³•åˆ°è¾¾ç»ˆç‚¹åˆ™è¾“å‡º-1ã€‚ä¸è¦æ¢è¡Œã€‚ æ ·ä¾‹è¾“å…¥4 4 0 -1 1 1 1 -1 1 1 1 -1 -1 0 1 1 1 1 æ ·ä¾‹è¾“å‡º3 HINTä»å·¦ä¸Šè§’çš„0å¤„å‘å³è·³ã€å‘å³ã€å‘ä¸‹è·³ï¼Œåˆ°è¾¾ç»ˆç‚¹ã€‚ é¢˜è§£è§£é¢˜åˆ†ææ­¤é¢˜éš¾ç‚¹åœ¨äºèŠ‚ç‚¹æœ‰å¤šç§çŠ¶æ€ï¼Œåœ¨ä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰ä¸åŒçš„ç«ç®­èƒŒåŒ…æ•°é‡ã€‚ è§£é¢˜æ€è·¯å¦‚æœæ²¡æœ‰ç«ç®­èƒŒåŒ…æ­¤é¢˜ä¸æœ€çŸ­è·¯å¾„é¢˜ç›®å·®ä¸å¤šï¼Œå¯¹äºæœ‰æƒå›¾æˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨Dijkstraç®—æ³•æˆ–SPFAç®—æ³•ï¼Œå¯¹äºæ— æƒå›¾æˆ‘ä»¬å¯ä»¥è€ƒè™‘ç”¨BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰å»æ¢ç´¢è¯¥å›¾ã€‚å¯¹äºèŠ‚ç‚¹çš„ç«ç®­çŠ¶æ€åœ¨å®ç°è¿‡ç¨‹ä¸­æˆ‘è€ƒè™‘å°†ç°å®ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹åœ¨ç¨‹åºä¸­åˆ†ä¸ºå¤šä¸ªï¼ˆåœ¨æœ¬é¢˜ä¸­ä¸º3ä¸ªï¼‰é€’æ¨ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527922/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//XUJCOJ 1065 èµ°è¿·å®«-2//2018-01-15#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int Y,X,rocket; //çŸ©é˜µå¤§å° ç«ç®­ä¸ªæ•°int map[210][210]; //èŠ‚ç‚¹æ˜¯å¦æœ‰å¢™ å¯ä»¥æ”¹ä¸ºboolä¼˜åŒ–å†…å­˜bool collected[105][105][4]; //èŠ‚ç‚¹çš„ç«ç®­çŠ¶æ€æ˜¯å¦è¢«æ”¶å½•struct quNode //å£°æ˜ä¸€ä¸ªç»“æ„æ–¹ä¾¿èŠ‚ç‚¹çš„çŠ¶æ€å…¥é˜Ÿ&#123; int r,c,rocketNums,time; //åŒ…å«å››ä¸ªå‚æ•°ï¼šä½ç½®rcã€å‰©ä½™ç«ç®­ä¸ªæ•°ã€å·²ç”¨æ—¶é—´ quNode(int rr,int cc,int timee,int rocketNumss):r(rr),c(cc),rocketNums(rocketNumss),time(timee) &#123; &#125;; quNode()&#123;&#125; //ä»¥ä¸Šä¸ºè¯¥ç»“æ„çš„æ„é€ å‡½æ•°&#125;;queue&lt;quNode&gt; Queue;struct Dir //å››ä¸ªæ–¹å‘æ–¹ä¾¿åæœŸç”¨å¾ªç¯éå†ä¸€ä¸ªèŠ‚ç‚¹çš„æ—è¾¹çš„èŠ‚ç‚¹&#123; int dr,dc;&#125;dir[4] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;,dirJump[4] = &#123; &#123;0,2&#125;,&#123;0,-2&#125;,&#123;2,0&#125;,&#123;-2,0&#125;&#125;;//dirä¸ºèµ°ä¸€æ ¼çš„æƒ…å†µ dirJumpä¸ºè·³ä¸€æ¬¡çš„æƒ…å†µï¼ˆèµ°ä¸¤ä¸ªï¼‰ int main()&#123; scanf("%d%d",&amp;Y,&amp;X); //è¾“å…¥çŸ©é˜µå¤§å° rocket = 3; //è®¾ç½®ç«ç®­ä¸ªæ•° quNode origin,finish; //å£°æ˜ä¸¤ä¸ªå¯å…¥é˜ŸèŠ‚ç‚¹ä¿å­˜èµ·ç‚¹å’Œç»ˆç‚¹ memset(collected,true,sizeof(collected)); bool flag = true; //ç”±äºèµ·ç‚¹ç»ˆç‚¹éƒ½ä¸º0 è®¾ä¸ªflagåˆ†å¼€ä¿å­˜å®ƒä»¬ for( int i = 1;i &lt;= Y; i++)&#123; for( int j = 1; j &lt;= X; j++)&#123; scanf("%d",&amp;map[i][j]); if(map[i][j] == 0 &amp;&amp; flag)&#123; //ä¿å­˜èµ·ç‚¹ origin = quNode(i,j,0,rocket); flag = false; &#125;else if(map[i][j] == 0 &amp;&amp; !flag)&#123; //ä¿å­˜ç»ˆç‚¹ map[i][j] = 1; finish = quNode(i,j,-1,-1); &#125; for( int t = 0; t &lt;= rocket; t++) //åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹çš„æ‰€æœ‰çŠ¶æ€éƒ½ä¸ºæœªæ”¶å½• collected[i][j][t] = false; &#125; &#125; collected[origin.r][origin.c][rocket] = true; //å°†èµ·ç‚¹æ”¶å½• Queue.push(origin); //å°†èµ·ç‚¹å…¥é˜Ÿ while(!Queue.empty())&#123; //å¦‚æœé˜Ÿåˆ—ä¸ºç©ºè¯´æ˜å›¾è¢«å®Œå…¨éå†é€€å‡ºå¾ªç¯ quNode nowP = Queue.front(); //ä»é˜Ÿå¤´æ‹¿ä¸€ä¸ªèŠ‚ç‚¹ if( nowP.r == finish.r &amp;&amp; nowP.c == finish.c)&#123; //å¦‚æœæ˜¯ç»ˆç‚¹åˆ™è¾“å‡ºæœ€çŸ­æ—¶é—´å¹¶ç»“æŸç¨‹åº printf("%d",nowP.time); return 0; &#125; Queue.pop(); //é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ if( map[nowP.r][nowP.c] == -1 &amp;&amp; nowP.rocketNums == 0 ) continue; for( int i = 0;i &lt; 4; i++)&#123; //éå†è¯¥èŠ‚ç‚¹å››ä¸ªæ–¹å‘ //èµ°ä¸€æ­¥ int newR = nowP.r + dir[i].dr; //å››ä¸ªæ–¹å‘çš„rc int newC = nowP.c + dir[i].dc; //å¦‚æœè¯¥èŠ‚ç‚¹æœªè¢«æ”¶å½•ä¸”ä¸ä¸ºå¢™ å°±å½•è¯¥èŠ‚ç‚¹ å°†time+1 å°†å…¶å…¥é˜Ÿ if(map[newR][newC] == 1 &amp;&amp; !collected[newR][newC][nowP.rocketNums])&#123; collected[newR][newC][nowP.rocketNums] = true; Queue.push(quNode(newR,newC,nowP.time+1,nowP.rocketNums)); &#125; //è·³ä¸€æ­¥ int newRJump = nowP.r + dirJump[i].dr; int newCJump = nowP.c + dirJump[i].dc; //å¦‚æœè¯¥èŠ‚ç‚¹æœªè¢«æ”¶å½•ä¸”ç«ç®­è¿˜æœ‰å‰©ä½™ å°±æ”¶å½•è¯¥èŠ‚ç‚¹ å°†time+1 å°†ç«ç®­æ•°-1 å°†å…¶å…¥é˜Ÿ if((map[newRJump][newCJump] == -1 || map[newRJump][newCJump] == 1) &amp;&amp; nowP.rocketNums &gt; 0 &amp;&amp; !collected[newRJump][newCJump][nowP.rocketNums-1])&#123; collected[newRJump][newCJump][nowP.rocketNums-1] = true; Queue.push(quNode(newRJump,newCJump,nowP.time+1,nowP.rocketNums-1)); &#125; &#125; &#125; printf("%d",-1); //å¦‚æœæ²¡æœ‰åœ¨whileå¾ªç¯ä¸­return è¯´æ˜æ²¡æœ‰éå†åˆ°ç»ˆç‚¹ è¯´æ˜ä¸è¿é€š è¾“å‡º-1 return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>é˜Ÿåˆ—</tag>
        <tag>BFS</tag>
        <tag>å›¾</tag>
        <tag>æœ€çŸ­è·¯å¾„</tag>
        <tag>XUJCOJ</tag>
        <tag>å¤šçŠ¶æ€</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç™¾ç»ƒ 2815 åŸå ¡é—®é¢˜ï¼ˆDFSæå¤§è¿é€šå­å›¾ï¼‰]]></title>
    <url>%2F2018%2F01%2F15%2Fbl-2815%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ï¼šhttp://bailian.openjudge.cn/practice/2815/ åŸå ¡é—®é¢˜æ€»æ—¶é—´é™åˆ¶ï¼š1000ms å†…å­˜é™åˆ¶ï¼š65536kB æè¿°123456789101112131415 1 2 3 4 5 6 7 #############################1 # | # | # | | # #####---#####---#---#####---#2 # # | # # # # # #---#####---#####---#####---#3 # | | # # # # # #---#########---#####---#---#4 # # | | | | # # ############################# (å›¾ 1) # = Wall | = No wall \- = No wall å›¾ 1 æ˜¯ä¸€ä¸ªåŸå ¡çš„åœ°å½¢å›¾ã€‚è¯·ä½ ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè®¡ç®—åŸå ¡ä¸€å…±æœ‰å¤šå°‘æˆ¿é—´ï¼Œæœ€å¤§çš„æˆ¿é—´æœ‰å¤šå¤§ã€‚åŸå ¡è¢«åˆ†å‰²æˆmï‚´n(mâ‰¤50ï¼Œnâ‰¤50)ä¸ªæ–¹å—ï¼Œæ¯ä¸ªæ–¹å—å¯ä»¥æœ‰0~4é¢å¢™ã€‚ è¾“å…¥ç¨‹åºä»æ ‡å‡†è¾“å…¥è®¾å¤‡è¯»å…¥æ•°æ®ã€‚ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«æ˜¯å—åŒ—å‘ã€ä¸œè¥¿å‘çš„æ–¹å—æ•°ã€‚åœ¨æ¥ä¸‹æ¥çš„è¾“å…¥è¡Œé‡Œï¼Œæ¯ä¸ªæ–¹å—ç”¨ä¸€ä¸ªæ•°å­—(0â‰¤pâ‰¤50)æè¿°ã€‚ç”¨ä¸€ä¸ªæ•°å­—è¡¨ç¤ºæ–¹å—å‘¨å›´çš„å¢™ï¼Œ1è¡¨ç¤ºè¥¿å¢™ï¼Œ2è¡¨ç¤ºåŒ—å¢™ï¼Œ4è¡¨ç¤ºä¸œå¢™ï¼Œ8è¡¨ç¤ºå—å¢™ã€‚æ¯ä¸ªæ–¹å—ç”¨ä»£è¡¨å…¶å‘¨å›´å¢™çš„æ•°å­—ä¹‹å’Œè¡¨ç¤ºã€‚åŸå ¡çš„å†…å¢™è¢«è®¡ç®—ä¸¤æ¬¡ï¼Œæ–¹å—(1,1)çš„å—å¢™åŒæ—¶ä¹Ÿæ˜¯æ–¹å—(2,1)çš„åŒ—å¢™ã€‚è¾“å…¥çš„æ•°æ®ä¿è¯åŸå ¡è‡³å°‘æœ‰ä¸¤ä¸ªæˆ¿é—´ã€‚ è¾“å‡ºåŸå ¡çš„æˆ¿é—´æ•°ã€åŸå ¡ä¸­æœ€å¤§æˆ¿é—´æ‰€åŒ…æ‹¬çš„æ–¹å—æ•°ã€‚ç»“æœæ˜¾ç¤ºåœ¨æ ‡å‡†è¾“å‡ºè®¾å¤‡ä¸Šã€‚ æ ·ä¾‹è¾“å…¥4711 6 11 6 3 10 67 9 6 13 5 15 51 10 12 7 13 7 513 11 10 8 10 12 13 æ ·ä¾‹è¾“å‡º59 é¢˜è§£è§£é¢˜åˆ†æè¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„æ±‚æå¤§è¿é€šå­å›¾çš„é—®é¢˜ï¼Œå¯ä»¥æŠŠæ¯ä¸ªæ–¹å—å½“åšä¸€ä¸ªå›¾èŠ‚ç‚¹ï¼Œæ²¡æœ‰å¢™çš„æ–¹å‘æœ‰ä¸€æ¡è¾¹ã€‚ è§£é¢˜æ€è·¯å› ä¸ºè¦æ±‚å‡ºæå¤§è¿é€šå­å›¾çš„èŠ‚ç‚¹ä¸ªæ•°æˆ‘ä»¬è€ƒè™‘ç”¨DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰é€’å½’çš„å»æ¢ç´¢æ¯ä¸ªæˆ¿é—´å¾—å‡ºé¢ç§¯ã€‚æ¢ç´¢å®Œä¸€ä¸ªæˆ¿é—´ï¼Œçœ‹æœ‰æ²¡æœ‰æœªè¢«è®¿é—®è¿‡çš„æ–¹å—ï¼Œå¦‚æœæœ‰è¯´æ˜ä¸€å®šå­˜åœ¨å¦ä¸€ä¸ªæˆ¿é—´æˆ‘ä»¬å†ç”¨DFSçš„æ–¹æ³•å»æ¢ç´¢å®ƒï¼Œç›´è‡³æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½è¢«è®¿é—®ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527902/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//ç™¾ç»ƒ 2815 åŸå ¡é—®é¢˜ï¼ˆDFSæå¤§è¿é€šå­å›¾ï¼‰//2018-01-15#include&lt;iostream&gt;using namespace std;int mapNode[55][55]; //å›¾èŠ‚ç‚¹æ•°ç»„ï¼Œä¿å­˜å¢™ä¿¡æ¯bool collected[55][55]; //æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦è¢«è®¿é—®int roomNum; //æˆ¿é—´æ•°é‡int roomNowArea; //å½“å‰æœç´¢çš„æˆ¿é—´çš„é¢ç§¯void dfs(int x,int y) &#123; if(collected[x][y])&#123; //å¦‚æœè¯¥èŠ‚ç‚¹å·²è¢«è®¿é—®å°±è¿”å›ä¸Šä¸€å±‚ return; &#125; collected[x][y] = true; //è®¿é—®å®ƒ roomNowArea++; //æ‰¾åˆ°ä¸€ä¸ªæœªè¢«è®¿é—®çš„èŠ‚ç‚¹å°†å½“å‰æˆ¿é—´é¢ç§¯åŠ ä¸€ /* å› ä¸º1ï¼Œ2ï¼Œ4ï¼Œ8çš„äºŒè¿›åˆ¶è¡¨è¾¾åˆ†åˆ«ä¸ºï¼š0001ã€0010ã€0100ã€1000 æ‰€ä»¥å¯ä»¥è¿ç”¨ä½è¿ç®—çœ‹å®ƒçš„é‚£ä¸€ä½ä¸Šæ˜¯ä¸æ˜¯1ï¼Œ å¦‚æœä¸æ˜¯åˆ™è¯´æ˜æ²¡æœ‰å¢™ï¼Œå¯ä»¥å‘è¿™ä¸ªæ–¹å‘ç»§ç»­æœç´¢ã€‚ */ if((mapNode[x][y] &amp; 2) == 0) dfs(x-1,y); //å¦‚æœæ²¡æœ‰åŒ—å¢™å°±æœç´¢å·¦è¾¹ if((mapNode[x][y] &amp; 8) == 0) dfs(x+1,y); //å—å¢™ if((mapNode[x][y] &amp; 1) == 0) dfs(x,y-1); //è¥¿å¢™ if((mapNode[x][y] &amp; 4) == 0) dfs(x,y+1); //ä¸œå¢™&#125;int main()&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; for( int i = 0; i &lt; x; i++)&#123; for( int j = 0; j &lt; y; j++)&#123; cin &gt;&gt; mapNode[i][j]; collected[i][j] = false; &#125; &#125; //ä»¥ä¸Šä¸ºè¾“å…¥é˜¶æ®µ int maxRoomArea = 0; //æœ€å¤§æˆ¿é—´é¢ç§¯ roomNum = 0; //æˆ¿é—´æ•°é‡åˆå§‹åŒ– for( int i = 0; i &lt; x; i++)&#123; for( int j = 0; j &lt; y; j++)&#123; if(!collected[i][j])&#123; //æ‰¾åˆ°æ²¡æœ‰è¢«è®¿é—®çš„èŠ‚ç‚¹ roomNum++; //æ‰¾åˆ°ä¸€ä¸ªæ–°çš„å°±è¯´æ˜æœ‰ä¸€ä¸ªæ–°çš„æˆ¿é—´ roomNowArea = 0; //é‡ç½®å½“å‰æˆ¿é—´çš„é¢ç§¯ dfs(i,j); //ä»è¯¥èŠ‚ç‚¹å¼€å§‹æœç´¢è¯¥æˆ¿é—´ if(roomNowArea &gt; maxRoomArea) maxRoomArea = roomNowArea; //ä¿å­˜æœ€å¤§æˆ¿é—´é¢ç§¯ &#125; &#125; &#125; cout &lt;&lt; roomNum &lt;&lt; endl //è¾“å‡º &lt;&lt; maxRoomArea; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>ACM</tag>
        <tag>ç™¾ç»ƒ</tag>
        <tag>DFS</tag>
        <tag>æå¤§è¿é€šå­å›¾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¸¸ç”¨bashå‘½ä»¤]]></title>
    <url>%2F2018%2F01%2F13%2Fbash%2F</url>
    <content type="text"><![CDATA[å…³äºæ–‡æœ¬çš„ç¨‹åº å‘½ä»¤ è§£é‡Š cp å¤åˆ¶ä¸€ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶ diff æ˜¾ç¤ºä¸¤ä¸ªæ–‡ä»¶çš„ä¸åŒä¹‹å¤„ file æ˜¾ç¤ºä¸æ–‡ä»¶å†…å®¹ç›¸å…³çš„ä¿¡æ¯ grep åœ¨æ–‡ä»¶ä¸­æŸ¥æ‰¾æŸä¸ªå­—ç¬¦ä¸² head æ˜¾ç¤ºæ–‡ä»¶å¼€å¤´éƒ¨åˆ†çš„å†…å®¹ lpq æ˜¾ç¤ºåœ¨æ‰“å°é˜Ÿåˆ—ä¸­çš„ä½œä¸š lpr å°†æ–‡ä»¶æ”¾å…¥æ‰“å°é˜Ÿåˆ—ä¸­ lprm ä»æ‰“å°é˜Ÿåˆ—ä¸­åˆ é™¤æŸä¸ªä½œä¸š mv å°†æ–‡ä»¶é‡å‘½åæˆ–ç§»åŠ¨åˆ°å…¶ä»–ç›®å½• sort å°†æ–‡ä»¶æŒ‰è¡Œæ’åº tail æ˜¾ç¤ºæ–‡ä»¶æœ«å°¾çš„å†…å®¹ uniq æ˜¾ç¤ºæ–‡ä»¶å†…å®¹ï¼Œå¿½ç•¥è¿ç»­é‡å¤çš„è¡Œ æ–‡ä»¶å‹ç¼©ã€è§£å‹ç¼©ã€å½’æ¡£ç¨‹åº å‘½ä»¤ è§£é‡Š bunzip2 å°† bzip å‹ç¼©çš„æ–‡ä»¶æ¢å¤ä¸ºåŸæ¥å¤§å°å’Œæ ¼å¼ bzcat æ˜¾ç¤º bzip2 å‹ç¼©è¿‡çš„æ–‡ä»¶ bzip2 å‹ç¼©æ–‡ä»¶ compress å‹ç¼©æ–‡ä»¶ï¼ˆä½†æ•ˆç‡æ²¡æœ‰ bzip2 æˆ– gzip é«˜ï¼‰ gunzip å°† gzip å‹ç¼©çš„æ–‡ä»¶æ¢å¤ä¸ºåŸæ¥å¤§å°å’Œæ ¼å¼ gzip å‹ç¼©æ–‡ä»¶ unzip è§£å‹ zip åŒ…ï¼Œä¸WindowsPKZIP å…¼å®¹ zcat æ˜¾ç¤º gzip å‹ç¼©è¿‡çš„æ–‡ä»¶ zip åˆ›å»ºzipåŒ…ï¼Œä¸ Windows PKZIP å…¼å®¹ tar å°†å½’æ¡£æ–‡ä»¶æ‰“åŒ…å’Œè§£åŒ… å®šä½ç¨‹åº å‘½ä»¤ è§£é‡Š locate/mlocate åœ¨æœ¬åœ°ç³»ç»Ÿä¸Šæœç´¢æ–‡ä»¶ whereis æ˜¾ç¤ºå®ç”¨ç¨‹åºã€æºä»£ç æˆ– man é¡µçš„å®Œæ•´è·¯å¾„å which æ˜¾ç¤ºå¯è¿è¡Œå‘½ä»¤çš„å®Œæ•´è·¯å¾„å æ˜¾ç¤ºç³»ç»Ÿå’Œç”¨æˆ·ä¿¡æ¯çš„ç¨‹åº å‘½ä»¤ è§£é‡Š finger æ˜¾ç¤ºç”¨æˆ·çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬å…¨å free æ˜¾ç¤ºå†…å­˜ä½¿ç”¨ä¿¡æ¯ hostname æ˜¾ç¤ºæœ¬åœ°ç³»ç»Ÿå uptime æ˜¾ç¤ºç³»ç»Ÿè´Ÿè½½å’Œè¿è¡Œä¿¡æ¯ w æ˜¾ç¤ºç™»å½•æœ¬åœ°ç³»ç»Ÿçš„ç”¨æˆ·çš„è¯¦ç»†ä¿¡æ¯ who æ˜¾ç¤ºç™»å½•æœ¬åœ°ç³»ç»Ÿçš„ç”¨æˆ·çš„ä¿¡æ¯ ç”¨æˆ·é€šä¿¡ç¨‹åº å‘½ä»¤ è§£é‡Š mesg æ¥å—æˆ–æ‹’ç» write å‘é€çš„æ¶ˆæ¯ write ç»™ç™»å½•çš„ç”¨æˆ·å‘é€æ¶ˆæ¯ å…¶ä»–ç¨‹åº å‘½ä»¤ è§£é‡Š date æ˜¾ç¤ºå½“å‰æ—¥æœŸå’Œæ—¶é—´ echo å¤åˆ¶è‡ªèº«å‚æ•°å¹¶åœ¨å±å¹•ä¸Šæ˜¾ç¤º]]></content>
      <categories>
        <category>æ³› - è®¡ç®—æœº</category>
      </categories>
      <tags>
        <tag>Bash</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2956 Repeatless Numbersï¼ˆæšä¸¾ï¼‰]]></title>
    <url>%2F2018%2F01%2F13%2Fpoj-2956-repeatless-numbers%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ï¼šhttp://poj.org/problem?id=2956 Repeatless NumbersTime Limit: 1000MS Memory Limit: 65536K DescriptionA repeatless number is a positive integer containing no repeated digits. For instance, the first 25 repeatless numbers are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, 27, â€¦ Given an integer _n_, your goal is to compute the _n_th repeatless number. InputThe input test file will contain multiple test cases, each consisting of a single line containing the integer _n_, where 1 â‰¤ _n_ â‰¤ 1000000. The end-of-file is marked by a test case with _n_ = 0 and should not be processed. OutputFor each input case, the program should print the _n_th repeatless number on a single line. Sample Input25100000 Sample Output2726057 é¢˜è§£é¢˜ç›®å¤§æ„æ¯ä½çš„æ•°å­—éƒ½ä¸ç›¸åŒçš„æ•°å­—ä¸ºRepeatless Numberï¼Œè¾“å…¥ä¸€ä¸ªæ•°nè¾“å‡ºç¬¬nä¸ªè¿™ç§æ•°å­—çš„å€¼ã€‚ è§£é¢˜åˆ†æå¯ä»¥è€ƒè™‘ä¸€ä¸ªä¸€ä¸ªæ•°å­—å»å°è¯•çœ‹å®ƒæ˜¯ä¸æ˜¯Repeatless Numbersï¼Œé‡åˆ°ç¬¬nä¸ªå°±è¾“å‡ºå¹¶è·³å‡ºå¾ªç¯ã€‚ç„¶è€Œè¿™æ ·ä¼šè¶…æ—¶ã€‚æˆ‘ä»¬è€ƒè™‘ç”¨DFSæšä¸¾æ•°å­—çš„æ¯ä½æ‰“è¡¨å®ç°ã€‚ è§£é¢˜æ€è·¯ä»å°åˆ°å¤§æšä¸¾æ¯ä¸€ä½ï¼Œå‰é¢å¯ç”¨0å ä½ï¼Œå…ˆè¿›è¡Œæ‰“è¡¨ï¼Œè¯»å…¥æ¯ä¸ªnç›´æ¥è¾“å‡ºè¡¨ä¸­ç¬¬né¡¹ã€‚å…·ä½“çš„å®ç°è§ä»£ç ï¼Œæœ‰è¯¦ç»†æ³¨é‡Šã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527896/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//POJ 2956 Repeatless Numbersï¼ˆæšä¸¾ï¼‰//2018-01-13#include &lt;iostream&gt;#define max 10000000 //æ‰“è¡¨çš„èŒƒå›´using namespace std;int a[max+10]; //ç¬¬nä¸ªæ•°å­—ä¿å­˜åœ¨a[n]ä¸­bool digitMap[10]; //10ä¸ªæ•°å­—æ˜¯å¦å¯ç”¨int n = 0; //ä»0å¼€å§‹éå†void dfs(int nowNum,int digit,int flag) //å‚æ•°è¡¨ä¸­ nowNumæ•°å­—çš„å€¼ nowNumæšä¸¾åˆ°ç¬¬å‡ ä½äº†ï¼Œ0æ˜¯å¦å¯ä»¥å ä½ä½¿ç”¨&#123; //å¦‚æœflagä¸º1ä½0ä¸èƒ½å ä½ä½¿ç”¨ 0æ—¶åä¹‹ if(n &gt; max)&#123; //å¦‚æœnå¤§äºæœ€å¤§å€¼å°±ä¸è¦ç»§ç»­æ‰“è¡¨äº† è·³å‡ºå‡½æ•° return; &#125; if(digit == 8)&#123; //å½“ä½æ•°ç­‰äº8æ—¶æ‰¾åˆ°ä¸€ä¸ª8ä½ï¼ˆå› ä¸ºæˆ‘ä»¬è¦æ‰“è¡¨åˆ°maxï¼Œmaxä¸º8ä½ï¼‰çš„æ²¡æœ‰é‡å¤ä½çš„æ•° a[n++] = nowNum; //nowNumä¸ºç¬¬nä¸ªç¬¦åˆè¦æ±‚çš„æ•°å­— return; &#125; for( int i = 0; i &lt; 10; i++)&#123; //éå†0-9åä¸ªæ•°å­—åœ¨å½“å‰ä½ä¸Šçš„æƒ…å†µ if(i == 0 &amp;&amp; flag == 0)&#123; //å¦‚æœè¯¥ä½ä¸º0ä¸”0å¯ä»¥ç»§ç»­ç«™ä½ä½¿ç”¨ dfs(0,digit+1,0); &#125;else&#123; if(digitMap[i])&#123; //å¦‚æœè¿™æ•°è¿˜æ²¡è¢«ç”¨è¿‡ digitMap[i] = false; //æ ‡è®°å®ƒä¸ºç”¨äº† dfs(nowNum*10+i,digit+1,1); //é€’å½’è§£å†³åé¢çš„ä½ digitMap[i] = true; //æŠŠè¯¥æ•°å­—æ ‡è®°ä¸ºæ²¡ç”¨è¿‡ ç»§ç»­éå† ï¼ˆå›æº¯æ³•ï¼‰ &#125; &#125; &#125;&#125;int main()&#123; for( int i = 0; i &lt; 10; i++)&#123; digitMap[i] = true; //å°†10ä¸ªæ•°å­—éƒ½æ ‡è®°ä¸ºå¯ç”¨ &#125; dfs(0,0,0); //ä»0å¼€å§‹éå† while(true)&#123; int m; cin &gt;&gt; m; if(m == 0)&#123; //å¦‚æœè¾“å…¥æ•°æ®ä¸º0 é€€å‡º break; &#125; cout &lt;&lt; a[m] &lt;&lt; endl; //è¾“å‡ºè¡¨ä¸­çš„å€¼ &#125; return 0;&#125; ä¸€ç‚¹æ€è€ƒæˆ‘è®¤ä¸ºæ­¤é¢˜å¯ç”¨dpä¸ç”¨é€’å½’çš„è§£å†³ï¼Œæˆ‘å‡†å¤‡ä¹‹åå°è¯•ä¸€ä¸‹ï¼Œä¹‹åä¹Ÿä¼šåœ¨æœ¬ç¯‡æ–‡ç« ä¸­ç»§ç»­æ›´æ–°ã€‚ å‚è€ƒèµ„æ–™ http://blog.sina.com.cn/s/blog_738dc7850101mmd8.html http://blog.csdn.net/u011686226/article/details/14497975]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>DFS</tag>
        <tag>POJ</tag>
        <tag>æšä¸¾æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1 Two Sum]]></title>
    <url>%2F2018%2F01%2F13%2Fleetcode-1-two-sum%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.com/problems/two-sum/description/ Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. é¢˜è§£é¢˜ç›®å¤§æ„ç»™å‡ºä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå’Œä¸€ä¸ªæ•´æ•°ï¼Œæ•°ç»„ä¸­å­˜åœ¨ä¸¤ä¸ªæ•°çš„å’Œç­‰äºé‚£ä¸ªç»™å®šçš„æ•´æ•°ï¼Œä»¥ä¸€ä¸ªä¸¤å•å…ƒæ•°ç»„çš„å½¢å¼è¿”å›é‚£ä¸¤ä¸ªæ•°åœ¨æ•°ç»„ä¸­çš„ä¸‹æ ‡ã€‚ è§£é¢˜åˆ†ææ­¤é¢˜å¾ˆç®€å•ï¼Œåªéœ€è¦ç”¨äºŒé‡å¾ªç¯æšä¸¾æ‰€æœ‰çš„å’Œçš„æƒ…å†µå°±å¯ä»¥å®ç°ã€‚ ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527959/123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;a(2); cout &lt;&lt; nums.size(); bool find = true; for( int i = 0; i &lt; nums.size()&amp;&amp;find; i++)&#123; for( int j = 0; j &lt; nums.size()&amp;&amp;find; j++)&#123; if(i == j)&#123; continue; &#125; if(nums[i]+nums[j] == target)&#123; a[0] = j; a[1] = i; find = false; &#125; &#125; &#125; return a; &#125;&#125;; ä¼˜åŒ–æ­¤é¢˜å¦‚æœä»¥ç®€å•æšä¸¾çš„æ–¹å¼å®ç°æˆ‘ä»¬å¾ˆå®¹æ˜“å¾—å‡ºå®ƒçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)ã€‚å½“ç„¶æˆ‘ä»¬æœ‰æ›´å¥½çš„å®ç°ï¼Œå¯ä»¥æŠŠæ—¶é—´å¤æ‚åº¦é™åˆ°O(n)ã€‚æŠŠå…ƒç´ å­˜åˆ°ä¸€ä¸ªhash_mapä¸­ï¼Œå•é‡å¾ªç¯éå†ï¼ˆtarget-æ¯ä¸ªå…ƒç´ ï¼‰æ˜¯å¦åœ¨hash_mapä¸­å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™è¿”å›å®ƒä»¬çš„ä¸‹æ ‡ã€‚hash_map.find()æ˜¯æ—¶é—´å¤æ‚åº¦ä¸ºO(1)ä¹˜ä¸Šæ•°ç»„çš„éå†æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚è¿™æ ·ä¼˜åŒ–å¯ä»¥æŠŠè¿è¡Œæ—¶é—´ä»319 msé™åˆ°6 msã€‚ ä¼˜åŒ–åçš„ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527963/123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; unordered_map&lt;int, int&gt; hash; vector&lt;int&gt; result; for (int i = 0; i &lt; numbers.size(); i++) &#123; int numberToFind = target - numbers[i]; if (hash.find(numberToFind) != hash.end()) &#123; result.push_back(hash[numberToFind] ); result.push_back(i ); return result; &#125; hash[numbers[i]] = i; &#125; return result; &#125;&#125;; å‚è€ƒèµ„æ–™ï¼š ã€ŠLEETCODE 50 COMMON INTERVIEW QUESTIONSã€‹hash_map.find()ä»‹ç»ï¼šhttp://www.cplusplus.com/reference/unordered_map/unordered_map/find/ hash_mapä¸mapçš„æ€§èƒ½åˆ†æï¼šhttp://blog.csdn.net/blues1021/article/details/45054159]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>é¢˜è§£</tag>
        <tag>ä¼˜åŒ–</tag>
        <tag>LeetCode</tag>
        <tag>hash_map</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1753 Flip Gameï¼ˆDFSæšä¸¾ï¼‰]]></title>
    <url>%2F2018%2F01%2F13%2Fpoj-1753-flip-game%2F</url>
    <content type="text"><![CDATA[é¢˜ç›®é“¾æ¥http://poj.org/problem?id=1753 Flip GameTime Limit: 1000MS Memory Limit: 65536K DescriptionFlip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either itâ€™s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules: Choose any one of the 16 pieces. Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any). Consider the following position as an example: bwbw wwww bbwb bwwb Here â€œbâ€ denotes pieces lying their black side up and â€œwâ€ denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become: bwbw bwww wwwb wwwb The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal. InputThe input consists of 4 lines with 4 characters â€œwâ€ or â€œbâ€ each that denote game field position. OutputWrite to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If itâ€™s impossible to achieve the goal, then write the word â€œImpossibleâ€ (without quotes). Sample Inputbwwbbbwbbwwbbwww Sample Output4 é¢˜è§£é¢˜ç›®å¤§æ„æœ‰4*4çš„æ£‹ç›˜ï¼Œæ¯ä¸ªæ£‹å­æœ‰é»‘ç™½ä¸¤ç§é¢œè‰²ï¼Œå½“æŠŠä¸€ä¸ªæ£‹å­çš„é¢œè‰²åè½¬(é»‘-&gt;ç™½æˆ–è€…ç™½-&gt;é»‘)æ—¶ï¼Œå…¶å‘¨å›´ä¸Šä¸‹å·¦å³(å¦‚æœå­˜åœ¨çš„è¯)çš„æ£‹å­çš„é¢œè‰²ä¹Ÿè¢«åè½¬ï¼Œé—®è‡³å°‘ç¿»è½¬å‡ æ¬¡æ£‹å­å¯ä»¥å°†æ£‹ç›˜ä¸Šçš„æ£‹å­å˜ä¸ºåŒä¸€ç§é¢œè‰²ã€‚ è§£é¢˜åˆ†æ ä¸€ä¸ªæ£‹å­ç¬¬äºŒæ¬¡è¢«ç¿»è½¬ä¼šæŠµæ¶ˆç¬¬ä¸€æ¬¡ç¿»è½¬ä¸€ä¸ªæ£‹å­çš„æ•ˆæœï¼Œä¸€ä¸ªæ£‹å­å¤šæ¬¡ç¿»è½¬æ˜¯æ— æ„ä¹‰çš„ï¼Œæ¯ä¸ªæ£‹å­åªæœ‰ç¿»è½¬å’Œä¸ç¿»è½¬ä¸¤ç§æƒ…å†µã€‚ æ£‹å­è¢«ç¿»è½¬çš„å…ˆåé¡ºåºå¯¹ç»“æœæ— å½±å“ã€‚ è§£é¢˜æ€è·¯æ£‹ç›˜ä¸Šä¸€å…±æœ‰16ä¸ªæ£‹å­ï¼Œæˆ‘ä»¬æœ€å¤šåªèƒ½ç¿»è½¬16æ¬¡æ£‹å­ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘æšä¸¾ç¿»è½¬çš„æ¬¡æ•°ï¼Œä¹‹ååœ¨ç»™å®šç¿»è½¬æ¬¡æ•°çš„æƒ…å†µä¸‹æšä¸¾è¢«ç¿»è½¬çš„æ£‹å­ã€‚ æ­¤é¢˜ä»æšä¸¾æ€è·¯ä¸XUJCOJ 16çº§çº¿ä¸Šæ¯”èµ›ï¼ˆ2017/03/05ï¼‰4:è€å¾è¿½å¦¹çº¸v2 çš„æ€è·¯åŸºæœ¬ä¸€è‡´ï¼Œå¯ä»¥å½“åšé¢å¤–ç»ƒä¹ ã€‚é¢˜ç›®é“¾æ¥ï¼šhttp://www.xujcoj.org/Home/Contest/problem/cid/63/match_id/4/ctype/0 ä»£ç Ubuntu Pastebin : https://paste.ubuntu.com/26527872/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//POJ 1753 Flip Gameï¼ˆDFSæšä¸¾ï¼‰//2018-01-12#include &lt;iostream&gt;using namespace std;bool a[4][4]; //æ£‹ç›˜æ•°ç»„bool ok = false; //æ˜¯å¦æ‰¾åˆ°æ–¹æ¡ˆint step; //å½“å‰è¦æšä¸¾çš„ç¿»è½¬æ¬¡æ•°bool isComplete() //æ£€æŸ¥æ˜¯å¦å…¨ä¸ºåŒè‰²&#123; bool re = true; for( int i = 0; i &lt; 4 &amp;&amp; re; i++)&#123; for( int j = 0; j &lt; 4 &amp;&amp; re; j++)&#123; if(a[i][j] != a[0][0])&#123; re = false; &#125; &#125; &#125; return re;&#125;void filp(int x,int y) //ç¿»è½¬ä¸€ä¸ªæ£‹å­&#123; a[x][y] = !a[x][y]; //ç¿»è½¬å®ƒæœ¬èº« if(x &gt; 0)&#123; //å·¦è¾¹çš„æ£‹å­å¦‚æœå­˜åœ¨åˆ™ç¿»è½¬å®ƒ a[x-1][y] = !a[x-1][y]; &#125; if(x &lt; 3)&#123; //å³è¾¹ a[x+1][y] = !a[x+1][y]; &#125; if(y &gt; 0)&#123; //ä¸Šè¾¹ a[x][y-1] = !a[x][y-1]; &#125; if(y &lt; 3)&#123; //ä¸‹è¾¹ a[x][y+1] = !a[x][y+1]; &#125;&#125;void dfs(int x,int y,int nowStep)//å½“å‰æšä¸¾åˆ°çš„æ£‹å­çš„åæ ‡ nowStepä¸ºå·²ç»ç¿»è½¬äº†å¤šå°‘æ£‹å­&#123; if(nowStep == step)&#123; //å¦‚æœç¿»è½¬æ£‹å­çš„æ¬¡æ•°è¾¾åˆ°å½“å‰è¦æšä¸¾çš„ç¿»è½¬æ¬¡æ•° ok = isComplete(); //æ£‹ç›˜æ˜¯å¦åŒè‰² return; &#125; if(y == 4 || ok)&#123; //å¦‚æœæ£‹ç›˜è¢«éå†å®Œæˆ–è€…å·²æ‰¾åˆ°æ–¹æ¡ˆå°±é€€å‡ºå‡½æ•° return; &#125; //ä»¥ä¸‹æ˜¯ä¸€ä¸ªç”¨é€’å½’ä»£æ›¿nå±‚å¾ªç¯çš„æ€è·¯ filp(x,y); //å¦‚æœç¿»è½¬å½“å‰æ£‹å­ if(x &lt; 3)&#123; //éå†å…¶ä»–æ£‹å­ ä»å·¦åˆ°å³ä»ä¸Šåˆ°ä¸‹ dfs(x+1,y,nowStep+1); &#125;else&#123; dfs(0,y+1,nowStep+1); &#125; filp(x,y); //å¦‚æœä¸ç¿»è½¬å½“å‰æ£‹å­ å†ç¿»è½¬ä¸€æ¬¡å½“å‰æ£‹å­æŠµæ¶ˆä¸Šæ¬¡ç¿»è½¬çš„æ•ˆæœç»§ç»­æšä¸¾ if(x &lt; 3)&#123; dfs(x+1,y,nowStep); &#125;else&#123; dfs(0,y+1,nowStep); &#125;&#125;int main()&#123; for( int i = 0; i &lt; 4; i++)&#123; for( int j = 0; j &lt; 4; j++)&#123; char temp; cin &gt;&gt; temp; if(temp == 'b')&#123; a[i][j] = true; &#125;else &#123; a[i][j] = false; &#125; &#125; &#125; //ä»¥ä¸Šä¸ºè¾“å…¥é˜¶æ®µ é»‘è‰²åœ¨æ•°ç»„ä¸­ä¸ºtrueç™½è‰²ä¸ºfalse int i; for( i = 0; i &lt;= 16; i++)&#123; step = i; dfs(0,0,0); //ä»å·¦ä¸Šè§’çš„æ£‹å­å¼€å§‹æšä¸¾ if(ok)&#123; //å¦‚æœæ‰¾åˆ°ä¸€ç§æ–¹æ¡ˆ break; &#125; &#125; if(i &lt;= 16)&#123; //å¦‚æœiå°äºç­‰äº16è¯´æ˜æ‰¾åˆ°ä¸€ç§æ–¹æ¡ˆ è¾“å‡ºæ­¥æ•°å³å¯ cout &lt;&lt; i; &#125;else&#123; //å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¾“å‡º"Impossible" cout &lt;&lt; "Impossible"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>é¢˜è§£</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>é¢˜è§£</tag>
        <tag>DFS</tag>
        <tag>POJ</tag>
        <tag>æšä¸¾æ³•</tag>
      </tags>
  </entry>
</search>
